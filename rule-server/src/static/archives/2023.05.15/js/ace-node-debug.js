/*!
 * Copyright:: 2016,2017,2019,2020- IBM, Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 9077:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RuleManual = exports.RulePotential = exports.RuleFail = exports.RuleRender = exports.RulePass = exports.eRulesetType = exports.eRuleCategory = exports.eToolkitLevel = exports.eRulePolicy = exports.eRuleConfidence = void 0;
var eRuleConfidence;
(function (eRuleConfidence) {
    eRuleConfidence["PASS"] = "PASS";
    eRuleConfidence["FAIL"] = "FAIL";
    eRuleConfidence["POTENTIAL"] = "POTENTIAL";
    eRuleConfidence["MANUAL"] = "MANUAL";
})(eRuleConfidence = exports.eRuleConfidence || (exports.eRuleConfidence = {}));
var eRulePolicy;
(function (eRulePolicy) {
    eRulePolicy["VIOLATION"] = "VIOLATION";
    eRulePolicy["RECOMMENDATION"] = "RECOMMENDATION";
    eRulePolicy["INFORMATION"] = "INFORMATION";
})(eRulePolicy = exports.eRulePolicy || (exports.eRulePolicy = {}));
var eToolkitLevel;
(function (eToolkitLevel) {
    eToolkitLevel["LEVEL_ONE"] = "1";
    eToolkitLevel["LEVEL_TWO"] = "2";
    eToolkitLevel["LEVEL_THREE"] = "3";
    eToolkitLevel["LEVEL_FOUR"] = "4";
})(eToolkitLevel = exports.eToolkitLevel || (exports.eToolkitLevel = {}));
var eRuleCategory;
(function (eRuleCategory) {
    eRuleCategory["ACCESSIBILITY"] = "Accessibility";
    eRuleCategory["DESIGN"] = "Design";
    eRuleCategory["OTHER"] = "Other";
})(eRuleCategory = exports.eRuleCategory || (exports.eRuleCategory = {}));
var eRulesetType;
(function (eRulesetType) {
    eRulesetType["DEFAULT"] = "default";
    eRulesetType["EXTENSION"] = "extension";
})(eRulesetType = exports.eRulesetType || (exports.eRulesetType = {}));
function RulePass(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.PASS],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RulePass = RulePass;
function RuleRender(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.PASS],
        reasonId: 0,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RuleRender = RuleRender;
function RuleFail(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.FAIL],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RuleFail = RuleFail;
function RulePotential(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.POTENTIAL],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RulePotential = RulePotential;
function RuleManual(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.MANUAL],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RuleManual = RuleManual;


/***/ }),

/***/ 8235:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ARIADefinitions = void 0;
var ARIADefinitions = /** @class */ (function () {
    function ARIADefinitions() {
    }
    ARIADefinitions.nameFromContent = function (role) {
        return (role in ARIADefinitions.designPatterns)
            && ARIADefinitions.designPatterns[role].nameFrom
            && ARIADefinitions.designPatterns[role].nameFrom.includes("contents");
    };
    /*
     * array of WAI-ARIA global states and properties
     * @see https://www.w3.org/TR/wai-aria-1.2/#global_states
     */
    ARIADefinitions.globalProperties = ["aria-atomic", "aria-busy", "aria-controls", "aria-current", "aria-describedby",
        "aria-details", "aria-flowto", "aria-hidden", "aria-keyshortcuts",
        "aria-label", "aria-labelledby", "aria-live", "aria-owns", "aria-relevant", "aria-roledescription"
        // the following are deprecated in ARIA 1.2, will indicate deprecation in individual role
        ,
        'aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid'
    ];
    // deprecated roles
    ARIADefinitions.globalDeprecatedRoles = [
        'directory'
    ];
    // the following are deprecated in ARIA 1.1 for all the roles
    ARIADefinitions.globalDeprecatedProperties = [
        'aria-grabbed', 'aria-dropeffect'
    ];
    /*
     * XSD data types for all WAI-ARIA properties
     * along with valid values when the data type is NMTOKEN
     * WAI-ARIA properties data types explaned:
     *  type: Used to identify the type of values allowed for the WAI-ARIA property
     *  values: Used to identify specific values of an WAI-ARIA property when type is nmtoken
     *  hiddenIDRefSupported: Used to identify if the WAI-ARIA property supports referencing hidden ID
     *                          true: refers to WAI-ARIA property supports hidden ID references
     *                          false: refers to WAI-ARIA property does not support hidden ID references
     *                        Default value will be set to false, if not specified.
     */
    ARIADefinitions.propertyDataTypes = {
        "aria-activedescendant": {
            type: "http://www.w3.org/2001/XMLSchema#idref",
            hiddenIDRefSupported: true
        },
        "aria-atomic": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-autocomplete": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["inline", "list", "both", "none", "undefined"] //add undefined to handle value empty
        },
        "aria-busy": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-checked": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "mixed", "undefined"]
        },
        "aria-colcount": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-colindex": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-colspan": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-controls": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-current": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["page", "step", "location", "date", "time", "true", "false", "undefined"] //add undefined for empty value
        },
        "aria-describedby": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-details": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs"
        },
        "aria-disabled": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-dropeffect": {
            type: "http://www.w3.org/2001/XMLSchema#nmtokens",
            values: ["copy", "move", "link", "execute", "popup", "none"]
        },
        "aria-errormessage": {
            type: "http://www.w3.org/2001/XMLSchema#idref",
            hiddenIDRefSupported: true
        },
        "aria-expanded": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "undefined"]
        },
        "aria-flowto": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: false
        },
        "aria-grabbed": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "undefined"]
        },
        "aria-haspopup": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "menu", "listbox", "tree", "grid", "dialog"]
        },
        "aria-hidden": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "undefined"]
        },
        "aria-invalid": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "spelling", "grammar", "undefined"] //add undefined for empty value
        },
        "aria-keyshortcuts": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        },
        "aria-label": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        },
        "aria-labelledby": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-level": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-live": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["off", "polite", "assertive"]
        },
        "aria-modal": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-multiline": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-multiselectable": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-orientation": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["horizontal", "vertical", "undefined"]
        },
        "aria-owns": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-placeholder": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        },
        "aria-posinset": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-pressed": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "mixed", "undefined"]
        },
        "aria-readonly": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-relevant": {
            type: "http://www.w3.org/2001/XMLSchema#nmtokens",
            values: ["additions", "removals", "text", "all"]
        },
        "aria-required": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-roledescription": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        },
        "aria-rowcount": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-rowindex": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-rowspan": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-selected": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "undefined"]
        },
        "aria-setsize": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-sort": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["ascending", "descending", "other", "none"]
        },
        "aria-valuemax": {
            type: "http://www.w3.org/2001/XMLSchema#decimal"
        },
        "aria-valuemin": {
            type: "http://www.w3.org/2001/XMLSchema#decimal"
        },
        "aria-valuenow": {
            type: "http://www.w3.org/2001/XMLSchema#decimal"
        },
        "aria-valuetext": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        }
    };
    /*
     * design patterns for concrete WAI-ARIA roles
     * legitimate keys for each role include:
     *
     * - container: appropriate container(s) for that role
     * - props: states and properties that may be associated with this role (in addition to the global states and properties listed above)
     * - reqProps: required states or properties for this role
     * - reqChildren: required children for this role
     * - htmlEquiv: HTML equivalent for this role
     * - roleType: one of widget, structure, landmark, liveRegion, window (as seen in https://www.w3.org/TR/wai-aria-1.2/#roles_categorization)
     * - nameRequired: determines whether an accessible name is required for a widget (see ARIA spec.)
     * - nameFrom: determines how an accessible name is supplied (author or content - see ARIA spec.)
     * - deprecated: if present, indicates that the role is deprecated, and provides a list of alternative role(s)
     */
    ARIADefinitions.designPatterns = {
        "alert": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "liveRegion",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "alertdialog": {
            container: null,
            props: ["aria-modal"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "window",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "application": {
            container: null,
            props: ["aria-activedescendant", "aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "article": {
            container: null,
            props: ["aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "banner": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "blockquote": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "button": {
            container: null,
            props: ["aria-expanded", "aria-pressed"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "button | input[@type='button']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
        "caption": {
            container: ["figure", "grid", "table", "treegrid"],
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "cell": {
            container: ["row"],
            props: ["aria-colindex", "aria-colspan", "aria-rowindex", "aria-rowspan"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "td",
            roleType: "structure",
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "checkbox": {
            container: null,
            props: ["aria-expanded", "aria-readonly", "aria-required"],
            reqProps: ["aria-checked"],
            reqChildren: null,
            htmlEquiv: "input[@type='checkbox']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-haspopup']
        },
        "code": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "columnheader": {
            container: ["row"],
            props: ["aria-colindex", "aria-colspan", "aria-expanded", "aria-readonly", "aria-required", "aria-rowindex", "aria-rowspan", "aria-selected", "aria-sort"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "th[@scope='col']",
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "combobox": {
            container: null,
            props: ["aria-controls", "aria-activedescendant", "aria-autocomplete", "aria-readonly", "aria-required"],
            reqProps: ["aria-expanded"],
            reqChildren: [],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "complementary": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "contentinfo": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "definition": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "deletion": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "dialog": {
            container: null,
            props: ["aria-modal"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "window",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "directory": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecated: true,
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "doc-abstract": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-acknowledgments": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-afterword": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-appendix": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-backlink": {
            container: null,
            props: ["aria-disabled", "aria-expanded", "aria-haspopup"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "a | link",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "doc-biblioentry": {
            container: ["list"],
            props: ["aria-level", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "li",
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-bibliography": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-biblioref": {
            container: null,
            props: ["aria-disabled", "aria-expanded", "aria-haspopup"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "a | link",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "doc-chapter": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-colophon": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-conclusion": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-cover": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "img",
            roleType: "structure",
            nameFrom: ["author"],
            presentationalChildren: true
        },
        "doc-credit": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-credits": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-dedication": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-endnote": {
            container: ["list"],
            props: ["aria-level", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "li",
            roleType: "structure",
            nameFrom: ["author"]
        },
        "doc-endnotes": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-epigraph": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-epilogue": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-errata": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-example": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-footnote": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-foreword": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-glossary": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-glossref": {
            container: null,
            props: ["aria-disabled", "aria-expanded", "aria-haspopup"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "a | link",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "doc-index": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"]
        },
        "doc-introduction": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-noteref": {
            container: null,
            props: ["aria-disabled", "aria-expanded", "aria-haspopup"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "a | link",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "doc-notice": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"]
        },
        "doc-pagebreak": {
            container: null,
            props: ["aria-orientation"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            presentationalChildren: true
        },
        "doc-pagelist": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"]
        },
        "doc-part": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-preface": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-prologue": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-pullquote": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"]
        },
        "doc-qna": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-subtitle": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"]
        },
        "doc-tip": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"]
        },
        "doc-toc": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"]
        },
        "document": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "emphasis": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "feed": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: ["article"],
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "figure": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "form": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "form",
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "generic": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "div | span",
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby", "aria-roledescription"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "graphics-document": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameRequired: true,
            nameFrom: ["author"]
        },
        "graphics-object": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameRequired: false,
            nameFrom: ["contents", "author"]
        },
        "graphics-symbol": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true
        },
        "grid": {
            container: null,
            props: ["aria-activedescendant", "aria-colcount", "aria-multiselectable", "aria-readonly", "aria-rowcount"],
            reqProps: null,
            reqChildren: ["row", "rowgroup"],
            htmlEquiv: "table",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "gridcell": {
            container: ["row"],
            props: ["aria-colindex", "aria-colspan", "aria-disabled", "aria-errormessage", "aria-expanded", "aria-haspopup", "aria-invalid", "aria-readonly", "aria-required", "aria-rowindex", "aria-rowspan", "aria-selected"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "td",
            roleType: "widget",
            nameFrom: ["author", "contents"]
        },
        "group": {
            container: null,
            props: ["aria-activedescendant"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "heading": {
            container: null,
            props: null,
            reqProps: ["aria-level"],
            reqChildren: null,
            htmlEquiv: "h1 | h2 | h3 | h4 | h5 | h6",
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "img": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "img",
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true,
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "insertion": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "link": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "a | link",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
        "list": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: ["listitem"],
            htmlEquiv: "ol | ul",
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "listbox": {
            container: null,
            props: ["aria-activedescendant", "aria-expanded", "aria-multiselectable", "aria-orientation", "aria-readonly", "aria-required"],
            reqProps: null,
            reqChildren: ["group", "option"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-haspopup']
        },
        "listitem": {
            container: ["list"],
            props: ["aria-level", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "li",
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "log": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "liveRegion",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "main": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "marquee": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "liveRegion",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "math": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            presentationalChildren: false,
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "menu": {
            container: null,
            props: ["aria-activedescendant", "aria-orientation"],
            reqProps: null,
            reqChildren: ["group", "menuitem", "menuitemcheckbox", "menuitemradio"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "menubar": {
            container: null,
            props: ["aria-activedescendant", "aria-orientation"],
            reqProps: null,
            reqChildren: ["group", "menuitem", "menuitemcheckbox", "menuitemradio"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "menuitem": {
            container: ["group", "menu", "menubar"],
            props: ["aria-expanded", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
        "menuitemcheckbox": {
            container: ["group", "menu", "menubar"],
            props: ["aria-expanded", "aria-posinset", "aria-setsize"],
            reqProps: ["aria-checked"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
        "menuitemradio": {
            container: ["group", "menu", "menubar"],
            props: ["aria-expanded", "aria-posinset", "aria-setsize"],
            reqProps: ["aria-checked"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
        "meter": {
            container: null,
            props: ["aria-valuemax", "aria-valuemin", "aria-valuetext"],
            reqProps: ["aria-valuenow"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true,
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "navigation": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "none": {
            container: null,
            props: [],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "note": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "option": {
            container: ["group", "listbox"],
            props: ["aria-selected", "aria-checked", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "option",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "paragraph": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "presentation": {
            container: null,
            props: [],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "progressbar": {
            container: null,
            props: ["aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true,
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "radio": {
            container: null,
            props: ["aria-posinset", "aria-setsize"],
            reqProps: ["aria-checked"],
            reqChildren: null,
            htmlEquiv: "input[@type='radio']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "radiogroup": {
            container: null,
            props: ["aria-activedescendant", "aria-orientation", "aria-readonly", "aria-required"],
            reqProps: null,
            reqChildren: ["radio"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-haspopup']
        },
        "region": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "row": {
            container: ["grid", "rowgroup", "table", "treegrid"],
            props: ["aria-activedescendant", "aria-colindex", "aria-expanded", "aria-level", "aria-posinset", "aria-rowindex", "aria-selected", "aria-setsize"],
            reqProps: null,
            reqChildren: ["cell", "columnheader", "gridcell", "rowheader"],
            htmlEquiv: "tr",
            roleType: "structure",
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "rowgroup": {
            container: ["grid", "table", "treegrid"],
            props: [],
            reqProps: null,
            reqChildren: ["row"],
            htmlEquiv: "tbody | tfoot | thead",
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "rowheader": {
            container: ["row"],
            props: ["aria-colindex", "aria-colspan", "aria-expanded", "aria-readonly", "aria-required", "aria-rowindex", "aria-rowspan", "aria-selected", "aria-sort"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "th[@scope='row']",
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "scrollbar": {
            container: null,
            props: ["aria-orientation", "aria-valuemax", "aria-valuemin", "aria-valuetext"],
            reqProps: ["aria-controls", "aria-valuenow"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "search": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "searchbox": {
            container: null,
            props: ["aria-activedescendant", "aria-autocomplete", "aria-multiline", "aria-placeholder", "aria-readonly", "aria-required"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "input[@type='search']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "separator": {
            container: null,
            props: ["aria-orientation"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "slider": {
            container: null,
            props: ["aria-orientation", "aria-readonly", "aria-valuemax", "aria-valuemin", "aria-valuetext"],
            reqProps: ["aria-valuenow"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true
        },
        "spinbutton": {
            container: null,
            props: ["aria-activedescendant", "aria-readonly", "aria-required", "aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-haspopup']
        },
        "status": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "liveRegion",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "strong": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "subscript": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "superscript": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "switch": {
            container: null,
            props: ["aria-expanded", "aria-readonly", "aria-required"],
            reqProps: ["aria-checked"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-haspopup']
        },
        "tab": {
            container: ["tablist"],
            props: ["aria-expanded", "aria-posinset", "aria-selected", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
        "table": {
            container: null,
            props: ["aria-colcount", "aria-rowcount"],
            reqProps: null,
            reqChildren: ["row", "rowgroup"],
            htmlEquiv: "table",
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "tablist": {
            container: null,
            props: ["aria-activedescendant", "aria-multiselectable", "aria-orientation"],
            reqProps: null,
            reqChildren: ["tab"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "tabpanel": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "term": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "dfn",
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "textbox": {
            container: null,
            props: ["aria-activedescendant", "aria-autocomplete", "aria-multiline", "aria-placeholder", "aria-readonly", "aria-required"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "input[@type='text']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "time": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "timer": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "liveRegion",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "toolbar": {
            container: null,
            props: ["aria-activedescendant", "aria-orientation"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "tooltip": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: false,
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "tree": {
            container: null,
            props: ["aria-activedescendant", "aria-multiselectable", "aria-orientation", "aria-required"],
            reqProps: null,
            reqChildren: ["group", "treeitem"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-haspopup']
        },
        "treegrid": {
            container: null,
            props: ["aria-activedescendant", "aria-colcount", "aria-multiselectable", "aria-orientation", "aria-readonly", "aria-required", "aria-rowcount"],
            reqProps: null,
            reqChildren: ["row", "rowgroup"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-haspopup']
        },
        "treeitem": {
            container: ["group", "tree"],
            props: ["aria-checked", "aria-expanded", "aria-level", "aria-posinset", "aria-selected", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
    }; // end designPatterns
    // copied from https://html.spec.whatwg.org/multipage/semantics-other.html#disabled-elements
    // https://html.spec.whatwg.org/multipage/input.html#input-type-attr-summary
    ARIADefinitions.elementsAllowedDisabled = ["button", "input", "select", "textarea", "optgroup", "option", "fieldset"]; // also form-associated custom element
    ARIADefinitions.elementsAllowedRequired = ["select", "textarea"]; // remove 'input' and add to the individual element, becuase required is not supported on input@type="range", "color", "hidden" or any button types
    ARIADefinitions.elementsAllowedReadOnly = ["textarea"]; // remove 'input' and add to the individual element, because readonly is not supported on input@type="checkbox", "radio", "range", "color", "file", hidden" or any button types
    /* https://www.w3.org/TR/html-aria/#docconformance
        * documentConformanceRequirement contains properties of the tags related to role without any additional attribute value
        * documentConformanceRequirementSpecialTags contains those tags that require special considerations
        */
    ARIADefinitions.documentConformanceRequirement = {
        "abbr": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "address": {
            implicitRole: ["group"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "article": {
            implicitRole: ["article"],
            validRoles: ["application", "document", "feed", "main", "none", "presentation", "region"],
            globalAriaAttributesValid: true
        },
        "aside": {
            implicitRole: ["complementary"],
            validRoles: ["doc-dedication", "doc-example", "doc-footnote", "doc-pullquote", "doc-tip", "feed", "none", "note", "presentation", "region", "search"],
            globalAriaAttributesValid: true
        },
        "audio": {
            implicitRole: null,
            validRoles: ["application"],
            globalAriaAttributesValid: true
        },
        "b": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "base": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "bdi": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "bdo": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "blockquote": {
            implicitRole: ["blockquote"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "body": {
            implicitRole: ["generic"],
            validRoles: null,
            otherDisallowedAriaAttributes: ['aria-hidden'],
            globalAriaAttributesValid: true
        },
        "br": {
            implicitRole: null,
            validRoles: ["none", "presentation"],
            globalAriaAttributesValid: false,
            otherAllowedAriaAttributes: ["aria-hidden"]
        },
        "button": {
            implicitRole: ["button"],
            validRoles: ["checkbox", "combobox", "gridcell", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "slider", "switch", "tab", "treeitem"],
            globalAriaAttributesValid: true
        },
        "canvas": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "caption": {
            implicitRole: ['caption'],
            validRoles: null,
            globalAriaAttributesValid: true,
            allowAttributesFromImplicitRole: false
        },
        "cite": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "code": {
            implicitRole: ["code"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "col": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "colgroup": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "data": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "datalist": {
            implicitRole: ["listbox"],
            validRoles: null,
            globalAriaAttributesValid: false,
            allowAttributesFromImplicitRole: false
        },
        "dd": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "del": {
            implicitRole: ["deletion"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "details": {
            implicitRole: ["group"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "dfn": {
            implicitRole: ["term"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "dialog": {
            implicitRole: ["dialog"],
            validRoles: ["alertdialog"],
            globalAriaAttributesValid: true
        },
        "dl": {
            implicitRole: null,
            validRoles: ["group", "list", "none", "presentation"],
            globalAriaAttributesValid: true
        },
        "dt": {
            implicitRole: ["term"],
            validRoles: ["listitem"],
            globalAriaAttributesValid: true
        },
        "em": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "embed": {
            implicitRole: null,
            validRoles: ["application", "document", "img", "none", "presentation"],
            globalAriaAttributesValid: true
        },
        "fieldset": {
            implicitRole: ["group"],
            validRoles: ["none", "presentation", "radiogroup"],
            globalAriaAttributesValid: true
        },
        "figcaption": {
            implicitRole: null,
            validRoles: ["group", "none", "presentation"],
            globalAriaAttributesValid: true
        },
        "form": {
            implicitRole: ["form"],
            validRoles: ["none", "presentation", "search"],
            globalAriaAttributesValid: true
        },
        "head": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "hgroup": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "h1": {
            implicitRole: ["heading"],
            validRoles: ["doc-subtitle", "none", "presentation", "tab"],
            globalAriaAttributesValid: true
        },
        "h2": {
            implicitRole: ["heading"],
            validRoles: ["doc-subtitle", "none", "presentation", "tab"],
            globalAriaAttributesValid: true
        },
        "h3": {
            implicitRole: ["heading"],
            validRoles: ["doc-subtitle", "none", "presentation", "tab"],
            globalAriaAttributesValid: true
        },
        "h4": {
            implicitRole: ["heading"],
            validRoles: ["doc-subtitle", "none", "presentation", "tab"],
            globalAriaAttributesValid: true
        },
        "h5": {
            implicitRole: ["heading"],
            validRoles: ["doc-subtitle", "none", "presentation", "tab"],
            globalAriaAttributesValid: true
        },
        "h6": {
            implicitRole: ["heading"],
            validRoles: ["doc-subtitle", "none", "presentation", "tab"],
            globalAriaAttributesValid: true
        },
        "hr": {
            implicitRole: ["separator"],
            validRoles: ["doc-pagebreak", "none", "presentation"],
            globalAriaAttributesValid: true
        },
        "html": {
            implicitRole: ["document"],
            validRoles: null,
            globalAriaAttributesValid: false,
            allowAttributesFromImplicitRole: false
        },
        "i": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "iframe": {
            implicitRole: null,
            validRoles: ["application", "document", "img", "none", "presentation"],
            globalAriaAttributesValid: true
        },
        "ins": {
            implicitRole: ["insertion"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "kbd": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "label": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "legend": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "link": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "main": {
            implicitRole: ["main"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "map": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "mark": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "math": {
            implicitRole: ["math"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "menu": {
            implicitRole: ["list"],
            validRoles: ["group", "listbox", "menu", "menubar", "none", "presentation", "radiogroup", "tablist", "toolbar", "tree"],
            globalAriaAttributesValid: true
        },
        "meta": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "meter": {
            implicitRole: ["meter"],
            validRoles: null,
            globalAriaAttributesValid: true,
            otherDisallowedAriaAttributes: ['aria-valuemax', 'aria-valuemin'],
            allowAttributesFromImplicitRole: false
        },
        "nav": {
            implicitRole: ["navigation"],
            validRoles: ["doc-index", "doc-pagelist", "doc-toc", "menu", "menubar", "tablist", "none", "presentation"],
            globalAriaAttributesValid: true
        },
        "noscript": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "object": {
            implicitRole: null,
            validRoles: ["application", "document", "img"],
            globalAriaAttributesValid: true
        },
        "ol": {
            implicitRole: ["list"],
            validRoles: ["group", "listbox", "menu", "menubar", "none", "presentation", "radiogroup", "tablist", "toolbar", "tree"],
            globalAriaAttributesValid: true
        },
        "optgroup": {
            implicitRole: ["group"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "option": {
            implicitRole: ["option"],
            validRoles: null,
            globalAriaAttributesValid: true,
            otherDisallowedAriaAttributes: ["aria-selected"]
        },
        "output": {
            implicitRole: ["status"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "p": {
            implicitRole: ["paragraph"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "param": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "picture": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false,
            otherAllowedAriaAttributes: ["aria-hidden"]
        },
        "pre": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "progress": {
            implicitRole: ["progressbar"],
            validRoles: null,
            globalAriaAttributesValid: true,
            otherDisallowedAriaAttributes: ["aria-valuemax"]
        },
        "q": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "rp": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "rt": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "ruby": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "s": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "samp": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "script": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "search": {
            implicitRole: ['search'],
            validRoles: ['search', 'form', 'group', 'none', 'presentation', 'region'],
            globalAriaAttributesValid: true
        },
        "slot": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "small": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "source": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "span": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "strong": {
            implicitRole: ["strong"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "style": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "sub": {
            implicitRole: ["subscript"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "sup": {
            implicitRole: ["superscript"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "svg": {
            implicitRole: ["graphics-document"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "table": {
            implicitRole: ["table"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "template": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "textarea": {
            implicitRole: ["textbox"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "tfoot": {
            implicitRole: ["rowgroup"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "thead": {
            implicitRole: ["rowgroup"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "time": {
            implicitRole: ["time"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "title": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "track": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "u": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "ul": {
            implicitRole: ["list"],
            validRoles: ["group", "listbox", "menu", "menubar", "none", "presentation", "radiogroup", "tablist", "toolbar", "tree"],
            globalAriaAttributesValid: true
        },
        "var": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "video": {
            implicitRole: null,
            validRoles: ["application"],
            globalAriaAttributesValid: true
        },
        "wbr": {
            implicitRole: null,
            validRoles: ["none", "presentation"],
            globalAriaAttributesValid: false,
            otherAllowedAriaAttributes: ["aria-hidden"]
        }
    }; // end documentConformanceRequirement
    ARIADefinitions.documentConformanceRequirementSpecialTags = {
        "a": {
            "with-href": {
                implicitRole: ["link"],
                //roleCondition: " when non-empty href attribute is present",
                validRoles: ["button", "checkbox", "doc-backlink", "doc-biblioref", "doc-glossref", "doc-noteref", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "switch", "tab", "treeitem"],
                globalAriaAttributesValid: true,
                otherDisallowedAriaAttributes: ["aria-disabled=true"]
            },
            "without-href": {
                implicitRole: ["generic"],
                //roleCondition: " when href attribute is not present",
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "area": {
            "with-href": {
                implicitRole: ["link"],
                //roleCondition: " when non-empty href attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "without-href": {
                implicitRole: ["generic"],
                //roleCondition: " when href attribute is not present",
                validRoles: ["button", "link"],
                globalAriaAttributesValid: true
            }
        },
        // TODO
        //        "autonomous custom element": {
        //            implicitRole: ["Role exposed from author defined ElementInternals. Otherwise no corresponding role."],
        //            validRoles: ["If role defined by ElementInternals", "any role", "no role Otherwise"],
        //            globalAriaAttributesValid: true
        //        },
        "div": {
            "child-dl": {
                implicitRole: ["generic"],
                validRoles: ["presentation", "none"],
                globalAriaAttributesValid: true
            },
            "no-child-dl": {
                implicitRole: ["generic"],
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "figure": {
            "child-figcaption": {
                implicitRole: ["figure"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "no-child-figcaption": {
                implicitRole: ["figure"],
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "footer": {
            "des-section-article-aside-main-nav": {
                implicitRole: ["generic"],
                //roleCondition: " when descendant of an article, aside, main, nav or section element",
                validRoles: ["doc-footnote", "group", "none", "presentation"],
                globalAriaAttributesValid: true
            },
            "other": {
                implicitRole: ["contentinfo"],
                //roleCondition: " when not a descendant of an article, aside, main, nav or section element",
                validRoles: ["doc-footnote", "group", "none", "presentation"],
                globalAriaAttributesValid: true
            }
        },
        // TODO
        //        "form-associated custom element": {
        //            implicitRole: ["Role exposed from author defined ElementInternals. Otherwise 'generic'."],
        //            validRoles: ["If role defined by ElementInternals", "form-related roles: button", "checkbox", "combobox", "group", "listbox", "progressbar", "radio", "radiogroup", "searchbox", "slider", "spinbutton", "switch", "textbox", "no role Otherwise"],
        //            globalAriaAttributesValid: true
        //        },
        "header": {
            "des-section-article-aside-main-nav": {
                implicitRole: ["generic"],
                //roleCondition: " when descendant of an article, aside, main, nav or section element",
                validRoles: ["group", "none", "presentation"],
                globalAriaAttributesValid: true
            },
            "other": {
                implicitRole: ["banner"],
                //roleCondition: " when not a descendant of an article, aside, main, nav or section element",
                validRoles: ["group", "none", "presentation"],
                globalAriaAttributesValid: true
            }
        },
        "img": {
            "img-with-alt-text": {
                implicitRole: ["img"],
                //roleCondition: " when alt attribute has text (is not empty)",
                validRoles: ["button", "checkbox", "doc-cover", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "progressbar", "radio", "scrollbar", "separator", "slider", "switch", "tab", "treeitem"],
                globalAriaAttributesValid: true
            },
            "img-with-empty-alt": {
                implicitRole: ["presentation"],
                //roleCondition: " when alt attribute is empty",
                validRoles: null,
                globalAriaAttributesValid: false,
                otherAllowedAriaAttributes: ["aria-hidden=true"]
            },
            "img-without-alt": {
                implicitRole: ["img"],
                //roleCondition: " when alt attribute, aria-label, or aria-labelledby are not present",
                validRoles: null,
                globalAriaAttributesValid: false,
                otherAllowedAriaAttributes: ["aria-hidden=true"]
            }
        },
        "input": {
            "button": {
                implicitRole: ["button"],
                validRoles: ["checkbox", "combobox", "gridcell", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "slider", "switch", "tab", "treeitem"],
                globalAriaAttributesValid: true
            },
            "checkbox-with-aria-pressed": {
                implicitRole: ["checkbox"],
                //roleCondition: " with type=checkbox and aria-pressed attribute is present",
                validRoles: ["button"],
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-required"],
                otherDisallowedAriaAttributes: ["aria-checked"]
            },
            "checkbox-without-aria-pressed": {
                implicitRole: ["checkbox"],
                //roleCondition: " with type=checkbox and aria-pressed attribute is not present",
                validRoles: ["menuitemcheckbox", "option", "switch"],
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-required"],
                otherDisallowedAriaAttributes: ["aria-checked"]
            },
            "color": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "date": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-required", "aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "datetime-local": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-required", "aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "email-no-list": {
                implicitRole: ["textbox"],
                //roleCondition: " with type=email and no list attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "email-with-list": {
                implicitRole: ["combobox"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "file": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-required"],
            },
            "hidden": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: false
            },
            "image": {
                implicitRole: ["button"],
                validRoles: ["checkbox", "gridcell", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "slider", "switch", "tab", "treeitem"],
                globalAriaAttributesValid: true
            },
            "month": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "number": {
                implicitRole: ["spinbutton"],
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"],
            },
            "password": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "radio": {
                implicitRole: ["radio"],
                validRoles: ["menuitemradio"],
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-required"],
                otherDisallowedAriaAttributes: ["aria-checked"]
            },
            "range": {
                implicitRole: ["slider"],
                validRoles: null,
                globalAriaAttributesValid: true,
                otherDisallowedAriaAttributes: ["aria-valuemax", "aria-valuemin"]
            },
            "reset": {
                implicitRole: ["button"],
                validRoles: ["checkbox", "combobox", "gridcell", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "slider", "switch", "tab", "treeitem"],
                globalAriaAttributesValid: true
            },
            "search-no-list": {
                implicitRole: ["searchbox"],
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"]
            },
            "search-with-list": {
                implicitRole: ["combobox"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "submit": {
                implicitRole: ["button"],
                validRoles: ["checkbox", "combobox", "gridcell", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "slider", "switch", "tab", "treeitem"],
                globalAriaAttributesValid: true
            },
            "tel-no-list": {
                implicitRole: ["textbox"],
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"]
            },
            "tel-with-list": {
                implicitRole: ["combobox"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "text-no-list": {
                implicitRole: ["textbox"],
                validRoles: ["combobox", "searchbox", "spinbutton"],
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"]
            },
            "text-with-list": {
                implicitRole: ["combobox"],
                validRoles: null,
                globalAriaAttributesValid: true
                // otherDisallowedAriaAttributes: ["aria-haspopup"]  // covered in a different rule
            },
            "time": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "url-no-list": {
                implicitRole: ["textbox"],
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"]
            },
            "url-with-list": {
                implicitRole: ["combobox"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "week": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "default-with-list": {
                // input with a missing or invalid type, with a list attribute
                implicitRole: ["combobox"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "default-no-list": {
                // input with a missing or invalid type, with a list attribute
                implicitRole: ["textbox"],
                validRoles: null,
                globalAriaAttributesValid: true
            }
        },
        "li": {
            "child-of-list-role": {
                implicitRole: ['listitem'],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "no-child-of-list-role": {
                implicitRole: ['listitem'],
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "section": {
            "with-name": {
                implicitRole: ["region"],
                validRoles: ["alert", "alertdialog", "application", "banner", "complementary", "contentinfo", "dialog", "doc-abstract", "doc-acknowledgments", "doc-afterword", "doc-appendix", "doc-bibliography", "doc-chapter", "doc-colophon", "doc-conclusion", "doc-credit", "doc-credits", "doc-dedication", "doc-endnotes", "doc-epigraph", "doc-epilogue", "doc-errata", "doc-example", "doc-foreword", "doc-glossary", "doc-index", "doc-introduction", "doc-notice", "doc-pagelist", "doc-part", "doc-preface", "doc-prologue", "doc-pullquote", "doc-qna", "doc-toc", "document", "feed", "group", "log", "main", "marquee", "navigation", "none", "note", "presentation", "search", "status", "tabpanel"],
                globalAriaAttributesValid: true
            },
            "without-name": {
                implicitRole: null,
                validRoles: ["alert", "alertdialog", "application", "banner", "complementary", "contentinfo", "dialog", "doc-abstract", "doc-acknowledgments", "doc-afterword", "doc-appendix", "doc-bibliography", "doc-chapter", "doc-colophon", "doc-conclusion", "doc-credit", "doc-credits", "doc-dedication", "doc-endnotes", "doc-epigraph", "doc-epilogue", "doc-errata", "doc-example", "doc-foreword", "doc-glossary", "doc-index", "doc-introduction", "doc-notice", "doc-pagelist", "doc-part", "doc-preface", "doc-prologue", "doc-pullquote", "doc-qna", "doc-toc", "document", "feed", "group", "log", "main", "marquee", "navigation", "none", "note", "presentation", "search", "status", "tabpanel"],
                globalAriaAttributesValid: true
            }
        },
        "select": {
            "no-multiple-attr-size-gt1": {
                //roleCondition: " with a multiple attribute or a size attribute having value greater than 1"
                implicitRole: ["combobox"],
                validRoles: ["menu"],
                globalAriaAttributesValid: true,
                otherDisallowedAriaAttributes: ["aria-multiselectable"]
            },
            "multiple-attr-size-gt1": {
                //roleCondition: " with no multiple attribute and no size attribute having value greater than 1"
                implicitRole: ["listbox"],
                validRoles: null,
                globalAriaAttributesValid: true,
                otherDisallowedAriaAttributes: ["aria-multiselectable"]
            }
        },
        "summary": {
            "first-summary-of-detail": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-disabled", "aria-haspopup"]
            },
            "no-first-summary-of-detail": {
                implicitRole: null,
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "tbody": {
            "des-table": {
                implicitRole: ["rowgroup"],
                validRoles: ["any"],
                globalAriaAttributesValid: true
            },
            "des-grid": {
                implicitRole: ["rowgroup"],
                validRoles: ["any"],
                globalAriaAttributesValid: true
            },
            "des-treegrid": {
                implicitRole: ["rowgroup"],
                validRoles: ["any"],
                globalAriaAttributesValid: true
            },
            "des-other": {
                implicitRole: null,
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "td": {
            "des-table": {
                implicitRole: ["cell"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-grid": {
                implicitRole: ["gridcell"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-treegrid": {
                implicitRole: ["gridcell"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-other": {
                implicitRole: null,
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "th": {
            "des-table-grid-treegrid-row-scope": {
                implicitRole: ["rowheader", "cell"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-table-grid-treegrid-column-scope": {
                implicitRole: ["columnheader", "cell"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-other": {
                implicitRole: null,
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "tr": {
            "des-table": {
                implicitRole: ["row"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-grid": {
                implicitRole: ["row"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-treegrid": {
                implicitRole: ["row"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-other": {
                implicitRole: null,
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "default": {
            implicitRole: null,
            //roleCondition: "",
            validRoles: ["any"],
            globalAriaAttributesValid: true
        }
    }; // end of documentConformanceRequirementSpecialTags
    // map aria attribute to the corresponding native attribute, apply to any element applicable
    // note this mapping is for the related attributes in the same element without checking the parent tree.
    // refer to https://w3c.github.io/html-aria/
    ARIADefinitions.relatedAriaHtmlAttributes = {
        "aria-checked": {
            conflict: {
                ariaAttributeValue: "false",
                htmlAttributeNames: ["checked"],
                htmlAttributeValues: null
            },
            overlapping: {
                ariaAttributeValue: "true",
                htmlAttributeNames: ["checked"],
                htmlAttributeValues: null
            }
        },
        "aria-disabled": {
            conflict: {
                ariaAttributeValue: "false",
                htmlAttributeNames: ["disabled"],
                htmlAttributeValues: null
            },
            overlapping: {
                ariaAttributeValue: "true",
                htmlAttributeNames: ["disabled"],
                htmlAttributeValues: null
            }
        },
        "aria-hidden": {
            conflict: {
                ariaAttributeValue: "false",
                htmlAttributeNames: ["hidden"],
                htmlAttributeValues: null
            },
            overlapping: {
                ariaAttributeValue: "true",
                htmlAttributeNames: ["hidden"],
                htmlAttributeValues: null
            }
        },
        "aria-placeholder": {
            conflict: {
                ariaAttributeValue: null,
                htmlAttributeNames: ["placeholder"],
                htmlAttributeValues: null
            }
        },
        "aria-valuemax": {
            conflict: {
                ariaAttributeValue: null,
                htmlAttributeNames: ["max"],
                htmlAttributeValues: null
            }
            //overlap case covered in the role definition: Authors SHOULD NOT use aria-valuemax on any element which allows the max attribute. Use the max attribute instead. 
        },
        "aria-valuemin": {
            conflict: {
                ariaAttributeValue: null,
                htmlAttributeNames: ["min"],
                htmlAttributeValues: null
            }
            ////overlap case covered in the role definition:Authors SHOULD NOT use aria-valuemin on any element which allows the min attribute. Use the min attribute instead.
        },
        "aria-readonly": {
            conflict: {
                ariaAttributeValue: "false",
                htmlAttributeNames: ["readonly", "contenteditable", "iscontenteditable"],
                htmlAttributeValues: [null, "false", "false"]
            },
            overlapping: {
                ariaAttributeValue: "true",
                htmlAttributeNames: ["readonly", "contenteditable", "iscontenteditable"],
                htmlAttributeValues: [null, "true", "true"]
            }
        },
        "aria-required": {
            conflict: {
                ariaAttributeValue: "false",
                htmlAttributeNames: ["required"],
                htmlAttributeValues: null
            },
            overlapping: {
                ariaAttributeValue: "true",
                htmlAttributeNames: ["required"],
                htmlAttributeValues: null
            }
        },
        "aria-colspan": {
            conflict: {
                // conflict occurs if both values are different
                ariaAttributeValue: "VALUE",
                htmlAttributeNames: ["colspan"],
                htmlAttributeValues: ["VALUE"]
            },
            overlapping: {
                // overlap occurs if both exists
                ariaAttributeValue: null,
                htmlAttributeNames: ["colspan"],
                htmlAttributeValues: null
            }
        },
        "aria-rowspan": {
            conflict: {
                // conflict occurs if both values are different
                ariaAttributeValue: "VALUE",
                htmlAttributeNames: ["rowspan"],
                htmlAttributeValues: ["VALUE"]
            },
            overlapping: {
                // overlap occurs if both exists 
                ariaAttributeValue: null,
                htmlAttributeNames: ["rowspan"],
                htmlAttributeValues: null
            }
        },
        "aria-autocomplete": {
            conflict: {
                // conflict occurs if both values are conflict
                ariaAttributeValue: "none",
                htmlAttributeNames: ["autocomplete"],
                htmlAttributeValues: ["on"]
            }
        }
    };
    ARIADefinitions.containers = [];
    return ARIADefinitions;
}());
exports.ARIADefinitions = ARIADefinitions;
;
var containerArray = [];
for (var roleDesign in ARIADefinitions.designPatterns) {
    var containers = ARIADefinitions.designPatterns[roleDesign].container;
    if (containers !== null) {
        for (var _i = 0, containers_1 = containers; _i < containers_1.length; _i++) {
            var container = containers_1[_i];
            if (containerArray.indexOf(container) == -1) {
                containerArray.push(container);
            }
        }
    }
}
ARIADefinitions.containers = containerArray;


/***/ }),

/***/ 4944:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ARIAMapper = void 0;
var ARIADefinitions_1 = __webpack_require__(8235);
var CommonMapper_1 = __webpack_require__(1794);
var DOMUtil_1 = __webpack_require__(295);
var legacy_1 = __webpack_require__(8422);
var fragment_1 = __webpack_require__(482);
var ARIAWalker_1 = __webpack_require__(8015);
var CacheUtil_1 = __webpack_require__(7788);
var DOMWalker_1 = __webpack_require__(7440);
var ARIAMapper = /** @class */ (function (_super) {
    __extends(ARIAMapper, _super);
    function ARIAMapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ARIAMapper.prototype.childrenCanHaveRole = function (node, role) {
        // if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
        //     const elem = node as Element;
        //     if (elem.getAttribute("aria-hidden") === "true") {
        //         return false;
        //     }
        // }
        return !(role in ARIADefinitions_1.ARIADefinitions.designPatterns && ARIADefinitions_1.ARIADefinitions.designPatterns[role].presentationalChildren);
    };
    ARIAMapper.prototype.getRole = function (node) {
        var role = ARIAMapper.nodeToRole(node);
        return role;
    };
    ARIAMapper.prototype.getNamespace = function () {
        return "aria";
    };
    ARIAMapper.prototype.getAttributes = function (node) {
        var retVal = {};
        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
            var elem_1 = node;
            for (var idx = 0; idx < elem_1.attributes.length; ++idx) {
                var attrInfo = elem_1.attributes[idx];
                var name_1 = attrInfo.name.toLowerCase();
                if (name_1.startsWith("aria-")) {
                    retVal[name_1.substring(5)] = attrInfo.nodeValue;
                }
            }
            var applyAttrRole = function (nodeName) {
                if (!(nodeName in ARIAMapper.elemAttrValueCalculators))
                    return;
                for (var attr in ARIAMapper.elemAttrValueCalculators[nodeName]) {
                    if (!(attr in retVal)) {
                        var value = ARIAMapper.elemAttrValueCalculators[nodeName][attr];
                        if (typeof value != "undefined" && value !== null) {
                            if (typeof value !== typeof "") {
                                value = value(elem_1);
                            }
                            retVal[attr] = value;
                        }
                    }
                }
            };
            applyAttrRole("global");
            applyAttrRole(node.nodeName.toLowerCase());
        }
        else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
            for (var attr in ARIAMapper.textAttrValueCalculators) {
                var val = ARIAMapper.textAttrValueCalculators[attr](node);
                if (typeof val != "undefined" && val !== null) {
                    retVal[attr] = val;
                }
            }
        }
        return retVal;
    };
    ARIAMapper.getAriaOwnedBy = function (elem) {
        var doc = fragment_1.FragmentUtil.getOwnerFragment(elem);
        if (!(0, CacheUtil_1.getCache)(doc, "ARIAMapper::precalcOwned", false)) {
            var owners = doc.querySelectorAll("[aria-owns]");
            for (var iOwner = 0; iOwner < owners.length; ++iOwner) {
                var owner = owners[iOwner];
                var ownIds = owner.getAttribute("aria-owns").split(/ +/g);
                for (var iId = 0; iId < ownIds.length; ++iId) {
                    var owned = doc.getElementById(ownIds[iId]);
                    if (owned) {
                        (0, CacheUtil_1.setCache)(owned, "aria-owned", owner);
                    }
                }
            }
            (0, CacheUtil_1.setCache)(doc, "ARIAMapper::precalcOwned", true);
        }
        return (0, CacheUtil_1.getCache)(elem, "aria-owned", null);
    };
    ARIAMapper.prototype.getNodeHierarchy = function (node) {
        if (!node)
            return [];
        if (node.nodeType !== 1) {
            var parentHierarchy = this.getNodeHierarchy(DOMWalker_1.DOMWalker.parentElement(node));
            var parentInfo = parentHierarchy.length > 0 ? parentHierarchy[parentHierarchy.length - 1] : {
                role: "",
                rolePath: "",
                roleCount: {},
                childrenCanHaveRole: true
            };
            var nodeHierarchy = [];
            // Set hierarchy
            for (var _i = 0, parentHierarchy_1 = parentHierarchy; _i < parentHierarchy_1.length; _i++) {
                var item = parentHierarchy_1[_i];
                nodeHierarchy.push(item);
            }
            nodeHierarchy.push({
                attributes: {},
                bounds: this.getBounds(node),
                namespace: this.getNamespace(),
                node: node,
                role: this.getRole(node) || "none",
                rolePath: parentInfo.rolePath + "/" + (this.getRole(node) || "none"),
                roleCount: {},
                childrenCanHaveRole: parentInfo.childrenCanHaveRole
            });
            return nodeHierarchy;
        }
        else {
            var elem = node;
            var nodeHierarchy = (0, CacheUtil_1.getCache)(elem, "ARIAMapper::getNodeHierarchy", null);
            if (!nodeHierarchy) {
                // This element hasn't been processed yet - but ::reset processes them all in the right order
                // Get details about the correct parent first
                var parent_1 = ARIAMapper.getAriaOwnedBy(elem);
                if (!parent_1) {
                    parent_1 = DOMWalker_1.DOMWalker.parentElement(elem);
                }
                while (parent_1 && parent_1.nodeType !== 1) {
                    parent_1 = DOMWalker_1.DOMWalker.parentElement(elem);
                }
                var parentHierarchy = parent_1 ? this.getNodeHierarchy(parent_1) : [];
                var parentInfo = parentHierarchy.length > 0 ? parentHierarchy[parentHierarchy.length - 1] : {
                    role: "",
                    rolePath: "",
                    roleCount: {},
                    childrenCanHaveRole: true
                };
                while (parentInfo.role === "none" || parentInfo.role === "/none") {
                    parent_1 = ARIAMapper.getAriaOwnedBy(parent_1) || DOMWalker_1.DOMWalker.parentElement(parent_1);
                    parentHierarchy = parent_1 ? this.getNodeHierarchy(parent_1) : [];
                    parentInfo = parentHierarchy[parentHierarchy.length - 1];
                }
                // Set initial node info
                var nodeInfo = {
                    attributes: elem.nodeType === 1 ? this.getAttributes(elem) : {},
                    bounds: this.getBounds(elem),
                    namespace: this.getNamespace(),
                    node: elem,
                    role: this.getRole(elem) || "none",
                    rolePath: "",
                    roleCount: {},
                    childrenCanHaveRole: true
                };
                // Adjust role if we're within a presentational container
                var presentationalContainer = !parentInfo.childrenCanHaveRole;
                if (presentationalContainer) {
                    nodeInfo.role = "none";
                }
                else {
                    nodeInfo.childrenCanHaveRole = parentInfo.childrenCanHaveRole
                        && this.childrenCanHaveRole(elem, nodeInfo.role);
                }
                // Set the paths
                if (nodeInfo.role !== "none") {
                    parentInfo.roleCount[nodeInfo.role] = (parentInfo.roleCount[nodeInfo.role] || 0) + 1;
                    nodeInfo.rolePath = parentInfo.rolePath + "/" + nodeInfo.role + "[" + parentInfo.roleCount[nodeInfo.role] + "]";
                }
                else {
                    nodeInfo.rolePath = parentInfo.rolePath;
                }
                // Set hierarchy
                nodeHierarchy = [];
                for (var _a = 0, parentHierarchy_2 = parentHierarchy; _a < parentHierarchy_2.length; _a++) {
                    var item = parentHierarchy_2[_a];
                    nodeHierarchy.push(item);
                }
                nodeHierarchy.push(nodeInfo);
                (0, CacheUtil_1.setCache)(elem, "ARIAMapper::getNodeHierarchy", nodeHierarchy);
            }
            return nodeHierarchy;
        }
    };
    ARIAMapper.prototype.reset = function (node) {
        ARIAMapper.nameComputationId = 0;
        this.hierarchyRole = [];
        this.hierarchyResults = [];
        this.hierarchyPath = [{
                rolePath: "",
                roleCount: {}
            }];
        // Get to the topmost node
        var goodNode = node;
        var next;
        while (next = DOMWalker_1.DOMWalker.parentNode(goodNode)) {
            goodNode = next;
        }
        ;
        // Walk the tree and set the hierarchies in the right order
        var ariaWalker = new ARIAWalker_1.ARIAWalker(goodNode, false, goodNode);
        do {
            if (ariaWalker.node.nodeType === 1) {
                this.getNodeHierarchy(ariaWalker.node);
            }
        } while (ariaWalker.nextNode());
    };
    ARIAMapper.prototype.openScope = function (node) {
        if (this.hierarchyRole === null) {
            this.reset(node);
        }
        this.pushHierarchy(node);
        for (var idx = 0; idx < this.hierarchyResults.length; ++idx) {
            if (this.hierarchyResults[idx].role[0] === "/") {
                this.hierarchyResults[idx].role = this.hierarchyResults[idx].role.substring(1);
            }
        }
        return this.hierarchyResults;
    };
    ARIAMapper.prototype.pushHierarchy = function (node) {
        // If we're not an element, no special handling
        var nodeHierarchy = [];
        // Determine our node info
        nodeHierarchy = this.getNodeHierarchy(node);
        var nodeInfo = nodeHierarchy[nodeHierarchy.length - 1];
        this.hierarchyRole.push(nodeInfo.role);
        if (nodeInfo.role !== "none") {
            this.hierarchyPath.push(nodeInfo);
        }
        this.hierarchyResults = nodeHierarchy;
    };
    ARIAMapper.prototype.closeScope = function (node) {
        var retVal = [];
        for (var _i = 0, _a = this.hierarchyResults; _i < _a.length; _i++) {
            var res = _a[_i];
            // const temp = res.node;
            // res.node = null;
            // let cloned = JSON.parse(JSON.stringify(res));
            // cloned.node = res.node = temp; 
            // retVal.push(cloned);
            retVal.push(res);
        }
        if (retVal.length > 0) {
            retVal[retVal.length - 1].role = "/" + retVal[retVal.length - 1].role;
            var parent_2 = DOMWalker_1.DOMWalker.parentElement(node);
            this.hierarchyResults = parent_2 ? (0, CacheUtil_1.getCache)(parent_2, "ARIAMapper::getNodeInfo", []) : [];
        }
        return retVal;
    };
    ARIAMapper.computeName = function (cur) {
        ++ARIAMapper.nameComputationId;
        return ARIAMapper.computeNameHelp(ARIAMapper.nameComputationId, cur, false, false);
    };
    ARIAMapper.computeNameHelp = function (walkId, cur, labelledbyTraverse, walkTraverse) {
        // 2g. None of the other content applies to text nodes, so just do this first
        if (cur.nodeType === 3 /* Node.TEXT_NODE */)
            return cur.nodeValue;
        if (cur.nodeType === 11)
            return "";
        if (cur.nodeType !== 1 /* Node.ELEMENT_NODE */) {
            if (walkTraverse || labelledbyTraverse)
                return "";
            throw new Error("Can only compute name on Element and Text " + cur.nodeType);
        }
        var elem = cur;
        // We've been here before - prevent recursion
        if ((0, CacheUtil_1.getCache)(elem, "data-namewalk", null) === "" + walkId)
            return "";
        (0, CacheUtil_1.setCache)(elem, "data-namewalk", "" + walkId);
        // See https://www.w3.org/TR/html-aam-1.0/#input-type-text-input-type-password-input-type-search-input-type-tel-input-type-url-and-textarea-element
        // 2a. Only show hidden content if it's referenced by a labelledby
        if (!labelledbyTraverse && !DOMWalker_1.DOMWalker.isNodeVisible(cur)) {
            return "";
        }
        // 2b. collect valid id references
        if (!labelledbyTraverse && elem.hasAttribute("aria-labelledby")) {
            var labelledby = elem.getAttribute("aria-labelledby").split(" ");
            var validElems = [];
            for (var _i = 0, labelledby_1 = labelledby; _i < labelledby_1.length; _i++) {
                var ref = labelledby_1[_i];
                var refElem = fragment_1.FragmentUtil.getById(cur, ref);
                if (refElem) {
                    validElems.push(refElem);
                }
            }
            if (validElems.length > 0) {
                var accumulated = "";
                for (var _a = 0, validElems_1 = validElems; _a < validElems_1.length; _a++) {
                    var elem_2 = validElems_1[_a];
                    accumulated += " " + this.computeNameHelp(walkId, elem_2, true, false);
                }
                return accumulated.trim();
            }
        }
        // Since nodeToRole calls back here for form and section, we need special casing here to handle those two cases
        if (["section", "form"].includes(cur.nodeName.toLowerCase())) {
            if (elem.hasAttribute("aria-label") && elem.getAttribute("aria-label").trim().length > 0) {
                // If I'm not an embedded control or I'm not recursing, return the aria-label
                if (!labelledbyTraverse && !walkTraverse) {
                    return elem.getAttribute("aria-label").trim();
                }
            }
            if (elem.hasAttribute("title")) {
                return elem.getAttribute("title");
            }
            return "";
        }
        // 2c. If label or walk, and this is a control, skip to the value, otherwise provide the label
        var role = ARIAMapper.nodeToRole(cur);
        var isEmbeddedControl = [
            "textbox", "button", "combobox", "listbox",
            "progressbar", "scrollbar", "slider", "spinbutton"
        ].includes(role);
        if (elem.hasAttribute("aria-label") && elem.getAttribute("aria-label").trim().length > 0) {
            // If I'm not an embedded control or I'm not recursing, return the aria-label
            if (!labelledbyTraverse && !walkTraverse || !isEmbeddedControl) {
                return elem.getAttribute("aria-label").trim();
            }
        }
        // 2d. 
        if (role !== "presentation" && role !== "none") {
            if ((cur.nodeName.toLowerCase() === "img" || cur.nodeName.toLowerCase() === "area") && elem.hasAttribute("alt")) {
                return DOMUtil_1.DOMUtil.cleanWhitespace(elem.getAttribute("alt")).trim();
            }
            if (cur.nodeName.toLowerCase() === "input" && elem.hasAttribute("id") && elem.getAttribute("id").length > 0) {
                var label = elem.ownerDocument.querySelector("label[for='" + elem.getAttribute("id") + "']");
                if (label) {
                    if (label.hasAttribute("aria-label") || label.hasAttribute("aria-labelledby")) {
                        return this.computeNameHelp(walkId, label, false, false);
                    }
                    else {
                        return label.textContent;
                    }
                }
            }
            if (cur.nodeName.toLowerCase() === "fieldset") {
                if (cur.querySelector("legend")) {
                    var legend = cur.querySelector("legend");
                    return legend.innerText;
                }
                else {
                    return this.computeNameHelp(walkId, cur, false, false);
                }
            }
        }
        // 2e.
        if ((walkTraverse || labelledbyTraverse) && isEmbeddedControl) {
            // If the embedded control has role textbox, return its value.
            if (role === "textbox") {
                if (elem.nodeName.toLowerCase() === "input") {
                    if (elem.hasAttribute("value"))
                        return elem.getAttribute("value");
                }
                else {
                    walkTraverse = false;
                }
            }
            // If the embedded control has role button, return the text alternative of the button.
            if (role === "button") {
                if (elem.nodeName.toLowerCase() === "input") {
                    var type = elem.getAttribute("type").toLowerCase();
                    if (["button", "submit", "reset"].includes(type)) {
                        if (elem.hasAttribute("value"))
                            return elem.getAttribute("value");
                        if (type === "submit")
                            return "Submit";
                        if (type === "reset")
                            return "Reset";
                    }
                }
                else {
                    walkTraverse = false;
                }
            }
            // TODO: If the embedded control has role combobox or listbox, return the text alternative of the chosen option.
            if (role === "combobox") {
                if (elem.hasAttribute("aria-activedescendant")) {
                    var selected = fragment_1.FragmentUtil.getById(elem, "aria-activedescendant");
                    if (selected) {
                        return ARIAMapper.computeNameHelp(walkId, selected, false, false);
                    }
                }
            }
            // If the embedded control has role range (e.g., a spinbutton or slider):
            if (["progressbar", "scrollbar", "slider", "spinbutton"].includes(role)) {
                // If the aria-valuetext property is present, return its value,
                if (elem.hasAttribute("aria-valuetext"))
                    return elem.getAttribute("aria-valuetext");
                // Otherwise, if the aria-valuenow property is present, return its value,
                if (elem.hasAttribute("aria-valuenow"))
                    return elem.getAttribute("aria-valuenow");
                // TODO: Otherwise, use the value as specified by a host language attribute.
            }
        }
        // 2f. 2h.
        if (walkTraverse || ARIADefinitions_1.ARIADefinitions.nameFromContent(role) || labelledbyTraverse) {
            // 2fi. Set the accumulated text to the empty string.
            var accumulated = "";
            // 2fii. Check for CSS generated textual content associated with the current node and 
            // include it in the accumulated text. The CSS :before and :after pseudo elements [CSS2] 
            // can provide textual content for elements that have a content model.
            //   For :before pseudo elements, User agents MUST prepend CSS textual content, without 
            //     a space, to the textual content of the current node.
            //   For :after pseudo elements, User agents MUST append CSS textual content, without a 
            //     space, to the textual content of the current node.
            var before = null;
            before = elem.ownerDocument.defaultView.getComputedStyle(elem, "before").content;
            if (before && before !== "none") {
                before = before.replace(/^"/, "").replace(/"$/, "");
                accumulated += before;
            }
            // 2fiii. For each child node of the current node:
            //   Set the current node to the child node.
            //   Compute the text alternative of the current node beginning with step 2. Set the result 
            //     to that text alternative.
            //   Append the result to the accumulated text.
            if (elem.nodeName.toUpperCase() === "SLOT") {
                //if no assignedNode, check its own text 
                if (!elem.assignedNodes() || elem.assignedNodes().length === 0) {
                    var innerText = legacy_1.RPTUtil.getInnerText(elem);
                    if (innerText && innerText !== null && innerText.trim().length > 0)
                        accumulated += " " + innerText;
                }
                else {
                    // check text from all assigned nodes
                    for (var _b = 0, _c = elem.assignedNodes(); _b < _c.length; _b++) {
                        var slotChild = _c[_b];
                        var nextChildContent = ARIAMapper.computeNameHelp(walkId, slotChild, labelledbyTraverse, true);
                        accumulated += " " + nextChildContent;
                    }
                }
            }
            else {
                var walkChild = elem.firstChild;
                while (walkChild) {
                    var nextChildContent = ARIAMapper.computeNameHelp(walkId, walkChild, labelledbyTraverse, true);
                    accumulated += " " + nextChildContent;
                    walkChild = walkChild.nextSibling;
                }
            }
            var after = null;
            try {
                after = elem.ownerDocument.defaultView.getComputedStyle(elem, "after").content;
            }
            catch (e) { }
            if (after && after !== "none") {
                after = after.replace(/^"/, "").replace(/"$/, "");
                accumulated += after;
            }
            // 2fiv. Return the accumulated text.
            accumulated = accumulated.replace(/\s+/g, " ").trim();
            if (accumulated.trim().length > 0) {
                return accumulated;
            }
        }
        // 2i. Otherwise, if the current node has a Tooltip attribute, return its value.
        if (elem.hasAttribute("title")) {
            return elem.getAttribute("title");
        }
        if (elem.tagName.toLowerCase() === "svg") {
            var title = elem.querySelector("title");
            if (title) {
                return title.textContent || title.innerText;
            }
        }
        return "";
    };
    /*        if (role in ARIADefinitions.designPatterns
                && ARIADefinitions.designPatterns[role].nameFrom
                && ARIADefinitions.designPatterns[role].nameFrom.includes("contents"))
            {
                name = elem.textContent;
            }
            if (elem.nodeName.toLowerCase() === "input" && elem.hasAttribute("id") && elem.getAttribute("id").trim().length > 0) {
                name = elem.ownerDocument.querySelector("label[for='"+elem.getAttribute("id").trim()+"']").textContent;
            }
            if (elem.hasAttribute("aria-label")) {
                name = elem.getAttribute("aria-label");
            }
            if (elem.hasAttribute("aria-labelledby")) {
                name = "";
                const ids = elem.getAttribute("aria-labelledby").split(" ");
                for (const id of ids) {
                    name += FragmentUtil.getById(elem, id).textContent + " ";
                }
                name = name.trim();
            }
            return name;
        }*/
    ARIAMapper.nodeToRole = function (node) {
        if (node.nodeType === 3 /* Node.TEXT_NODE */) {
            return "text";
        }
        else if (node.nodeType !== 1 /* Node.ELEMENT_NODE */) {
            return null;
        }
        var elem = node;
        if (!elem || elem.nodeType !== 1 /* Node.ELEMENT_NODE */) {
            return null;
        }
        if (elem.hasAttribute("role") && elem.getAttribute("role").trim().length > 0) {
            var roleStr = elem.getAttribute("role").trim();
            var roles_2 = roleStr.split(" ");
            for (var _i = 0, roles_1 = roles_2; _i < roles_1.length; _i++) {
                var role = roles_1[_i];
                if (role === "presentation" || role === "none") {
                    // If element is focusable, then presentation roles are to be ignored
                    if (!legacy_1.RPTUtil.isFocusable(elem)) {
                        return null;
                    }
                }
                else if (role in ARIADefinitions_1.ARIADefinitions.designPatterns) {
                    return role;
                }
            }
        }
        //return this.elemToImplicitRole(elem);
        var roles = legacy_1.RPTUtil.getImplicitRole(elem);
        return !roles || roles.length === 0 ? null : roles[0];
    };
    ////////////////////////////////////////////////////////////////////////////
    // Helper functions
    ////
    // https://www.w3.org/TR/html-aam-1.0/#mapping-html-to-accessibility-apis
    ARIAMapper.elemAttrValueCalculators = {
        "global": {
            "name": ARIAMapper.computeName
        },
        "datalist": {
            // set to "true" if the datalist's selection model allows multiple option elements to be
            // selected at a time, and "false" otherwise
            "multiselectable": function (elem) {
                var id = elem.getAttribute("id");
                if (id && id.length > 0) {
                    var input = elem.ownerDocument.querySelector("input[list='" + id + "']");
                    return "" + (elem.getAttribute("multiple")
                        && (elem.getAttribute("multiple") == "true" || elem.getAttribute("multiple") == ""));
                }
                return null;
            }
        },
        "h1": {
            "level": "1"
        },
        "h2": {
            "level": "2"
        },
        "h3": {
            "level": "3"
        },
        "h4": {
            "level": "4"
        },
        "h5": {
            "level": "5"
        },
        "h6": {
            "level": "6"
        },
        "input": {
            // - type="checkbox" state set to "mixed" if the element's indeterminate IDL attribute 
            // is true, or "true" if the element's checkedness is true, or "false" otherwise
            // - type="radio" state set to "true" if the element's checkedness is true, or "false" 
            // otherwise. 
            "checked": function (elem) {
                if (elem.getAttribute("type") === "checkbox" || elem.getAttribute("type") === "radio") {
                    return "" + elem.checked;
                }
                return null;
            }
            // - type="radio" and not in menu reflecting number of type=radio input elements 
            // within the radio button group
            ,
            "setsize": function (elem) { return null; throw new Error("NOT IMPLEMENTED"); }
            // - type="radio" and not in menu value reflecting the elements position 
            // within the radio button group."
            ,
            "posinset": function (elem) { return null; throw new Error("NOT IMPLEMENTED"); }
            // input (type attribute in the Text, Search, Telephone, URL, or E-mail states with a 
            // suggestions source element) combobox role, with the aria-owns property set to the same
            // value as the list attribute
            ,
            "owns": function (elem) { return null; throw new Error("NOT IMPLEMENTED"); }
        },
        "keygen": {
            "multiselectable": "false"
        },
        "li": {
            // Number of li elements within the ol, ul, menu
            "setsize": function (elem) {
                var parent = DOMUtil_1.DOMUtil.getAncestor(elem, ["ol", "ul", "menu"]);
                if (!parent)
                    return null;
                var lis = parent.querySelectorAll("li");
                var otherlis = parent.querySelectorAll("ol li, ul li, menu li");
                return "" + (lis.length - otherlis.length);
            }
            // Position of li element within the ol, ul, menu
            ,
            "posinset": function (elem) {
                var parent = DOMUtil_1.DOMUtil.getAncestor(elem, ["ol", "ul", "menu"]);
                if (!parent)
                    return null;
                var lis = parent.querySelectorAll("li");
                var num = 0;
                for (var idx = 0; idx < lis.length; ++idx) {
                    var li = lis[idx];
                    if (DOMUtil_1.DOMUtil.sameNode(parent, DOMUtil_1.DOMUtil.getAncestor(li, ["ol", "ul", "menu"]))) {
                        return "" + num;
                    }
                    ++num;
                }
                return null;
            }
        },
        "menuitem": {
            // type = checkbox or radio, set to "true" if the checked attribute 
            // is present, and "false" otherwise
            "checked": function (elem) { return "" + !!(elem.getAttribute("checked")
                && (elem.getAttribute("checked") == "true" || elem.getAttribute("checked") == "")); }
        },
        "option": {
            // set to "true" if the element's selectedness is true, or "false" otherwise.
            "selected": function (elem) { return "" + !!(elem.getAttribute("selected")
                && (elem.getAttribute("selected") == "true" || elem.getAttribute("selected") == "")); }
        },
        "progress": {
            "valuemax": function (elem) { return elem.getAttribute("max") || "1"; },
            "valuemin": function (elem) { return "0"; },
            "valuenow": function (elem) { return elem.getAttribute("value"); }
        }
    };
    ARIAMapper.textAttrValueCalculators = {
        "name": function (node) { return node.nodeValue; }
    };
    ARIAMapper.nameComputationId = 0;
    return ARIAMapper;
}(CommonMapper_1.CommonMapper));
exports.ARIAMapper = ARIAMapper;


/***/ }),

/***/ 8015:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ARIAWalker = void 0;
var fragment_1 = __webpack_require__(482);
var DOMWalker_1 = __webpack_require__(7440);
var ARIAMapper_1 = __webpack_require__(4944);
/**
 * Walks in an ARIA order
 *
 * See also ../dom/DOMWalker
 */
var ARIAWalker = /** @class */ (function () {
    function ARIAWalker(element, bEnd, root) {
        this.root = root || element;
        this.node = element;
        this.bEndTag = (bEnd == undefined ? false : bEnd == true);
    }
    ARIAWalker.prototype.atRoot = function () {
        if (this.ownerElement)
            return false;
        if (this.root === this.node) {
            return true;
        }
        else if (this.root.isSameNode) {
            return this.root.isSameNode(this.node);
        }
        else if (this.root.compareDocumentPosition) {
            return this.root.compareDocumentPosition(this.node) === 0;
        }
        else {
            // Not supported in this environment - try our best
            return this.node.parentNode === null;
        }
    };
    ARIAWalker.prototype.nextNode = function () {
        var skipOwned = false;
        do {
            skipOwned = false;
            // console.log(this.node.nodeName, this.bEndTag?"END":"START", this.node.nodeType === 1 && (this.node as any).getAttribute("id"));
            if (!this.bEndTag) {
                var iframeNode = this.node;
                var elementNode = this.node;
                var slotElement = this.node;
                if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && this.node.nodeName.toUpperCase() === "IFRAME"
                    && DOMWalker_1.DOMWalker.isNodeVisible(iframeNode)
                    && iframeNode.contentDocument
                    && iframeNode.contentDocument.documentElement) {
                    var ownerElement = this.node;
                    this.node = iframeNode.contentDocument.documentElement;
                    this.node.ownerElement = ownerElement;
                }
                else if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && DOMWalker_1.DOMWalker.isNodeVisible(elementNode)
                    && elementNode.shadowRoot
                    && elementNode.shadowRoot.firstChild) {
                    var ownerElement = this.node;
                    this.node = elementNode.shadowRoot;
                    this.node.ownerElement = ownerElement;
                }
                else if (this.node.nodeType === 1
                    && elementNode.nodeName.toLowerCase() === "slot"
                    && slotElement.assignedNodes().length > 0) {
                    //TODO: need to conside its own content, a slot may have its own content or assigned content
                    var slotOwner = this.node;
                    this.node = slotElement.assignedNodes()[0];
                    this.node.slotOwner = slotOwner;
                    this.node.slotIndex = 0;
                }
                else if ((this.node.nodeType === 1 /* Node.ELEMENT_NODE */ || this.node.nodeType === 11) /* Node.ELEMENT_NODE */ && this.node.firstChild) {
                    this.node = this.node.firstChild;
                }
                else {
                    this.bEndTag = true;
                }
            }
            else {
                if (this.atRoot()) {
                    return false;
                }
                else if (this.node.slotOwner) {
                    var slotOwner = this.node.slotOwner;
                    var nextSlotIndex = this.node.slotIndex + 1;
                    delete this.node.slotOwner;
                    delete this.node.slotIndex;
                    if (nextSlotIndex < slotOwner.assignedNodes().length) {
                        this.node = slotOwner.assignedNodes()[nextSlotIndex];
                        this.node.slotOwner = slotOwner;
                        this.node.slotIndex = nextSlotIndex;
                        this.bEndTag = false;
                    }
                    else {
                        this.node = slotOwner;
                        this.bEndTag = true;
                    }
                }
                else if (this.node.ownerElement) {
                    this.node = this.node.ownerElement;
                    this.bEndTag = true;
                }
                else if (this.node.nextSibling) {
                    this.node = this.node.nextSibling;
                    this.bEndTag = false;
                    skipOwned = true;
                }
                else if (this.node.parentNode) {
                    if (this.node.parentNode.nodeType === 1 && this.node.parentNode.hasAttribute("aria-owns")) {
                        var ownIds = this.node.parentNode.getAttribute("aria-owns").split(/ +/g);
                        if (this.node.nodeType !== 1 || !this.node.hasAttribute("id")) {
                            this.node = fragment_1.FragmentUtil.getOwnerFragment(this.node).getElementById(ownIds[0]);
                            this.bEndTag = false;
                        }
                        else {
                            var idx = ownIds.indexOf(this.node.getAttribute("id"));
                            if (idx === ownIds.length - 1) {
                                // last one
                                this.node = this.node.parentNode;
                                this.bEndTag = true;
                            }
                            else {
                                // grab next
                                this.node = fragment_1.FragmentUtil.getOwnerFragment(this.node).getElementById(ownIds[idx + 1]);
                                this.bEndTag = false;
                            }
                        }
                    }
                    this.node = this.node.parentNode;
                    this.bEndTag = true;
                }
                else {
                    return false;
                }
            }
        } while ((this.node.nodeType !== 1 /* Node.ELEMENT_NODE */ && this.node.nodeType !== 11 && this.node.nodeType !== 3 /* Node.TEXT_NODE */)
            || (this.node.nodeType === 1 && this.node.getAttribute("aChecker") === "ACE")
            || (skipOwned && this.node.nodeType === 1 && !!ARIAMapper_1.ARIAMapper.getAriaOwnedBy(this.node)));
        return true;
    };
    ARIAWalker.prototype.prevNode = function () {
        do {
            if (this.bEndTag) {
                var iframeNode = this.node;
                var elementNode = this.node;
                if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && this.node.nodeName.toUpperCase() === "IFRAME"
                    && DOMWalker_1.DOMWalker.isNodeVisible(iframeNode)
                    && iframeNode.contentDocument
                    && iframeNode.contentDocument.documentElement) {
                    var ownerElement = this.node;
                    this.node = iframeNode.contentDocument.documentElement;
                    this.node.ownerElement = ownerElement;
                }
                else if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && DOMWalker_1.DOMWalker.isNodeVisible(elementNode)
                    && elementNode.shadowRoot
                    && elementNode.shadowRoot.lastChild) {
                    var ownerElement = this.node;
                    this.node = elementNode.shadowRoot;
                    this.node.ownerElement = ownerElement;
                }
                else if ((this.node.nodeType === 1 /* Node.ELEMENT_NODE */ || this.node.nodeType === 11) && this.node.lastChild) {
                    this.node = this.node.lastChild;
                }
                else {
                    this.bEndTag = false;
                }
            }
            else {
                if (this.atRoot()) {
                    return false;
                }
                else if (this.node.previousSibling) {
                    this.node = this.node.previousSibling;
                    this.bEndTag = true;
                }
                else if (this.node.ownerElement) {
                    this.node = this.node.ownerElement;
                    this.bEndTag = false;
                }
                else if (this.node.parentNode) {
                    this.node = this.node.parentNode;
                    this.bEndTag = false;
                }
                else {
                    return false;
                }
            }
        } while ((this.node.nodeType !== 1 /* Node.ELEMENT_NODE */ && this.node.nodeType !== 11)
            || (this.node.nodeType === 1 && this.node.getAttribute("aChecker") === "ACE"));
        return true;
    };
    return ARIAWalker;
}());
exports.ARIAWalker = ARIAWalker;


/***/ }),

/***/ 9193:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AncestorUtil = void 0;
var AncestorUtil = /** @class */ (function () {
    function AncestorUtil() {
    }
    AncestorUtil.isPresentationFrame = function (contextHierarchy) {
        if (contextHierarchy && contextHierarchy.dom) {
            // Skip current node because we want ancestry
            for (var idx = contextHierarchy.dom.length - 2; idx >= 0; --idx) {
                var elem = contextHierarchy.dom[idx].node;
                if (elem.nodeType === 1
                    && elem.nodeName.toLowerCase() === "iframe"
                    && (elem.getAttribute("role") === "presentation" || elem.getAttribute("aria-hidden") === "true")) {
                    return true;
                }
            }
        }
        return false;
    };
    AncestorUtil.isFrame = function (contextHierarchy) {
        if (contextHierarchy && contextHierarchy.dom) {
            // Skip current node because we want ancestry
            for (var idx = contextHierarchy.dom.length - 2; idx >= 0; --idx) {
                var elem = contextHierarchy.dom[idx].node;
                if (elem.nodeType === 1 && elem.nodeName.toLowerCase() === "iframe") {
                    return true;
                }
            }
        }
        return false;
    };
    return AncestorUtil;
}());
exports.AncestorUtil = AncestorUtil;


/***/ }),

/***/ 482:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FragmentUtil = void 0;
var FragmentUtil = /** @class */ (function () {
    function FragmentUtil() {
    }
    FragmentUtil.getOwnerFragment = function (node) {
        var n = node;
        while (n.parentNode && (n = n.parentNode)) {
            if (n.nodeType === 11) {
                return n;
            }
        }
        return node.ownerDocument;
    };
    FragmentUtil.getById = function (node, id) {
        return this.getOwnerFragment(node).getElementById(id);
    };
    FragmentUtil.getAncestor = function (hierarchies, elemName) {
        var matches = hierarchies["dom"].filter(function (info) { return info.role === elemName; });
        return matches.length > 0 && matches[0].node || null;
    };
    FragmentUtil.getAncestorWithRole = function (hierarchies, role) {
        var matches = hierarchies["aria"].filter(function (info) { return info.role === role; });
        return matches.length > 0 && matches[0].node || null;
    };
    return FragmentUtil;
}());
exports.FragmentUtil = FragmentUtil;


/***/ }),

/***/ 2527:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2021- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LangUtil = void 0;
// From https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
var validPrimaryLangs = [
    ["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "aaa", "aab", "aac", "aad", "aae", "aaf", "aag", "aah", "aai", "aak", "aal", "aam", "aan", "aao", "aap", "aaq", "aas", "aat", "aau", "aav", "aaw", "aax", "aaz", "aba", "abb", "abc", "abd", "abe", "abf", "abg", "abh", "abi", "abj", "abl", "abm", "abn", "abo", "abp", "abq", "abr", "abs", "abt", "abu", "abv", "abw", "abx", "aby", "abz", "aca", "acb", "acd", "ace", "acf", "ach", "aci", "ack", "acl", "acm", "acn", "acp", "acq", "acr", "acs", "act", "acu", "acv", "acw", "acx", "acy", "acz", "ada", "adb", "add", "ade", "adf", "adg", "adh", "adi", "adj", "adl", "adn", "ado", "adp", "adq", "adr", "ads", "adt", "adu", "adw", "adx", "ady", "adz", "aea", "aeb", "aec", "aed", "aee", "aek", "ael", "aem", "aen", "aeq", "aer", "aes", "aeu", "aew", "aey", "aez", "afa", "afb", "afd", "afe", "afg", "afh", "afi", "afk", "afn", "afo", "afp", "afs", "aft", "afu", "afz", "aga", "agb", "agc", "agd", "age", "agf", "agg", "agh", "agi", "agj", "agk", "agl", "agm", "agn", "ago", "agp", "agq", "agr", "ags", "agt", "agu", "agv", "agw", "agx", "agy", "agz", "aha", "ahb", "ahg", "ahh", "ahi", "ahk", "ahl", "ahm", "ahn", "aho", "ahp", "ahr", "ahs", "aht", "aia", "aib", "aic", "aid", "aie", "aif", "aig", "aih", "aii", "aij", "aik", "ail", "aim", "ain", "aio", "aip", "aiq", "air", "ais", "ait", "aiw", "aix", "aiy", "aja", "ajg", "aji", "ajn", "ajp", "ajt", "aju", "ajw", "ajz", "akb", "akc", "akd", "ake", "akf", "akg", "akh", "aki", "akj", "akk", "akl", "akm", "ako", "akp", "akq", "akr", "aks", "akt", "aku", "akv", "akw", "akx", "aky", "akz", "ala", "alc", "ald", "ale", "alf", "alg", "alh", "ali", "alj", "alk", "all", "alm", "aln", "alo", "alp", "alq", "alr", "als", "alt", "alu", "alv", "alw", "alx", "aly", "alz", "ama", "amb", "amc", "ame", "amf", "amg", "ami", "amj", "amk", "aml", "amm", "amn", "amo", "amp", "amq", "amr", "ams", "amt", "amu", "amv", "amw", "amx", "amy", "amz", "ana", "anb", "anc", "and", "ane", "anf", "ang", "anh", "ani", "anj", "ank", "anl", "anm", "ann", "ano", "anp", "anq", "anr", "ans", "ant", "anu", "anv", "anw", "anx", "any", "anz", "aoa", "aob", "aoc", "aod", "aoe", "aof", "aog", "aoh", "aoi", "aoj", "aok", "aol", "aom", "aon", "aor", "aos", "aot", "aou", "aox", "aoz", "apa", "apb", "apc", "apd", "ape", "apf", "apg", "aph", "api", "apj", "apk", "apl", "apm", "apn", "apo", "app", "apq", "apr", "aps", "apt", "apu", "apv", "apw", "apx", "apy", "apz", "aqa", "aqc", "aqd", "aqg", "aqk", "aql", "aqm", "aqn", "aqp", "aqr", "aqt", "aqz", "arb", "arc", "ard", "are", "arh", "ari", "arj", "ark", "arl", "arn", "aro", "arp", "arq", "arr", "ars", "art", "aru", "arv", "arw", "arx", "ary", "arz", "asa", "asb", "asc", "asd", "ase", "asf", "asg", "ash", "asi", "asj", "ask", "asl", "asn", "aso", "asp", "asq", "asr", "ass", "ast", "asu", "asv", "asw", "asx", "asy", "asz", "ata", "atb", "atc", "atd", "ate", "atg", "ath", "ati", "atj", "atk", "atl", "atm", "atn", "ato", "atp", "atq", "atr", "ats", "att", "atu", "atv", "atw", "atx", "aty", "atz", "aua", "aub", "auc", "aud", "aue", "auf", "aug", "auh", "aui", "auj", "auk", "aul", "aum", "aun", "auo", "aup", "auq", "aur", "aus", "aut", "auu", "auw", "aux", "auy", "auz", "avb", "avd", "avi", "avk", "avl", "avm", "avn", "avo", "avs", "avt", "avu", "avv", "awa", "awb", "awc", "awd", "awe", "awg", "awh", "awi", "awk", "awm", "awn", "awo", "awr", "aws", "awt", "awu", "awv", "aww", "awx", "awy", "axb", "axe", "axg", "axk", "axl", "axm", "axx", "aya", "ayb", "ayc", "ayd", "aye", "ayg", "ayh", "ayi", "ayk", "ayl", "ayn", "ayo", "ayp", "ayq", "ayr", "ays", "ayt", "ayu", "ayx", "ayy", "ayz", "aza", "azb", "azc", "azd", "azg", "azj", "azm", "azn", "azo", "azt", "azz"],
    ["ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "baa", "bab", "bac", "bad", "bae", "baf", "bag", "bah", "bai", "baj", "bal", "ban", "bao", "bap", "bar", "bas", "bat", "bau", "bav", "baw", "bax", "bay", "baz", "bba", "bbb", "bbc", "bbd", "bbe", "bbf", "bbg", "bbh", "bbi", "bbj", "bbk", "bbl", "bbm", "bbn", "bbo", "bbp", "bbq", "bbr", "bbs", "bbt", "bbu", "bbv", "bbw", "bbx", "bby", "bbz", "bca", "bcb", "bcc", "bcd", "bce", "bcf", "bcg", "bch", "bci", "bcj", "bck", "bcl", "bcm", "bcn", "bco", "bcp", "bcq", "bcr", "bcs", "bct", "bcu", "bcv", "bcw", "bcy", "bcz", "bda", "bdb", "bdc", "bdd", "bde", "bdf", "bdg", "bdh", "bdi", "bdj", "bdk", "bdl", "bdm", "bdn", "bdo", "bdp", "bdq", "bdr", "bds", "bdt", "bdu", "bdv", "bdw", "bdx", "bdy", "bdz", "bea", "beb", "bec", "bed", "bee", "bef", "beg", "beh", "bei", "bej", "bek", "bem", "beo", "bep", "beq", "ber", "bes", "bet", "beu", "bev", "bew", "bex", "bey", "bez", "bfa", "bfb", "bfc", "bfd", "bfe", "bff", "bfg", "bfh", "bfi", "bfj", "bfk", "bfl", "bfm", "bfn", "bfo", "bfp", "bfq", "bfr", "bfs", "bft", "bfu", "bfw", "bfx", "bfy", "bfz", "bga", "bgb", "bgc", "bgd", "bge", "bgf", "bgg", "bgi", "bgj", "bgk", "bgl", "bgm", "bgn", "bgo", "bgp", "bgq", "bgr", "bgs", "bgt", "bgu", "bgv", "bgw", "bgx", "bgy", "bgz", "bha", "bhb", "bhc", "bhd", "bhe", "bhf", "bhg", "bhh", "bhi", "bhj", "bhk", "bhl", "bhm", "bhn", "bho", "bhp", "bhq", "bhr", "bhs", "bht", "bhu", "bhv", "bhw", "bhx", "bhy", "bhz", "bia", "bib", "bic", "bid", "bie", "bif", "big", "bij", "bik", "bil", "bim", "bin", "bio", "bip", "biq", "bir", "bit", "biu", "biv", "biw", "bix", "biy", "biz", "bja", "bjb", "bjc", "bjd", "bje", "bjf", "bjg", "bjh", "bji", "bjj", "bjk", "bjl", "bjm", "bjn", "bjo", "bjp", "bjq", "bjr", "bjs", "bjt", "bju", "bjv", "bjw", "bjx", "bjy", "bjz", "bka", "bkb", "bkc", "bkd", "bkf", "bkg", "bkh", "bki", "bkj", "bkk", "bkl", "bkm", "bkn", "bko", "bkp", "bkq", "bkr", "bks", "bkt", "bku", "bkv", "bkw", "bkx", "bky", "bkz", "bla", "blb", "blc", "bld", "ble", "blf", "blg", "blh", "bli", "blj", "blk", "bll", "blm", "bln", "blo", "blp", "blq", "blr", "bls", "blt", "blv", "blw", "blx", "bly", "blz", "bma", "bmb", "bmc", "bmd", "bme", "bmf", "bmg", "bmh", "bmi", "bmj", "bmk", "bml", "bmm", "bmn", "bmo", "bmp", "bmq", "bmr", "bms", "bmt", "bmu", "bmv", "bmw", "bmx", "bmy", "bmz", "bna", "bnb", "bnc", "bnd", "bne", "bnf", "bng", "bni", "bnj", "bnk", "bnl", "bnm", "bnn", "bno", "bnp", "bnq", "bnr", "bns", "bnt", "bnu", "bnv", "bnw", "bnx", "bny", "bnz", "boa", "bob", "boe", "bof", "bog", "boh", "boi", "boj", "bok", "bol", "bom", "bon", "boo", "bop", "boq", "bor", "bot", "bou", "bov", "bow", "box", "boy", "boz", "bpa", "bpb", "bpd", "bpe", "bpg", "bph", "bpi", "bpj", "bpk", "bpl", "bpm", "bpn", "bpo", "bpp", "bpq", "bpr", "bps", "bpt", "bpu", "bpv", "bpw", "bpx", "bpy", "bpz", "bqa", "bqb", "bqc", "bqd", "bqf", "bqg", "bqh", "bqi", "bqj", "bqk", "bql", "bqm", "bqn", "bqo", "bqp", "bqq", "bqr", "bqs", "bqt", "bqu", "bqv", "bqw", "bqx", "bqy", "bqz", "bra", "brb", "brc", "brd", "brf", "brg", "brh", "bri", "brj", "brk", "brl", "brm", "brn", "bro", "brp", "brq", "brr", "brs", "brt", "bru", "brv", "brw", "brx", "bry", "brz", "bsa", "bsb", "bsc", "bse", "bsf", "bsg", "bsh", "bsi", "bsj", "bsk", "bsl", "bsm", "bsn", "bso", "bsp", "bsq", "bsr", "bss", "bst", "bsu", "bsv", "bsw", "bsx", "bsy", "bta", "btb", "btc", "btd", "bte", "btf", "btg", "bth", "bti", "btj", "btk", "btl", "btm", "btn", "bto", "btp", "btq", "btr", "bts", "btt", "btu", "btv", "btw", "btx", "bty", "btz", "bua", "bub", "buc", "bud", "bue", "buf", "bug", "buh", "bui", "buj", "buk", "bum", "bun", "buo", "bup", "buq", "bus", "but", "buu", "buv", "buw", "bux", "buy", "buz", "bva", "bvb", "bvc", "bvd", "bve", "bvf", "bvg", "bvh", "bvi", "bvj", "bvk", "bvl", "bvm", "bvn", "bvo", "bvp", "bvq", "bvr", "bvt", "bvu", "bvv", "bvw", "bvx", "bvy", "bvz", "bwa", "bwb", "bwc", "bwd", "bwe", "bwf", "bwg", "bwh", "bwi", "bwj", "bwk", "bwl", "bwm", "bwn", "bwo", "bwp", "bwq", "bwr", "bws", "bwt", "bwu", "bww", "bwx", "bwy", "bwz", "bxa", "bxb", "bxc", "bxd", "bxe", "bxf", "bxg", "bxh", "bxi", "bxj", "bxk", "bxl", "bxm", "bxn", "bxo", "bxp", "bxq", "bxr", "bxs", "bxu", "bxv", "bxw", "bxx", "bxz", "bya", "byb", "byc", "byd", "bye", "byf", "byg", "byh", "byi", "byj", "byk", "byl", "bym", "byn", "byo", "byp", "byq", "byr", "bys", "byt", "byv", "byw", "byx", "byy", "byz", "bza", "bzb", "bzc", "bzd", "bze", "bzf", "bzg", "bzh", "bzi", "bzj", "bzk", "bzl", "bzm", "bzn", "bzo", "bzp", "bzq", "bzr", "bzs", "bzt", "bzu", "bzv", "bzw", "bzx", "bzy", "bzz"],
    ["ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "caa", "cab", "cac", "cad", "cae", "caf", "cag", "cah", "cai", "caj", "cak", "cal", "cam", "can", "cao", "cap", "caq", "car", "cas", "cau", "cav", "caw", "cax", "cay", "caz", "cba", "cbb", "cbc", "cbd", "cbe", "cbg", "cbh", "cbi", "cbj", "cbk", "cbl", "cbn", "cbo", "cbq", "cbr", "cbs", "cbt", "cbu", "cbv", "cbw", "cby", "cca", "ccc", "ccd", "cce", "ccg", "cch", "ccj", "ccl", "ccm", "ccn", "cco", "ccp", "ccq", "ccr", "ccs", "cda", "cdc", "cdd", "cde", "cdf", "cdg", "cdh", "cdi", "cdj", "cdm", "cdn", "cdo", "cdr", "cds", "cdy", "cdz", "cea", "ceb", "ceg", "cek", "cel", "cen", "cet", "cey", "cfa", "cfd", "cfg", "cfm", "cga", "cgc", "cgg", "cgk", "chb", "chc", "chd", "chf", "chg", "chh", "chj", "chk", "chl", "chm", "chn", "cho", "chp", "chq", "chr", "cht", "chw", "chx", "chy", "chz", "cia", "cib", "cic", "cid", "cie", "cih", "cik", "cim", "cin", "cip", "cir", "ciw", "ciy", "cja", "cje", "cjh", "cji", "cjk", "cjm", "cjn", "cjo", "cjp", "cjr", "cjs", "cjv", "cjy", "cka", "ckb", "ckh", "ckl", "ckm", "ckn", "cko", "ckq", "ckr", "cks", "ckt", "cku", "ckv", "ckx", "cky", "ckz", "cla", "clc", "cld", "cle", "clh", "cli", "clj", "clk", "cll", "clm", "clo", "clt", "clu", "clw", "cly", "cma", "cmc", "cme", "cmg", "cmi", "cmk", "cml", "cmm", "cmn", "cmo", "cmr", "cms", "cmt", "cna", "cnb", "cnc", "cng", "cnh", "cni", "cnk", "cnl", "cno", "cnp", "cnr", "cns", "cnt", "cnu", "cnw", "cnx", "coa", "cob", "coc", "cod", "coe", "cof", "cog", "coh", "coj", "cok", "col", "com", "con", "coo", "cop", "coq", "cot", "cou", "cov", "cow", "cox", "coy", "coz", "cpa", "cpb", "cpc", "cpe", "cpf", "cpg", "cpi", "cpn", "cpo", "cpp", "cps", "cpu", "cpx", "cpy", "cqd", "cqu", "cra", "crb", "crc", "crd", "crf", "crg", "crh", "cri", "crj", "crk", "crl", "crm", "crn", "cro", "crp", "crq", "crr", "crs", "crt", "crv", "crw", "crx", "cry", "crz", "csa", "csb", "csc", "csd", "cse", "csf", "csg", "csh", "csi", "csj", "csk", "csl", "csm", "csn", "cso", "csp", "csq", "csr", "css", "cst", "csu", "csv", "csw", "csx", "csy", "csz", "cta", "ctc", "ctd", "cte", "ctg", "cth", "ctl", "ctm", "ctn", "cto", "ctp", "cts", "ctt", "ctu", "cty", "ctz", "cua", "cub", "cuc", "cug", "cuh", "cui", "cuj", "cuk", "cul", "cum", "cuo", "cup", "cuq", "cur", "cus", "cut", "cuu", "cuv", "cuw", "cux", "cuy", "cvg", "cvn", "cwa", "cwb", "cwd", "cwe", "cwg", "cwt", "cya", "cyb", "cyo", "czh", "czk", "czn", "czo", "czt"],
    ["da", "de", "dv", "dz", "daa", "dac", "dad", "dae", "daf", "dag", "dah", "dai", "daj", "dak", "dal", "dam", "dao", "dap", "daq", "dar", "das", "dau", "dav", "daw", "dax", "day", "daz", "dba", "dbb", "dbd", "dbe", "dbf", "dbg", "dbi", "dbj", "dbl", "dbm", "dbn", "dbo", "dbp", "dbq", "dbr", "dbt", "dbu", "dbv", "dbw", "dby", "dcc", "dcr", "dda", "ddd", "dde", "ddg", "ddi", "ddj", "ddn", "ddo", "ddr", "dds", "ddw", "dec", "ded", "dee", "def", "deg", "deh", "dei", "dek", "del", "dem", "den", "dep", "deq", "der", "des", "dev", "dez", "dga", "dgb", "dgc", "dgd", "dge", "dgg", "dgh", "dgi", "dgk", "dgl", "dgn", "dgo", "dgr", "dgs", "dgt", "dgu", "dgw", "dgx", "dgz", "dha", "dhd", "dhg", "dhi", "dhl", "dhm", "dhn", "dho", "dhr", "dhs", "dhu", "dhv", "dhw", "dhx", "dia", "dib", "dic", "did", "dif", "dig", "dih", "dii", "dij", "dik", "dil", "dim", "din", "dio", "dip", "diq", "dir", "dis", "dit", "diu", "diw", "dix", "diy", "diz", "dja", "djb", "djc", "djd", "dje", "djf", "dji", "djj", "djk", "djl", "djm", "djn", "djo", "djr", "dju", "djw", "dka", "dkg", "dkk", "dkl", "dkr", "dks", "dkx", "dlg", "dlk", "dlm", "dln", "dma", "dmb", "dmc", "dmd", "dme", "dmf", "dmg", "dmk", "dml", "dmm", "dmn", "dmo", "dmr", "dms", "dmu", "dmv", "dmw", "dmx", "dmy", "dna", "dnd", "dne", "dng", "dni", "dnj", "dnk", "dnn", "dno", "dnr", "dnt", "dnu", "dnv", "dnw", "dny", "doa", "dob", "doc", "doe", "dof", "doh", "doi", "dok", "dol", "don", "doo", "dop", "doq", "dor", "dos", "dot", "dov", "dow", "dox", "doy", "doz", "dpp", "dra", "drb", "drc", "drd", "dre", "drg", "drh", "dri", "drl", "drn", "dro", "drq", "drr", "drs", "drt", "dru", "drw", "dry", "dsb", "dse", "dsh", "dsi", "dsl", "dsn", "dso", "dsq", "dta", "dtb", "dtd", "dth", "dti", "dtk", "dtm", "dtn", "dto", "dtp", "dtr", "dts", "dtt", "dtu", "dty", "dua", "dub", "duc", "dud", "due", "duf", "dug", "duh", "dui", "duj", "duk", "dul", "dum", "dun", "duo", "dup", "duq", "dur", "dus", "duu", "duv", "duw", "dux", "duy", "duz", "dva", "dwa", "dwk", "dwl", "dwr", "dws", "dwu", "dww", "dwy", "dwz", "dya", "dyb", "dyd", "dyg", "dyi", "dym", "dyn", "dyo", "dyu", "dyy", "dza", "dzd", "dze", "dzg", "dzl", "dzn"],
    ["ee", "el", "en", "eo", "es", "et", "eu", "eaa", "ebc", "ebg", "ebk", "ebo", "ebr", "ebu", "ecr", "ecs", "ecy", "eee", "efa", "efe", "efi", "ega", "egl", "ego", "egx", "egy", "ehs", "ehu", "eip", "eit", "eiv", "eja", "eka", "ekc", "eke", "ekg", "eki", "ekk", "ekl", "ekm", "eko", "ekp", "ekr", "eky", "ele", "elh", "eli", "elk", "elm", "elo", "elp", "elu", "elx", "ema", "emb", "eme", "emg", "emi", "emk", "emm", "emn", "emo", "emp", "emq", "ems", "emu", "emw", "emx", "emy", "emz", "ena", "enb", "enc", "end", "enf", "enh", "enl", "enm", "enn", "eno", "enq", "enr", "enu", "env", "enw", "enx", "eot", "epi", "era", "erg", "erh", "eri", "erk", "ero", "err", "ers", "ert", "erw", "ese", "esg", "esh", "esi", "esk", "esl", "esm", "esn", "eso", "esq", "ess", "esu", "esx", "esy", "etb", "etc", "eth", "etn", "eto", "etr", "ets", "ett", "etu", "etx", "etz", "euq", "eve", "evh", "evn", "ewo", "ext", "eya", "eyo", "eza", "eze"],
    ["fa", "ff", "fi", "fj", "fo", "fr", "fy", "faa", "fab", "fad", "faf", "fag", "fah", "fai", "faj", "fak", "fal", "fam", "fan", "fap", "far", "fat", "fau", "fax", "fay", "faz", "fbl", "fcs", "fer", "ffi", "ffm", "fgr", "fia", "fie", "fif", "fil", "fip", "fir", "fit", "fiu", "fiw", "fkk", "fkv", "fla", "flh", "fli", "fll", "fln", "flr", "fly", "fmp", "fmu", "fnb", "fng", "fni", "fod", "foi", "fom", "fon", "for", "fos", "fox", "fpe", "fqs", "frc", "frd", "frk", "frm", "fro", "frp", "frq", "frr", "frs", "frt", "fse", "fsl", "fss", "fub", "fuc", "fud", "fue", "fuf", "fuh", "fui", "fuj", "fum", "fun", "fuq", "fur", "fut", "fuu", "fuv", "fuy", "fvr", "fwa", "fwe"],
    ["ga", "gd", "gl", "gn", "gu", "gv", "gaa", "gab", "gac", "gad", "gae", "gaf", "gag", "gah", "gai", "gaj", "gak", "gal", "gam", "gan", "gao", "gap", "gaq", "gar", "gas", "gat", "gau", "gav", "gaw", "gax", "gay", "gaz", "gba", "gbb", "gbc", "gbd", "gbe", "gbf", "gbg", "gbh", "gbi", "gbj", "gbk", "gbl", "gbm", "gbn", "gbo", "gbp", "gbq", "gbr", "gbs", "gbu", "gbv", "gbw", "gbx", "gby", "gbz", "gcc", "gcd", "gce", "gcf", "gcl", "gcn", "gcr", "gct", "gda", "gdb", "gdc", "gdd", "gde", "gdf", "gdg", "gdh", "gdi", "gdj", "gdk", "gdl", "gdm", "gdn", "gdo", "gdq", "gdr", "gds", "gdt", "gdu", "gdx", "gea", "geb", "gec", "ged", "gef", "geg", "geh", "gei", "gej", "gek", "gel", "gem", "geq", "ges", "gev", "gew", "gex", "gey", "gez", "gfk", "gft", "gfx", "gga", "ggb", "ggd", "gge", "ggg", "ggk", "ggl", "ggn", "ggo", "ggr", "ggt", "ggu", "ggw", "gha", "ghc", "ghe", "ghh", "ghk", "ghl", "ghn", "gho", "ghr", "ghs", "ght", "gia", "gib", "gic", "gid", "gie", "gig", "gih", "gii", "gil", "gim", "gin", "gio", "gip", "giq", "gir", "gis", "git", "giu", "giw", "gix", "giy", "giz", "gji", "gjk", "gjm", "gjn", "gjr", "gju", "gka", "gkd", "gke", "gkn", "gko", "gkp", "gku", "glb", "glc", "gld", "glh", "gli", "glj", "glk", "gll", "glo", "glr", "glu", "glw", "gly", "gma", "gmb", "gmd", "gme", "gmg", "gmh", "gml", "gmm", "gmn", "gmq", "gmr", "gmu", "gmv", "gmw", "gmx", "gmy", "gmz", "gna", "gnb", "gnc", "gnd", "gne", "gng", "gnh", "gni", "gnj", "gnk", "gnl", "gnm", "gnn", "gno", "gnq", "gnr", "gnt", "gnu", "gnw", "gnz", "goa", "gob", "goc", "god", "goe", "gof", "gog", "goh", "goi", "goj", "gok", "gol", "gom", "gon", "goo", "gop", "goq", "gor", "gos", "got", "gou", "gow", "gox", "goy", "goz", "gpa", "gpe", "gpn", "gqa", "gqi", "gqn", "gqr", "gqu", "gra", "grb", "grc", "grd", "grg", "grh", "gri", "grj", "grk", "grm", "gro", "grq", "grr", "grs", "grt", "gru", "grv", "grw", "grx", "gry", "grz", "gse", "gsg", "gsl", "gsm", "gsn", "gso", "gsp", "gss", "gsw", "gta", "gti", "gtu", "gua", "gub", "guc", "gud", "gue", "guf", "gug", "guh", "gui", "guk", "gul", "gum", "gun", "guo", "gup", "guq", "gur", "gus", "gut", "guu", "guv", "guw", "gux", "guz", "gva", "gvc", "gve", "gvf", "gvj", "gvl", "gvm", "gvn", "gvo", "gvp", "gvr", "gvs", "gvy", "gwa", "gwb", "gwc", "gwd", "gwe", "gwf", "gwg", "gwi", "gwj", "gwm", "gwn", "gwr", "gwt", "gwu", "gww", "gwx", "gxx", "gya", "gyb", "gyd", "gye", "gyf", "gyg", "gyi", "gyl", "gym", "gyn", "gyo", "gyr", "gyy", "gyz", "gza", "gzi", "gzn"],
    ["ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "haa", "hab", "hac", "had", "hae", "haf", "hag", "hah", "hai", "haj", "hak", "hal", "ham", "han", "hao", "hap", "haq", "har", "has", "hav", "haw", "hax", "hay", "haz", "hba", "hbb", "hbn", "hbo", "hbu", "hca", "hch", "hdn", "hds", "hdy", "hea", "hed", "heg", "heh", "hei", "hem", "hgm", "hgw", "hhi", "hhr", "hhy", "hia", "hib", "hid", "hif", "hig", "hih", "hii", "hij", "hik", "hil", "him", "hio", "hir", "hit", "hiw", "hix", "hji", "hka", "hke", "hkh", "hkk", "hkn", "hks", "hla", "hlb", "hld", "hle", "hlt", "hlu", "hma", "hmb", "hmc", "hmd", "hme", "hmf", "hmg", "hmh", "hmi", "hmj", "hmk", "hml", "hmm", "hmn", "hmp", "hmq", "hmr", "hms", "hmt", "hmu", "hmv", "hmw", "hmx", "hmy", "hmz", "hna", "hnd", "hne", "hng", "hnh", "hni", "hnj", "hnn", "hno", "hns", "hnu", "hoa", "hob", "hoc", "hod", "hoe", "hoh", "hoi", "hoj", "hok", "hol", "hom", "hoo", "hop", "hor", "hos", "hot", "hov", "how", "hoy", "hoz", "hpo", "hps", "hra", "hrc", "hre", "hrk", "hrm", "hro", "hrp", "hrr", "hrt", "hru", "hrw", "hrx", "hrz", "hsb", "hsh", "hsl", "hsn", "hss", "hti", "hto", "hts", "htu", "htx", "hub", "huc", "hud", "hue", "huf", "hug", "huh", "hui", "huj", "huk", "hul", "hum", "huo", "hup", "huq", "hur", "hus", "hut", "huu", "huv", "huw", "hux", "huy", "huz", "hvc", "hve", "hvk", "hvn", "hvv", "hwa", "hwc", "hwo", "hya", "hyw", "hyx"],
    ["ia", "id", "ie", "ig", "ii", "ik", "in", "io", "is", "it", "iu", "iw", "iai", "ian", "iap", "iar", "iba", "ibb", "ibd", "ibe", "ibg", "ibh", "ibi", "ibl", "ibm", "ibn", "ibr", "ibu", "iby", "ica", "ich", "icl", "icr", "ida", "idb", "idc", "idd", "ide", "idi", "idr", "ids", "idt", "idu", "ifa", "ifb", "ife", "iff", "ifk", "ifm", "ifu", "ify", "igb", "ige", "igg", "igl", "igm", "ign", "igo", "igs", "igw", "ihb", "ihi", "ihp", "ihw", "iin", "iir", "ijc", "ije", "ijj", "ijn", "ijo", "ijs", "ike", "iki", "ikk", "ikl", "iko", "ikp", "ikr", "iks", "ikt", "ikv", "ikw", "ikx", "ikz", "ila", "ilb", "ilg", "ili", "ilk", "ill", "ilm", "ilo", "ilp", "ils", "ilu", "ilv", "ilw", "ima", "ime", "imi", "iml", "imn", "imo", "imr", "ims", "imy", "inb", "inc", "ine", "ing", "inh", "inj", "inl", "inm", "inn", "ino", "inp", "ins", "int", "inz", "ior", "iou", "iow", "ipi", "ipo", "iqu", "iqw", "ira", "ire", "irh", "iri", "irk", "irn", "iro", "irr", "iru", "irx", "iry", "isa", "isc", "isd", "ise", "isg", "ish", "isi", "isk", "ism", "isn", "iso", "isr", "ist", "isu", "itb", "itc", "itd", "ite", "iti", "itk", "itl", "itm", "ito", "itr", "its", "itt", "itv", "itw", "itx", "ity", "itz", "ium", "ivb", "ivv", "iwk", "iwm", "iwo", "iws", "ixc", "ixl", "iya", "iyo", "iyx", "izh", "izi", "izr", "izz"],
    ["ja", "ji", "jv", "jw", "jaa", "jab", "jac", "jad", "jae", "jaf", "jah", "jaj", "jak", "jal", "jam", "jan", "jao", "jaq", "jar", "jas", "jat", "jau", "jax", "jay", "jaz", "jbe", "jbi", "jbj", "jbk", "jbm", "jbn", "jbo", "jbr", "jbt", "jbu", "jbw", "jcs", "jct", "jda", "jdg", "jdt", "jeb", "jee", "jeg", "jeh", "jei", "jek", "jel", "jen", "jer", "jet", "jeu", "jgb", "jge", "jgk", "jgo", "jhi", "jhs", "jia", "jib", "jic", "jid", "jie", "jig", "jih", "jii", "jil", "jim", "jio", "jiq", "jit", "jiu", "jiv", "jiy", "jje", "jjr", "jka", "jkm", "jko", "jkp", "jkr", "jks", "jku", "jle", "jls", "jma", "jmb", "jmc", "jmd", "jmi", "jml", "jmn", "jmr", "jms", "jmw", "jmx", "jna", "jnd", "jng", "jni", "jnj", "jnl", "jns", "job", "jod", "jog", "jor", "jos", "jow", "jpa", "jpr", "jpx", "jqr", "jra", "jrb", "jrr", "jrt", "jru", "jsl", "jua", "jub", "juc", "jud", "juh", "jui", "juk", "jul", "jum", "jun", "juo", "jup", "jur", "jus", "jut", "juu", "juw", "juy", "jvd", "jvn", "jwi", "jya", "jye", "jyy"],
    ["ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "kaa", "kab", "kac", "kad", "kae", "kaf", "kag", "kah", "kai", "kaj", "kak", "kam", "kao", "kap", "kaq", "kar", "kav", "kaw", "kax", "kay", "kba", "kbb", "kbc", "kbd", "kbe", "kbf", "kbg", "kbh", "kbi", "kbj", "kbk", "kbl", "kbm", "kbn", "kbo", "kbp", "kbq", "kbr", "kbs", "kbt", "kbu", "kbv", "kbw", "kbx", "kby", "kbz", "kca", "kcb", "kcc", "kcd", "kce", "kcf", "kcg", "kch", "kci", "kcj", "kck", "kcl", "kcm", "kcn", "kco", "kcp", "kcq", "kcr", "kcs", "kct", "kcu", "kcv", "kcw", "kcx", "kcy", "kcz", "kda", "kdc", "kdd", "kde", "kdf", "kdg", "kdh", "kdi", "kdj", "kdk", "kdl", "kdm", "kdn", "kdo", "kdp", "kdq", "kdr", "kdt", "kdu", "kdv", "kdw", "kdx", "kdy", "kdz", "kea", "keb", "kec", "ked", "kee", "kef", "keg", "keh", "kei", "kej", "kek", "kel", "kem", "ken", "keo", "kep", "keq", "ker", "kes", "ket", "keu", "kev", "kew", "kex", "key", "kez", "kfa", "kfb", "kfc", "kfd", "kfe", "kff", "kfg", "kfh", "kfi", "kfj", "kfk", "kfl", "kfm", "kfn", "kfo", "kfp", "kfq", "kfr", "kfs", "kft", "kfu", "kfv", "kfw", "kfx", "kfy", "kfz", "kga", "kgb", "kgc", "kgd", "kge", "kgf", "kgg", "kgh", "kgi", "kgj", "kgk", "kgl", "kgm", "kgn", "kgo", "kgp", "kgq", "kgr", "kgs", "kgt", "kgu", "kgv", "kgw", "kgx", "kgy", "kha", "lyg", "khb", "khc", "khd", "khe", "khf", "khg", "khh", "khi", "khj", "khk", "khl", "khn", "kho", "khp", "khq", "khr", "khs", "kht", "khu", "khv", "khw", "khx", "khy", "khz", "kia", "kib", "kic", "kid", "kie", "kif", "kig", "kih", "kii", "kij", "kil", "kim", "kio", "kip", "kiq", "kis", "kit", "kiu", "kiv", "kiw", "kix", "kiy", "kiz", "kja", "kjb", "kjc", "kjd", "kje", "kjf", "kjg", "kjh", "kji", "kjj", "kjk", "kjl", "kjm", "kjn", "kjo", "kjp", "kjq", "kjr", "kjs", "kjt", "kju", "kjv", "kjx", "kjy", "kjz", "kka", "kkb", "kkc", "kkd", "kke", "kkf", "kkg", "kkh", "kki", "kkj", "kkk", "kkl", "kkm", "kkn", "kko", "kkp", "kkq", "kkr", "kks", "kkt", "kku", "kkv", "kkw", "kkx", "kky", "kkz", "kla", "klb", "klc", "kld", "kle", "klf", "klg", "klh", "kli", "klj", "klk", "kll", "klm", "kln", "klo", "klp", "klq", "klr", "kls", "klt", "klu", "klv", "klw", "klx", "kly", "klz", "kma", "kmb", "kmc", "kmd", "kme", "kmf", "kmg", "kmh", "kmi", "kmj", "kmk", "kml", "kmm", "kmn", "kmo", "kmp", "kmq", "kmr", "kms", "kmt", "kmu", "kmv", "kmw", "kmx", "kmy", "kmz", "kna", "knb", "knc", "knd", "kne", "knf", "kng", "kni", "knj", "knk", "knl", "knm", "knn", "kno", "knp", "knq", "knr", "kns", "knt", "knu", "knv", "knw", "knx", "kny", "knz", "koa", "koc", "kod", "koe", "kof", "kog", "koh", "koi", "koj", "kok", "kol", "koo", "kop", "koq", "kos", "kot", "kou", "kov", "kow", "kox", "koy", "koz", "kpa", "kpb", "kpc", "kpd", "kpe", "kpf", "kpg", "kph", "kpi", "kpj", "kpk", "kpl", "kpm", "kpn", "kpo", "kpp", "kpq", "kpr", "kps", "kpt", "kpu", "kpv", "kpw", "kpx", "kpy", "kpz", "kqa", "kqb", "kqc", "kqd", "kqe", "kqf", "kqg", "kqh", "kqi", "kqj", "kqk", "kql", "kqm", "kqn", "kqo", "kqp", "kqq", "kqr", "kqs", "kqt", "kqu", "kqv", "kqw", "kqx", "kqy", "kqz", "kra", "krb", "krc", "krd", "kre", "krf", "krh", "kri", "krj", "krk", "krl", "krm", "krn", "kro", "krp", "krr", "krs", "krt", "kru", "krv", "krw", "krx", "kry", "krz", "ksa", "ksb", "ksc", "ksd", "kse", "ksf", "ksg", "ksh", "ksi", "ksj", "ksk", "ksl", "ksm", "ksn", "kso", "ksp", "ksq", "ksr", "kss", "kst", "ksu", "ksv", "ksw", "ksx", "ksy", "ksz", "kta", "ktb", "ktc", "ktd", "kte", "ktf", "ktg", "kth", "kti", "ktj", "ktk", "ktl", "ktm", "ktn", "kto", "ktp", "ktq", "ktr", "kts", "ktt", "ktu", "ktv", "ktw", "ktx", "kty", "ktz", "kub", "kuc", "kud", "kue", "kuf", "kug", "kuh", "kui", "kuj", "kuk", "kul", "kum", "kun", "kuo", "kup", "kuq", "kus", "kut", "kuu", "kuv", "kuw", "kux", "kuy", "kuz", "kva", "kvb", "kvc", "kvd", "kve", "kvf", "kvg", "kvh", "kvi", "kvj", "kvk", "kvl", "kvm", "kvn", "kvo", "kvp", "kvq", "kvr", "kvs", "kvt", "kvu", "kvv", "kvw", "kvx", "kvy", "kvz", "kwa", "kwb", "kwc", "kwd", "kwe", "kwf", "kwg", "kwh", "kwi", "kwj", "kwk", "kwl", "kwm", "kwn", "kwo", "kwp", "kwq", "kwr", "kws", "kwt", "kwu", "kwv", "kww", "kwx", "kwy", "kwz", "kxa", "kxb", "kxc", "kxd", "kxe", "kxf", "kxh", "kxi", "kxj", "kxk", "kxl", "kxm", "kxn", "kxo", "kxp", "kxq", "kxr", "kxs", "kxt", "kxu", "kxv", "kxw", "kxx", "kxy", "kxz", "kya", "kyb", "kyc", "kyd", "kye", "kyf", "kyg", "kyh", "kyi", "kyj", "kyk", "kyl", "kym", "kyn", "kyo", "kyp", "kyq", "kyr", "kys", "kyt", "kyu", "kyv", "kyw", "kyx", "kyy", "kyz", "kza", "kzb", "kzc", "kzd", "kze", "kzf", "kzg", "kzh", "kzi", "kzj", "kzk", "kzl", "kzm", "kzn", "kzo", "kzp", "kzq", "kzr", "kzs", "kzt", "kzu", "kzv", "kzw", "kzx", "kzy", "kzz"],
    ["la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "laa", "lab", "lac", "lad", "lae", "laf", "lag", "lah", "lai", "laj", "lak", "lal", "lam", "lan", "lap", "laq", "lar", "las", "lau", "law", "lax", "lay", "laz", "lba", "lbb", "lbc", "lbe", "lbf", "lbg", "lbi", "lbj", "lbk", "lbl", "lbm", "lbn", "lbo", "lbq", "lbr", "lbs", "lbt", "lbu", "lbv", "lbw", "lbx", "lby", "lbz", "lcc", "lcd", "lce", "lcf", "lch", "lcl", "lcm", "lcp", "lcq", "lcs", "lda", "ldb", "ldd", "ldg", "ldh", "ldi", "ldj", "ldk", "ldl", "ldm", "ldn", "ldo", "ldp", "ldq", "lea", "leb", "lec", "led", "lee", "lef", "leg", "leh", "lei", "lej", "lek", "lel", "lem", "len", "leo", "lep", "leq", "ler", "les", "let", "leu", "lev", "lew", "lex", "ley", "lez", "lfa", "lfn", "lga", "lgb", "lgg", "lgh", "lgi", "lgk", "lgl", "lgm", "lgn", "lgq", "lgr", "lgt", "lgu", "lgz", "lha", "lhh", "lhi", "lhl", "lhm", "lhn", "lhp", "lhs", "lht", "lhu", "lia", "lib", "lic", "lid", "lie", "lif", "lig", "lih", "lii", "lij", "lik", "lil", "lio", "lip", "liq", "lir", "lis", "liu", "liv", "liw", "lix", "liy", "liz", "lja", "lje", "lji", "ljl", "ljp", "ljw", "ljx", "lka", "lkb", "lkc", "lkd", "lke", "lkh", "lki", "lkj", "lkl", "lkm", "lkn", "lko", "lkr", "lks", "lkt", "lku", "lky", "lla", "llb", "llc", "lld", "lle", "llf", "llg", "llh", "lli", "llj", "llk", "lll", "llm", "lln", "llo", "llp", "llq", "lls", "llu", "llx", "lma", "lmb", "lmc", "lmd", "lme", "lmf", "lmg", "lmh", "lmi", "lmj", "lmk", "lml", "lmm", "lmn", "lmo", "lmp", "lmq", "lmr", "lmu", "lmv", "lmw", "lmx", "lmy", "lmz", "lna", "lnb", "lnd", "lng", "lnh", "lni", "lnj", "lnl", "lnm", "lnn", "lno", "lns", "lnu", "lnw", "lnz", "loa", "lob", "loc", "loe", "lof", "log", "loh", "loi", "loj", "lok", "lol", "lom", "lon", "loo", "lop", "loq", "lor", "los", "lot", "lou", "lov", "low", "lox", "loy", "loz", "lpa", "lpe", "lpn", "lpo", "lpx", "lra", "lrc", "lre", "lrg", "lri", "lrk", "lrl", "lrm", "lrn", "lro", "lrr", "lrt", "lrv", "lrz", "lsa", "lsb", "lsd", "lse", "lsg", "lsh", "lsi", "lsl", "lsm", "lsn", "lso", "lsp", "lsr", "lss", "lst", "lsv", "lsy", "ltc", "ltg", "lth", "lti", "ltn", "lto", "lts", "ltu", "lua", "luc", "lud", "lue", "luf", "lui", "luj", "luk", "lul", "lum", "lun", "luo", "lup", "luq", "lur", "lus", "lut", "luu", "luv", "luw", "luy", "luz", "lva", "lvi", "lvk", "lvs", "lvu", "lwa", "lwe", "lwg", "lwh", "lwl", "lwm", "lwo", "lws", "lwt", "lwu", "lww", "lxm", "lya", "lyg", "lyn", "lzh", "lzl", "lzn", "lzz"],
    ["mg", "mh", "mi", "mk", "ml", "mn", "mo", "mr", "ms", "mt", "my", "maa", "mab", "mad", "mae", "maf", "mag", "mai", "maj", "mak", "mam", "man", "map", "maq", "mas", "mat", "mau", "mav", "maw", "max", "maz", "mba", "mbb", "mbc", "mbd", "mbe", "mbf", "mbh", "mbi", "mbj", "mbk", "mbl", "mbm", "mbn", "mbo", "mbp", "mbq", "mbr", "mbs", "mbt", "mbu", "mbv", "mbw", "mbx", "mby", "mbz", "mca", "mcb", "mcc", "mcd", "mce", "mcf", "mcg", "mch", "mci", "mcj", "mck", "mcl", "mcm", "mcn", "mco", "mcp", "mcq", "mcr", "mcs", "mct", "mcu", "mcv", "mcw", "mcx", "mcy", "mcz", "mda", "mdb", "mdc", "mdd", "mde", "mdf", "mdg", "mdh", "mdi", "mdj", "mdk", "mdl", "mdm", "mdn", "mdp", "mdq", "mdr", "mds", "mdt", "mdu", "mdv", "mdw", "mdx", "mdy", "mdz", "mea", "meb", "mec", "med", "mee", "mef", "meg", "meh", "mei", "mej", "mek", "mel", "mem", "men", "meo", "mep", "meq", "mer", "mes", "met", "meu", "mev", "mew", "mey", "mez", "mfa", "mfb", "mfc", "mfd", "mfe", "mff", "mfg", "mfh", "mfi", "mfj", "mfk", "mfl", "mfm", "mfn", "mfo", "mfp", "mfq", "mfr", "mfs", "mft", "mfu", "mfv", "mfw", "mfx", "mfy", "mfz", "mga", "mgb", "mgc", "mgd", "mge", "mgf", "mgg", "mgh", "mgi", "mgj", "mgk", "mgl", "mgm", "mgn", "mgo", "mgp", "mgq", "mgr", "mgs", "mgt", "mgu", "mgv", "mgw", "mgx", "mgy", "mgz", "mha", "mhb", "mhc", "mhd", "mhe", "mhf", "mhg", "mhh", "mhi", "mhj", "mhk", "mhl", "mhm", "mhn", "mho", "mhp", "mhq", "mhr", "mhs", "mht", "mhu", "mhw", "mhx", "mhy", "mhz", "mia", "mib", "mic", "mid", "mie", "mif", "mig", "mih", "mii", "mij", "mik", "mil", "mim", "min", "mio", "mip", "miq", "mir", "mis", "mit", "miu", "miw", "mix", "miy", "miz", "mja", "mjb", "mjc", "mjd", "mje", "mjg", "mjh", "mji", "mjj", "mjk", "mjl", "mjm", "mjn", "mjo", "mjp", "mjq", "mjr", "mjs", "mjt", "mju", "mjv", "mjw", "mjx", "mjy", "mjz", "mka", "mkb", "mkc", "mke", "mkf", "mkg", "mkh", "mki", "mkj", "mkk", "mkl", "mkm", "mkn", "mko", "mkp", "mkq", "mkr", "mks", "mkt", "mku", "mkv", "mkw", "mkx", "mky", "mkz", "mla", "mlb", "mlc", "mld", "mle", "mlf", "mlh", "mli", "mlj", "mlk", "mll", "mlm", "mln", "mlo", "mlp", "mlq", "mlr", "mls", "mlu", "mlv", "mlw", "mlx", "mlz", "mma", "mmb", "mmc", "mmd", "mme", "mmf", "mmg", "mmh", "mmi", "mmj", "mmk", "mml", "mmm", "mmn", "mmo", "mmp", "mmq", "mmr", "mmt", "mmu", "mmv", "mmw", "mmx", "mmy", "mmz", "mna", "mnb", "mnc", "mnd", "mne", "mnf", "mng", "mnh", "mni", "mnj", "mnk", "mnl", "mnm", "mnn", "mno", "mnp", "mnq", "mnr", "mns", "mnt", "mnu", "mnv", "mnw", "mnx", "mny", "mnz", "moa", "moc", "mod", "moe", "mof", "mog", "moh", "moi", "moj", "mok", "mom", "moo", "mop", "moq", "mor", "mos", "mot", "mou", "mov", "mow", "mox", "moy", "moz", "mpa", "mpb", "mpc", "mpd", "mpe", "mpg", "mph", "mpi", "mpj", "mpk", "mpl", "mpm", "mpn", "mpo", "mpp", "mpq", "mpr", "mps", "mpt", "mpu", "mpv", "mpw", "mpx", "mpy", "mpz", "mqa", "mqb", "mqc", "mqe", "mqf", "mqg", "mqh", "mqi", "mqj", "mqk", "mql", "mqm", "mqn", "mqo", "mqp", "mqq", "mqr", "mqs", "mqt", "mqu", "mqv", "mqw", "mqx", "mqy", "mqz", "mra", "mrb", "mrc", "mrd", "mre", "mrf", "mrg", "mrh", "mrj", "mrk", "mrl", "mrm", "mrn", "mro", "mrp", "mrq", "mrr", "mrs", "mrt", "mru", "mrv", "mrw", "mrx", "mry", "mrz", "msb", "msc", "msd", "mse", "msf", "msg", "msh", "msi", "msj", "msk", "msl", "msm", "msn", "mso", "msp", "msq", "msr", "mss", "mst", "msu", "msv", "msw", "msx", "msy", "msz", "mta", "mtb", "mtc", "mtd", "mte", "mtf", "mtg", "mth", "mti", "mtj", "mtk", "mtl", "mtm", "mtn", "mto", "mtp", "mtq", "mtr", "mts", "mtt", "mtu", "mtv", "mtw", "mtx", "mty", "mua", "mub", "muc", "mud", "mue", "mug", "muh", "mui", "muj", "muk", "mul", "mum", "mun", "muo", "mup", "muq", "mur", "mus", "mut", "muu", "muv", "mux", "muy", "muz", "mva", "mvb", "mvd", "mve", "mvf", "mvg", "mvh", "mvi", "mvk", "mvl", "mvm", "mvn", "mvo", "mvp", "mvq", "mvr", "mvs", "mvt", "mvu", "mvv", "mvw", "mvx", "mvy", "mvz", "mwa", "mwb", "mwc", "mwd", "mwe", "mwf", "mwg", "mwh", "mwi", "mwj", "mwk", "mwl", "mwm", "mwn", "mwo", "mwp", "mwq", "mwr", "mws", "mwt", "mwu", "mwv", "mww", "mwx", "mwy", "mwz", "mxa", "mxb", "mxc", "mxd", "mxe", "mxf", "mxg", "mxh", "mxi", "mxj", "mxk", "mxl", "mxm", "mxn", "mxo", "mxp", "mxq", "mxr", "mxs", "mxt", "mxu", "mxv", "mxw", "mxx", "mxy", "mxz", "myb", "myc", "myd", "mye", "myf", "myg", "myh", "myi", "myj", "myk", "myl", "mym", "myn", "myo", "myp", "myq", "myr", "mys", "myt", "myu", "myv", "myw", "myx", "myy", "myz", "mza", "mzb", "mzc", "mzd", "mze", "mzg", "mzh", "mzi", "mzj", "mzk", "mzl", "mzm", "mzn", "mzo", "mzp", "mzq", "mzr", "mzs", "mzt", "mzu", "mzv", "mzw", "mzx", "mzy", "mzz"],
    ["na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "naa", "nab", "nac", "nad", "nae", "naf", "nag", "nah", "nai", "naj", "nak", "nal", "nam", "nan", "nao", "nap", "naq", "nar", "nas", "nat", "naw", "nax", "nay", "naz", "nba", "nbb", "nbc", "nbd", "nbe", "nbf", "nbg", "nbh", "nbi", "nbj", "nbk", "nbm", "nbn", "nbo", "nbp", "nbq", "nbr", "nbs", "nbt", "nbu", "nbv", "nbw", "nbx", "nby", "nca", "ncb", "ncc", "ncd", "nce", "ncf", "ncg", "nch", "nci", "ncj", "nck", "ncl", "ncm", "ncn", "nco", "ncp", "ncq", "ncr", "ncs", "nct", "ncu", "ncx", "ncz", "nda", "ndb", "ndc", "ndd", "ndf", "ndg", "ndh", "ndi", "ndj", "ndk", "ndl", "ndm", "ndn", "ndp", "ndq", "ndr", "nds", "ndt", "ndu", "ndv", "ndw", "ndx", "ndy", "ndz", "nea", "neb", "nec", "ned", "nee", "nef", "neg", "neh", "nei", "nej", "nek", "nem", "nen", "neo", "neq", "ner", "nes", "net", "neu", "nev", "new", "nex", "ney", "nez", "nfa", "nfd", "nfl", "nfr", "nfu", "nga", "ngb", "ngc", "ngd", "nge", "ngf", "ngg", "ngh", "ngi", "ngj", "ngk", "ngl", "ngm", "ngn", "ngo", "ngp", "ngq", "ngr", "ngs", "ngt", "ngu", "ngv", "ngw", "ngx", "ngy", "ngz", "nha", "nhb", "nhc", "nhd", "nhe", "nhf", "nhg", "nhh", "nhi", "nhk", "nhm", "nhn", "nho", "nhp", "nhq", "nhr", "nht", "nhu", "nhv", "nhw", "nhx", "nhy", "nhz", "nia", "nib", "nic", "nid", "nie", "nif", "nig", "nih", "nii", "nij", "nik", "nil", "nim", "nin", "nio", "niq", "nir", "nis", "nit", "niu", "niv", "niw", "nix", "niy", "niz", "nja", "njb", "njd", "njh", "nji", "njj", "njl", "njm", "njn", "njo", "njr", "njs", "njt", "nju", "njx", "njy", "njz", "nka", "nkb", "nkc", "nkd", "nke", "nkf", "nkg", "nkh", "nki", "nkj", "nkk", "nkm", "nkn", "nko", "nkp", "nkq", "nkr", "nks", "nkt", "nku", "nkv", "nkw", "nkx", "nkz", "nla", "nlc", "nle", "nlg", "nli", "nlj", "nlk", "nll", "nlm", "nln", "nlo", "nlq", "nlr", "nlu", "nlv", "nlw", "nlx", "nly", "nlz", "nma", "nmb", "nmc", "nmd", "nme", "nmf", "nmg", "nmh", "nmi", "nmj", "nmk", "nml", "nmm", "nmn", "nmo", "nmp", "nmq", "nmr", "nms", "nmt", "nmu", "nmv", "nmw", "nmx", "nmy", "nmz", "nna", "nnb", "nnc", "nnd", "nne", "nnf", "nng", "nnh", "nni", "nnj", "nnk", "nnl", "nnm", "nnn", "nnp", "nnq", "nnr", "nns", "nnt", "nnu", "nnv", "nnw", "nnx", "nny", "nnz", "noa", "noc", "nod", "noe", "nof", "nog", "noh", "noi", "noj", "nok", "nol", "nom", "non", "noo", "nop", "noq", "nos", "not", "nou", "nov", "now", "noy", "noz", "npa", "npb", "npg", "nph", "npi", "npl", "npn", "npo", "nps", "npu", "npx", "npy", "nqg", "nqk", "nql", "nqm", "nqn", "nqo", "nqq", "nqt", "nqy", "nra", "nrb", "nrc", "nre", "nrf", "nrg", "nri", "nrk", "nrl", "nrm", "nrn", "nrp", "nrr", "nrt", "nru", "nrx", "nrz", "nsa", "nsb", "nsc", "nsd", "nse", "nsf", "nsg", "nsh", "nsi", "nsk", "nsl", "nsm", "nsn", "nso", "nsp", "nsq", "nsr", "nss", "nst", "nsu", "nsv", "nsw", "nsx", "nsy", "nsz", "ntd", "nte", "ntg", "nti", "ntj", "ntk", "ntm", "nto", "ntp", "ntr", "nts", "ntu", "ntw", "ntx", "nty", "ntz", "nua", "nub", "nuc", "nud", "nue", "nuf", "nug", "nuh", "nui", "nuj", "nuk", "nul", "num", "nun", "nuo", "nup", "nuq", "nur", "nus", "nut", "nuu", "nuv", "nuw", "nux", "nuy", "nuz", "nvh", "nvm", "nvo", "nwa", "nwb", "nwc", "nwe", "nwg", "nwi", "nwm", "nwo", "nwr", "nwx", "nwy", "nxa", "nxd", "nxe", "nxg", "nxi", "nxk", "nxl", "nxm", "nxn", "nxo", "nxq", "nxr", "nxu", "nxx", "nyb", "nyc", "nyd", "nye", "nyf", "nyg", "nyh", "nyi", "nyj", "nyk", "nyl", "nym", "nyn", "nyo", "nyp", "nyq", "nyr", "nys", "nyt", "nyu", "nyv", "nyw", "nyx", "nyy", "nza", "nzb", "nzd", "nzi", "nzk", "nzm", "nzs", "nzu", "nzy", "nzz"],
    ["oc", "oj", "om", "or", "os", "oaa", "oac", "oar", "oav", "obi", "obk", "obl", "obm", "obo", "obr", "obt", "obu", "oca", "och", "ocm", "oco", "ocu", "oda", "odk", "odt", "odu", "ofo", "ofs", "ofu", "ogb", "ogc", "oge", "ogg", "ogo", "ogu", "oht", "ohu", "oia", "oin", "ojb", "ojc", "ojg", "ojp", "ojs", "ojv", "ojw", "oka", "okb", "okc", "okd", "oke", "okg", "okh", "oki", "okj", "okk", "okl", "okm", "okn", "oko", "okr", "oks", "oku", "okv", "okx", "okz", "ola", "old", "ole", "olk", "olm", "olo", "olr", "olt", "olu", "oma", "omb", "omc", "ome", "omg", "omi", "omk", "oml", "omn", "omo", "omp", "omq", "omr", "omt", "omu", "omv", "omw", "omx", "omy", "ona", "onb", "one", "ong", "oni", "onj", "onk", "onn", "ono", "onp", "onr", "ons", "ont", "onu", "onw", "onx", "ood", "oog", "oon", "oor", "oos", "opa", "opk", "opm", "opo", "opt", "opy", "ora", "orc", "ore", "org", "orh", "orn", "oro", "orr", "ors", "ort", "oru", "orv", "orw", "orx", "ory", "orz", "osa", "osc", "osi", "osn", "oso", "osp", "ost", "osu", "osx", "ota", "otb", "otd", "ote", "oti", "otk", "otl", "otm", "otn", "oto", "otq", "otr", "ots", "ott", "otu", "otw", "otx", "oty", "otz", "oua", "oub", "oue", "oui", "oum", "oun", "ovd", "owi", "owl", "oyb", "oyd", "oym", "oyy", "ozm"],
    ["pa", "pi", "pl", "ps", "pt", "paa", "pab", "pac", "pad", "pae", "paf", "pag", "pah", "pai", "pak", "pal", "pam", "pao", "pap", "paq", "par", "pas", "pat", "pau", "pav", "paw", "pax", "pay", "paz", "pbb", "pbc", "pbe", "pbf", "pbg", "pbh", "pbi", "pbl", "pbm", "pbn", "pbo", "pbp", "pbr", "pbs", "pbt", "pbu", "pbv", "pby", "pbz", "pca", "pcb", "pcc", "pcd", "pce", "pcf", "pcg", "pch", "pci", "pcj", "pck", "pcl", "pcm", "pcn", "pcp", "pcr", "pcw", "pda", "pdc", "pdi", "pdn", "pdo", "pdt", "pdu", "pea", "peb", "ped", "pee", "pef", "peg", "peh", "pei", "pej", "pek", "pel", "pem", "peo", "pep", "peq", "pes", "pev", "pex", "pey", "pez", "pfa", "pfe", "pfl", "pga", "pgd", "pgg", "pgi", "pgk", "pgl", "pgn", "pgs", "pgu", "pgy", "pgz", "pha", "phd", "phg", "phh", "phi", "phk", "phl", "phm", "phn", "pho", "phq", "phr", "pht", "phu", "phv", "phw", "pia", "pib", "pic", "pid", "pie", "pif", "pig", "pih", "pii", "pij", "pil", "pim", "pin", "pio", "pip", "pir", "pis", "pit", "piu", "piv", "piw", "pix", "piy", "piz", "pjt", "pka", "pkb", "pkc", "pkg", "pkh", "pkn", "pko", "pkp", "pkr", "pks", "pkt", "pku", "pla", "plb", "plc", "pld", "ple", "plf", "plg", "plh", "plj", "plk", "pll", "pln", "plo", "plp", "plq", "plr", "pls", "plt", "plu", "plv", "plw", "ply", "plz", "pma", "pmb", "pmc", "pmd", "pme", "pmf", "pmh", "pmi", "pmj", "pmk", "pml", "pmm", "pmn", "pmo", "pmq", "pmr", "pms", "pmt", "pmu", "pmw", "pmx", "pmy", "pmz", "pna", "pnb", "pnc", "pnd", "pne", "png", "pnh", "pni", "pnj", "pnk", "pnl", "pnm", "pnn", "pno", "pnp", "pnq", "pnr", "pns", "pnt", "pnu", "pnv", "pnw", "pnx", "pny", "pnz", "poc", "pod", "poe", "pof", "pog", "poh", "poi", "pok", "pom", "pon", "poo", "pop", "poq", "pos", "pot", "pov", "pow", "pox", "poy", "poz", "ppa", "ppe", "ppi", "ppk", "ppl", "ppm", "ppn", "ppo", "ppp", "ppq", "ppr", "pps", "ppt", "ppu", "pqa", "pqe", "pqm", "pqw", "pra", "prb", "prc", "prd", "pre", "prf", "prg", "prh", "pri", "prk", "prl", "prm", "prn", "pro", "prp", "prq", "prr", "prs", "prt", "pru", "prw", "prx", "pry", "prz", "psa", "psc", "psd", "pse", "psg", "psh", "psi", "psl", "psm", "psn", "pso", "psp", "psq", "psr", "pss", "pst", "psu", "psw", "psy", "pta", "pth", "pti", "ptn", "pto", "ptp", "ptq", "ptr", "ptt", "ptu", "ptv", "ptw", "pty", "pua", "pub", "puc", "pud", "pue", "puf", "pug", "pui", "puj", "puk", "pum", "puo", "pup", "puq", "pur", "put", "puu", "puw", "pux", "puy", "puz", "pwa", "pwb", "pwg", "pwi", "pwm", "pwn", "pwo", "pwr", "pww", "pxm", "pye", "pym", "pyn", "pys", "pyu", "pyx", "pyy", "pzn"],
    ["qu", "qua", "qub", "quc", "qud", "quf", "qug", "quh", "qui", "quk", "qul", "qum", "qun", "qup", "quq", "qur", "qus", "quv", "quw", "qux", "quy", "quz", "qva", "qvc", "qve", "qvh", "qvi", "qvj", "qvl", "qvm", "qvn", "qvo", "qvp", "qvs", "qvw", "qvy", "qvz", "qwa", "qwc", "qwe", "qwh", "qwm", "qws", "qwt", "qxa", "qxc", "qxh", "qxl", "qxn", "qxo", "qxp", "qxq", "qxr", "qxs", "qxt", "qxu", "qxw", "qya", "qyp"],
    ["rm", "rn", "ro", "ru", "rw", "raa", "rab", "rac", "rad", "raf", "rag", "rah", "rai", "raj", "rak", "ral", "ram", "ran", "rao", "rap", "raq", "rar", "ras", "rat", "rau", "rav", "raw", "rax", "ray", "raz", "rbb", "rbk", "rbl", "rbp", "rcf", "rdb", "rea", "reb", "ree", "reg", "rei", "rej", "rel", "rem", "ren", "rer", "res", "ret", "rey", "rga", "rge", "rgk", "rgn", "rgr", "rgs", "rgu", "rhg", "rhp", "ria", "rie", "rif", "ril", "rim", "rin", "rir", "rit", "riu", "rjg", "rji", "rjs", "rka", "rkb", "rkh", "rki", "rkm", "rkt", "rkw", "rma", "rmb", "rmc", "rmd", "rme", "rmf", "rmg", "rmh", "rmi", "rmk", "rml", "rmm", "rmn", "rmo", "rmp", "rmq", "rmr", "rms", "rmt", "rmu", "rmv", "rmw", "rmx", "rmy", "rmz", "rna", "rnd", "rng", "rnl", "rnn", "rnp", "rnr", "rnw", "roa", "rob", "roc", "rod", "roe", "rof", "rog", "rol", "rom", "roo", "rop", "ror", "rou", "row", "rpn", "rpt", "rri", "rro", "rrt", "rsb", "rsi", "rsl", "rsm", "rtc", "rth", "rtm", "rts", "rtw", "rub", "ruc", "rue", "ruf", "rug", "ruh", "rui", "ruk", "ruo", "rup", "ruq", "rut", "ruu", "ruy", "ruz", "rwa", "rwk", "rwl", "rwm", "rwo", "rwr", "rxd", "rxw", "ryn", "rys", "ryu", "rzh"],
    ["sa", "sc", "sd", "se", "sg", "sh", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "saa", "sab", "sac", "sad", "sae", "saf", "sah", "sai", "saj", "sak", "sal", "sam", "sao", "sap", "saq", "sar", "sas", "sat", "sau", "sav", "saw", "sax", "say", "saz", "sba", "sbb", "sbc", "sbd", "sbe", "sbf", "sbg", "sbh", "sbi", "sbj", "sbk", "sbl", "sbm", "sbn", "sbo", "sbp", "sbq", "sbr", "sbs", "sbt", "sbu", "sbv", "sbw", "sbx", "sby", "sbz", "sca", "scb", "sce", "scf", "scg", "sch", "sci", "sck", "scl", "scn", "sco", "scp", "scq", "scs", "sct", "scu", "scv", "scw", "scx", "sda", "sdb", "sdc", "sde", "sdf", "sdg", "sdh", "sdj", "sdk", "sdl", "sdm", "sdn", "sdo", "sdp", "sdq", "sdr", "sds", "sdt", "sdu", "sdv", "sdx", "sdz", "sea", "seb", "sec", "sed", "see", "sef", "seg", "seh", "sei", "sej", "sek", "sel", "sem", "sen", "seo", "sep", "seq", "ser", "ses", "set", "seu", "sev", "sew", "sey", "sez", "sfb", "sfe", "sfm", "sfs", "sfw", "sga", "sgb", "sgc", "sgd", "sge", "sgg", "sgh", "sgi", "sgj", "sgk", "sgl", "sgm", "sgn", "sgo", "sgp", "sgr", "sgs", "sgt", "sgu", "sgw", "sgx", "sgy", "sgz", "sha", "shb", "shc", "shd", "she", "shg", "shh", "shi", "shj", "shk", "shl", "shm", "shn", "sho", "shp", "shq", "shr", "shs", "sht", "shu", "shv", "shw", "shx", "shy", "shz", "sia", "sib", "sid", "sie", "sif", "sig", "sih", "sii", "sij", "sik", "sil", "sim", "sio", "sip", "siq", "sir", "sis", "sit", "siu", "siv", "siw", "six", "siy", "siz", "sja", "sjb", "sjd", "sje", "sjg", "sjk", "sjl", "sjm", "sjn", "sjo", "sjp", "sjr", "sjs", "sjt", "sju", "sjw", "ska", "skb", "skc", "skd", "ske", "skf", "skg", "skh", "ski", "skj", "skk", "skm", "skn", "sko", "skp", "skq", "skr", "sks", "skt", "sku", "skv", "skw", "skx", "sky", "skz", "sla", "slc", "sld", "sle", "slf", "slg", "slh", "sli", "slj", "sll", "slm", "sln", "slp", "slq", "slr", "sls", "slt", "slu", "slw", "slx", "sly", "slz", "sma", "smb", "smc", "smd", "smf", "smg", "smh", "smi", "smj", "smk", "sml", "smm", "smn", "smp", "smq", "smr", "sms", "smt", "smu", "smv", "smw", "smx", "smy", "smz", "snb", "snc", "sne", "snf", "sng", "snh", "sni", "snj", "snk", "snl", "snm", "snn", "sno", "snp", "snq", "snr", "sns", "snu", "snv", "snw", "snx", "sny", "snz", "soa", "sob", "soc", "sod", "soe", "sog", "soh", "soi", "soj", "sok", "sol", "son", "soo", "sop", "soq", "sor", "sos", "sou", "sov", "sow", "sox", "soy", "soz", "spb", "spc", "spd", "spe", "spg", "spi", "spk", "spl", "spm", "spn", "spo", "spp", "spq", "spr", "sps", "spt", "spu", "spv", "spx", "spy", "sqa", "sqh", "sqj", "sqk", "sqm", "sqn", "sqo", "sqq", "sqr", "sqs", "sqt", "squ", "sqx", "sra", "srb", "src", "sre", "srf", "srg", "srh", "sri", "srk", "srl", "srm", "srn", "sro", "srq", "srr", "srs", "srt", "sru", "srv", "srw", "srx", "sry", "srz", "ssa", "ssb", "ssc", "ssd", "sse", "ssf", "ssg", "ssh", "ssi", "ssj", "ssk", "ssl", "ssm", "ssn", "sso", "ssp", "ssq", "ssr", "sss", "sst", "ssu", "ssv", "ssx", "ssy", "ssz", "sta", "stb", "std", "ste", "stf", "stg", "sth", "sti", "stj", "stk", "stl", "stm", "stn", "sto", "stp", "stq", "str", "sts", "stt", "stu", "stv", "stw", "sty", "sua", "sub", "suc", "sue", "sug", "sui", "suj", "suk", "sul", "sum", "suo", "suq", "sur", "sus", "sut", "suv", "suw", "sux", "suy", "suz", "sva", "svb", "svc", "sve", "svk", "svm", "svr", "svs", "svx", "swb", "swc", "swf", "swg", "swh", "swi", "swj", "swk", "swl", "swm", "swn", "swo", "swp", "swq", "swr", "sws", "swt", "swu", "swv", "sww", "swx", "swy", "sxb", "sxc", "sxe", "sxg", "sxk", "sxl", "sxm", "sxn", "sxo", "sxr", "sxs", "sxu", "sxw", "sya", "syb", "syc", "syd", "syi", "syk", "syl", "sym", "syn", "syo", "syr", "sys", "syw", "syx", "syy", "sza", "szb", "szc", "szd", "sze", "szg", "szl", "szn", "szp", "szs", "szv", "szw", "szy"],
    ["ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "taa", "tab", "tac", "tad", "tae", "taf", "tag", "tai", "taj", "tak", "tal", "tan", "tao", "tap", "taq", "tar", "tas", "tau", "tav", "taw", "tax", "tay", "taz", "tba", "tbb", "tbc", "tbd", "tbe", "tbf", "tbg", "tbh", "tbi", "tbj", "tbk", "tbl", "tbm", "tbn", "tbo", "tbp", "tbq", "tbr", "tbs", "tbt", "tbu", "tbv", "tbw", "tbx", "tby", "tbz", "tca", "tcb", "tcc", "tcd", "tce", "tcf", "tcg", "tch", "tci", "tck", "tcl", "tcm", "tcn", "tco", "tcp", "tcq", "tcs", "tct", "tcu", "tcw", "tcx", "tcy", "tcz", "tda", "tdb", "tdc", "tdd", "tde", "tdf", "tdg", "tdh", "tdi", "tdj", "tdk", "tdl", "tdm", "tdn", "tdo", "tdq", "tdr", "tds", "tdt", "tdu", "tdv", "tdx", "tdy", "tea", "teb", "tec", "ted", "tee", "tef", "teg", "teh", "tei", "tek", "tem", "ten", "teo", "tep", "teq", "ter", "tes", "tet", "teu", "tev", "tew", "tex", "tey", "tez", "tfi", "tfn", "tfo", "tfr", "tft", "tga", "tgb", "tgc", "tgd", "tge", "tgf", "tgg", "tgh", "tgi", "tgj", "tgn", "tgo", "tgp", "tgq", "tgr", "tgs", "tgt", "tgu", "tgv", "tgw", "tgx", "tgy", "tgz", "thc", "thd", "the", "thf", "thh", "thi", "thk", "thl", "thm", "thn", "thp", "thq", "thr", "ths", "tht", "thu", "thv", "thw", "thx", "thy", "thz", "tia", "tic", "tid", "tie", "tif", "tig", "tih", "tii", "tij", "tik", "til", "tim", "tin", "tio", "tip", "tiq", "tis", "tit", "tiu", "tiv", "tiw", "tix", "tiy", "tiz", "tja", "tjg", "tji", "tjj", "tjl", "tjm", "tjn", "tjo", "tjp", "tjs", "tju", "tjw", "tka", "tkb", "tkd", "tke", "tkf", "tkg", "tkk", "tkl", "tkm", "tkn", "tkp", "tkq", "tkr", "tks", "tkt", "tku", "tkv", "tkw", "tkx", "tkz", "tla", "tlb", "tlc", "tld", "tlf", "tlg", "tlh", "tli", "tlj", "tlk", "tll", "tlm", "tln", "tlo", "tlp", "tlq", "tlr", "tls", "tlt", "tlu", "tlv", "tlw", "tlx", "tly", "tma", "tmb", "tmc", "tmd", "tme", "tmf", "tmg", "tmh", "tmi", "tmj", "tmk", "tml", "tmm", "tmn", "tmo", "tmp", "tmq", "tmr", "tms", "tmt", "tmu", "tmv", "tmw", "tmy", "tmz", "tna", "tnb", "tnc", "tnd", "tne", "tnf", "tng", "tnh", "tni", "tnk", "tnl", "tnm", "tnn", "tno", "tnp", "tnq", "tnr", "tns", "tnt", "tnu", "tnv", "tnw", "tnx", "tny", "tnz", "tob", "toc", "tod", "toe", "tof", "tog", "toh", "toi", "toj", "tol", "tom", "too", "top", "toq", "tor", "tos", "tou", "tov", "tow", "tox", "toy", "toz", "tpa", "tpc", "tpe", "tpf", "tpg", "tpi", "tpj", "tpk", "tpl", "tpm", "tpn", "tpo", "tpp", "tpq", "tpr", "tpt", "tpu", "tpv", "tpw", "tpx", "tpy", "tpz", "tqb", "tql", "tqm", "tqn", "tqo", "tqp", "tqq", "tqr", "tqt", "tqu", "tqw", "tra", "trb", "trc", "trd", "tre", "trf", "trg", "trh", "tri", "trj", "trk", "trl", "trm", "trn", "tro", "trp", "trq", "trr", "trs", "trt", "tru", "trv", "trw", "trx", "try", "trz", "tsa", "tsb", "tsc", "tsd", "tse", "tsf", "tsg", "tsh", "tsi", "tsj", "tsk", "tsl", "tsm", "tsp", "tsq", "tsr", "tss", "tst", "tsu", "tsv", "tsw", "tsx", "tsy", "tsz", "tta", "ttb", "ttc", "ttd", "tte", "ttf", "ttg", "tth", "tti", "ttj", "ttk", "ttl", "ttm", "ttn", "tto", "ttp", "ttq", "ttr", "tts", "ttt", "ttu", "ttv", "ttw", "tty", "ttz", "tua", "tub", "tuc", "tud", "tue", "tuf", "tug", "tuh", "tui", "tuj", "tul", "tum", "tun", "tuo", "tup", "tuq", "tus", "tut", "tuu", "tuv", "tuw", "tux", "tuy", "tuz", "tva", "tvd", "tve", "tvk", "tvl", "tvm", "tvn", "tvo", "tvs", "tvt", "tvu", "tvw", "tvx", "tvy", "twa", "twb", "twc", "twd", "twe", "twf", "twg", "twh", "twl", "twm", "twn", "two", "twp", "twq", "twr", "twt", "twu", "tww", "twx", "twy", "txa", "txb", "txc", "txe", "txg", "txh", "txi", "txj", "txm", "txn", "txo", "txq", "txr", "txs", "txt", "txu", "txx", "txy", "tya", "tye", "tyh", "tyi", "tyj", "tyl", "tyn", "typ", "tyr", "tys", "tyt", "tyu", "tyv", "tyx", "tyy", "tyz", "tza", "tzh", "tzj", "tzl", "tzm", "tzn", "tzo", "tzx"],
    ["ug", "uk", "ur", "uz", "uam", "uan", "uar", "uba", "ubi", "ubl", "ubr", "ubu", "uby", "uda", "ude", "udg", "udi", "udj", "udl", "udm", "udu", "ues", "ufi", "uga", "ugb", "uge", "ugn", "ugo", "ugy", "uha", "uhn", "uis", "uiv", "uji", "uka", "ukg", "ukh", "uki", "ukk", "ukl", "ukp", "ukq", "uks", "uku", "ukv", "ukw", "uky", "ula", "ulb", "ulc", "ule", "ulf", "uli", "ulk", "ull", "ulm", "uln", "ulu", "ulw", "uma", "umb", "umc", "umd", "umg", "umi", "umm", "umn", "umo", "ump", "umr", "ums", "umu", "una", "und", "une", "ung", "uni", "unk", "unm", "unn", "unp", "unr", "unu", "unx", "unz", "uok", "upi", "upv", "ura", "urb", "urc", "ure", "urf", "urg", "urh", "uri", "urj", "urk", "url", "urm", "urn", "uro", "urp", "urr", "urt", "uru", "urv", "urw", "urx", "ury", "urz", "usa", "ush", "usi", "usk", "usp", "uss", "usu", "uta", "ute", "uth", "utp", "utr", "utu", "uum", "uun", "uur", "uuu", "uve", "uvh", "uvl", "uwa", "uya", "uzn", "uzs"],
    ["ve", "vi", "vo", "vaa", "vae", "vaf", "vag", "vah", "vai", "vaj", "val", "vam", "van", "vao", "vap", "var", "vas", "vau", "vav", "vay", "vbb", "vbk", "vec", "ved", "vel", "vem", "veo", "vep", "ver", "vgr", "vgt", "vic", "vid", "vif", "vig", "vil", "vin", "vis", "vit", "viv", "vka", "vki", "vkj", "vkk", "vkl", "vkm", "vkn", "vko", "vkp", "vkt", "vku", "vkz", "vlp", "vls", "vma", "vmb", "vmc", "vmd", "vme", "vmf", "vmg", "vmh", "vmi", "vmj", "vmk", "vml", "vmm", "vmp", "vmq", "vmr", "vms", "vmu", "vmv", "vmw", "vmx", "vmy", "vmz", "vnk", "vnm", "vnp", "vor", "vot", "vra", "vro", "vrs", "vrt", "vsi", "vsl", "vsv", "vto", "vum", "vun", "vut", "vwa"],
    ["wa", "wo", "waa", "wab", "wac", "wad", "wae", "waf", "wag", "wah", "wai", "waj", "wak", "wal", "wam", "wan", "wao", "wap", "waq", "war", "was", "wat", "wau", "wav", "waw", "wax", "way", "waz", "wba", "wbb", "wbe", "wbf", "wbh", "wbi", "wbj", "wbk", "wbl", "wbm", "wbp", "wbq", "wbr", "wbs", "wbt", "wbv", "wbw", "wca", "wci", "wdd", "wdg", "wdj", "wdk", "wdu", "wdy", "wea", "wec", "wed", "weg", "weh", "wei", "wem", "wen", "weo", "wep", "wer", "wes", "wet", "weu", "wew", "wfg", "wga", "wgb", "wgg", "wgi", "wgo", "wgu", "wgw", "wgy", "wha", "whg", "whk", "whu", "wib", "wic", "wie", "wif", "wig", "wih", "wii", "wij", "wik", "wil", "wim", "win", "wir", "wit", "wiu", "wiv", "wiw", "wiy", "wja", "wji", "wka", "wkb", "wkd", "wkl", "wkr", "wku", "wkw", "wky", "wla", "wlc", "wle", "wlg", "wlh", "wli", "wlk", "wll", "wlm", "wlo", "wlr", "wls", "wlu", "wlv", "wlw", "wlx", "wly", "wma", "wmb", "wmc", "wmd", "wme", "wmg", "wmh", "wmi", "wmm", "wmn", "wmo", "wms", "wmt", "wmw", "wmx", "wnb", "wnc", "wnd", "wne", "wng", "wni", "wnk", "wnm", "wnn", "wno", "wnp", "wnu", "wnw", "wny", "woa", "wob", "woc", "wod", "woe", "wof", "wog", "woi", "wok", "wom", "won", "woo", "wor", "wos", "wow", "woy", "wpc", "wra", "wrb", "wrd", "wrg", "wrh", "wri", "wrk", "wrl", "wrm", "wrn", "wro", "wrp", "wrr", "wrs", "wru", "wrv", "wrw", "wrx", "wry", "wrz", "wsa", "wsg", "wsi", "wsk", "wsr", "wss", "wsu", "wsv", "wtf", "wth", "wti", "wtk", "wtm", "wtw", "wua", "wub", "wud", "wuh", "wul", "wum", "wun", "wur", "wut", "wuu", "wuv", "wux", "wuy", "wwa", "wwb", "wwo", "wwr", "www", "wxa", "wxw", "wya", "wyb", "wyi", "wym", "wyr", "wyy"],
    ["xh", "xaa", "xab", "xac", "xad", "xae", "xag", "xai", "xaj", "xak", "xal", "xam", "xan", "xao", "xap", "xaq", "xar", "xas", "xat", "xau", "xav", "xaw", "xay", "xba", "xbb", "xbc", "xbd", "xbe", "xbg", "xbi", "xbj", "xbm", "xbn", "xbo", "xbp", "xbr", "xbw", "xbx", "xby", "xcb", "xcc", "xce", "xcg", "xch", "xcl", "xcm", "xcn", "xco", "xcr", "xct", "xcu", "xcv", "xcw", "xcy", "xda", "xdc", "xdk", "xdm", "xdo", "xdy", "xeb", "xed", "xeg", "xel", "xem", "xep", "xer", "xes", "xet", "xeu", "xfa", "xga", "xgb", "xgd", "xgf", "xgg", "xgi", "xgl", "xgm", "xgn", "xgr", "xgu", "xgw", "xha", "xhc", "xhd", "xhe", "xhr", "xht", "xhu", "xhv", "xia", "xib", "xii", "xil", "xin", "xip", "xir", "xis", "xiv", "xiy", "xjb", "xjt", "xka", "xkb", "xkc", "xkd", "xke", "xkf", "xkg", "xkh", "xki", "xkj", "xkk", "xkl", "xkn", "xko", "xkp", "xkq", "xkr", "xks", "xkt", "xku", "xkv", "xkw", "xkx", "xky", "xkz", "xla", "xlb", "xlc", "xld", "xle", "xlg", "xli", "xln", "xlo", "xlp", "xls", "xlu", "xly", "xma", "xmb", "xmc", "xmd", "xme", "xmf", "xmg", "xmh", "xmj", "xmk", "xml", "xmm", "xmn", "xmo", "xmp", "xmq", "xmr", "xms", "xmt", "xmu", "xmv", "xmw", "xmx", "xmy", "xmz", "xna", "xnb", "xnd", "xng", "xnh", "xni", "xnj", "xnk", "xnm", "xnn", "xno", "xnq", "xnr", "xns", "xnt", "xnu", "xny", "xnz", "xoc", "xod", "xog", "xoi", "xok", "xom", "xon", "xoo", "xop", "xor", "xow", "xpa", "xpb", "xpc", "xpd", "xpe", "xpf", "xpg", "xph", "xpi", "xpj", "xpk", "xpl", "xpm", "xpn", "xpo", "xpp", "xpq", "xpr", "xps", "xpt", "xpu", "xpv", "xpw", "xpx", "xpy", "xpz", "xqa", "xqt", "xra", "xrb", "xrd", "xre", "xrg", "xri", "xrm", "xrn", "xrq", "xrr", "xrt", "xru", "xrw", "xsa", "xsb", "xsc", "xsd", "xse", "xsh", "xsi", "xsj", "xsl", "xsm", "xsn", "xso", "xsp", "xsq", "xsr", "xss", "xsu", "xsv", "xsy", "xta", "xtb", "xtc", "xtd", "xte", "xtg", "xth", "xti", "xtj", "xtl", "xtm", "xtn", "xto", "xtp", "xtq", "xtr", "xts", "xtt", "xtu", "xtv", "xtw", "xty", "xtz", "xua", "xub", "xud", "xug", "xuj", "xul", "xum", "xun", "xuo", "xup", "xur", "xut", "xuu", "xve", "xvi", "xvn", "xvo", "xvs", "xwa", "xwc", "xwd", "xwe", "xwg", "xwj", "xwk", "xwl", "xwo", "xwr", "xwt", "xww", "xxb", "xxk", "xxm", "xxr", "xxt", "xya", "xyb", "xyj", "xyk", "xyl", "xyt", "xyy", "xzh", "xzm", "xzp"],
    ["yi", "yo", "yaa", "yab", "yac", "yad", "yae", "yaf", "yag", "yah", "yai", "yaj", "yak", "yal", "yam", "yan", "yao", "yap", "yaq", "yar", "yas", "yat", "yau", "yav", "yaw", "yax", "yay", "yaz", "yba", "ybb", "ybd", "ybe", "ybh", "ybi", "ybj", "ybk", "ybl", "ybm", "ybn", "ybo", "ybx", "yby", "ych", "ycl", "ycn", "ycp", "yda", "ydd", "yde", "ydg", "ydk", "yds", "yea", "yec", "yee", "yei", "yej", "yel", "yen", "yer", "yes", "yet", "yeu", "yev", "yey", "yga", "ygi", "ygl", "ygm", "ygp", "ygr", "ygs", "ygu", "ygw", "yha", "yhd", "yhl", "yhs", "yia", "yif", "yig", "yih", "yii", "yij", "yik", "yil", "yim", "yin", "yip", "yiq", "yir", "yis", "yit", "yiu", "yiv", "yix", "yiy", "yiz", "yka", "ykg", "yki", "ykk", "ykl", "ykm", "ykn", "yko", "ykr", "ykt", "yku", "yky", "yla", "ylb", "yle", "ylg", "yli", "yll", "ylm", "yln", "ylo", "ylr", "ylu", "yly", "yma", "ymb", "ymc", "ymd", "yme", "ymg", "ymh", "ymi", "ymk", "yml", "ymm", "ymn", "ymo", "ymp", "ymq", "ymr", "yms", "ymt", "ymx", "ymz", "yna", "ynd", "yne", "yng", "ynh", "ynk", "ynl", "ynn", "yno", "ynq", "yns", "ynu", "yob", "yog", "yoi", "yok", "yol", "yom", "yon", "yos", "yot", "yox", "yoy", "ypa", "ypb", "ypg", "yph", "ypk", "ypm", "ypn", "ypo", "ypp", "ypz", "yra", "yrb", "yre", "yri", "yrk", "yrl", "yrm", "yrn", "yro", "yrs", "yrw", "yry", "ysc", "ysd", "ysg", "ysl", "ysm", "ysn", "yso", "ysp", "ysr", "yss", "ysy", "yta", "ytl", "ytp", "ytw", "yty", "yua", "yub", "yuc", "yud", "yue", "yuf", "yug", "yui", "yuj", "yuk", "yul", "yum", "yun", "yup", "yuq", "yur", "yut", "yuu", "yuw", "yux", "yuy", "yuz", "yva", "yvt", "ywa", "ywg", "ywl", "ywn", "ywq", "ywr", "ywt", "ywu", "yww", "yxa", "yxg", "yxl", "yxm", "yxu", "yxy", "yyr", "yyu", "yyz", "yzg", "yzk"],
    ["za", "zh", "zu", "zaa", "zab", "zac", "zad", "zae", "zaf", "zag", "zah", "zai", "zaj", "zak", "zal", "zam", "zao", "zap", "zaq", "zar", "zas", "zat", "zau", "zav", "zaw", "zax", "zay", "zaz", "zba", "zbc", "zbe", "zbl", "zbt", "zbu", "zbw", "zca", "zch", "zdj", "zea", "zeg", "zeh", "zen", "zga", "zgb", "zgh", "zgm", "zgn", "zgr", "zhb", "zhd", "zhi", "zhn", "zhw", "zhx", "zia", "zib", "zik", "zil", "zim", "zin", "zir", "ziw", "ziz", "zka", "zkb", "zkd", "zkg", "zkh", "zkk", "zkn", "zko", "zkp", "zkr", "zkt", "zku", "zkv", "zkz", "zla", "zle", "zlj", "zlm", "zln", "zlq", "zls", "zlw", "zma", "zmb", "zmc", "zmd", "zme", "zmf", "zmg", "zmh", "zmi", "zmj", "zmk", "zml", "zmm", "zmn", "zmo", "zmp", "zmq", "zmr", "zms", "zmt", "zmu", "zmv", "zmw", "zmx", "zmy", "zmz", "zna", "znd", "zne", "zng", "znk", "zns", "zoc", "zoh", "zom", "zoo", "zoq", "zor", "zos", "zpa", "zpb", "zpc", "zpd", "zpe", "zpf", "zpg", "zph", "zpi", "zpj", "zpk", "zpl", "zpm", "zpn", "zpo", "zpp", "zpq", "zpr", "zps", "zpt", "zpu", "zpv", "zpw", "zpx", "zpy", "zpz", "zqe", "zra", "zrg", "zrn", "zro", "zrp", "zrs", "zsa", "zsk", "zsl", "zsm", "zsr", "zsu", "zte", "ztg", "ztl", "ztm", "ztn", "ztp", "ztq", "zts", "ztt", "ztu", "ztx", "zty", "zua", "zuh", "zum", "zun", "zuy", "zwa", "zxx", "zyb", "zyg", "zyj", "zyn", "zyp", "zza", "zzj"]
];
var LangUtil = /** @class */ (function () {
    function LangUtil() {
    }
    /* Determine if given string is a valid BCP 47 string */
    LangUtil.isBcp47 = function (langStr) {
        return /^(([a-zA-Z]{2,3}(-[a-zA-Z](-[a-zA-Z]{3}){0,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-([0-9a-zA-Z]{5,8}|[0-9][a-zA-Z]{3}))*(-[0-9a-wy-zA-WY-Z](-[a-zA-Z0-9]{2,8})+)*(-x(-[a-zA-Z0-9]{1,8})+)?|x(-[a-zA-Z0-9]{1,8})+|(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE|art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))$/.test(langStr);
    };
    LangUtil.validPrimaryLang = function (langStr) {
        var primary = langStr.toLowerCase();
        if (primary.includes("-")) {
            primary = primary.split("-")[0];
        }
        if (!primary.match(/[a-z]{2,3}/))
            return false;
        // qaa..qtz
        if (primary.length === 3
            && primary.charAt(0) === "q"
            && primary.charCodeAt(1) >= 97 && primary.charCodeAt(1) <= 116
            && primary.charCodeAt(2) >= 97 && primary.charCodeAt(2) <= 122) {
        }
        return validPrimaryLangs[primary.charCodeAt(0) - 97].includes(primary);
    };
    LangUtil.matchPrimaryLang = function (lang1, lang2) {
        var primary1 = lang1;
        if (primary1.includes("-")) {
            primary1 = primary1.split("-")[0];
        }
        var primary2 = lang2;
        if (primary2.includes("-")) {
            primary2 = primary2.split("-")[0];
        }
        return primary1.toLowerCase() === primary2.toLowerCase();
    };
    return LangUtil;
}());
exports.LangUtil = LangUtil;


/***/ }),

/***/ 8422:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeWalker = exports.RPTUtil = void 0;
var CacheUtil_1 = __webpack_require__(7788);
var ARIADefinitions_1 = __webpack_require__(8235);
var ARIAMapper_1 = __webpack_require__(4944);
var DOMWalker_1 = __webpack_require__(7440);
var VisUtil_1 = __webpack_require__(8174);
var fragment_1 = __webpack_require__(482);
var CSSUtil_1 = __webpack_require__(1775);
var DOMUtil_1 = __webpack_require__(295);
var RPTUtil = /** @class */ (function () {
    function RPTUtil() {
    }
    RPTUtil.isDefinedAriaAttributeAtIndex = function (ele, index) {
        var attrName = ele.attributes[index].name;
        return RPTUtil.isDefinedAriaAttribute(ele, attrName);
    };
    /**
     * this method returns user-defined aria attribute name from dom
     * @param ele  element
     * @returns user defined aria attributes
     */
    RPTUtil.getUserDefinedAriaAttributes = function (elem) {
        var ariaAttributes = [];
        var domAttributes = elem.attributes;
        if (domAttributes) {
            for (var i = 0; i < domAttributes.length; i++) {
                var attrName = domAttributes[i].name.trim().toLowerCase();
                var isAria = attrName.substring(0, 5) === 'aria-';
                if (isAria)
                    ariaAttributes.push(attrName);
            }
        }
        return ariaAttributes;
    };
    /**
     * this method returns user-defined html attribute name from dom
     * @param ele  element
     * @returns user defined html attributes
     */
    RPTUtil.getUserDefinedHtmlAttributes = function (elem) {
        var htmlAttributes = [];
        var domAttributes = elem.attributes;
        if (domAttributes) {
            for (var i = 0; i < domAttributes.length; i++) {
                var attrName = domAttributes[i].name.trim().toLowerCase();
                var isAria = attrName.substring(0, 5) === 'aria-';
                if (!isAria)
                    htmlAttributes.push(attrName);
            }
        }
        return htmlAttributes;
    };
    /**
     * this method returns user-defined aria attribute name-value pair from dom
     * @param ele  element
     * @returns user defined aria attributes
     */
    RPTUtil.getUserDefinedAriaAttributeNameValuePairs = function (elem) {
        var ariaAttributes = [];
        var domAttributes = elem.attributes;
        if (domAttributes) {
            for (var i = 0; i < domAttributes.length; i++) {
                var attrName = domAttributes[i].name.trim().toLowerCase();
                var attrValue = elem.getAttribute(attrName);
                if (attrValue === '')
                    attrValue = null;
                var isAria = attrName.substring(0, 5) === 'aria-';
                if (isAria)
                    ariaAttributes.push({ name: attrName, value: attrValue });
            }
        }
        return ariaAttributes;
    };
    /**
     * this method returns user-defined html attribute name-value pair from dom
     * @param ele  element
     * @returns user defined html attributes
     */
    RPTUtil.getUserDefinedHtmlAttributeNameValuePairs = function (elem) {
        var htmlAttributes = [];
        var domAttributes = elem.attributes;
        if (domAttributes) {
            for (var i = 0; i < domAttributes.length; i++) {
                var attrName = domAttributes[i].name.trim().toLowerCase();
                var attrValue = elem.getAttribute(attrName);
                if (attrValue === '')
                    attrValue = null;
                var isAria = attrName.substring(0, 5) === 'aria-';
                if (!isAria)
                    htmlAttributes.push({ name: attrName, value: attrValue });
            }
        }
        return htmlAttributes;
    };
    /**
     * This method handles implicit aria definitions, for example, an input with checked is equivalent to aria-checked="true"
     */
    RPTUtil.getAriaAttribute = function (ele, attributeName) {
        // If the attribute is defined, it takes precedence
        var retVal = ele.getAttribute(attributeName);
        if (ele.hasAttribute(attributeName) && retVal.trim() === "") { //"" is treated as false, so we need return it before the below check
            return retVal;
        }
        // Then determine implicit values from other attributes
        if (!retVal) {
            var tag = ele.nodeName.toLowerCase();
            if (attributeName in RPTUtil.ariaAttributeImplicitMappings) {
                if (tag in RPTUtil.ariaAttributeImplicitMappings[attributeName]) {
                    retVal = RPTUtil.ariaAttributeImplicitMappings[attributeName][tag];
                    if (typeof (retVal) === "function") {
                        retVal = retVal(ele);
                    }
                }
                else if ("*" in RPTUtil.ariaAttributeImplicitMappings[attributeName]) {
                    retVal = RPTUtil.ariaAttributeImplicitMappings[attributeName]["*"];
                    if (typeof (retVal) === "function") {
                        retVal = retVal(ele);
                    }
                }
            }
        }
        // Check role-based defaults
        if (!retVal) {
            var role = ARIAMapper_1.ARIAMapper.nodeToRole(ele);
            if (role in RPTUtil.ariaAttributeRoleDefaults && attributeName in RPTUtil.ariaAttributeRoleDefaults[role]) {
                retVal = RPTUtil.ariaAttributeRoleDefaults[role][attributeName];
                if (typeof (retVal) === "function") {
                    retVal = retVal(ele);
                }
            }
        }
        // Still not defined? Check global defaults
        if (!retVal && attributeName in RPTUtil.ariaAttributeGlobalDefaults) {
            retVal = RPTUtil.ariaAttributeGlobalDefaults[attributeName];
        }
        return retVal;
    };
    RPTUtil.wordCount = function (str) {
        str = str.trim();
        if (str.length === 0)
            return 0;
        return str.split(/\s+/g).length;
    };
    /**
     * Note that this only detects if the element itself is in the tab order.
     * However, this element may delegate focus to another element via aria-activedescendant
     * Also, focus varies by browser...  sticking to things that are focusable on chrome and firefox
     */
    RPTUtil.isTabbable = function (element) {
        // Using https://allyjs.io/data-tables/focusable.html
        // Handle the explicit cases first
        if (!VisUtil_1.VisUtil.isNodeVisible(element))
            return false;
        if (element.hasAttribute("tabindex")) {
            return parseInt(element.getAttribute("tabindex")) >= 0;
        }
        // Explicit cases handled - now the implicit
        var nodeName = element.nodeName.toLowerCase();
        if (nodeName in RPTUtil.tabTagMap) {
            var retVal = RPTUtil.tabTagMap[nodeName];
            if (typeof (retVal) === "function") {
                retVal = retVal(element);
            }
            return retVal;
        }
        else {
            return false;
        }
    };
    RPTUtil.tabIndexLEZero = function (elem) {
        if (RPTUtil.hasAttribute(elem, "tabindex")) {
            if (elem.getAttribute("tabindex").match(/^-?\d+$/)) {
                var tabindexValue = parseInt(elem.getAttribute("tabindex"));
                return tabindexValue === 0 || tabindexValue === -1;
            }
        }
        return false;
    };
    /**
     * get number of tabbable children
     * @param element
     */
    RPTUtil.getTabbableChildren = function (element) {
        var count = 0;
        // If node has children, look for tab stops in the children
        if (element.firstChild || element.nodeName.toUpperCase() === "IFRAME") {
            var nw = new NodeWalker(element);
            while (nw.nextNode() && nw.node != element) {
                if (nw.node.nodeType == 1 && !nw.bEndTag && RPTUtil.isTabbable(nw.node)) {
                    ++count;
                }
            }
        }
        return count;
    };
    //TODO: function does not handle equivalents for roles: row, link, header, button
    // But it may not have to.  Bug reports have been about radio buttons and checkboxes.
    RPTUtil.isHtmlEquiv = function (node, htmlEquiv) {
        var retVal = false;
        if (node) {
            var nodeName = node.nodeName.toLowerCase();
            if (nodeName === "input") {
                var type = node.getAttribute("type").toLowerCase();
                if (type) {
                    if (htmlEquiv.indexOf("checkbox") != -1) {
                        retVal = type === "checkbox";
                    }
                    else if (htmlEquiv.indexOf("radio") != -1) {
                        retVal = type === "radio";
                    }
                }
            }
        }
        return retVal;
    };
    RPTUtil.isDefinedAriaAttribute = function (ele, attrName) {
        var isDefinedAriaAttribute = false;
        if (attrName.substring(0, 5) === 'aria-') {
            // User agents SHOULD treat state and property attributes with a value of "" the same as they treat an absent attribute.
            isDefinedAriaAttribute = ele.hasAttribute && ele.hasAttribute(attrName) && ele.getAttribute(attrName).length > 0;
        }
        return isDefinedAriaAttribute;
    };
    RPTUtil.normalizeSpacing = function (s) {
        return s.trim().replace(/\s+/g, ' ');
    };
    ;
    RPTUtil.nonExistantIDs = function (node, targetids) {
        var returnnotfoundids = '';
        if (RPTUtil.normalizeSpacing(targetids).length < 1)
            return returnnotfoundids;
        var targetArray = targetids.split(" ");
        var doc = node.ownerDocument;
        for (var i = 0; i < targetArray.length; i++) {
            var xp = "//*[@id='" + targetArray[i] + "']";
            var xpathResult = doc.evaluate(xp, node, doc.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
            var r = xpathResult.iterateNext();
            if (!r)
                returnnotfoundids += targetArray[i] + ', ';
        }
        if (RPTUtil.normalizeSpacing(returnnotfoundids).length >= 2)
            returnnotfoundids = returnnotfoundids.substring(0, returnnotfoundids.length - 2);
        else
            returnnotfoundids = '';
        return returnnotfoundids;
    };
    RPTUtil.getDocElementsByTag = function (elem, tagName) {
        var doc = fragment_1.FragmentUtil.getOwnerFragment(elem);
        tagName = tagName.toLowerCase();
        var cache = (0, CacheUtil_1.getCache)(doc, "RPT_DOCELEMSBYTAG", {});
        if (!(tagName in cache)) {
            cache[tagName] = doc.querySelectorAll(tagName);
            (0, CacheUtil_1.setCache)(doc, "RPT_DOCELEMSBYTAG", cache);
        }
        return cache[tagName];
    };
    /**
     * This function is responsible for get a list of all the child elemnts which match the tag
     * name provided.
     *
     * Note: This is a wrapper function to: RPTUtil.getChildByTagHidden
     *
     * @parm {element} parentElem - The parent element
     * @parm {string} tagName - The tag to search for under the parent element
     * @parm {boolean} ignoreHidden - true if hidden elements with the tag should ignored from the list
     *                                false if the hidden elements should be added
     *
     * @return {List} retVal - list of all the elements which matched the tag under the parent that were provided.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getChildByTag = function (parentElem, tagName) {
        return RPTUtil.getChildByTagHidden(parentElem, tagName, false, false);
    };
    /**
     * This function is responsible for get a list of all the child elemnts which match the tag
     * name provided.
     *
     * @parm {element} parentElem - The parent element
     * @parm {string} tagName - The tag to search for under the parent element
     * @parm {boolean} ignoreHidden - true if hidden elements with the tag should ignored from the list
     *                                false if the hidden elements should be added
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     *
     * @return {List} retVal - list of all the elements which matched the tag under the parent that were provided.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getChildByTagHidden = function (parentElem, tagName, ignoreHidden, considerHiddenSetting) {
        // Variable Decleration
        var retVal = [];
        var child = parentElem.firstChild;
        // Loop over all the child elements of the parent to build a list of all the elements that
        // match the tagName provided
        while (child != null) {
            // Only include the children into the return array if they match with tagname.
            if (child.nodeName.toLowerCase() === tagName) {
                // In the case that ignorehidden was set to true, then perform a isNodeVisible check
                // and in the case the node is not visilble we more to theses then move to the next node.
                // Perform a couple of checks to determine if hidden elements should be ignored or not.
                //  1. When ignoreHidden is set to true upfront, then perform a isNodeVisible
                //  2. If considerHiddenSetting option is set to true then we perform the check to consider the
                //     Check Hidden Content that is provided.
                //  2.1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                //       be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                //       add it to the roleToElems hash at all or even do any checking for it at all.
                if ((ignoreHidden || (considerHiddenSetting && !RPTUtil.shouldCheckHiddenContent(child))) && !VisUtil_1.VisUtil.isNodeVisible(child)) {
                    // Move on to the next element
                    child = child.nextSibling;
                    continue;
                }
                // Push the element
                retVal.push(child);
            }
            // Move to the next sibling element
            child = child.nextSibling;
        }
        return retVal;
    };
    /**
     * This function is responsible for finding a list of elements that match given roles(s).
     * This function by defauly will not consider Check Hidden Setting at all.
     * This function by defauly will not consider implicit roles.
     * Note: This is a wrapper function to: RPTUtil.getElementsByRoleHidden
     *
     * @parm {document} doc - The document node
     * @parm {list or string} roles - List or single role for which to return elements based on.
     *
     * @return {List} retVal - list of all the elements which matched the role(s) that were provided.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getElementsByRole = function (doc, roles) {
        return RPTUtil.getElementsByRoleHidden(doc, roles, false, false);
    };
    /**
     * This function is responsible for finding a list of elements that match given roles(s).
     * This function aslo finds elements with implicit roles.
     * This function will also consider elements that are hidden based on the if the Check
     * Hidden Content settings should be considered or not.
     *
     * @parm {document} doc - The document node
     * @parm {list or string} roles - List or single role for which to return elements based on.
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {List} retVal - list of all the elements which matched the role(s) that were provided.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getElementsByRoleHidden = function (doc, roles, considerHiddenSetting, considerImplicitRoles) {
        // In the case that the role to element assoication is already made, and available in the global hasAttribute
        // we can just use that one instead of building a new one.
        var roleToElems = null;
        if (considerImplicitRoles) {
            roleToElems = (0, CacheUtil_1.getCache)(doc, "RPTUtil_GETELEMENTSBY_ROLE_IMPLICIT", null);
        }
        else {
            roleToElems = (0, CacheUtil_1.getCache)(doc, "RPTUtil_GETELEMENTSBY_ROLE", null);
        }
        // Build the new role to element, this is where we loop through all the elements and extract all the
        // elements bsaed on roles.
        if (roleToElems === null) {
            // Re-initialize the roleToElems hash
            roleToElems = {};
            // Get the body of the doc
            var root = doc.body;
            // Keep looping until we are at the very parent node of the entire page, so that we can loop through
            // all the nodes.
            while (DOMWalker_1.DOMWalker.parentNode(root) !== null) {
                // Get the parentNode
                root = DOMWalker_1.DOMWalker.parentNode(root);
            }
            // Build a nodewalter based of the root node, this node walter will be use loop over all the nodes
            // and build the roles to Element coralation
            var nw = new NodeWalker(root);
            // Loop over the entire doc/list of nodes to build the role to element map
            // Note: This will build an roleToElems hash which is in the following format.
            // roleToElems = {
            //    document: [{div},{abbr},{var}],
            //    main: [{div}],
            //    navigation: [{div}]
            // }
            while (nw.nextNode()) {
                if (!nw.elem())
                    continue;
                // Only check the elements which have the role attribute assiciated to them
                if (!nw.bEndTag) {
                    var wRoles = [];
                    //check if the node has role attributes
                    if (nw.elem() && nw.elem().hasAttribute("role")) {
                        // Extract all the roles that are assigned to this element, can have multiple roles on one
                        // element split by space, so we need to extract all of them into an array.
                        wRoles = nw.elem().getAttribute("role").split(" ");
                    }
                    if (nw.elem() && wRoles.length === 0 && considerImplicitRoles) {
                        //check if there are any implicit roles for this element.
                        var implicitRole = RPTUtil.getImplicitRole(nw.node);
                        if (implicitRole !== null && implicitRole.length > 0)
                            wRoles = implicitRole;
                    }
                    if (wRoles.length === 0) {
                        continue;
                    }
                    // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                    // or not.
                    //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
                    //     Check Hidden Content that is provided.
                    //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                    //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                    //     add it to the roleToElems hash at all or even do any checking for it at all.
                    //
                    // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                    //       so on and so forth.
                    if (considerHiddenSetting && RPTUtil.shouldNodeBeSkippedHidden(nw.node)) {
                        continue;
                    }
                    // Loop through all the roles and assigned this node to all thes roles
                    for (var i = 0; i < wRoles.length; ++i) {
                        // In the case that the role key is not already in the roleToElems hash, construct the
                        // add the key and assign empty array.
                        if (!(wRoles[i] in roleToElems)) {
                            roleToElems[wRoles[i]] = [];
                        }
                        // Add the node to the array for the role
                        roleToElems[wRoles[i]].push(nw.node);
                    }
                }
            }
            // Set the roleToElems hash map as a global variable
            if (considerImplicitRoles) {
                (0, CacheUtil_1.setCache)(doc, "RPTUtil_GETELEMENTSBY_ROLE_IMPLICIT", roleToElems);
            }
            else {
                (0, CacheUtil_1.setCache)(doc, "RPTUtil_GETELEMENTSBY_ROLE", roleToElems);
            }
        }
        // Initilize the return value
        var retVal = [];
        // Handle the cases where the provided role is a string and not an array,
        // for this case we take the string and put it into an array
        if (typeof (roles) === "string") {
            var role = roles;
            roles = [];
            roles.push(role);
        }
        // Loop through the roles that were provided and find the list of elements for this roles
        // and add them to the return value.
        if (roles.length) {
            // loop over all the roles
            for (var i = 0; i < roles.length; ++i) {
                // Extract the role from the array
                var nextRole = roles[i];
                // Fetch the list of all the elements for this role
                var copyRoles = roleToElems[nextRole];
                // If there are elements to copy to another array, then perform the copy
                if (copyRoles) {
                    // Loop over all the elements which are to be copied
                    for (var j = 0; j < copyRoles.length; ++j) {
                        // Add this element to the return val
                        retVal.push(copyRoles[j]);
                    }
                }
            }
        }
        return retVal;
    };
    /**
     * This function is responsible for retrieving user defined element's roles from dom.
     * @parm {HTMLElement} ele - element for which to find role.
     *
     * @return {List} roles - list of user defined roles in the element role attribute.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getUserDefinedRoles = function (ele) {
        return RPTUtil.getRoles(ele, false);
    };
    /**
     * This function is responsible for retrieving element's roles.
     * This function also finds implicit roles.
     * @parm {HTMLElement} ele - element for which to find role.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {List} roles - list of attribute roles and implicit roles.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getRoles = function (ele, considerImplicitRoles) {
        var roles = [];
        if (ele && ele.hasAttribute && ele.hasAttribute("role")) {
            var attrRoles = RPTUtil.normalizeSpacing(ele.getAttribute("role").trim()).split(" ");
            for (var i = 0; i < attrRoles.length; ++i) {
                roles.push(attrRoles[i]);
            }
        }
        //check if implicit roles exist.
        //Note: element can have multiple implicit roles
        if (considerImplicitRoles) {
            var implicitRole = RPTUtil.getImplicitRole(ele);
            if (implicitRole !== null && implicitRole.length > 0) {
                //add implicit roles to the attributes roles.
                RPTUtil.concatUniqueArrayItemList(implicitRole, roles);
            }
        }
        return roles;
    };
    /**
     * Returns the implicit role of the elemement
     * @parm {HTMLElement} ele - element for which to find role.
     *
     * @return the implicit role or [] if doesn't exist
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getImplicitRole = function (ele) {
        if (!ele || ele.nodeType !== 1)
            return [];
        var implicitRoles = (0, CacheUtil_1.getCache)(ele, "RPTUtil_ImplicitRole", null);
        if (!implicitRoles) {
            var tagProperty = RPTUtil.getElementAriaProperty(ele);
            // check if there are any implicit roles for this element.
            if (tagProperty && tagProperty.implicitRole) {
                if (tagProperty.implicitRole.includes("generic")) {
                    // the 'generic' role is only allowed if a valid aria attribute exists.
                    var domAriaAttributes_1 = RPTUtil.getUserDefinedAriaAttributes(ele);
                    if (domAriaAttributes_1.length === 0) {
                        (0, CacheUtil_1.setCache)(ele, "RPTUtil_ImplicitRole", []);
                        return [];
                    }
                    var roleAttributes = [];
                    var pattern = ARIADefinitions_1.ARIADefinitions.designPatterns['generic'];
                    if (pattern.reqProps && pattern.reqProps.length > 0)
                        RPTUtil.concatUniqueArrayItemList(pattern.reqProps, roleAttributes);
                    if (tagProperty.globalAriaAttributesValid)
                        RPTUtil.concatUniqueArrayItemList(ARIADefinitions_1.ARIADefinitions.globalProperties, roleAttributes);
                    if (pattern.deprecatedProps && pattern.deprecatedProps.length > 0)
                        RPTUtil.reduceArrayItemList(pattern.deprecatedProps, roleAttributes);
                    // remove 'generic' role if roleAttributes doesn't contain any of domAriaAttributes 
                    if (roleAttributes.length > 0 && !roleAttributes.some(function (attr) { return domAriaAttributes_1.includes(attr); })) {
                        var implicit = RPTUtil.reduceArrayItemList(['generic'], tagProperty.implicitRole);
                        (0, CacheUtil_1.setCache)(ele, "RPTUtil_ImplicitRole", implicit);
                        return implicit;
                    }
                }
                (0, CacheUtil_1.setCache)(ele, "RPTUtil_ImplicitRole", tagProperty.implicitRole);
                return tagProperty.implicitRole;
            }
            (0, CacheUtil_1.setCache)(ele, "RPTUtil_ImplicitRole", []);
            return [];
        }
        return implicitRoles;
    };
    /**
     * Returns the required properties of the role
     * @parm {string} role - the role
     * @parm {HTMLElement} ele - element for which to find role.
     *
     * @return {List} properties - list of properties that are required by the role
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getRoleRequiredProperties = function (role, ele) {
        if (role === null) {
            return null;
        }
        if (ARIADefinitions_1.ARIADefinitions.designPatterns[role]) {
            var requiredAttributes = ARIADefinitions_1.ARIADefinitions.designPatterns[role].reqProps;
            // handle special case of separator
            if (role.toLowerCase() === "separator" && ele && RPTUtil.isFocusable(ele)) {
                requiredAttributes = RPTUtil.concatUniqueArrayItemList(["aria-valuenow"], requiredAttributes || []);
            }
            return requiredAttributes;
        }
        else {
            return null;
        }
    };
    /**
     * Test if the ele node is focusable
     */
    RPTUtil.isFocusable = function (ele) {
        if (ele === "undefined" || ele === null) {
            return false;
        }
        return RPTUtil.isTabbable(ele);
    };
    /**
     * This function is responsible for finding if a element has given role.
     * This function aslo finds if element has given roles as implicit role.
     * @parm {HTMLElement} ele - element for which to find role.
     * @parm {list or string} roles - List or single role for which to find if element has these roles.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {List} retVal - true or false based on if th element has the specified role.
     *
     * @memberOf RPTUtil
     *
     * Consider to use hasRoleInSemantics() instead.
     */
    RPTUtil.hasRole = function (ele, role, considerImplicitRoles) {
        var retVal = false;
        if (ele && ele.hasAttribute && ele.hasAttribute("role")) {
            if (typeof (role) != typeof ("")) {
                var roles = ele.getAttribute("role").trim().split(" ");
                for (var i = 0; !retVal && i < roles.length; ++i) {
                    retVal = roles[i] in role;
                }
            }
            else {
                var roles = ele.getAttribute("role").trim().split(" ");
                for (var i = 0; !retVal && i < roles.length; ++i) {
                    retVal = roles[i] === role;
                }
            }
        }
        //if none of the the attribute roles matched with given role
        //check if implicit roles matches.
        //Note: element can have multiple implicit roles
        if (!retVal && considerImplicitRoles) {
            var wRoles = [];
            //check if there are any implicit roles for this element.
            var implicitRole = RPTUtil.getImplicitRole(ele);
            if (implicitRole !== null && implicitRole.length > 0) {
                RPTUtil.concatUniqueArrayItemList(implicitRole, wRoles);
                //if role is array loop thru and see if any  of the implicit role present in the array
                if (typeof (role) != typeof ("")) {
                    for (var i = 0; !retVal && i < wRoles.length; ++i) {
                        retVal = wRoles[i] in role;
                    }
                }
                else {
                    for (var i = 0; !retVal && i < wRoles.length; ++i) {
                        retVal = wRoles[i] === role;
                    }
                }
            }
        }
        return retVal;
    };
    /**
     * Checks if the element has the role, including the implied role if role is not explicitly specified.
     *
     * This function is replacing the hasRole function
     *
     * @parm {HTMLElement} ele - element for which to find role.
     * @parm {list or string} roles - List or single role for which to find if element has these roles.
     *
     * @return {List} retVal - true or false based on if the element has the specified role.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.hasRoleInSemantics = function (ele, role) {
        var retVal = false;
        var roleSpecified = false;
        if (ele && ele.hasAttribute && ele.hasAttribute("role")) {
            if (typeof (role) != typeof ("")) {
                var roles = ele.getAttribute("role").trim().toLowerCase().split(/\s+/);
                for (var i = 0; !retVal && i < roles.length; ++i) {
                    roleSpecified = true;
                    retVal = roles[i] in role;
                }
            }
            else {
                var roles = ele.getAttribute("role").trim().toLowerCase().split(/\s+/);
                for (var i = 0; !retVal && i < roles.length; ++i) {
                    roleSpecified = true;
                    retVal = roles[i] === role;
                }
            }
        }
        if (roleSpecified) {
            return retVal;
        }
        //check if implicit roles matches.
        //Note: element can have multiple implicit roles
        //check if there are any implicit roles for this element.
        var impRoles = RPTUtil.getImplicitRole(ele);
        if (impRoles !== null && impRoles.length > 0) {
            //if role is array loop thru and see if any  of the implicit role present in the array
            if (typeof (role) != typeof ("")) {
                for (var i = 0; !retVal && i < impRoles.length; ++i) {
                    retVal = impRoles[i] in role;
                }
            }
            else {
                for (var i = 0; !retVal && i < impRoles.length; ++i) {
                    retVal = impRoles[i] === role;
                }
            }
        }
        return retVal;
    };
    /**
     * This function is responsible for finding if a element has given role.
     * This function also checks if element has given roles as implicit roles.
     * @parm {HTMLElement} ele - element for which to find role.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {bool} retVal - true or false based on if the element has the specified role.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.hasAnyRole = function (ele, considerImplicitRoles) {
        var retVal = false;
        if (ele && ele.hasAttribute && ele.hasAttribute("role")) {
            retVal = true;
        }
        //check if implicit roles exist.
        //Note: element can have multiple implicit roles
        if (!retVal && considerImplicitRoles) {
            //check if there are any implicit roles for this element.
            var impRoles = RPTUtil.getImplicitRole(ele);
            if (impRoles !== null && impRoles.length > 0)
                retVal = true;
        }
        return retVal;
    };
    RPTUtil.isDataTable = function (tableNode) {
        return !(RPTUtil.hasRole(tableNode, "none") || RPTUtil.hasRole(tableNode, "presentation"));
    };
    /*
     * A complex data table is a data table with any of the following characteristics:
     *
     * a thead element that contains two or more tr elements
     * a table with more than one thead element
     * a table with two or more tr elements that contain only th elements
     * a th or td element with a rowspan or colspan attribute
     * a tr element that contains at least one td element and two or more th elements
     * a table with headers not located in the first row or first column
     * a td element with a headers attribute value that contains more than two IDREFs
     */
    RPTUtil.isComplexDataTable = function (table) {
        if ("RPTUtil_isComplexDataTable" in table) {
            return !!table.RPTUtil_isComplexDataTable;
        }
        var isComplexTable = false;
        if (table && RPTUtil.isDataTable(table)) {
            var thNodes = null, tdNodes = null;
            var trNodes = table.getElementsByTagName("tr");
            var trNodeCount = trNodes.length;
            var tdNodeCount = 0, thNodeCount = 0, trNodesHavingOnlyThNodes = 0;
            for (var i = 0; !isComplexTable && i < trNodeCount; ++i) {
                thNodes = trNodes[i].getElementsByTagName("th");
                tdNodes = trNodes[i].getElementsByTagName("td");
                thNodeCount = thNodes.length;
                tdNodeCount = tdNodes.length;
                if (tdNodeCount !== 0) {
                    // a tr element that contains at least one td element and two or more th elements;
                    isComplexTable = thNodeCount > 1;
                    // a th element with a rowspan or colspan attribute
                    for (var j = 0; !isComplexTable && j < thNodeCount; ++j) {
                        isComplexTable = ((thNodes[j].hasAttribute("rowspan") ||
                            thNodes[j].hasAttribute("colspan")) &&
                            RPTUtil.getAncestor(thNodes[j], "table") === table);
                    }
                    // a td element with a rowspan or colspan attribute
                    // a td element with a headers attribute value that contains more than two IDREFs
                    for (var k = 0; !isComplexTable && k < tdNodeCount; ++k) {
                        isComplexTable = ((tdNodes[k].hasAttribute("rowspan") ||
                            tdNodes[k].hasAttribute("colspan") ||
                            (tdNodes[k].hasAttribute("headers") && RPTUtil.normalizeSpacing(tdNodes[k].getAttribute("headers")).split(" ").length > 2)) &&
                            RPTUtil.getAncestor(tdNodes[k], "table") === table);
                    }
                }
                else {
                    // two or more tr elements that contain only th elements
                    if (thNodeCount > 0) {
                        ++trNodesHavingOnlyThNodes;
                    }
                    isComplexTable = trNodesHavingOnlyThNodes === 2;
                }
            }
            if (!isComplexTable) {
                var theadNodes = table.getElementsByTagName("thead");
                var theadNodesLength = theadNodes.length;
                if (theadNodesLength > 0) {
                    // table has more than one thead element
                    isComplexTable = theadNodesLength > 1;
                    // a thead element that contains two or more tr elements
                    if (!isComplexTable) {
                        isComplexTable = theadNodes[0].getElementsByTagName("tr").length > 1;
                    }
                }
            }
            if (!isComplexTable && trNodeCount !== 0) {
                // a table with headers not located in the first row or first column
                isComplexTable = thNodeCount > 0 && !RPTUtil.isTableHeaderInFirstRowOrColumn(table);
            }
        }
        table.RPTUtil_isComplexDataTable = isComplexTable;
        return isComplexTable;
    };
    // Return true if a table's header is in the first row or column
    RPTUtil.isTableHeaderInFirstRowOrColumn = function (ruleContext) {
        var passed = false;
        var rows = ruleContext.rows;
        // Check if the first row is all TH's
        if (rows != null && rows.length > 0) {
            var firstRow = rows[0];
            passed = firstRow.cells.length > 0 && RPTUtil.getChildByTagHidden(firstRow, "td", false, true).length === 0;
            // If the first row isn't a header row, try the first column
            if (!passed) {
                // Assume that the first column has all TH's unless we find a TD in the first column.
                passed = true;
                for (var i = 0; passed && i < rows.length; ++i) {
                    // If no cells in this row, that's okay too.
                    passed = !rows[i].cells ||
                        rows[i].cells.length === 0 ||
                        rows[i].cells[0].nodeName.toLowerCase() != "td";
                }
            }
            if (!passed) {
                // Special case - both first row and first column are headers, but they did not use
                // a th for the upper-left cell
                passed = true;
                for (var i = 1; passed && i < firstRow.cells.length; ++i) {
                    passed = firstRow.cells[i].nodeName.toLowerCase() != "td";
                }
                for (var i = 1; passed && i < rows.length; ++i) {
                    // If no cells in this row, that's okay too.
                    passed = !rows[i].cells ||
                        rows[i].cells.length === 0 ||
                        rows[i].cells[0].nodeName.toLowerCase() != "td";
                }
            }
        }
        return passed;
    };
    RPTUtil.isNodeInGrid = function (node) {
        return RPTUtil.getAncestorWithRole(node, "grid") != null;
    };
    RPTUtil.isLayoutTable = function (tableNode) {
        return RPTUtil.hasRole(tableNode, "presentation") || RPTUtil.hasRole(tableNode, "none");
    };
    RPTUtil.getFileExt = function (url) {
        var m = url.match(/\.(([^;?#\.]|^$)+)([;?#]|$)/);
        if (m != null && m.length >= 2) {
            return "." + m[1];
        }
        return "";
    };
    RPTUtil.getFileAnchor = function (url) {
        var m = url.match(/#(([^;?\.]|^$)+)([;?]|$)/);
        if (m != null && m.length >= 2) {
            return m[1];
        }
        return "";
    };
    RPTUtil.checkObjEmbed = function (node, extTest, mimeTest) {
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName != "object" && nodeName != "embed" &&
            nodeName != "a" && nodeName != "area")
            return false;
        var retVal = false;
        // Check mime type
        if (!retVal && node.hasAttribute("type")) {
            var mime = node.getAttribute("type").toLowerCase();
            retVal = mimeTest(mime);
        }
        if (!retVal && node.hasAttribute("codetype")) {
            var mime = node.getAttribute("codetype");
            retVal = mimeTest(mime);
        }
        // Check the filename
        if (!retVal) {
            var filename = "";
            if (nodeName === "embed") {
                filename = node.getAttribute("src");
            }
            else if (nodeName === "a" || nodeName === "area") {
                filename = node.getAttribute("href");
            }
            else if (node.hasAttribute("data")) {
                filename = node.getAttribute("data");
            }
            if (filename === null)
                filename = "";
            var ext = RPTUtil.getFileExt(filename);
            retVal = extTest(ext);
        }
        // Check for filenames in the params
        if (!retVal && nodeName === "object") {
            // In the case that Check Hidden Option is set then comply with that setting
            var params = RPTUtil.getChildByTagHidden(node, "param", false, true);
            for (var i = 0; !retVal && params != null && i < params.length; ++i) {
                retVal = params[i].hasAttribute("value") &&
                    extTest(RPTUtil.getFileExt(params[i].getAttribute("value")));
            }
        }
        return retVal;
    };
    RPTUtil.isAudioObjEmbedLink = function (node) {
        return RPTUtil.checkObjEmbed(node, RPTUtil.isAudioExt, function (mime) {
            return mime.startsWith("audio");
        });
    };
    RPTUtil.isAudioExt = function (ext) {
        var audio_extensions = [".aif", ".aifc", ".aiff", ".air", ".asf", ".au", ".cda",
            ".dsm", ".dss", ".dwd", ".iff", ".kar", ".m1a", ".med",
            ".mp2", ".mp3", ".mpa", ".pcm", ".ra", ".ram", ".rm",
            ".sam", ".sf", ".sf2", ".smp", ".snd", ".svx", ".ul",
            ".voc", ".wav", ".wma", ".wve"
        ];
        return RPTUtil.valInArray(ext.toLowerCase(), audio_extensions);
    };
    RPTUtil.isVideoObjEmbedLink = function (node) {
        return RPTUtil.checkObjEmbed(node, RPTUtil.isVideoExt, function (mime) {
            return mime.startsWith("video") ||
                mime.startsWith("application/x-shockwave-flash");
        });
    };
    RPTUtil.isVideoExt = function (ext) {
        var video_extensions = [".asf", ".avi", ".divx", ".dv", ".m1v", ".m2p", ".m2v", ".moov",
            ".mov", ".mp4", ".mpeg", ".mpg", ".mpv", ".ogm", ".omf", ".qt",
            ".rm", ".rv", ".smi", ".smil", ".swf", ".vob", ".wmv", ".rmvb",
            ".mvb"
        ];
        return RPTUtil.valInArray(ext.toLowerCase(), video_extensions);
    };
    RPTUtil.isImageObjEmbedLink = function (node) {
        return RPTUtil.checkObjEmbed(node, RPTUtil.isImgExt, function (mime) {
            return mime.startsWith("image");
        });
    };
    RPTUtil.isImgExt = function (ext) {
        var image_extensions = [".bmp", ".gif", ".jpg", ".jpeg", ".pcx", ".png"];
        return RPTUtil.valInArray(ext.toLowerCase(), image_extensions);
    };
    RPTUtil.isHtmlExt = function (ext) {
        var html_extensions = [".asp", ".aspx", ".cfm", ".cfml", ".cgi", ".htm", ".html", ".shtm",
            ".shtml", ".php", ".pl", ".py", ".shtm", ".shtml", ".xhtml"
        ];
        return RPTUtil.valInArray(ext.toLowerCase(), html_extensions);
    };
    RPTUtil.isPresentationalElement = function (node) {
        // Elements extracted from https://developer.mozilla.org/en/docs/Web/HTML/Element#Inline_text_semantics,
        // http://dev.w3.org/html5/html-author/#text-level-semantics and https://wiki.whatwg.org/wiki/Presentational_elements_and_attributes
        var presentationalElements = ["abbr", "b", "bdi", "bdo", "br", "cite", "code", "data", "dfn",
            "em", "i", "kbd", "mark", "q", "rp", "rt", "rtc", "ruby", "s",
            "samp", "small", "span", "strong", "sub", "sup", "time", "u",
            "var", "wbr", "a", "progress", "meter", "basefont", "big", "center",
            "strike", "tt", "font", "blink", "h1", "h2", "h3", "h4", "h5", "h6",
            "hr", "blockquote", "p"
        ];
        return RPTUtil.valInArray(node.nodeName.toLowerCase(), presentationalElements);
    };
    RPTUtil.hasTriggered = function (doc, id) {
        return (0, CacheUtil_1.getCache)(doc, id, false);
    };
    RPTUtil.triggerOnce = function (doc, id, passed) {
        if (passed)
            return true;
        var triggered = (0, CacheUtil_1.getCache)(doc, id, false);
        (0, CacheUtil_1.setCache)(doc, id, true);
        return triggered;
    };
    /* determine if the given value exists in the given array */
    RPTUtil.valInArray = function (value, arr) {
        for (var idx in arr) {
            if (arr[idx] === value)
                return true;
        }
        return false;
    };
    /**
     * return the ancestor of the given element
     * @param tagNames string, array, or dictionary containing the tags to search for
     */
    RPTUtil.getAncestor = function (element, tagNames) {
        var walkNode = element;
        while (walkNode !== null) {
            var thisTag = walkNode.nodeName.toLowerCase();
            if (typeof (tagNames) === "string") {
                if (thisTag === tagNames.toLowerCase()) {
                    break;
                }
            }
            else if (tagNames.length) {
                for (var idx in tagNames) {
                    if (tagNames[idx] === thisTag)
                        return walkNode;
                }
            }
            else if (thisTag in tagNames) {
                break;
            }
            walkNode = DOMWalker_1.DOMWalker.parentNode(walkNode);
        }
        return walkNode;
    };
    // return true if element1 and element2 are siblings
    RPTUtil.isSibling = function (element1, element2) {
        if (element1 && element2) {
            var node = null;
            if (DOMWalker_1.DOMWalker.parentNode(element1) && DOMWalker_1.DOMWalker.parentNode(element1).firstChild) {
                node = DOMWalker_1.DOMWalker.parentNode(element1).firstChild;
            }
            while (node) {
                if (node === element2)
                    return true;
                node = node.nextSibling;
            }
        }
        return false;
    };
    /**
     * return the ancestor of the given element and role.
     *
     * @parm {element} element - The element to start the node walk on to find parent node
     * @parm {string} role - The role to search for on an element under the provided element
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node} walkNode - A parent node of the element passed in, which has the provided role
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getAncestorWithRole = function (element, roleName, considerImplicitRoles) {
        var walkNode = DOMWalker_1.DOMWalker.parentNode(element);
        while (walkNode !== null) {
            if (considerImplicitRoles) {
                if (RPTUtil.hasRoleInSemantics(walkNode, roleName)) {
                    break;
                }
            }
            else {
                if (RPTUtil.hasRole(walkNode, roleName, false)) {
                    break;
                }
            }
            walkNode = DOMWalker_1.DOMWalker.parentNode(walkNode);
        }
        return walkNode;
    };
    /**
     * return the ancestor with the given style properties.
     *
     * @parm {element} element - The element to start the node walk on to find parent node
     * @parm {[string]} styleProps - The style properties and values of the parent to search for.
     *         such as {"overflow":['auto', 'scroll'], "overflow-x":['auto', 'scroll']}
     *          or {"overflow":['*'], "overflow-x":['*']}, The '*' for any value to check the existence of the style prop.
     * @parm {bool} excludedValues - style values that should be ignored.
     * @return {node} walkNode - A parent node of the element, which has the style properties
     * @memberOf RPTUtil
     */
    RPTUtil.getAncestorWithStyles = function (elem, styleProps, excludedValues) {
        if (excludedValues === void 0) { excludedValues = []; }
        var walkNode = elem;
        while (walkNode !== null) {
            var styles = (0, CSSUtil_1.getDefinedStyles)(walkNode);
            for (var style in styleProps) {
                var value = styles[style];
                if (value) {
                    value = value.split(" ")[0]; //get rid of !important
                    if (!excludedValues.includes(value)) {
                        if (styleProps[style].includes('*')) {
                            return walkNode;
                        }
                        else if (styleProps[style].includes(value))
                            return walkNode;
                    }
                }
            }
            walkNode = DOMWalker_1.DOMWalker.parentElement(walkNode);
        }
        return null;
    };
    /**
     * This function is responsible for finding a node which matches the role and is a sibling of the
     * provided element.
     *
     * This function by default will not consider Check Hidden Setting at all.
     *
     * Note: This is a wrapper function to: RPTUtil.getSiblingWithRoleHidden
     *
     * @parm {element} element - The element to start the node walk on to find sibling node
     * @parm {string} role - The role to search for on an element under the provided element
     *
     * @return {node} walkNode - A sibling node of the element passed in, which has the provided role
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getSiblingWithRole = function (element, role) {
        return RPTUtil.getSiblingWithRoleHidden(element, role, false);
    };
    /**
     * This function is responsible for finding a node which matches the role and is a sibling of the
     * provided element.
     *
     * This function also considers implicit roles for the elements.
     *
     * This function will also consider elements that are hidden based on the if the Check
     * Hidden Content settings should be considered or not.
     *
     * @parm {element} element - The element to start the node walk on to find sibling node
     * @parm {string} role - The role to search for on an element under the provided element
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicit - true or false based on if Implicit roles should be considered.
     *
     * @return {node} walkNode - A sibling node of the element passed in, which has the provided role
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getSiblingWithRoleHidden = function (element, role, considerHiddenSetting, considerImplicitRole) {
        // Variable Declaration
        var walkNode = null;
        var hasRole = false;
        // Only perform the check if element and role are both provided
        if (element && role) {
            // Fetch the next sibling element
            walkNode = element.nextSibling;
            // Keep looping over the next siblings to find element which matches
            // the provided role.
            while (walkNode !== null && !hasRole) {
                // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                // or not.
                //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
                //     Check Hidden Content that is provided.
                //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                //     add it to the roleToElems hash at all or even do any checking for it at all.
                //
                // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                //       so on and so forth.
                if (considerHiddenSetting && RPTUtil.shouldNodeBeSkippedHidden(walkNode)) {
                    // Move on to the next node
                    walkNode = walkNode.nextSibling;
                    continue;
                }
                // Check if this node has the role that we need to check exists
                if (considerImplicitRole) {
                    hasRole = RPTUtil.hasRoleInSemantics(walkNode, role);
                }
                else {
                    hasRole = RPTUtil.hasRole(walkNode, role, false);
                }
                // Move on to the next node
                walkNode = walkNode.nextSibling;
            }
            // If we still have not found a node that matches the role, start a reverse look up
            if (!walkNode) {
                // Fetch the previous Sibling of this element
                walkNode = element.previousSibling;
                // Keep looping over all the previous siblings to search for an element which
                // matches the provided role.
                while (walkNode !== null && !hasRole) {
                    // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                    // or not.
                    //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
                    //     Check Hidden Content that is provided.
                    //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                    //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                    //     add it to the roleToElems hash at all or even do any checking for it at all.
                    //
                    // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                    //       so on and so forth.
                    if (considerHiddenSetting && RPTUtil.shouldNodeBeSkippedHidden(walkNode)) {
                        // Move on to the next node
                        walkNode = walkNode.previousSibling;
                        continue;
                    }
                    // Check if this node has the role that we need to check exists
                    hasRole = RPTUtil.hasRole(walkNode, role, considerImplicitRole);
                    // Move on to the next node
                    walkNode = walkNode.previousSibling;
                }
            }
        }
        return walkNode;
    };
    RPTUtil.isDescendant = function (parent, child) {
        var node = DOMWalker_1.DOMWalker.parentNode(child);
        while (node != null) {
            if (node === parent) {
                return true;
            }
            node = DOMWalker_1.DOMWalker.parentNode(node);
        }
        return false;
    };
    //check if the first form control child is disabled
    RPTUtil.isDisabledByFirstChildFormElement = function (element) {
        var formElements = ["input", "textarea", "select", "keygen", "progress", "meter", "output"];
        if (element.firstChild != null) {
            var nw = new NodeWalker(element);
            while (nw.nextNode()) {
                if (formElements.includes(nw.node.nodeName.toLowerCase())) {
                    if (RPTUtil.isNodeDisabled(nw.node))
                        return true;
                    return false;
                }
            }
        }
        return false;
    };
    RPTUtil.isDisabledByReferringElement = function (element) {
        var id = element.getAttribute("id");
        var doc = element.ownerDocument;
        var root = doc.body;
        while (DOMWalker_1.DOMWalker.parentNode(root) !== null) {
            // Get the parentNode
            root = DOMWalker_1.DOMWalker.parentNode(root);
        }
        var nw = new NodeWalker(root);
        while (nw.nextNode()) {
            // check the element whose 'aria-describedby' equals to the id
            if (nw.node && nw.node.nodeType === 1 && nw.elem()) {
                var AriaDescribedbyIDArray = (nw.elem().getAttribute("aria-describedby") || "").split(" ");
                if (AriaDescribedbyIDArray.includes(id) && RPTUtil.isNodeDisabled(nw.node)) {
                    return true;
                }
            }
        }
    };
    /**
     * This function is responsible for getting a descendant element with the specified role, under
     * the element that was provided.
     *
     * Note by default this function will not consider the Check Hidden Content Setting.
     *
     * Note: This is a wrapper function to: RPTUtil.getDescendantWithRoleHidden
     *
     * @parm {element} element - parent element for which we will be checking descendants for
     * @parm {string} roleName - The role to look for on the descendants elements
     *
     * @return {node} - The descendant element that matches the role specified (only one)
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getDescendantWithRole = function (element, roleName) {
        return RPTUtil.getDescendantWithRoleHidden(element, roleName, false);
    };
    /**
     * This function is responsible for getting a descendant element with the specified role, under
     * the element that was provided. This function aslo finds elements with implicit roles.
     *
     * @parm {element} element - parent element for which we will be checking descendants for
     * @parm {string} roleName - The role to look for on the descendants elements
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node} - The descendant element that matches the role specified (only one)
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getDescendantWithRoleHidden = function (element, roleName, considerHiddenSetting, considerImplicitRoles) {
        // Variable Decleration
        var descendant = null;
        var nw = new NodeWalker(element);
        // Loop over all the childrens of the element provided and check if the rolename provided exists
        while (nw.nextNode() && nw.node != element && nw.node != element.nextSibling) {
            // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
            // or not.
            //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
            //     Check Hidden Content that is provided.
            //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
            //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
            //     add it to the roleToElems hash at all or even do any checking for it at all.
            //
            // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
            //       so on and so forth.
            if (considerHiddenSetting && RPTUtil.shouldNodeBeSkippedHidden(nw.node)) {
                continue;
            }
            // Check if this node has the role specified, if it does then set this as the descendant and stop checking the rest of the
            // nodes.
            // Check if this node has the implicit roles, if it does then set this as the descendant and stop checking the rest of the
            // nodes.
            if (considerImplicitRoles ? RPTUtil.hasRoleInSemantics(nw.node, roleName) : RPTUtil.hasRole(nw.node, roleName, false)) {
                descendant = nw.node;
                break;
            }
        }
        return descendant;
    };
    /**
     * This function is responsible for getting All descendant elements with the specified role, under
     * the element that was provided. This function aslo finds elements with implicit roles.
     *
     * @parm {element} element - parent element for which we will be checking descendants for
     * @parm {string} roleName - The role to look for on the descendants elements
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node} - The descendant element that matches the role specified (only one)
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getAllDescendantsWithRoleHidden = function (element, roleName, considerHiddenSetting, considerImplicitRoles) {
        // Variable Decleration
        var descendants = [];
        var nw = new NodeWalker(element);
        // Loop over all the childrens of the element provided and check if the rolename provided exists
        while (nw.nextNode() && nw.node != element && nw.node != element.nextSibling) {
            if (nw.bEndTag) {
                continue;
            }
            // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
            // or not.
            //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
            //     Check Hidden Content that is provided.
            //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
            //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
            //     add it to the roleToElems hash at all or even do any checking for it at all.
            //
            // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
            //       so on and so forth.
            if (considerHiddenSetting && RPTUtil.shouldNodeBeSkippedHidden(nw.node)) {
                continue;
            }
            // Check if this node has the role specified, if it does then set this as the descendant and stop checking the rest of the
            // nodes.
            // Check if this node has the implicit roles, if it does then set this as the descendant and stop checking the rest of the
            // nodes.
            if (RPTUtil.hasRole(nw.node, roleName, considerImplicitRoles)) {
                descendants.push(nw.node);
            }
        }
        return descendants;
    };
    /**
     * This function is responsible for getting All direct children in AT tree with a role (exclude none and presentation)
     *
     * @parm {element} element - parent element for which we will be checking children for
     * @return {node} - The direct child elements in AT tree that has a role
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getDirectATChildren = function (element) {
        var requiredChildRoles = RPTUtil.getRequiredChildRoles(element, true);
        var direct = [];
        RPTUtil.retrieveDirectATChildren(element, requiredChildRoles, direct);
        return direct;
    };
    /**
     * This function is responsible for recursively any child path till either no child or a child with a role is found (exclude none and presentation)
     *
     * @parm {element} element - parent element for which we will be checking children for
     * @return {node} - The direct child elements in AT tree
     *
     * @memberOf RPTUtil
     */
    RPTUtil.retrieveDirectATChildren = function (element, requiredChildRoles, direct) {
        var children = [];
        if (element.children !== null && element.children.length > 0) {
            for (var i = 0; i < element.children.length; i++) {
                children.push(element.children[i]);
            }
        }
        // if the element contains "aria-own" attribute, then the aria-owned children need to be included too
        var owned = element.getAttribute("aria-owns");
        if (owned) {
            var doc = element.ownerDocument;
            if (doc) {
                var ownedIds = owned.split(" ");
                for (var i = 0; i < ownedIds.length; i++) {
                    var ownedElem = doc.getElementById(ownedIds[i]);
                    if (ownedElem) {
                        children.push(ownedElem);
                    }
                }
            }
        }
        if (children.length > 0) {
            for (var i = 0; i < children.length; i++) {
                //ignore hidden and invisible child
                if (VisUtil_1.VisUtil.isNodeHiddenFromAT(children[i]) || !VisUtil_1.VisUtil.isNodeVisible(children[i]))
                    continue;
                var roles = RPTUtil.getRoles(children[i], false);
                if (roles === null || roles.length === 0) {
                    roles = RPTUtil.getImplicitRole(children[i]);
                }
                if (roles && roles !== null && roles.length > 0) {
                    //remove 'none' and 'presentation'
                    roles = roles.filter(function (role) {
                        return role !== "none" && role !== "presentation";
                    });
                    // a 'group' role is allowed but not required for some elements so remove it if exists
                    if (roles.includes("group") && requiredChildRoles && requiredChildRoles.includes('group')) {
                        roles = roles.filter(function (role) {
                            return role !== 'group';
                        });
                    }
                }
                if (roles && roles !== null && roles.length > 0) {
                    direct.push(children[i]);
                }
                else {
                    // recursive until get a return value, 
                    RPTUtil.retrieveDirectATChildren(children[i], requiredChildRoles, direct);
                }
            }
            return null;
        }
        else
            return null;
    };
    /**
     * this function returns null or required child roles for a given element with one more roles,
     * return null if the role is 'none' or 'presentation'
     * @param element
     * @param includeImplicit include implicit roles if no role is explicitly provided
     * @returns
     */
    RPTUtil.getRequiredChildRoles = function (element, includeImplicit) {
        var roles = RPTUtil.getRoles(element, false);
        // if explicit role doesn't exist, get the implicit one
        if ((!roles || roles.length === 0) && includeImplicit) {
            roles = RPTUtil.getImplicitRole(element);
        }
        /**
         * ignore if the element doesn't have any explicit or implicit role
        */
        if (!roles || roles.length === 0) {
            return null;
        }
        /**
         * ignore if the element contains none or presentation role
        */
        var presentationRoles = ["none", "presentation"];
        var found = roles.some(function (r) { return presentationRoles.includes(r); });
        if (found)
            return null;
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        var requiredChildRoles = new Array();
        for (var j = 0; j < roles.length; ++j) {
            if (designPatterns[roles[j]] && designPatterns[roles[j]].reqChildren !== null) {
                requiredChildRoles = RPTUtil.concatUniqueArrayItemList(designPatterns[roles[j]].reqChildren, requiredChildRoles);
            }
        }
        return requiredChildRoles;
    };
    /**
     * This function is responsible for getting an element referenced by aria-owns and has the
     * role that was specified.
     *
     * Note by default this function will not consider the Check Hidden Content Setting.
     *
     * Note: This is a wrapper function to: RPTUtil.getAriaOwnsWithRoleHidden
     *
     * @parm {element} element - Element to check for aria-owns
     * @parm {string} roleName - The role to look for on the aria-owns element
     *
     * @return {node} - The element that is referenced by aria-owns and has role specified.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getAriaOwnsWithRole = function (element, roleName) {
        return RPTUtil.getAriaOwnsWithRoleHidden(element, roleName, false);
    };
    /**
     * This function is responsible for getting an element referenced by aria-owns and has the
     * role that was specified. This function aslo finds elements with implicit roles.
     *
     * @parm {element} element - Element to check for aria-owns
     * @parm {string} roleName - The role to look for on the aria-owns element
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node} - The element that is referenced by aria-owns and has role specified.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getAriaOwnsWithRoleHidden = function (element, roleName, considerHiddenSetting, considerImplicitRoles) {
        // Variable Decleration
        var referencedElement = null;
        var referencedElemHasRole = false;
        // In the case aria-owns is not on the element just break out of this function with null
        if (RPTUtil.attributeNonEmpty(element, "aria-owns")) {
            // Get the reference ID
            var referenceID = element.getAttribute("aria-owns");
            // Get the element for the reference ID
            referencedElement = fragment_1.FragmentUtil.getById(element, referenceID);
            // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
            // or not.
            //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
            //     Check Hidden Content that is provided.
            //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
            //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
            //     add it to the roleToElems hash at all or even do any checking for it at all.
            if (considerHiddenSetting && referencedElement != null && RPTUtil.shouldNodeBeSkippedHidden(referencedElement)) {
                referencedElemHasRole = null;
            }
            else {
                referencedElemHasRole = RPTUtil.hasRole(referencedElement, roleName, considerImplicitRoles);
            }
        }
        return referencedElemHasRole ? referencedElement : null;
    };
    /** get element containing label for the given element
     * @deprecated Deprecated because the function name is misleading. Use getLabelForElement(element) instead
     */
    RPTUtil.getInputLabel = function (element) {
        return RPTUtil.getLabelForElement(element);
    };
    /**
     * This function is responsible for getting the element containing the label for the given element.
     *
     * Note: This is a wrapper function to: RPTUtil.getLabelForElementHidden
     *
     * @parm {element} element - The element for which to get the label element for.
     *
     * @return {element} element - return the element for the label, otherwise null
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getLabelForElement = function (element) {
        return RPTUtil.getLabelForElementHidden(element, false);
    };
    /**
     * This function is responsible for getting the element containing the label for the given element.
     *
     * This function will return null if the containing lable element is hidden, when the ignoreHidden option
     * is set to true.
     *
     * @parm {element} element - The element for which to get the label element for.
     * @parm {boolean} ignoreHidden - true if hidden elements with label should be ignored from the list
     *                                false if the hidden elements should be added
     *
     * @return {element} element - return the element for the label, otherwise null
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getLabelForElementHidden = function (element, ignoreHidden) {
        // Check if the global RPTUtil_LABELS hash is available, as this will contain the label nodes based on
        // for attribute.
        //if (!getCache(element.ownerDocument,"RPTUtil_LABELS", null)) {
        var root = element.getRootNode();
        if (!(0, CacheUtil_1.getCache)((root.nodeType === 11) ? root : root, "RPTUtil_LABELS", null)) {
            // Variable Decleration
            var idToLabel = {};
            // Get all the label elements in the entire doc
            var labelNodes = RPTUtil.getDocElementsByTag(element, "label");
            // Loop over all the label nodes, in the case the label node has a for attribute,
            // extract that attribute and add this node to the hash if it is visible.
            for (var i = 0; i < labelNodes.length; ++i) {
                if (labelNodes[i].hasAttribute("for")) {
                    // If ignore hidden is specified and the node is not visible we do not add it to the
                    // labelNodes hash.
                    if (ignoreHidden && !VisUtil_1.VisUtil.isNodeVisible(labelNodes[i])) {
                        continue;
                    }
                    idToLabel[labelNodes[i].getAttribute("for")] = labelNodes[i];
                }
            }
            // Add the built hash to the ownerDocument (document), to be used later to fast retrival
            //setCache(element.ownerDocument, "RPTUtil_LABELS", idToLabel);
            (0, CacheUtil_1.setCache)((root.nodeType === 11) ? root : root, "RPTUtil_LABELS", idToLabel);
        }
        // If this element has an id attribute, get the corosponding label element
        if (element.hasAttribute("id")) {
            // Fetch the id attribute
            var ctrlId = element.getAttribute("id");
            // Return the corosponding label element.
            // Note: in the case that the the id is not found in the hash that means, it does not exists or is hidden
            if (ctrlId.trim().length > 0) {
                //return getCache(element.getRootNode().ownerDocument,"RPTUtil_LABELS",{})[ctrlId];
                return (0, CacheUtil_1.getCache)((root.nodeType === 11) ? root : root, "RPTUtil_LABELS", {})[ctrlId];
            }
        }
        return null;
    };
    /* Return specified element attribute if present else return null */
    RPTUtil.getElementAttribute = function (element, attr) {
        return (element && element.hasAttribute && element.hasAttribute(attr)) ? element.getAttribute(attr) : null;
    };
    // Return true if the element has an ARIA label
    RPTUtil.hasAriaLabel = function (element) {
        // Rpt_Aria_ValidIdRef determines if the aria-labelledby id points to a valid element
        return RPTUtil.attributeNonEmpty(element, "aria-label") || RPTUtil.attributeNonEmpty(element, "aria-labelledby");
    };
    // Return true if element has valid implicit label
    RPTUtil.hasImplicitLabel = function (element) {
        var parentNode = RPTUtil.getAncestor(element, "label");
        // Test  a) if the parent is a label which is the implicit label
        //       b) if the form element is the first child of the label
        //       c) if the form element requires an implicit or explicit label : "input",  "textarea", "select", "keygen", "progress", "meter", "output"
        // form elements that do not require implicit or explicit label element are:
        // "optgroup", "option", "datalist"(added later). These were handled differently in the main rule, might need to refactor the code later
        if (parentNode && parentNode.tagName.toLowerCase() === "label" && RPTUtil.isFirstFormElement(parentNode, element)) {
            var parentClone = parentNode.cloneNode(true);
            // exclude all form elements from the label since they might also have inner content
            parentClone = RPTUtil.removeAllFormElementsFromLabel(parentClone);
            return RPTUtil.hasInnerContentHidden(parentClone);
        }
        else {
            return false;
        }
    };
    RPTUtil.isFirstFormElement = function (parentNode, element) {
        var formElementsRequiringLabel = ["input", "textarea", "select", "keygen", "progress", "meter", "output"];
        if (parentNode.firstChild != null) {
            var nw = new NodeWalker(parentNode);
            while (nw.nextNode()) {
                if (formElementsRequiringLabel.indexOf(nw.node.nodeName.toLowerCase()) !== -1) {
                    return nw.node === element;
                }
            }
        }
        return false;
    };
    // check if the element is a shadow host or descendant of a shadow host, but not a descedant of the shadow root of the host (to be assigned to shadow slot or ignored)  
    RPTUtil.isShadowHostElement = function (element) {
        if (RPTUtil.isShadowElement(element))
            return false;
        var walkNode = element;
        while (walkNode) {
            if (walkNode.shadowRoot)
                return true;
            walkNode = DOMWalker_1.DOMWalker.parentElement(walkNode);
        }
        return false;
    };
    //check if an element is in a shadow tree
    RPTUtil.isShadowElement = function (element) {
        var root = element.getRootNode();
        if (root.toString() === "[object ShadowRoot]")
            return true;
        return false;
    };
    RPTUtil.removeAllFormElementsFromLabel = function (element) {
        var formElements = ["input", "textarea", "select", "button", "datalist", "optgroup", "option", "keygen", "output", "progress", "meter"];
        var childNodes = element.childNodes;
        for (var i = 0; i < childNodes.length; i++) {
            if (formElements.indexOf(childNodes[i].nodeName.toLowerCase()) > -1) {
                element.removeChild(childNodes[i]);
            }
        }
        return element;
    };
    // Given an array of elements, return true if the elements have unique ARIA labels
    RPTUtil.hasUniqueAriaLabelsLocally = function (elements, isGlobal) {
        if (elements.length === 0)
            return false;
        var doc = elements[0].ownerDocument;
        var hasDuplicateLabels = false;
        var uniqueAriaLabels = null;
        if (isGlobal) {
            uniqueAriaLabels = (0, CacheUtil_1.getCache)(doc, "RPTUtil_HAS_UNIQUE_ARIA_LABELS", null);
        }
        if (uniqueAriaLabels === null) {
            uniqueAriaLabels = {};
        }
        for (var i = 0; !hasDuplicateLabels && i < elements.length; ++i) {
            if (elements[i].hasAttribute) {
                if (elements[i].hasAttribute("aria-label")) {
                    var ariaLabel = RPTUtil.normalizeSpacing(elements[i].getAttribute("aria-label")).toLowerCase();
                    hasDuplicateLabels = ariaLabel in uniqueAriaLabels;
                    uniqueAriaLabels[ariaLabel] = true;
                }
                else if (elements[i].hasAttribute("aria-labelledby")) {
                    var labelID = elements[i].getAttribute("aria-labelledby");
                    var labelNode = fragment_1.FragmentUtil.getById(elements[i], labelID);
                    var label = labelNode ? RPTUtil.getInnerText(labelNode) : "";
                    var normalizedLabel = RPTUtil.normalizeSpacing(label).toLowerCase();
                    hasDuplicateLabels = normalizedLabel in uniqueAriaLabels;
                    uniqueAriaLabels[normalizedLabel] = true;
                }
                else {
                    // Has no label at all
                    hasDuplicateLabels = true;
                }
            }
        }
        if (isGlobal) {
            (0, CacheUtil_1.setCache)(doc, "RPTUtil_HAS_UNIQUE_ARIA_LABELS", uniqueAriaLabels);
        }
        return !hasDuplicateLabels;
    };
    RPTUtil.getAriaLabel = function (ele) {
        if (ele.hasAttribute) {
            if (ele.hasAttribute("aria-labelledby")) {
                var labelIDs = ele.getAttribute("aria-labelledby").trim().split(" ");
                var normalizedLabel = "";
                for (var j = 0, length_1 = labelIDs.length; j < length_1; ++j) {
                    var labelID = labelIDs[j];
                    var labelNode = fragment_1.FragmentUtil.getById(ele, labelID);
                    var label = labelNode ? RPTUtil.getInnerText(labelNode) : "";
                    normalizedLabel += RPTUtil.normalizeSpacing(label).toLowerCase();
                }
                return normalizedLabel.trim();
            }
            else if (ele.hasAttribute("aria-label")) {
                return RPTUtil.normalizeSpacing(ele.getAttribute("aria-label")).toLowerCase().trim();
            }
        }
        if (ele.nodeName.toLowerCase() === "input") {
            //const label = RPTUtil.getLabelForElement(ele);
            var label = RPTUtil.getLabelForElementHidden(ele, true);
            if (!label)
                return "";
            return (RPTUtil.getAriaLabel(label) || label.innerText || "").trim();
        }
        return "";
    };
    RPTUtil.findAriaLabelDupes = function (elements) {
        var dupeMap = {};
        elements.forEach(function (ele) {
            dupeMap[RPTUtil.getAriaLabel(ele)] = (dupeMap[RPTUtil.getAriaLabel(ele)] || 0) + 1;
        });
        return dupeMap;
    };
    // Given an array of elements, return true if the elements have unique ARIA labels globally
    RPTUtil.hasUniqueAriaLabels = function (elements) {
        return RPTUtil.hasUniqueAriaLabelsLocally(elements, true);
    };
    // Given an array of elements, return true if the elements have unique ARIA labels
    RPTUtil.hasDuplicateAriaLabelsLocally = function (elements, isGlobal) {
        if (elements.length === 0)
            return false;
        var doc = elements[0].ownerDocument;
        var hasDuplicateLabels = false;
        var uniqueAriaLabels = null;
        var duplicateLabelNameArray = new Array();
        if (isGlobal) {
            uniqueAriaLabels = (0, CacheUtil_1.getCache)(doc, "RPTUtil_HAS_UNIQUE_ARIA_LABELS", null);
        }
        if (uniqueAriaLabels === null) {
            uniqueAriaLabels = {};
        }
        for (var i = 0; i < elements.length; ++i) {
            if (elements[i].hasAttribute) {
                if (elements[i].hasAttribute("aria-label")) {
                    var ariaLabel = RPTUtil.normalizeSpacing(elements[i].getAttribute("aria-label")).toLowerCase();
                    hasDuplicateLabels = ariaLabel in uniqueAriaLabels;
                    uniqueAriaLabels[ariaLabel] = true;
                    if (!(ariaLabel in duplicateLabelNameArray)) {
                        duplicateLabelNameArray[ariaLabel] = new Array();
                    }
                    duplicateLabelNameArray[ariaLabel].push(elements[i].nodeName.toLowerCase());
                }
                else if (elements[i].hasAttribute("aria-labelledby")) {
                    var labelIDs = elements[i].getAttribute("aria-labelledby").trim().split(" ");
                    var normalizedLabel = "";
                    for (var j = 0, length_2 = labelIDs.length; j < length_2; ++j) {
                        var labelID = labelIDs[j];
                        var labelNode = fragment_1.FragmentUtil.getById(elements[i], labelID);
                        var label = labelNode ? RPTUtil.getInnerText(labelNode) : "";
                        normalizedLabel += RPTUtil.normalizeSpacing(label).toLowerCase();
                    }
                    hasDuplicateLabels = normalizedLabel in uniqueAriaLabels;
                    uniqueAriaLabels[normalizedLabel] = true;
                    if (!(normalizedLabel in duplicateLabelNameArray)) {
                        duplicateLabelNameArray[normalizedLabel] = new Array();
                    }
                    duplicateLabelNameArray[normalizedLabel].push(elements[i].nodeName.toLowerCase());
                }
            }
        }
        if (isGlobal) {
            (0, CacheUtil_1.setCache)(doc, "RPTUtil_HAS_UNIQUE_ARIA_LABELS", uniqueAriaLabels);
        }
        return duplicateLabelNameArray;
    };
    // Given an array of elements, return true if the elements have unique ARIA labels globally
    RPTUtil.hasDuplicateAriaLabels = function (elements) {
        return RPTUtil.hasDuplicateAriaLabelsLocally(elements, true);
    };
    // Given an array of elements, return true if the elements have unique aria-labelledby attributes
    RPTUtil.hasUniqueAriaLabelledby = function (elements) {
        var hasDuplicateLabels = false;
        var labelRefs = {};
        for (var i = 0; !hasDuplicateLabels && i < elements.length; ++i) {
            if (elements[i].hasAttribute && elements[i].hasAttribute("aria-labelledby")) {
                var labelRef = RPTUtil.normalizeSpacing(elements[i].getAttribute("aria-labelledby"));
                hasDuplicateLabels = labelRef in labelRefs;
                labelRefs[labelRef] = true;
            }
            else {
                hasDuplicateLabels = true;
            }
        }
        return !hasDuplicateLabels;
    };
    /* Determine the node depth of the given element */
    RPTUtil.nodeDepth = function (element) {
        var depth = 0;
        var walkNode = element;
        while (walkNode !== null) {
            walkNode = DOMWalker_1.DOMWalker.parentNode(walkNode);
            depth = depth + 1;
        }
        return depth;
    };
    /* compare node order of the 2 given nodes */
    /* returns
     *   0 if the nodes are equal
     *   1 if node b is before node a
     *  -1 if node a is before node b
     *   2 if node a is nested in node b
     *  -2 if node b is nested in node a
     *   null if either node is null or their parent nodes are not equal
     */
    RPTUtil.compareNodeOrder = function (nodeA, nodeB) {
        if (nodeA === nodeB)
            return 0;
        var aDepth = RPTUtil.nodeDepth(nodeA);
        var bDepth = RPTUtil.nodeDepth(nodeB);
        if (bDepth > aDepth) {
            for (var i = 0; i < bDepth - aDepth; ++i)
                nodeB = DOMWalker_1.DOMWalker.parentNode(nodeB);
            if (nodeA === nodeB) // Node B nested in Node A
                return -2;
        }
        else if (aDepth > bDepth) {
            for (var i = 0; i < aDepth - bDepth; ++i)
                nodeA = DOMWalker_1.DOMWalker.parentNode(nodeA);
            if (nodeA === nodeB) // Node A nested in Node B
                return 2;
        }
        while (nodeA != null && nodeB != null && DOMWalker_1.DOMWalker.parentNode(nodeA) != DOMWalker_1.DOMWalker.parentNode(nodeB)) {
            nodeA = DOMWalker_1.DOMWalker.parentNode(nodeA);
            nodeB = DOMWalker_1.DOMWalker.parentNode(nodeB);
        }
        if (nodeA === null || nodeB === null || DOMWalker_1.DOMWalker.parentNode(nodeA) != DOMWalker_1.DOMWalker.parentNode(nodeB))
            return null;
        while (nodeB != null && nodeB != nodeA)
            nodeB = nodeB.previousSibling;
        if (nodeB === null) // nodeB before nodeA
            return 1;
        else
            return -1;
    };
    /**
     *  Determine if the given attribute of the given element is not empty
     *  @memberOf RPTUtil
     */
    RPTUtil.attributeNonEmpty = function (element, attrStr) {
        return element.hasAttribute(attrStr) && element.getAttribute(attrStr).trim().length > 0;
    };
    /* Return a pointer to the given frame, null if not found */
    RPTUtil.getFrameByName = function (ruleContext, frameName) {
        var window = ruleContext.ownerDocument.defaultView;
        var frameList = [window];
        var idx = 0;
        while (idx < frameList.length) {
            try {
                if (frameList[idx].name === frameName)
                    return frameList[idx];
                for (var i = 0; i < frameList[idx].frames.length; ++i) {
                    try {
                        // Ensure it's a real frame and avoid recursion
                        if (frameList[idx].frames[i] && !frameList.includes(frameList[idx].frames[i])) {
                            frameList.push(frameList[idx].frames[i]);
                        }
                    }
                    catch (e) { }
                }
            }
            catch (e) { }
            ++idx;
        }
        return null;
    };
    RPTUtil.defaultNSResolver = function (prefix) {
        var uri;
        switch (prefix) {
            case 'html':
                uri = 'http://www.w3.org/1999/xhtml';
            case 'x2':
                uri = 'http://www.w3.org/TR/xhtml2';
            case 'x':
                uri = 'http://www.w3.org/1999/xhtml';
            case 'xhtml':
                uri = 'http://www.w3.org/1999/xhtml';
            default:
                uri = null;
        }
        return uri;
    };
    //checking if only the inner text is empty or not
    RPTUtil.isInnerTextOnlyEmpty = function (element) {
        // Get the innerText of the element
        var text = element.innerText;
        if (text === undefined && element.textContent !== undefined) {
            // In headless mode,  innerText is sometimes 'undefined'
            // so we try textContent as a workaround
            text = element.textContent;
        }
        var retVal = !(text !== null && text.trim().length > 0);
        if (element.nodeType === 1 && element.nodeName.toLowerCase() === "slot") {
            //TODO: need to conside its own content, a slot may have its own content or assigned content
            for (var _i = 0, _a = element.assignedNodes(); _i < _a.length; _i++) {
                var slotElem = _a[_i];
                retVal = retVal && RPTUtil.isInnerTextEmpty(slotElem);
            }
        }
        // Trim the inner text and verify that it is not empty.
        return retVal;
    };
    /* Return the inner text of the given element */
    RPTUtil.getInnerText = function (element) {
        var retVal = element.innerText;
        if (retVal === undefined || retVal.trim() === "")
            retVal = element.textContent;
        return retVal;
    };
    /** Return the text content of the given node
     *  this is different than innerText or textContent that return text content of a node and its descendants
    */
    RPTUtil.getNodeText = function (element) {
        if (!element)
            return "";
        var text = "";
        var childNodes = element.childNodes;
        for (var i = 0; i < childNodes.length; ++i) {
            if (childNodes[i].nodeType == 3) {
                text += childNodes[i].nodeValue;
            }
        }
        return text;
    };
    /**
     * This function is responsible for checking if elements inner text is empty or not.
     *
     * @parm {element} node The node which should be checked it has inner text or not.
     * @return {bool} true if element has empty inner text, false otherwise
     *
     * @memberOf RPTUtil
     */
    RPTUtil.isInnerTextEmpty = function (element) {
        // Get the innerText of the element
        var text = RPTUtil.getInnerText(element);
        // Trim the inner text and verify that it is not empty.
        return !(text != null && text.trim().length > 0);
    };
    RPTUtil.hasInnerContent = function (element) {
        var text = RPTUtil.getInnerText(element);
        var hasContent = (text != null && text.trim().length > 0);
        if (element.firstChild != null) {
            var nw = new NodeWalker(element);
            while (!hasContent && nw.nextNode()) {
                hasContent = (nw.node.nodeName.toLowerCase() === "img" &&
                    RPTUtil.attributeNonEmpty(nw.node, "alt"));
            }
        }
        return hasContent;
    };
    /**
     * This function is responsible for determine if an element has inner content.
     * This function also considers cases where inner text is hidden, which now will
     * be classified as does not have hidden content.
     *
     * @parm {element} node The node which should be checked it has inner text or not.
     * @return {bool} true if element has empty inner text, false otherwise
     *
     * @memberOf RPTUtil
     */
    RPTUtil.hasInnerContentHidden = function (element) {
        return RPTUtil.hasInnerContentHiddenHyperLink(element, false);
    };
    RPTUtil.svgHasName = function (element) {
        return RPTUtil.attributeNonEmpty(element, "aria-label")
            || RPTUtil.attributeNonEmpty(element, "aria-labelledby")
            || !!element.querySelector(":scope > title");
    };
    RPTUtil.hasInnerContentHiddenHyperLink = function (element, hyperlink_flag) {
        if (!element)
            return false;
        // Variable Decleration
        var childElement = element.firstElementChild;
        var hasContent = false;
        // In the case that the childElement is not null then we need to check each of the elements
        // to make sure that the elements are not all hidden.
        if (childElement != null) {
            // Get the nodewalter of the element node, so that we can loop over it and verify
            // that the elements under the element are not completly hidden.
            var nw = new NodeWalker(element);
            // Loop over all the nodes until there are no more nodes or we have determine that there is content under
            // this parent element.
            while (!hasContent && nw.nextNode() && nw.node != element) {
                // Get the next node
                var node = nw.node;
                // In the case an img element is present with alt then we can mark this as pass
                // otherwise keep checking all the other elements. Make sure that this image element is not hidden.
                hasContent = (node.nodeName.toLowerCase() === "img"
                    && (RPTUtil.attributeNonEmpty(node, "alt") || RPTUtil.attributeNonEmpty(node, "title"))
                    && VisUtil_1.VisUtil.isNodeVisible(node)) || (node.nodeName.toLowerCase() === "svg"
                    && RPTUtil.svgHasName(node));
                // Now we check if this node is of type element, visible
                if (!hasContent && node.nodeType === 1 && VisUtil_1.VisUtil.isNodeVisible(node)) {
                    // Check if the innerText of the element is empty or not
                    hasContent = !RPTUtil.isInnerTextOnlyEmpty(node);
                    if (!hasContent && hyperlink_flag === true) {
                        hasContent = RPTUtil.attributeNonEmpty(node, "aria-label") || RPTUtil.attributeNonEmpty(node, "aria-labelledby");
                        var doc = node.ownerDocument;
                        if (doc) {
                            var win = doc.defaultView;
                            if (win) {
                                var cStyle = win.getComputedStyle(node);
                                if (!hasContent && cStyle != null) {
                                    //                                       console.log(cStyle.backgroundImage);
                                    //                                       console.log(cStyle.content)
                                    hasContent = ((cStyle.backgroundImage && cStyle.backgroundImage.indexOf) || cStyle.content) && RPTUtil.attributeNonEmpty(node, "alt");
                                }
                            }
                        }
                    }
                }
                // Check for cases where there is text node after an element under the parent
                // In the case we detect nodetype as text node and the patent of the text node is
                // the same element we are checking has Inner content for then get the inner content of this
                // text node.
                if (node.nodeType === 3 && DOMWalker_1.DOMWalker.parentElement(node) === element) {
                    // Check if the innerText of the element is empty or not
                    hasContent = !RPTUtil.isInnerTextEmpty(node);
                }
            }
        }
        // In the case there are no child elements then we can simply perform the check for only innertext
        // the img with alt case will be covered in the above if, as img is considers as an element.
        else {
            // Check if the innerText of the element is empty or not
            hasContent = !RPTUtil.isInnerTextEmpty(element);
        }
        return hasContent;
    };
    RPTUtil.hasInnerContentOrAlt = function (element) {
        var text = RPTUtil.getInnerText(element);
        var hasContent = (text != null && text.trim().length > 0) || RPTUtil.attributeNonEmpty(element, "alt");
        if (element.firstChild != null) {
            var nw = new NodeWalker(element);
            while (!hasContent && nw.nextNode() && nw.node != element) {
                hasContent = (nw.node.nodeName.toLowerCase() === "img" &&
                    RPTUtil.attributeNonEmpty(nw.node, "alt"));
                if (!hasContent
                    && (RPTUtil.hasRole(nw.node, "button", true) || RPTUtil.hasRole(nw.node, "textbox"))
                    && (RPTUtil.hasAriaLabel(nw.node) || RPTUtil.attributeNonEmpty(nw.node, "title") || RPTUtil.getLabelForElementHidden(nw.elem(), true))) {
                    hasContent = true;
                }
            }
        }
        return hasContent;
    };
    RPTUtil.concatUniqueArrayItem = function (item, arr) {
        arr.indexOf(item) === -1 && item !== null ? arr.push(item) : false;
        return arr;
    };
    RPTUtil.concatUniqueArrayItemList = function (itemList, arr) {
        for (var i = 0; itemList !== null && i < itemList.length; i++) {
            arr = RPTUtil.concatUniqueArrayItem(itemList[i], arr);
        }
        return arr;
    };
    /**
     * remove array items from a given array
     * @param itemList items to be removed from arr
     * @param arr the array
     * @returns
     */
    RPTUtil.reduceArrayItemList = function (itemList, arr) {
        if (arr && arr.length > 0 && itemList && itemList.length > 0) {
            var result = arr.filter(function (value) {
                return !itemList.includes(value);
            });
            return result;
        }
        return arr;
    };
    /**
     * this function is responsible for resolving ARIA requirements for an HTML element per ARIA in HTML
     * @param ruleContext the HTML element to be examined
     * @returns
     */
    RPTUtil.getElementAriaProperty = function (ruleContext) {
        var tagProperty = (0, CacheUtil_1.getCache)(ruleContext, "RPTUtil_ElementAriaProperty", null);
        if (!tagProperty) {
            var tagName = null;
            var name_1 = null;
            if (ruleContext.tagName) {
                tagName = ruleContext.tagName.toLowerCase();
            }
            else if (ruleContext.nodeName) {
                tagName = ruleContext.nodeName.toLowerCase();
            }
            // check if the tagProperty exists in the documentConformanceRequirement hash.
            tagProperty = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirement[tagName];
            // The tag needs to check some special attributes
            if (tagProperty === null || tagProperty === undefined) {
                var specialTagProperties = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags[tagName];
                switch (tagName) { // special cases
                    case "a":
                        RPTUtil.attributeNonEmpty(ruleContext, "href") ? tagProperty = specialTagProperties["with-href"] : tagProperty = specialTagProperties["without-href"];
                        break;
                    case "area":
                        RPTUtil.attributeNonEmpty(ruleContext, "href") ? tagProperty = specialTagProperties["with-href"] : tagProperty = specialTagProperties["without-href"];
                        break;
                    case "figure": {
                        var fcs = RPTUtil.getChildByTag(ruleContext, "figcaption");
                        fcs !== null && fcs.length > 0 ? tagProperty = specialTagProperties["child-figcaption"] : tagProperty = specialTagProperties["no-child-figcaption"];
                        break;
                    }
                    case "footer":
                    case "header":
                        if (RPTUtil.getAncestorWithRole(ruleContext, "article", true) !== null || RPTUtil.getAncestorWithRole(ruleContext, "complementary", true) !== null
                            || RPTUtil.getAncestorWithRole(ruleContext, "navigation", true) !== null || RPTUtil.getAncestorWithRole(ruleContext, "region", true) !== null
                            || RPTUtil.getAncestor(ruleContext, ["article", "aside", "main", "nav", "section"]) !== null)
                            tagProperty = specialTagProperties["des-section-article-aside-main-nav"];
                        else
                            tagProperty = specialTagProperties["other"];
                        break;
                    case "img":
                        if (ruleContext.hasAttribute("alt")) {
                            ruleContext.getAttribute("alt").trim() === "" ? tagProperty = specialTagProperties["img-with-empty-alt"] : tagProperty = specialTagProperties["img-with-alt-text"];
                        }
                        else {
                            RPTUtil.hasAriaLabel(ruleContext) ? tagProperty = specialTagProperties["img-with-alt-text"] : tagProperty = specialTagProperties["img-without-alt"];
                        }
                        break;
                    case "input":
                        if (RPTUtil.attributeNonEmpty(ruleContext, "type")) {
                            var type = ruleContext.getAttribute("type").trim().toLowerCase();
                            tagProperty = specialTagProperties[type];
                            if (tagProperty === null || tagProperty === undefined) {
                                switch (type) {
                                    case "checkbox":
                                        RPTUtil.attributeNonEmpty(ruleContext, "aria-pressed") ? tagProperty = specialTagProperties["checkbox-with-aria-pressed"] : tagProperty = specialTagProperties["checkbox-without-aria-pressed"];
                                        break;
                                    case "email":
                                        RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["email-with-list"] : tagProperty = specialTagProperties["email-no-list"];
                                        break;
                                    case "search":
                                        RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["search-with-list"] : tagProperty = specialTagProperties["search-no-list"];
                                        break;
                                    case "tel":
                                        RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["tel-with-list"] : tagProperty = specialTagProperties["tel-no-list"];
                                        break;
                                    case "text":
                                        RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["text-with-list"] : tagProperty = specialTagProperties["text-no-list"];
                                        break;
                                    case "url":
                                        RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["url-with-list"] : tagProperty = specialTagProperties["url-no-list"];
                                        break;
                                    default:
                                        // default
                                        RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["default-with-list"] : tagProperty = specialTagProperties["default-no-list"];
                                        break;
                                }
                            }
                        }
                        else {
                            // default type is the same as type=text
                            RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["text-with-list"] : tagProperty = specialTagProperties["text-no-list"];
                        }
                        break;
                    case "li":
                        specialTagProperties = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags["li"];
                        if (ruleContext.parentElement && RPTUtil.hasRoleInSemantics(ruleContext.parentElement, "list"))
                            tagProperty = specialTagProperties["child-of-list-role"];
                        else
                            tagProperty = specialTagProperties["no-child-of-list-role"];
                        break;
                    case "section":
                        name_1 = ARIAMapper_1.ARIAMapper.computeName(ruleContext);
                        if (name_1 && name_1.trim().length > 0) {
                            tagProperty = specialTagProperties["with-name"];
                        }
                        else {
                            tagProperty = specialTagProperties["without-name"];
                        }
                        break;
                    case "select":
                        specialTagProperties = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags["select"];
                        if (ruleContext.hasAttribute("multiple") ||
                            RPTUtil.attributeNonEmpty(ruleContext, "size") && ruleContext.getAttribute("size") > 1)
                            tagProperty = specialTagProperties["multiple-attr-size-gt1"];
                        else
                            tagProperty = specialTagProperties["no-multiple-attr-size-gt1"];
                        break;
                    case "summary":
                        specialTagProperties = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags["summary"];
                        if (ruleContext.parentElement && ruleContext.parentElement.nodeName.toLowerCase() === 'details'
                            && DOMUtil_1.DOMUtil.sameNode(__spreadArray([], ruleContext.parentElement.children, true).filter(function (elem) { return elem.nodeName.toLowerCase() === 'summary'; })[0], ruleContext))
                            tagProperty = specialTagProperties["first-summary-of-detail"];
                        else
                            tagProperty = specialTagProperties["no-first-summary-of-detail"];
                        break;
                    case "tbody":
                    case "td":
                    case "tr":
                        if (RPTUtil.getAncestorWithRole(ruleContext, "table", true) !== null) {
                            tagProperty = specialTagProperties["des-table"];
                        }
                        else {
                            RPTUtil.getAncestorWithRole(ruleContext, "grid", true) || RPTUtil.getAncestorWithRole(ruleContext, "treegrid", true) ? tagProperty = specialTagProperties["des-grid"] : tagProperty = specialTagProperties["des-other"];
                        }
                        break;
                    case "th":
                        if (RPTUtil.getAncestorWithRole(ruleContext, "table", true) !== null || RPTUtil.getAncestorWithRole(ruleContext, "grid", true) !== null || RPTUtil.getAncestorWithRole(ruleContext, "treegrid", true) !== null) {
                            var scope = RPTUtil.getScopeForTh(ruleContext);
                            if (scope === 'column')
                                tagProperty = specialTagProperties["des-table-grid-treegrid-column-scope"];
                            else
                                tagProperty = specialTagProperties["des-table-grid-treegrid-row-scope"];
                        }
                        else {
                            tagProperty = specialTagProperties["des-other"];
                        }
                        break;
                    case "div":
                        var prt = ruleContext.parentElement;
                        prt !== null && prt.nodeName.toLowerCase() === 'dl' ? tagProperty = specialTagProperties["child-dl"] : tagProperty = specialTagProperties["no-child-dl"];
                        break;
                    default:
                        tagProperty = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags["default"];
                } //switch
            }
        }
        (0, CacheUtil_1.setCache)(ruleContext, "RPTUtil_ElementAriaProperty", tagProperty);
        return tagProperty || null;
    };
    RPTUtil.getScopeForTh = function (element) {
        /** https://www.w3.org/TR/html5/tabular-data.html#header-and-data-cell-semantics
         * A header cell anchored at the slot with coordinate (x, y) with width width and height height is
         * said to be a column header if any of the following conditions are true:
         * * The cell's scope attribute is in the column state, or
         * * The cell's scope attribute is in the auto state, and there are no data cells in any of
         *   the cells covering slots with y-coordinates y .. y+height-1.
         * A header cell anchored at the slot with coordinate (x, y) with width width and height height is
         * said to be a row header if any of the following conditions are true:
         * * The cell's scope attribute is in the row state, or
         * * The cell's scope attribute is in the auto state, the cell is not a column header, and there are
         *   no data cells in any of the cells covering slots with x-coordinates x .. x+width-1.
         */
        // Note: auto is default scope
        // Easiest answer is if scope is specified
        if (element.hasAttribute("scope")) {
            var scope = element.getAttribute("scope").toLowerCase();
            if (scope === "row" || scope === 'rowgroup')
                return "row";
            if (scope === "col" || scope === 'colgroup')
                return "column";
        }
        // scope is auto, default (without a scope) or invalid value.
        // if all the sibling elements are th, then return "columnheader" 
        var siblings = function (element) { return __spreadArray([], element.parentElement.children, true).filter(function (node) { return node.nodeType === 1 && node.tagName != "TH"; }); };
        if (siblings === null || siblings.length === 0)
            return "column";
        else
            return "row";
    };
    RPTUtil.getAllowedAriaRoles = function (ruleContext, properties) {
        var allowedRoles = (0, CacheUtil_1.getCache)(ruleContext, "RPTUtil_AllowedAriaRoles", null);
        if (!allowedRoles) {
            allowedRoles = [];
            var tagProperty = null;
            if (properties !== null && properties !== undefined) {
                tagProperty = properties;
            }
            else {
                tagProperty = RPTUtil.getElementAriaProperty(ruleContext);
            }
            if (tagProperty !== null && tagProperty !== undefined) {
                if (tagProperty.implicitRole !== null) {
                    RPTUtil.concatUniqueArrayItemList(tagProperty.implicitRole, allowedRoles);
                }
                if (tagProperty.validRoles !== null) {
                    RPTUtil.concatUniqueArrayItemList(tagProperty.validRoles, allowedRoles);
                }
                var implicitRoles = RPTUtil.getImplicitRole(ruleContext);
                if (implicitRoles && implicitRoles.length > 0) {
                    RPTUtil.concatUniqueArrayItemList(tagProperty.validRoles, allowedRoles);
                }
            }
            (0, CacheUtil_1.setCache)(ruleContext, "RPTUtil_AllowedAriaRoles", allowedRoles);
        }
        return allowedRoles;
    };
    RPTUtil.getAllowedAriaAttributes = function (ruleContext, roles, properties) {
        var allowedAttributes = (0, CacheUtil_1.getCache)(ruleContext, "RPTUtil_AllowedAriaAttributes", null);
        if (!allowedAttributes) {
            allowedAttributes = [];
            var permittedRoles = __spreadArray([], roles, true);
            var tagName = ruleContext.tagName.toLowerCase();
            var prohibitedAttributes = [];
            // Element with a disabled attribute  https://www.w3.org/TR/html5/disabled-elements.html
            if (ARIADefinitions_1.ARIADefinitions.elementsAllowedDisabled.indexOf(tagName) > -1) {
                // Use the aria-disabled attribute on any element that is allowed the disabled attribute in HTML5.
                allowedAttributes = RPTUtil.concatUniqueArrayItem("aria-disabled", allowedAttributes);
            }
            // Element with a required attribute http://www.the-art-of-web.com/html/html5-form-validation/
            if (ARIADefinitions_1.ARIADefinitions.elementsAllowedRequired.indexOf(tagName) > -1) {
                // Use the aria-required attribute on any element that is allowed the required attribute in HTML5.
                allowedAttributes = RPTUtil.concatUniqueArrayItem("aria-required", allowedAttributes);
            }
            if (ARIADefinitions_1.ARIADefinitions.elementsAllowedReadOnly.indexOf(tagName) > -1) {
                // Use the aria-readonly attribute on any element that is allowed the readonly attribute in HTML5.
                allowedAttributes = RPTUtil.concatUniqueArrayItem("aria-readonly", allowedAttributes);
            }
            var tagProperty = null;
            if (properties != null && properties !== undefined)
                tagProperty = properties;
            else
                tagProperty = RPTUtil.getElementAriaProperty(ruleContext);
            if (tagProperty !== null && tagProperty !== undefined) {
                // add the implicit role allowed attributes to the allowed role list if there is no specified role
                // ignore if the element doesn't allow the attributes from the implicit roles
                if (tagProperty.implicitRole !== null &&
                    (permittedRoles === null || permittedRoles === undefined || permittedRoles.length === 0)
                    && tagProperty.allowAttributesFromImplicitRole === undefined) {
                    for (var i = 0; i < tagProperty.implicitRole.length; i++) {
                        var roleProperty = ARIADefinitions_1.ARIADefinitions.designPatterns[tagProperty.implicitRole[i]];
                        if (roleProperty !== null && roleProperty !== undefined) {
                            var properties_1 = roleProperty.props;
                            RPTUtil.concatUniqueArrayItemList(properties_1, allowedAttributes);
                            properties_1 = RPTUtil.getRoleRequiredProperties(tagProperty.implicitRole[i], ruleContext);
                            RPTUtil.concatUniqueArrayItemList(properties_1, allowedAttributes);
                            var prohibitedProps = roleProperty.prohibitedProps;
                            if (prohibitedProps && prohibitedProps.length > 0)
                                RPTUtil.concatUniqueArrayItemList(prohibitedProps, prohibitedAttributes);
                            // special case of separator
                            if (tagProperty.implicitRole[i] === "separator" && RPTUtil.isFocusable(ruleContext)) {
                                RPTUtil.concatUniqueArrayItemList(["aria-disabled", "aria-valuenow", "aria-valuemax", "aria-valuemin", "aria-valuetext"], allowedAttributes);
                            }
                        }
                    }
                }
                // Adding the global properties to the valid attribute list
                if (tagProperty.globalAriaAttributesValid) {
                    var properties_2 = ARIADefinitions_1.ARIADefinitions.globalProperties; // global properties
                    RPTUtil.concatUniqueArrayItemList(properties_2, allowedAttributes);
                }
            }
            // adding the other role to the allowed roles for the attributes
            if (tagProperty && tagProperty.otherRolesForAttributes && tagProperty.otherRolesForAttributes.length > 0)
                RPTUtil.concatUniqueArrayItemList(tagProperty.otherRolesForAttributes, permittedRoles);
            // adding the specified role properties to the allowed attribute list
            for (var i = 0; permittedRoles !== null && i < permittedRoles.length; i++) {
                var roleProperties = ARIADefinitions_1.ARIADefinitions.designPatterns[permittedRoles[i]];
                if (roleProperties !== null && roleProperties !== undefined) {
                    // ignore the properties if the element doesn't allow attributes from the implicit role
                    if (!tagProperty || tagProperty.implicitRole === null || !tagProperty.implicitRole.includes(permittedRoles[i]) || (tagProperty.implicitRole.includes(permittedRoles[i]) && tagProperty.allowAttributesFromImplicitRole === undefined)) {
                        var properties_3 = roleProperties.props; // allowed properties
                        RPTUtil.concatUniqueArrayItemList(properties_3, allowedAttributes);
                        properties_3 = RPTUtil.getRoleRequiredProperties(permittedRoles[i], ruleContext); // required properties
                        RPTUtil.concatUniqueArrayItemList(properties_3, allowedAttributes);
                    }
                    var prohibitedProps = roleProperties.prohibitedProps;
                    if (prohibitedProps && prohibitedProps.length > 0)
                        RPTUtil.concatUniqueArrayItemList(prohibitedProps, prohibitedAttributes);
                    // special case for separator
                    if (permittedRoles[i] === "separator" && RPTUtil.isFocusable(ruleContext)) {
                        RPTUtil.concatUniqueArrayItemList(["aria-disabled", "aria-valuemax", "aria-valuemin", "aria-valuetext"], allowedAttributes);
                    }
                }
            }
            // ignore aria-level, aria-setsize or aria-posinset if "row" is not in treegrid
            if (permittedRoles.includes("row") && RPTUtil.getAncestorWithRole(ruleContext, "treegrid", true) == null) {
                var index = -1;
                if ((index = allowedAttributes.indexOf("aria-level")) > -1)
                    allowedAttributes.splice(index, 1);
                if ((index = allowedAttributes.indexOf("aria-setsize")) > -1)
                    allowedAttributes.splice(index, 1);
                if ((index = allowedAttributes.indexOf("aria-posinset")) > -1)
                    allowedAttributes.splice(index, 1);
            }
            // add the other allowed attributes for the element
            if (tagProperty && tagProperty.otherAllowedAriaAttributes && tagProperty.otherAllowedAriaAttributes.length > 0) {
                // check attribute-value pair if exists
                var allowed = [];
                for (var p = 0; p < tagProperty.otherAllowedAriaAttributes.length; p++) {
                    var attr = tagProperty.otherAllowedAriaAttributes[p];
                    if (attr.includes("=")) {
                        var pair = attr.split("=");
                        if (ruleContext.getAttribute(pair[0]) === pair[1])
                            allowed.push(pair[0]);
                    }
                    else
                        allowed.push(attr);
                }
                if (allowed.length > 0)
                    RPTUtil.concatUniqueArrayItemList(allowed, allowedAttributes);
            }
            // add the other prohibitted attributes for the element
            if (tagProperty && tagProperty.otherDisallowedAriaAttributes && tagProperty.otherDisallowedAriaAttributes.length > 0) {
                // check attribute-value pair if exists
                var disallowed = [];
                for (var p = 0; p < tagProperty.otherDisallowedAriaAttributes.length; p++) {
                    var attr = tagProperty.otherDisallowedAriaAttributes[p];
                    if (attr.includes("=")) {
                        var pair = attr.split("=");
                        if (ruleContext.getAttribute(pair[0]) === pair[1])
                            disallowed.push(pair[0]);
                    }
                    else
                        disallowed.push(attr);
                }
                if (disallowed.length > 0)
                    RPTUtil.concatUniqueArrayItemList(disallowed, prohibitedAttributes);
            }
            //exclude the prohibitedAttributes from the allowedAttributes
            allowedAttributes = RPTUtil.reduceArrayItemList(prohibitedAttributes, allowedAttributes);
            (0, CacheUtil_1.setCache)(ruleContext, "RPTUtil_AllowedAriaAttributes", allowedAttributes);
        }
        return allowedAttributes;
    };
    /**
     *
     * @param ariaAttr
     * @param htmlAttrs
     * @type: conflict or overlapping
     * @returns htmlAttrName, 'Pass' or null
     *         htmlAttrName that conflicts with the ariaAttr,
     *         'Pass' with no conflict with the ariaAttr,
     *         or null where ariaAttr won't cause conflict
     */
    RPTUtil.getConflictOrOverlappingHtmlAttribute = function (ariaAttr, htmlAttrs, type) {
        var exist = ARIADefinitions_1.ARIADefinitions.relatedAriaHtmlAttributes[ariaAttr['name']];
        if (exist) {
            var examinedHtmlAtrNames = [];
            var ariaAttrValue = '';
            if (type === 'conflict') {
                if (!exist.conflict)
                    return null;
                ariaAttrValue = exist.conflict.ariaAttributeValue;
            }
            else if (type === 'overlapping') {
                if (!exist.overlapping)
                    return null;
                ariaAttrValue = exist.overlapping.ariaAttributeValue;
            }
            else
                return null;
            if (ariaAttrValue === null || ariaAttrValue === 'VALUE' || ariaAttrValue === ariaAttr['value']) {
                var htmlAttrNames = [];
                var htmlAttrValues = [];
                if (type === 'conflict') {
                    htmlAttrNames = exist.conflict.htmlAttributeNames;
                    htmlAttrValues = exist.conflict.htmlAttributeValues;
                }
                else {
                    htmlAttrNames = exist.overlapping.htmlAttributeNames;
                    htmlAttrValues = exist.overlapping.htmlAttributeValues;
                }
                for (var i = 0; i < htmlAttrs.length; i++) {
                    var index = htmlAttrNames.indexOf(htmlAttrs[i]['name']);
                    if (index !== -1) {
                        if (htmlAttrValues === null
                            || (ariaAttrValue === 'VALUE' && htmlAttrValues[index] === 'VALUE' && htmlAttrs[i]['value'] !== ariaAttr['value'])
                            || htmlAttrs[i]['value'] === htmlAttrValues[index]) {
                            examinedHtmlAtrNames.push({ result: 'Failed', 'attr': htmlAttrs[i]['name'] });
                            continue;
                        }
                        else
                            examinedHtmlAtrNames.push({ result: 'Pass', 'attr': htmlAttrs[i]['name'] });
                    }
                }
            }
            return examinedHtmlAtrNames;
        }
        else
            return null;
    };
    RPTUtil.containsPresentationalChildrenOnly = function (elem) {
        var roles = RPTUtil.getRoles(elem, false);
        // if explicit role doesn't exist, get the implicit one
        if (!roles || roles.length === 0)
            roles = RPTUtil.getImplicitRole(elem);
        //ignore if the element doesn't have any explicit or implicit role, shouldn't happen
        if (!roles || roles.length === 0)
            return false;
        for (var i = 0; roles !== null && i < roles.length; i++) {
            var roleProperties = ARIADefinitions_1.ARIADefinitions.designPatterns[roles[i]];
            if (roleProperties !== null && roleProperties !== undefined) {
                var presentional = roleProperties.presentationalChildren;
                if (presentional === true)
                    return true;
            }
        }
        return false;
    };
    RPTUtil.shouldBePresentationalChild = function (element) {
        var walkNode = DOMWalker_1.DOMWalker.parentElement(element);
        while (walkNode) {
            if (RPTUtil.containsPresentationalChildrenOnly(walkNode))
                return true;
            //aria-own case: if the element is referred by an aria-won
            walkNode = ARIAMapper_1.ARIAMapper.getAriaOwnedBy(walkNode) || DOMWalker_1.DOMWalker.parentElement(walkNode);
        }
        return false;
    };
    /** moved to CSSUtil
    public static CSS(element) {
        let styleText = "";
        if (element === null) return [];
        if (element.IBM_CSS_THB) return element.IBM_CSS_THB;
        let nodeName = element.nodeName.toLowerCase();
        if (nodeName === "style") {
            styleText = RPTUtil.getInnerText(element);
        } else if (element.hasAttribute("style")) {
            styleText = element.getAttribute("style");
        } else return [];
        if (styleText === null || styleText.trim().length === 0) return [];
        //remove comment blocks
        let re = /(\/\*+(?:(?:(?:[^\*])+)|(?:[\*]+(?!\/)))[*]+\/)|\/\/.* /g;
        let subst = ' ';
        styleText = styleText.replace(re, subst);
        // Find all "key : val;" pairs with various whitespace inbetween
        let rKeyVals = /\s*([^:\s]+)\s*:\s*([^;$}]+)\s*(;|$)/g;
        // Find all "selector { csskeyvals } with various whitespace inbetween
        let rSelectors = /\s*([^{]*){([^}]*)}/g;
        if (styleText.indexOf("{") === -1) {

            let keyVals = {};
            let m;
            while ((m = rKeyVals.exec(styleText)) != null) {
                keyVals[m[1]] = m[2].trim().toLowerCase();
            }
            let retVal = [{
                selector: null,
                values: keyVals
            }];
            element.IBM_CSS_THB = retVal;
            return retVal;
        } else {
            let retVal = [];
            let m;
            let m2;
            while ((m = rSelectors.exec(styleText)) != null) {
                let keyVals = {}
                let selKey = m[1];
                let selVal = m[2];

                while ((m2 = rKeyVals.exec(selVal)) != null) {
                    keyVals[m2[1]] = m2[2].trim().toLowerCase();
                }
                retVal.push({
                    selector: selKey,
                    values: keyVals
                });
            }
            element.IBM_CSS_THB = retVal;
            return retVal;
        }
    }
    */
    RPTUtil.getControlOfLabel = function (node) {
        // Handle the easy case of label -> for
        var labelAncestor = RPTUtil.getAncestor(node, "label");
        if (labelAncestor) {
            if (labelAncestor.hasAttribute("for")) {
                return fragment_1.FragmentUtil.getById(node, labelAncestor.getAttribute("for"));
            }
        }
        // Create a dictionary containing ids of parent nodes
        var idDict = {};
        var parentWalk = node;
        while (parentWalk) {
            if (parentWalk.nodeType === 1 /* Node.ELEMENT_NODE */) {
                var ancestor = parentWalk;
                if (ancestor.hasAttribute("id")) {
                    idDict[ancestor.getAttribute("id")] = true;
                }
            }
            parentWalk = DOMWalker_1.DOMWalker.parentNode(parentWalk);
        }
        // Iterate through controls that use aria-labelledby and see if any of them reference one of my ancestor ids
        var inputsUsingLabelledBy = node.ownerDocument.querySelectorAll("*[aria-labelledby]");
        for (var idx = 0; idx < inputsUsingLabelledBy.length; ++idx) {
            var inputUsingLabelledBy = inputsUsingLabelledBy[idx];
            var ariaLabelledBy = inputUsingLabelledBy.getAttribute("aria-labelledby");
            var sp = ariaLabelledBy.split(" ");
            for (var _i = 0, sp_1 = sp; _i < sp_1.length; _i++) {
                var id = sp_1[_i];
                if (id in idDict) {
                    return inputUsingLabelledBy;
                }
            }
        }
        // Find the cases where we're within an aria labelledby
        return null;
    };
    /**
     * This function is responsible for checking if the node that is provied is
     * disabled or not. Following is how the check is performed:
     *    1. Check if the current node is disabled with the following options:
     *       attribute --> disabled
     *         Also needs to be "button", "input", "select", "textarea", "optgroup", "option",
     *         "menuitem", "fieldset" nodes (in array elementsAllowedDisabled)
     *       attribute --> aria-disabled="true"
     *    2. Check if any of the current nodes parents are disabled with the same
     *       options listed in 1.
     *
     *    Note: If either current node or any of the parent nodes are disabled then this
     *          function will return true (node is disabled).
     *
     * @parm {HTMLElement} node - The node which should be checked if it is disabled or not.
     * @return {bool} true if the node is disabled, false otherwise
     *
     * @memberOf RPTUtil
     */
    RPTUtil.isNodeDisabled = function (node) {
        // Set PT_NODE_DISABLED to false for all the nodes, before the check and this will be changed to
        // true when we detect that the node is disabled. We have to set it to false so that we know
        // the node has already been checked. Only set it to false if the setting is undefined or null
        // as if it is defined we do not wnat to reset it. As if it is true then we should make use of it
        // to speed up the check.
        var PT_NODE_DISABLED = (0, CacheUtil_1.getCache)(node, "PT_NODE_DISABLED", false);
        // Check the nodeType of this node, if this node is a text node then
        // we get the parentnode and set that as the node as a text nodes,
        // disabled is directly related to the parent node.
        if (node.nodeType === 3) {
            node = DOMWalker_1.DOMWalker.parentNode(node);
        }
        // Variable Declaration
        var nodeName = node.nodeName.toLowerCase();
        // Get the disabled element property, disabled and aria-disabled attribute and check that it is true
        var disabledAttribute = node.hasAttribute("disabled");
        var disabledPropertyCustom = PT_NODE_DISABLED;
        var ariaDisabledAttribute = node.hasAttribute('aria-disabled') && node.getAttribute("aria-disabled") === 'true';
        // If this node has disabled attribute and the node allows disabled attribute, then return true.
        // Disabled attribute is only allowed on "button", "input", "select", "textarea", "optgroup", "option", "menuitem", "fieldset"
        // In the case aria-disabled is set to true, then also return true
        if (disabledPropertyCustom || (disabledAttribute && ARIADefinitions_1.ARIADefinitions.elementsAllowedDisabled.indexOf(nodeName) > -1) || ariaDisabledAttribute) {
            PT_NODE_DISABLED = true;
            (0, CacheUtil_1.setCache)(node, "PT_NODE_DISABLED", PT_NODE_DISABLED);
            return true;
        }
        // Get the parentNode for this node, becuase we have to check all parents to make sure they do not have
        // disabled attribute. Only keep checking until we are all the way back to the parentNode
        // element.
        var parentElement = DOMWalker_1.DOMWalker.parentNode(node);
        // If the parent node exists and the nodetype is element (1), then run recursive call to perform the check
        // all the way up to the very parent node. Use recursive call here instead of a while loop so that we do not
        // have to duplicate the logic for checking if the node is disabled or not for all the parents starting with
        // child node.
        if (parentElement != null && parentElement.nodeType === 1) {
            // Check upwards recursively, and save the results in an variable
            var nodeDisabled = RPTUtil.isNodeDisabled(parentElement);
            // If the node is found to be disabled then add the custom PT_NODE_DISABLED to true.
            // so that we can use this next time, to quickly determine if node is disabled or not.
            // This is extra percaution, the isNodeDisabled function already sets this.
            if (nodeDisabled) {
                PT_NODE_DISABLED = true;
            }
            // Check upwards recursively
            (0, CacheUtil_1.setCache)(node, "PT_NODE_DISABLED", PT_NODE_DISABLED);
            return nodeDisabled;
        }
        // Return false (node is not disabled)
        return false;
    };
    /**
     * This function is responsible for determine if hidden content should be checked
     * in rules.
     *
     * @parm {element} node - A node so that the document can be accessed to check for the
     *                        option. Can be document element or a simple node element.
     * @return {bool} true if hidden content should be checked, false otherwise
     *
     * @memberOf RPTUtil
     */
    RPTUtil.shouldCheckHiddenContent = function (node) {
        return false;
    };
    /**
     * This function is responsible for determining if node should be skipped from checking or not, based
     * on the Check Hidden Content settings and if the node is visible or not.
     *
     * @parm {element} node - Node to check if it is visible or not based on the Check Hidden Content
     *                        setting.
     *
     * @return {bool} true if node should be skipped, false otherwise
     *
     * @memberOf RPTUtil
     */
    RPTUtil.shouldNodeBeSkippedHidden = function (node) {
        // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
        // or not.
        //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
        //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we
        //     return true to identify that the node should not be scanned/added to any hash/array.
        //
        // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
        //       so on and so forth.
        if (!RPTUtil.shouldCheckHiddenContent(node) && !VisUtil_1.VisUtil.isNodeVisible(node)) {
            return true;
        }
        return false;
    };
    RPTUtil.isfocusableByDefault = function (node) {
        var focusableElements = ['input', 'select', 'button', 'textarea', 'option', 'area'];
        if (node.nodeName.toLowerCase() === "a" && RPTUtil.hasAttribute(node, 'href'))
            return true;
        if (node.nodeName.toLowerCase() === "area" && RPTUtil.hasAttribute(node, 'href'))
            return true;
        if (focusableElements.indexOf(node.nodeName.toLowerCase()) != -1)
            return true;
        return false;
    };
    /**
     * This function check if a non-tabable node has valid tabable content.
     * If it is tabable (the tabindex is not speicified or is not -1), returns false;
     * If it is non-tabable, but a child is tabable and does not have element content, returns false;
     * Otherwise, returns true.
     */
    RPTUtil.nonTabableChildCheck = function (element) {
        if (!element.hasAttribute("tabindex") ||
            (parseInt(element.getAttribute("tabindex")) != -1)) {
            return false;
        }
        var nw = new NodeWalker(element);
        while (nw.nextNode()) {
            var child = nw.elem();
            if (child === null) { // Text node. usually is a cartridge return.
                continue;
            }
            if (child.hasAttribute("tabindex") &&
                (parseInt(child.getAttribute("tabindex")) != -1) &&
                !RPTUtil.hasInnerContent(child)) {
                return false;
            }
        }
        return true;
    };
    RPTUtil.hasAttribute = function (element, attributeName) {
        var hasAttribute = false;
        if (element.hasAttribute) {
            hasAttribute = element.hasAttribute(attributeName);
        }
        else if (element.attributes && element.attributes.getNamedItem) {
            var attr = element.attributes.getNamedItem(attributeName);
            hasAttribute = attr && attr.specified;
        }
        return hasAttribute;
    };
    // This list contains a list of elements tags which have display: none by default, since we have rules triggering
    RPTUtil.navLinkKeywords = ['start', 'next', 'prev', 'previous', 'contents', 'index'];
    // This list contains a list of rule ids for the rules that have to check for hidden content regardless of the Check Hidden
    // Content Setting. This means that when the engine is actually determine which elements to mass to the rules, it will always
    // pass theses rules no matter what the Check Hidden Content Setting is.
    RPTUtil.rulesThatHaveToCheckHidden = ['RPT_Elem_UniqueId'];
    // https://www.w3.org/TR/wai-aria-1.1/#introstates
    RPTUtil.ariaAttributeRoleDefaults = {
        "alert": {
            "aria-live": "assertive",
            "aria-atomic": "true"
        },
        "combobox": {
            "aria-haspopup": "listbox"
        },
        "listbox": {
            "aria-orientation": "vertical"
        },
        "log": {
            "aria-live": "polite"
        },
        "menu": {
            "aria-orientation": "vertical"
        },
        "menubar": {
            "aria-orientation": "horizontal"
        },
        "meter": {
            "aria-valuemin": "0",
            "aria-valuemax": "100"
        },
        "option": {
            "aria-selected": "false"
        },
        "progressbar": {
            "aria-valuemin": "0",
            "aria-valuemax": "100"
        },
        "scrollbar": {
            "aria-orientation": "vertical",
            "aria-valuemin": "0",
            "aria-valuemax": "100"
        },
        "separator": {
            "aria-orientation": "horizontal",
            "aria-valuemin": "0",
            "aria-valuemax": "100"
        },
        "slider": {
            "aria-orientation": "horizontal",
            "aria-valuemin": "0",
            "aria-valuemax": "100"
        },
        "spinbutton": {
        // Not sure how to encode min/max (or now in 1.2 - "has no value")
        //"aria-valuenow": "0" TODO: at risk: maybe delete after ARIA 1.2 reaches proposed rec
        // Probably just delete spinbutton from this list completely and let user agents handle "defaults"
        },
        "status": {
            "aria-live": "polite",
            "aria-atomic": "true"
        },
        "tab": {
            "aria-selected": "false"
        },
        "tablist": {
            "aria-orientation": "horizontal"
        },
        "toolbar": {
            "aria-orientation": "horizontal"
        },
        "tree": {
            "aria-orientation": "vertical"
        }
    };
    // https://www.w3.org/TR/wai-aria-1.1/#aria-atomic
    RPTUtil.ariaAttributeGlobalDefaults = {
        "aria-atomic": "false",
        "aria-autocomplete": "none",
        "aria-busy": "false",
        "aria-checked": undefined,
        "aria-current": "false",
        "aria-disabled": "false",
        "aria-dropeffect": "none",
        "aria-expanded": undefined,
        "aria-grabbed": undefined,
        "aria-haspopup": "false",
        "aria-hidden": undefined,
        "aria-invalid": "false",
        "aria-live": "off",
        "aria-modal": "false",
        "aria-multiline": "false",
        "aria-multiselectable": "false",
        "aria-orientation": undefined,
        "aria-pressed": undefined,
        "aria-readonly": "false",
        //"aria-relevant": "additions text", TODO: are multiple values supported?
        "aria-required": "false",
        "aria-selected": undefined,
        "aria-sort": "none"
    };
    // https://www.w3.org/TR/html-aam-1.0/#html-attribute-state-and-property-mappings
    RPTUtil.ariaAttributeImplicitMappings = {
        "aria-autocomplete": {
            "form": function (e) {
                return "off" === e.getAttribute("autocomplete") ? "none" : "both";
            },
            "input": function (e) {
                return "off" === e.getAttribute("autocomplete") ? "none" : "both";
            },
            "select": function (e) {
                return "off" === e.getAttribute("autocomplete") ? "none" : "both";
            },
            "textarea": function (e) {
                return "off" === e.getAttribute("autocomplete") ? "none" : "both";
            }
        },
        "aria-checked": {
            "input": function (e) {
                if (e.hasAttribute("indeterminate"))
                    return "mixed";
                return "" + e.hasAttribute("checked");
            },
            "menuitem": function (e) {
                if (e.hasAttribute("indeterminate"))
                    return "mixed";
                return "" + e.hasAttribute("checked");
            },
            "*": function (e) {
                if (e.hasAttribute("indeterminate"))
                    return "mixed";
            },
        },
        "aria-disabled": {
            "button": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "fieldset": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "input": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "optgroup": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "option": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "select": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "textarea": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            }
        },
        "aria-expanded": {
            "details": function (e) {
                return e.getAttribute("open");
            },
            "dialog": function (e) {
                return e.getAttribute("open");
            }
        },
        "aria-multiselectable": {
            "select": function (e) {
                if (e.hasAttribute("multiple"))
                    return "true";
                return;
            }
        },
        "aria-placeholder": {
            "input": function (e) {
                return e.getAttribute("placeholder");
            },
            "textarea": function (e) {
                return e.getAttribute("placeholder");
            }
        },
        "aria-required": {
            "input": function (e) {
                return e.getAttribute("required");
            },
            "select": function (e) {
                return e.getAttribute("required");
            },
            "textarea": function (e) {
                return e.getAttribute("required");
            }
        }
    };
    RPTUtil.tabTagMap = {
        "button": function (element) {
            return !element.hasAttribute("disabled");
        },
        "iframe": true,
        "input": function (element) {
            return element.getAttribute("type") !== "hidden" && !element.hasAttribute("disabled");
        },
        "select": function (element) {
            return !element.hasAttribute("disabled");
        },
        "textarea": true,
        "div": function (element) {
            return element.hasAttribute("contenteditable");
        },
        "a": function (element) {
            // xlink:href?? see svg
            return element.hasAttribute("href");
        },
        "area": function (element) {
            return element.hasAttribute("href");
        },
        "audio": function (element) {
            return element.hasAttribute("controls");
        },
        "video": function (element) {
            return element.hasAttribute("controls");
        },
        "summary": function (element) {
            // first summary child of a details element is automatically focusable 
            return element.parentElement && element.parentElement.nodeName.toLowerCase() === 'details'
                && DOMUtil_1.DOMUtil.sameNode(__spreadArray([], element.parentElement.children, true).filter(function (elem) { return elem.nodeName.toLowerCase() === 'summary'; })[0], element);
        },
        "details": function (element) {
            //details element without a direct summary child is automatically focusable
            return element.children && __spreadArray([], element.children, true).filter(function (elem) { return elem.nodeName.toLowerCase() === 'summary'; }).length === 0;
        }
    };
    return RPTUtil;
}());
exports.RPTUtil = RPTUtil;
/** moved to CSSUtil
export class RPTUtilStyle {
    public static getWeightNumber(styleVal) {
        let map = {
            "light": 100,
            "bold": 700
        };
        let retVal = parseInt(styleVal);
        if (retVal) return retVal;
        if (styleVal in map)
            return map[styleVal];
        return 400;
    }

    public static getFontInPixels = function (styleVal) {
        let map = {
            "xx-small": 16,
            "x-small": 10,
            "small": 13,
            "medium": 16,
            "large": 18,
            "x-large": 24,
            "xx-large": 32
        };
        let value = parseFloat(styleVal);
        if (!value) {
            return map[styleVal];
        }
        let units = styleVal.substring(("" + value).length);
        if (units === "" || units === "px") return value;
        if (units === "em") return value * 16;
        if (units === "%") return value / 100 * 16;
        if (units === "pt") return value * 4 / 3;
        return Math.round(value);
    }
}
*/
/* Return a node walker for the given element.
 * bEnd is optional and defaults to false
 * but if true, indicates the node is the end node*/
var NodeWalker = /** @class */ (function () {
    function NodeWalker(node, bEnd) {
        this.node = node;
        this.bEndTag = (bEnd === undefined ? false : bEnd === true);
    }
    NodeWalker.prototype.elem = function () {
        return this.node.nodeType === 1 && this.node || null;
    };
    NodeWalker.prototype.nextNode = function () {
        if (!this.node) {
            this.bEndTag = false;
            return false;
        }
        if (!this.bEndTag) {
            var iframeNode = this.node;
            var elementNode = this.node;
            var slotElement = this.node;
            if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                && this.node.nodeName.toUpperCase() === "IFRAME"
                && iframeNode.contentDocument
                && iframeNode.contentDocument.documentElement) {
                var ownerElement = this.node;
                this.node = iframeNode.contentDocument.documentElement;
                this.node.nwOwnerElement = ownerElement;
            }
            else if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                && elementNode.shadowRoot
                && elementNode.shadowRoot.firstChild) {
                var ownerElement = this.node;
                this.node = elementNode.shadowRoot;
                this.node.nwOwnerElement = ownerElement;
            }
            else if (this.node.nodeType === 1
                && elementNode.nodeName.toLowerCase() === "slot"
                && slotElement.assignedNodes().length > 0) {
                var slotOwner = this.node;
                this.node = slotElement.assignedNodes()[0];
                this.node.nwSlotOwner = slotOwner;
                this.node.nwSlotIndex = 0;
            }
            else if (this.node.firstChild) {
                this.node = this.node.firstChild;
            }
            else {
                this.bEndTag = true;
                return this.nextNode();
            }
        }
        else {
            if (this.node.nwSlotOwner) {
                var slotOwner = this.node.nwSlotOwner;
                var nextSlotIndex = this.node.nwSlotIndex + 1;
                delete this.node.nwSlotOwner;
                delete this.node.nwSlotIndex;
                if (nextSlotIndex < slotOwner.assignedNodes().length) {
                    this.node = slotOwner.assignedNodes()[nextSlotIndex];
                    this.node.nwSlotOwner = slotOwner;
                    this.node.nwSlotIndex = nextSlotIndex;
                    this.bEndTag = false;
                }
                else {
                    this.node = slotOwner;
                    this.bEndTag = true;
                }
            }
            else if (this.node.nwOwnerElement) {
                this.node = this.node.nwOwnerElement;
                this.bEndTag = true;
            }
            else if (this.node.nextSibling) {
                this.node = this.node.nextSibling;
                this.bEndTag = false;
            }
            else if (this.node.parentNode) {
                this.node = this.node.parentNode;
                this.bEndTag = true;
            }
            else {
                return false;
            }
        }
        return true;
    };
    NodeWalker.prototype.prevNode = function () {
        if (this.bEndTag && this.node.lastChild) {
            this.node = this.node.lastChild;
            this.bEndTag = true;
        }
        else if (this.node.previousSibling) {
            this.node = this.node.previousSibling;
            this.bEndTag = true;
        }
        else if (this.node.parentNode) {
            this.node = this.node.parentNode;
            this.bEndTag = false;
        }
        else {
            return false;
        }
        if (this.bEndTag && (this.node.firstChild === null || typeof (this.node.firstChild) === 'undefined'))
            this.bEndTag = false;
        return true;
    };
    return NodeWalker;
}());
exports.NodeWalker = NodeWalker;


/***/ }),

/***/ 1794:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMapper = void 0;
var DOMWalker_1 = __webpack_require__(7440);
var CommonMapper = /** @class */ (function () {
    function CommonMapper() {
        this.hierarchyRole = null;
        this.hierarchyPath = null;
        this.hierarchyResults = null;
    }
    CommonMapper.prototype.getBounds = function (node) {
        return null;
    };
    CommonMapper.prototype.reset = function (node) {
        this.hierarchyRole = [];
        this.hierarchyResults = [];
        this.hierarchyPath = [{
                rolePath: "",
                roleCount: {}
            }];
        var ancestors = [];
        var parent = DOMWalker_1.DOMWalker.parentNode(node);
        while (parent && parent.nodeType != 9 /* Node.DOCUMENT_NODE */) {
            ancestors.push(parent);
            parent = DOMWalker_1.DOMWalker.parentNode(parent);
        }
        ancestors = ancestors.reverse();
        for (var _i = 0, ancestors_1 = ancestors; _i < ancestors_1.length; _i++) {
            var ancestor = ancestors_1[_i];
            var siblings = [];
            var sibling = ancestor.previousSibling;
            while (sibling) {
                siblings.push(sibling);
                sibling = sibling.previousSibling;
            }
            siblings = siblings.reverse();
            for (var _a = 0, siblings_1 = siblings; _a < siblings_1.length; _a++) {
                var sibling_1 = siblings_1[_a];
                this.pushHierarchy(sibling_1);
                this.popHierarchy();
            }
            this.pushHierarchy(ancestor);
        }
    };
    CommonMapper.prototype.pushHierarchy = function (node) {
        var role = this.getRole(node) || "none";
        this.hierarchyRole.push(role);
        if (role !== "none") {
            var parentPathInfo = this.hierarchyPath[this.hierarchyPath.length - 1];
            parentPathInfo.roleCount[role] = (parentPathInfo.roleCount[role] || 0) + 1;
            this.hierarchyPath.push({
                "rolePath": parentPathInfo.rolePath + "/" + role + "[" + parentPathInfo.roleCount[role] + "]",
                "roleCount": {}
            });
        }
        var attr = {};
        if (node.nodeType === 1) {
            attr = this.getAttributes(node);
        }
        this.hierarchyResults.push({
            node: node,
            namespace: this.getNamespace(),
            role: role,
            attributes: attr,
            rolePath: this.hierarchyPath[this.hierarchyPath.length - 1].rolePath,
            bounds: this.getBounds(node)
        });
    };
    CommonMapper.prototype.popHierarchy = function () {
        var role = this.hierarchyRole.pop();
        if (role !== "none") {
            this.hierarchyPath.pop();
        }
        this.hierarchyResults.pop();
    };
    CommonMapper.prototype.openScope = function (node) {
        if (this.hierarchyRole === null) {
            this.reset(node);
        }
        this.pushHierarchy(node);
        return this.hierarchyResults;
    };
    CommonMapper.prototype.closeScope = function (node) {
        var retVal = [];
        for (var _i = 0, _a = this.hierarchyResults; _i < _a.length; _i++) {
            var res = _a[_i];
            // const temp = res.node;
            // res.node = null;
            // let cloned = JSON.parse(JSON.stringify(res));
            // cloned.node = res.node = temp; 
            // retVal.push(cloned);
            retVal.push(res);
        }
        retVal[retVal.length - 1].role = "/" + retVal[retVal.length - 1].role;
        this.popHierarchy();
        return retVal;
    };
    return CommonMapper;
}());
exports.CommonMapper = CommonMapper;


/***/ }),

/***/ 2306:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = exports.PartInfo = exports.AttrInfo = void 0;
// Context that will cause this rule to execute. 
// Context syntax:
//   Triggers:
//     aria:role - Triggers on element with ARIA role role
//     aria:role[attribute] - Triggers on elements with the equivalent logical 
//       aria- attribute (e.g., button[disabled] will trigger on 
//       <button disabled> or <div role="button" aria-disabled="true">)
//     role[attribute=value] - Similar to above, with case-sensitive match
//       to value
//     role[attribute~value] - Similar to above, with case-insensitive match
//     dom:element - Triggers on an element with the specified name
//     dom:element[attribute] - Triggers on a dom element with the specified attribute
//     dom:*[attribute] - Triggers on all elements with the specified attribute
//   Combining triggers:
//     trigger1 trigger2 - Triggers on elements with trigger2 within an 
//       element with trigger1
//     !trigger1 trigger2 - Triggers on elements with trigger2 not within
//       element with trigger1
//     trigger1>trigger2 - Triggers on elements with trigger2 with an
//       an immediate parent with trigger1
//     trigger1+trigger2 - Triggers on elements with trigger2 with an
//       immediate previous sibling with trigger1
//     trigger1~trigger2 - Triggers on elements with trigger2 with an
//       some earlier sibling with trigger1
//     context,context - Triggers on elements with either context
var AttrInfo = /** @class */ (function () {
    function AttrInfo(inclusive, attr, eq, value) {
        this.inclusive = inclusive;
        this.attr = attr;
        this.eq = eq;
        this.value = value;
        if (!inclusive
            && ((typeof eq) !== "undefined" && eq.length > 0)) {
            throw new Error("Cannot have !attr" + eq + " context");
        }
        if (inclusive && (typeof eq) !== "undefined" && eq.length > 0 && ((typeof value) === "undefined" || value.length === 0)) {
            throw new Error("Cannot have equivalence check without a value");
        }
    }
    AttrInfo.prototype.matches = function (context) {
        var ruleAttrPart = this;
        var elemAttrs = context.attributes;
        if (!(ruleAttrPart.attr in elemAttrs)) {
            return !ruleAttrPart.inclusive;
        }
        else if (!ruleAttrPart.inclusive) {
            return false;
        }
        else if (!ruleAttrPart.eq) {
            // inclusive match and I have that attribute and no equivalence defined
            return true;
        }
        else {
            // inclusive match and I have that attribute and equivalence defined
            var attrValue = elemAttrs[ruleAttrPart.attr];
            if (ruleAttrPart.eq === "=") {
                return ruleAttrPart.value === attrValue;
            }
            else if (ruleAttrPart.eq === "!=") {
                return ruleAttrPart.value !== attrValue;
            }
            else if (ruleAttrPart.eq === "~") {
                return ruleAttrPart.value === attrValue;
            }
            else if (ruleAttrPart.eq === "!~") {
                return ruleAttrPart.value !== attrValue;
            }
            else {
                throw new Error("Context equivalence operator not supported");
            }
        }
    };
    return AttrInfo;
}());
exports.AttrInfo = AttrInfo;
var PartInfo = /** @class */ (function () {
    function PartInfo(inclusive, namespace, role, attrs, connector) {
        this.inclusive = inclusive;
        this.namespace = namespace;
        this.role = role;
        this.attrs = attrs;
        this.connector = connector;
        if (role === "*" && !inclusive) {
            throw new Error("!* context not supported");
        }
    }
    PartInfo.prototype.matches = function (contextHier, hierLevel) {
        var rulePart = this;
        var ruleRoleMatch = (rulePart.namespace in contextHier) && contextHier[rulePart.namespace][hierLevel]
            && (contextHier[rulePart.namespace][hierLevel].role === rulePart.role
                || contextHier[rulePart.namespace][hierLevel].role !== "none" && rulePart.role === "*");
        if (ruleRoleMatch
            && rulePart.role === "*"
            && rulePart.namespace === "dom"
            && (contextHier[rulePart.namespace][hierLevel].role === "#text"
                || contextHier[rulePart.namespace][hierLevel].role === "/#text")) {
            ruleRoleMatch = false;
        }
        if (rulePart.inclusive && !ruleRoleMatch)
            return false;
        if (!rulePart.inclusive && !ruleRoleMatch)
            return true;
        // Match the attributes
        var ruleAttrs = rulePart.attrs;
        var elemContext = contextHier[rulePart.namespace][hierLevel];
        var match = true;
        for (var _i = 0, ruleAttrs_1 = ruleAttrs; _i < ruleAttrs_1.length; _i++) {
            var ruleAttrPart = ruleAttrs_1[_i];
            match = match && ruleAttrPart.matches(elemContext);
        }
        if (!rulePart.inclusive)
            match = !match;
        return match;
    };
    return PartInfo;
}());
exports.PartInfo = PartInfo;
var Context = /** @class */ (function () {
    function Context(context) {
        this.contextInfo = [];
        var contextHierMatches = context.match(/!?[/a-zA-Z:0-9*\-_]+(\[[^\]]+\])*[ >+~]?/g);
        var results = [];
        for (var _i = 0, contextHierMatches_1 = contextHierMatches; _i < contextHierMatches_1.length; _i++) {
            var part = contextHierMatches_1[_i];
            var parts = part.match(/(!?)([/a-zA-Z:0-9*\-_]+)((\[[^\]]+\])*)([ >+~]?)/);
            var attrInfo = [];
            for (var _a = 0, _b = parts[3].match(/\[([^\]]+)\]/g) || []; _a < _b.length; _a++) {
                var attrPart = _b[_a];
                var attrParts = attrPart.match(/\[(!?)([a-z:A-Z*\-_]+)(!?[=~])?([^\]]+)?\]/);
                attrInfo.push(new AttrInfo(attrParts[1] !== "!", attrParts[2].toLowerCase(), attrParts[3], attrParts[4]));
            }
            parts[2] = parts[2].toLowerCase();
            var nsParts = parts[2].split(":");
            var incl = parts[1] !== "!";
            var ns = nsParts.shift();
            var role = nsParts.join(":");
            var partInfo = new PartInfo(incl, ns, role, attrInfo, parts[parts.length - 1]);
            results.push(partInfo);
        }
        this.contextInfo = results;
    }
    Context.cleanContext = function (context) {
        context = context.toLowerCase().trim();
        context = context.replace(/ +!/g, " !");
        context = context.replace(/ +([>+~,])/g, "$1");
        context = context.replace(/([>+~,]) +/g, "$1");
        context = context.replace(/ +/g, " ");
        return context.trim();
    };
    Context.parse = function (context) {
        var contexts = Context.splitMultiple(Context.cleanContext(context));
        var retVal = [];
        for (var i = 0; i < contexts.length; ++i) {
            var ctx = new Context(contexts[i]);
            retVal.push(ctx);
        }
        return retVal;
    };
    /**
     * Handles initial processing of splitting on comma - context,context
     * @param context
     */
    Context.splitMultiple = function (context) {
        var contexts = [];
        if (context) {
            if (context.indexOf(",") === -1) {
                contexts.push(context);
            }
            else {
                for (var _i = 0, _a = context.split(","); _i < _a.length; _i++) {
                    var c = _a[_i];
                    contexts.push(c);
                }
            }
        }
        return contexts;
    };
    return Context;
}());
exports.Context = Context;


/***/ }),

/***/ 9324:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Engine = void 0;
var IEngine_1 = __webpack_require__(9077);
var DOMWalker_1 = __webpack_require__(7440);
var Context_1 = __webpack_require__(2306);
var Config_1 = __webpack_require__(3962);
var DOMMapper_1 = __webpack_require__(5697);
var DOMUtil_1 = __webpack_require__(295);
var CacheUtil_1 = __webpack_require__(7788);
var WrappedRule = /** @class */ (function () {
    function WrappedRule(rule, parsedInfo) {
        this.rule = rule;
        this.parsedInfo = parsedInfo;
        this.ns = this.parsedInfo.contextInfo[this.parsedInfo.contextInfo.length - 1].namespace;
        Config_1.Config.DEBUG && console.log("Added Rule:", rule.id, JSON.stringify(this.parsedInfo));
    }
    /**
     * This function is responsible converting the node into a snippet which can be added to report.
     *
     * Note: This function will take the node and extract the node name and the attributes and build the snippet based on this.
     *
     * TODO: Future, maybe we can extract more then just single line, add more info or even add closing tags etc...
     *
     * @param {HTMLElement} node - The html element to convert into element snippet with node name and attributes only.
     *
     * @return {String} nodeSnippet - return the element snippet of the element that was provided which only contains,
     *                                nodename and attributes. i.e. <table id=\"layout_table1\" role=\"presentation\">
     *
     * @memberOf this
     */
    WrappedRule.convertNodeToSnippet = function (node) {
        // Variable Decleration
        var nodeSnippet = '';
        // Extract the node name and add it to the node snippet
        nodeSnippet += '<' + node.nodeName.toLowerCase();
        // Extract all the node attributes as an array
        var nodeAttributes = node.attributes;
        // In the case there are attributes on this node
        if (nodeAttributes !== null && typeof nodeAttributes !== 'undefined') {
            // Loop over all theses attributes and add the name and value to the nodeSnippet which will be returned
            for (var i = nodeAttributes.length - 1; i >= 0; i--) {
                if (nodeAttributes[i].name === "data-namewalk")
                    continue;
                // Add the attribute name and value.
                nodeSnippet += ' ' + nodeAttributes[i].name + '="' + nodeAttributes[i].value + '"';
            }
        }
        // Close the node
        nodeSnippet += '>';
        // Return the node snippet
        return nodeSnippet;
    };
    WrappedRule.prototype.run = function (engine, context, options, contextHierarchies) {
        var startTime = new Date().getTime();
        var results;
        try {
            results = this.rule.run(context, options, contextHierarchies);
        }
        catch (e) {
            var err = e;
            console.error("RULE EXCEPTION:", this.rule.id, context.dom.rolePath, err.stack);
            throw e;
        }
        var endTime = new Date().getTime();
        if (!results)
            results = [];
        if (!(results instanceof Array)) {
            results = [results];
        }
        var retVal = [];
        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
            var result = results_1[_i];
            var message = engine.getMessage(this.rule.id, result.reasonId, result.messageArgs);
            var path = {};
            for (var ns in context) {
                path[ns] = context[ns].rolePath;
            }
            var ruleId = this.rule.id.replace(/^(.*)\$\$\d+$/, "$1");
            retVal.push({
                ruleId: ruleId,
                value: result.value,
                node: context["dom"].node,
                path: path,
                ruleTime: endTime - startTime,
                reasonId: result.reasonId,
                message: message,
                messageArgs: result.messageArgs,
                apiArgs: result.apiArgs,
                bounds: context["dom"].bounds,
                snippet: WrappedRule.convertNodeToSnippet(context["dom"].node)
            });
        }
        return retVal;
    };
    return WrappedRule;
}());
var Engine = /** @class */ (function () {
    function Engine() {
        this.mappers = {};
        this.ruleMap = {};
        this.wrappedRuleMap = {};
        this.nlsMap = {};
        this.helpMap = {};
        this.inclRules = {};
        this.exclRules = {};
        // Need a DOM Mapper as a minimum
        this.addMapper(new DOMMapper_1.DOMMapper());
    }
    Engine.getLanguages = function () {
        var env = typeof process !== "undefined" && typeof process.nodeType === "undefined" && process.env;
        // If all else fails, default to US English
        var nodeLang = "en-US";
        if (env) {
            nodeLang = env.LANG || env.LANGUAGE || env.LC_ALL || env.LC_MESSAGES;
            if (nodeLang) {
                nodeLang = nodeLang.split(".")[0].replace(/_/g, "-");
            }
        }
        return typeof navigator !== "undefined" && navigator.languages || [nodeLang];
    };
    Engine.prototype.run = function (root, options) {
        if (root === null) {
            return Promise.reject("null document");
        }
        if (root.nodeType === 9 /* Node.DOCUMENT_NODE */) {
            root = root.documentElement;
        }
        root.ownerDocument && (root.ownerDocument.PT_CHECK_HIDDEN_CONTENT = false);
        (0, CacheUtil_1.clearCaches)(root);
        var walker = new DOMWalker_1.DOMWalker(root);
        var retVal = {
            results: [],
            numExecuted: 0,
            ruleTime: 0,
            totalTime: 0
        };
        var start = new Date().getTime();
        // Reset the role mappers
        for (var namespace in this.mappers) {
            this.mappers[namespace].reset(root);
        }
        // Initialize the context detector
        do {
            // Get the context information from the rule mappers
            var contextHierarchies = {};
            for (var namespace in this.mappers) {
                if (!walker.bEndTag) {
                    contextHierarchies[namespace] = this.mappers[namespace].openScope(walker.node);
                    // if (namespace === "dom" && walker.node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                    // const elem = walker.node as Element;
                    // let id;
                    // if (elem.hasAttribute("id") && (id = elem.getAttribute("id").trim()).length > 0) {
                    // if (root.ownerDocument.getElementById(id) === elem) {
                    // contextHierarchies["dom"][contextHierarchies["dom"].length-1].rolePath = "//*[@id='"+id+"']";
                    // }
                    // }
                    // }
                }
                else {
                    contextHierarchies[namespace] = this.mappers[namespace].closeScope(walker.node);
                }
            }
            if (walker.node.nodeType !== 11
                && (DOMWalker_1.DOMWalker.isNodeVisible(walker.node)
                    // || walker.node.nodeName.toLowerCase() === "head"
                    || walker.node.nodeName.toLowerCase() === "meta"
                    || walker.node.nodeName.toLowerCase() === "style"
                    || walker.node.nodeName.toLowerCase() === "datalist"
                    || walker.node.nodeName.toLowerCase() === "param"
                    || !DOMUtil_1.DOMUtil.getAncestor(walker.node, ["body"]))) {
                var context = {};
                for (var ns in contextHierarchies) {
                    var nsHier = contextHierarchies[ns];
                    var lastHier = nsHier[nsHier.length - 1];
                    context[ns] = lastHier;
                }
                var matchingRules = this.getMatchingRules(contextHierarchies);
                var depMatch = {};
                for (var _i = 0, matchingRules_1 = matchingRules; _i < matchingRules_1.length; _i++) {
                    var matchingRule = matchingRules_1[_i];
                    var fulfillsDependencies = true;
                    for (var _a = 0, _b = matchingRule.rule.dependencies || []; _a < _b.length; _a++) {
                        var dep = _b[_a];
                        if (!depMatch[dep])
                            fulfillsDependencies = false;
                    }
                    if (fulfillsDependencies) {
                        var results = [];
                        try {
                            results = matchingRule.run(this, context, options, contextHierarchies);
                        }
                        catch (err) {
                            // Wrapper shows error in console. Skip this rule as N/A
                            // We don't want to kill the engine
                        }
                        // If out of scope, it fulfills the dependency
                        if (results.length === 0) {
                            depMatch[matchingRule.rule.id] = true;
                        }
                        for (var _c = 0, results_2 = results; _c < results_2.length; _c++) {
                            var result = results_2[_c];
                            retVal.results.push(result);
                            retVal.ruleTime += result.ruleTime;
                            retVal.numExecuted++;
                            if (result.value[1] === IEngine_1.eRuleConfidence.PASS) {
                                depMatch[result.ruleId] = true;
                            }
                        }
                    }
                }
            }
        } while (walker.nextNode());
        (0, CacheUtil_1.clearCaches)(root);
        retVal.totalTime = new Date().getTime() - start;
        return Promise.resolve(retVal);
    };
    Engine.prototype.enableRules = function (ruleIds) {
        for (var ruleId in this.ruleMap) {
            this.ruleMap[ruleId].enabled = false;
        }
        for (var _i = 0, _a = ruleIds || []; _i < _a.length; _i++) {
            var ruleId = _a[_i];
            if (!(ruleId in this.ruleMap)) {
                console.warn("WARNING: Rule Id", ruleId, "could not be enabled.");
            }
            else {
                this.ruleMap[ruleId].enabled = true;
            }
        }
    };
    Engine.prototype.getRule = function (ruleId) {
        return this.ruleMap[ruleId];
    };
    Engine.prototype.getRulesIds = function () {
        var retVal = [];
        for (var ruleId in this.ruleMap) {
            retVal.push(ruleId);
        }
        return retVal;
    };
    Engine.prototype.addRules = function (rules) {
        for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {
            var rule = rules_1[_i];
            this.addRule(rule, true);
        }
        this._sortRules();
    };
    Engine.prototype.addRule = function (rule, skipSort) {
        var ctxs = Context_1.Context.parse(rule.context);
        var idx = 0;
        var ruleId = rule.id;
        if (ruleId in this.ruleMap) {
            console.log("WARNING: Rule", ruleId, "already added to engine. Ignoring...");
            return;
        }
        this.ruleMap[ruleId] = rule;
        for (var _i = 0, ctxs_1 = ctxs; _i < ctxs_1.length; _i++) {
            var ctx = ctxs_1[_i];
            var wrapId = ruleId;
            if (idx >= 1) {
                wrapId = ruleId + "$$" + idx;
            }
            ++idx;
            var wrappedRule = new WrappedRule(rule, ctx);
            this.wrappedRuleMap[wrapId] = wrappedRule;
            var parts = wrappedRule.parsedInfo.contextInfo;
            var lastPart = parts[parts.length - 1];
            var triggerRole = lastPart.namespace + ":" + lastPart.role;
            if (lastPart.inclusive) {
                this.inclRules[triggerRole] = this.inclRules[triggerRole] || [];
                this.inclRules[triggerRole].push(wrappedRule);
            }
            else {
                this.exclRules[triggerRole] = this.exclRules[triggerRole] || [];
                this.exclRules[triggerRole].push(wrappedRule);
            }
        }
        if (!skipSort) {
            this._sortRules();
        }
    };
    Engine.prototype._sortRules = function () {
        for (var role in this.inclRules) {
            this.inclRules[role].sort(function (ruleA, ruleB) {
                var hasDepA = ruleA.rule.dependencies && ruleA.rule.dependencies.length > 0;
                var hasDepB = ruleB.rule.dependencies && ruleB.rule.dependencies.length > 0;
                // If B depends on A, sort A before B
                if (hasDepB && ruleB.rule.dependencies.includes(ruleA.rule.id))
                    return -1;
                // If A depends on B, sort B before A
                if (hasDepA && ruleA.rule.dependencies.includes(ruleB.rule.id))
                    return 1;
                // Otherwise, doesn't matter
                return 0;
            });
        }
        for (var role in this.exclRules) {
            this.exclRules[role].sort(function (ruleA, ruleB) {
                var hasDepA = ruleA.rule.dependencies && ruleA.rule.dependencies.length > 0;
                var hasDepB = ruleB.rule.dependencies && ruleB.rule.dependencies.length > 0;
                // If B depends on A, sort A before B
                if (hasDepB && ruleB.rule.dependencies.includes(ruleA.rule.id))
                    return -1;
                // If A depends on B, sort B before A
                if (hasDepA && ruleA.rule.dependencies.includes(ruleB.rule.id))
                    return 1;
                // Otherwise, doesn't matter
                return 0;
            });
        }
    };
    Engine.prototype.addNlsMap = function (map) {
        for (var key in map) {
            this.nlsMap[key] = map[key];
        }
    };
    Engine.prototype.addHelpMap = function (map) {
        for (var key in map) {
            this.helpMap[key] = map[key];
        }
    };
    Engine.prototype.getMessage = function (ruleId, ruleIdx, msgArgs) {
        var splitter = ruleId.indexOf("$$");
        if (splitter >= 0) {
            ruleId = ruleId.substring(0, splitter);
        }
        if (!(ruleId in this.nlsMap))
            return ruleId;
        var messageTemplate = this.nlsMap[ruleId][ruleIdx || 0];
        if (!messageTemplate)
            return ruleId + "_" + ruleIdx;
        return messageTemplate.replace(/\{(\d+)\}/g, function (matchedStr, matchedNum, matchedIndex) { return msgArgs[matchedNum]; });
    };
    Engine.prototype.getHelp = function (ruleId, reasonId, archiveId) {
        if (!archiveId) {
            // Set to the latest
            archiveId = "latest";
        }
        return "".concat(Config_1.Config.helpRoot, "/").concat(archiveId, "/doc").concat(this.getHelpRel(ruleId, reasonId));
    };
    Engine.prototype.getHelpRel = function (ruleId, ruleIdx) {
        var splitter = ruleId.indexOf("$$");
        if (splitter >= 0) {
            ruleId = ruleId.substring(0, splitter);
        }
        if (!(ruleId in this.helpMap))
            return ruleId;
        ruleIdx = ruleIdx || 0;
        var helpStr = null;
        if (ruleIdx in this.helpMap[ruleId]) {
            helpStr = this.helpMap[ruleId][ruleIdx || 0];
        }
        else {
            helpStr = this.helpMap[ruleId][0];
        }
        if (!helpStr)
            return ruleId + "_" + ruleIdx;
        return helpStr;
    };
    Engine.prototype.addMapper = function (mapper) {
        this.mappers[mapper.getNamespace()] = mapper;
    };
    Engine.match = function (rule, contextHier) {
        var ruleParts = rule.parsedInfo.contextInfo;
        var partIdx = ruleParts.length - 1;
        var curNS = ruleParts[partIdx].namespace;
        var curHier = contextHier[curNS][contextHier[curNS].length - 1];
        var contextNode = curHier.node;
        // If the end of the rule part doesn't match the end of the hierarchy, we don't have a match
        if (!ruleParts[partIdx].matches(contextHier, contextHier[curNS].length - 1)) {
            return false;
        }
        // If there was only one part, we have a match
        if (ruleParts.length === 1) {
            return true;
        }
        // Need to deal with parent parts. To walk the hierarchy, these need to be
        // all in the same namespace. Confirm that is true.
        curNS = ruleParts[0].namespace;
        curHier = contextHier[curNS][contextHier[curNS].length - 1];
        --partIdx;
        if (ruleParts.slice(0, ruleParts.length - 1).some(function (part) { return part.namespace !== curNS; })) {
            console.error("[ERROR] Rule ".concat(rule.rule.id, " has inconsitent parent namespaces"));
            return false;
        }
        // If the target node matches the end of the hierarchy, move up past it, otherwise, start at the end
        var hierIdx = contextHier[curNS].length - (curHier.node.isSameNode(contextNode) ? 2 : 1);
        while (hierIdx >= 0 && partIdx >= 0) {
            var part = ruleParts[partIdx];
            var matchesPart = ruleParts[partIdx].matches(contextHier, hierIdx);
            if (part.connector === ">") {
                if (!matchesPart) {
                    // Direct parent check and doesn't match
                    return false;
                }
                else {
                    // Direct parent check and does match
                    --partIdx;
                    --hierIdx;
                }
            }
            else if (part.connector === " ") {
                if (part.inclusive) {
                    // inclusive ancestor match
                    if (matchesPart) {
                        --partIdx;
                    }
                    // If doesn't match, just move up the role hierarchy
                    --hierIdx;
                }
                else if (!matchesPart) {
                    // exclusive ancestor match and current matches
                    return false;
                }
                else {
                    // exclusive ancestor match and current doesn't match - check for other ancestors
                    var parentMatch = false;
                    for (var searchIdx = hierIdx - 1; !parentMatch && searchIdx >= 0; --searchIdx) {
                        parentMatch = !ruleParts[partIdx].matches(contextHier, searchIdx);
                    }
                    if (parentMatch)
                        return false;
                    else
                        --partIdx;
                }
            }
            else {
                throw new Error("Context connector " + part.connector + " is not supported");
            }
        }
        return partIdx === -1;
    };
    Engine.prototype.getMatchingRules = function (ctxHier) {
        var matches = [];
        function addMatches(rules) {
            for (var _i = 0, rules_2 = rules; _i < rules_2.length; _i++) {
                var rule = rules_2[_i];
                if (rule.rule.enabled && Engine.match(rule, ctxHier)) {
                    matches.push(rule);
                }
            }
        }
        for (var ns in ctxHier) {
            var role = ns + ":" + (ctxHier[ns].length > 0 ? ctxHier[ns][ctxHier[ns].length - 1].role : "none");
            if (role in this.inclRules) {
                addMatches(this.inclRules[role]);
            }
            for (var xRole in this.exclRules) {
                if (xRole !== role) {
                    addMatches(this.exclRules[xRole]);
                }
            }
            if (role !== ns + ":none") {
                if (role.startsWith(ns + ":/")) {
                    if (ns + ":/*" in this.inclRules) {
                        addMatches(this.inclRules[ns + ":/*"]);
                    }
                }
                else {
                    if (ns + ":*" in this.inclRules) {
                        addMatches(this.inclRules[ns + ":*"]);
                    }
                }
            }
        }
        return this.sortDeps(matches);
    };
    /**
     * Sorts the rules in order to execute dependencies in the correct order
     * @param inRules List of wrapped rules to sort
     * @returns Sorted list of wrapped rules
     */
    Engine.prototype.sortDeps = function (inRules) {
        var depRules = [];
        for (var _i = 0, inRules_1 = inRules; _i < inRules_1.length; _i++) {
            var rule = inRules_1[_i];
            depRules.push(rule);
        }
        var retVal = [];
        var idToRule = {};
        // Iterate through the rules. If that rule's dependencies can be met by rules already in the list, add it to the list
        // Repeat until no changes are made to the satisfied list
        // If a rule cannot be satisfied, it will never execute, so it can be dropped.
        var change = false;
        do {
            change = false;
            for (var idx = 0; idx < depRules.length; ++idx) {
                var depRule = depRules[idx];
                if (depRule.rule.id in idToRule)
                    continue;
                var allMatch = true;
                if (depRule.rule.dependencies && depRule.rule.dependencies.length > 0) {
                    for (var _a = 0, _b = depRule.rule.dependencies; _a < _b.length; _a++) {
                        var depId = _b[_a];
                        if (!(depId in idToRule)) {
                            allMatch = false;
                        }
                    }
                }
                if (depRule.rule.prereqs && depRule.rule.prereqs.length > 0) {
                    for (var _c = 0, _d = depRule.rule.prereqs; _c < _d.length; _c++) {
                        var depId = _d[_c];
                        if (!(depId in idToRule)) {
                            allMatch = false;
                        }
                    }
                }
                if (allMatch) {
                    change = true;
                    retVal.push(depRule);
                    idToRule[depRule.rule.id] = true;
                    depRules.splice(idx--, 1);
                }
            }
        } while (change);
        return retVal;
    };
    return Engine;
}());
exports.Engine = Engine;


/***/ }),

/***/ 3962:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Config = void 0;
var Config = /** @class */ (function () {
    function Config() {
    }
    Config.DEBUG = false;
    Config.helpRoot = "https://able.ibm.com/rules/archives";
    return Config;
}());
exports.Config = Config;


/***/ }),

/***/ 9831:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorObj = exports.ColorUtil = void 0;
var DOMWalker_1 = __webpack_require__(7440);
var ColorUtil = /** @class */ (function () {
    function ColorUtil() {
    }
    // Rewrite the color object to account for alpha
    ColorUtil.Color = function (cssStyleColor) {
        cssStyleColor = cssStyleColor.toLowerCase();
        if (cssStyleColor === "transparent")
            return new ColorObj(255, 255, 255, 0);
        if (cssStyleColor in ColorUtil.CSSColorLookup)
            cssStyleColor = ColorUtil.CSSColorLookup[cssStyleColor];
        if (cssStyleColor.startsWith("rgb(")) {
            var rgbRegex = /\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/;
            var m = cssStyleColor.match(rgbRegex);
            if (m === null)
                return null;
            else {
                return new ColorObj(m[1], m[2], m[3]);
            }
        }
        else if (cssStyleColor.startsWith("rgba(")) {
            var rgbRegex = /\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(.+)\s*\)/;
            var m = cssStyleColor.match(rgbRegex);
            if (m === null)
                return null;
            else {
                return new ColorObj(m[1], m[2], m[3], m[4]);
            }
        }
        else if (cssStyleColor.charAt(0) != "#") {
            return null;
        }
        else {
            if (cssStyleColor.length === 4) {
                // The three-digit RGB (#rgb) is converted to six-digit form (#rrggbb) by replicating digits
                // (https://www.w3.org/TR/css-color-3/#rgb-color)
                cssStyleColor = "#" + cssStyleColor.charAt(1).repeat(2) +
                    cssStyleColor.charAt(2).repeat(2) +
                    cssStyleColor.charAt(3).repeat(2);
            }
            var thisRed = parseInt(cssStyleColor.substring(1, 3), 16);
            var thisGreen = parseInt(cssStyleColor.substring(3, 5), 16);
            var thisBlue = parseInt(cssStyleColor.substring(5, 7), 16);
            return new ColorObj(thisRed, thisGreen, thisBlue);
        }
        //    return null; // Unreachable
    };
    ;
    ColorUtil.ColorCombo = function (ruleContext) {
        try {
            var doc = ruleContext.ownerDocument;
            if (!doc) {
                return null;
            }
            var win = doc.defaultView;
            if (!win) {
                return null;
            }
            var ancestors = [];
            var walkNode = ruleContext;
            while (walkNode) {
                if (walkNode.nodeType === 1)
                    ancestors.push(walkNode);
                walkNode = DOMWalker_1.DOMWalker.parentElement(walkNode);
            }
            var retVal = {
                "hasGradient": false,
                "hasBGImage": false,
                "textShadow": false,
                "fg": null,
                "bg": null
            };
            // start
            var cStyle = win.getComputedStyle(ruleContext);
            var compStyleColor = cStyle.color;
            if (!compStyleColor)
                compStyleColor = "black";
            var fg = ColorUtil.Color(compStyleColor);
            var reColor = /transparent|rgba?\([^)]+\)/gi;
            var guessGradColor = function (gradList, bgColor, fgColor) {
                try {
                    // If there's only one color, return that
                    if (typeof gradList.length === "undefined")
                        return gradList;
                    var overallWorst = null;
                    var overallWorstRatio = null;
                    for (var iGrad = 1; iGrad < gradList.length; ++iGrad) {
                        var worstColor = gradList[iGrad - 1];
                        var worstRatio = fgColor.contrastRatio(gradList[iGrad - 1]);
                        var step = .1;
                        var idx = 0;
                        while (step > .0001) {
                            while (idx + step <= 1 && worstRatio > fgColor.contrastRatio(gradList[iGrad].mix(gradList[iGrad - 1], idx + step).getOverlayColor(bgColor))) {
                                worstColor = gradList[iGrad].mix(gradList[iGrad - 1], idx + step).getOverlayColor(bgColor);
                                worstRatio = fgColor.contrastRatio(worstColor);
                                idx = idx + step;
                            }
                            while (idx - step >= 0 && worstRatio > fgColor.contrastRatio(gradList[iGrad].mix(gradList[iGrad - 1], idx - step).getOverlayColor(bgColor))) {
                                worstColor = gradList[iGrad].mix(gradList[iGrad - 1], idx - step).getOverlayColor(bgColor);
                                worstRatio = fgColor.contrastRatio(worstColor);
                                idx = idx - step;
                            }
                            step = step / 10;
                        }
                        if (overallWorstRatio === null || overallWorstRatio > worstRatio) {
                            overallWorstRatio = worstRatio;
                            overallWorst = worstColor;
                        }
                    }
                    return overallWorst; // return the darkest color
                }
                catch (e) {
                    console.log(e);
                }
                return bgColor;
            };
            var priorStackBG = ColorUtil.Color("white");
            var thisStackOpacity = null;
            var thisStackAlpha = null;
            var thisStackBG = null;
            // Ancestors processed from the topmost parent toward the child
            while (ancestors.length > 0) {
                var procNext = ancestors.pop();
                //var procNext = ancestors.splice(0, 1)[0];
                // cStyle is the computed style of this layer
                var cStyle = win.getComputedStyle(procNext);
                if (cStyle === null)
                    continue;
                // thisBgColor is the color of this layer or null if the layer is transparent
                var thisBgColor = null;
                if (cStyle.backgroundColor && cStyle.backgroundColor != "transparent" && cStyle.backgroundColor != "rgba(0, 0, 0, 0)") {
                    thisBgColor = ColorUtil.Color(cStyle.backgroundColor);
                }
                // If there is a gradient involved, set thisBgColor to the worst color combination available against the foreground
                if (cStyle.backgroundImage && cStyle.backgroundImage.indexOf && cStyle.backgroundImage.indexOf("gradient") != -1) {
                    var gradColors = cStyle.backgroundImage.match(reColor);
                    if (gradColors) {
                        var gradColorComp = [];
                        for (var i = 0; i < gradColors.length; ++i) {
                            if (!gradColors[i].length) {
                                gradColors.splice(i--, 1);
                            }
                            else {
                                var colorComp = ColorUtil.Color(gradColors[i]);
                                if (colorComp.alpha !== undefined && colorComp.alpha < 1) {
                                    // mix the grdient bg color wit parent bg if alpha < 1
                                    var compStackBg = thisStackBG || priorStackBG;
                                    colorComp = colorComp.getOverlayColor(compStackBg);
                                }
                                gradColorComp.push(colorComp);
                            }
                        }
                        thisBgColor = guessGradColor(gradColorComp, thisStackBG || priorStackBG, fg);
                    }
                }
                // Handle non-solid opacity
                if (thisStackOpacity === null || (cStyle.opacity && cStyle.opacity.length > 0 && parseFloat(cStyle.opacity) < 1)) {
                    // New stack, reset
                    if (thisStackBG != null) {
                        // Overlay
                        thisStackBG.alpha = thisStackOpacity * thisStackAlpha;
                        priorStackBG = thisStackBG.getOverlayColor(priorStackBG);
                    }
                    thisStackOpacity = 1.0;
                    thisStackAlpha = null;
                    thisStackBG = null;
                    if (cStyle.opacity && cStyle.opacity.length > 0) {
                        thisStackOpacity = parseFloat(cStyle.opacity);
                    }
                    if (thisBgColor != null) {
                        thisStackBG = thisBgColor;
                        thisStackAlpha = thisStackBG.alpha || 1.0;
                        delete thisStackBG.alpha;
                        if (thisStackOpacity === 1.0 && thisStackAlpha === 1.0) {
                            retVal.hasBGImage = false;
                            retVal.hasGradient = false;
                        }
                    }
                }
                // Handle solid color backgrounds and gradient color backgrounds
                else if (thisBgColor != null) {
                    // If this stack already has a background color, blend it
                    if (thisStackBG === null) {
                        thisStackBG = thisBgColor;
                        thisStackAlpha = thisStackBG.alpha || 1.0;
                        delete thisStackBG.alpha;
                    }
                    else {
                        thisStackBG = thisBgColor.getOverlayColor(thisStackBG);
                        //thisStackAlpha = thisBgColor.alpha || 1.0;
                        thisStackAlpha = thisStackBG.alpha || 1.0;
                    }
                    // #526: If thisBgColor had an alpha value, it may not expose through thisStackBG in the above code
                    // We can't wipe out the gradient info if this layer was transparent
                    if (thisStackOpacity === 1.0 && thisStackAlpha === 1.0 && (thisStackBG.alpha || 1.0) === 1.0 && (thisBgColor.alpha || 1.0) === 0) {}
                }
                if (cStyle.backgroundImage && cStyle.backgroundImage != "none") {
                    if (cStyle.backgroundImage.indexOf && cStyle.backgroundImage.indexOf("gradient") != -1) {
                        retVal.hasGradient = true;
                    }
                    else {
                        retVal.hasBGImage = true;
                    }
                }
            }
            if (thisStackBG != null) {
                fg = fg.getOverlayColor(thisStackBG);
                delete fg.alpha;
            }
            fg.alpha = (fg.alpha || 1) * thisStackOpacity;
            fg = fg.getOverlayColor(priorStackBG);
            if (thisStackBG != null) {
                thisStackBG.alpha = thisStackOpacity * thisStackAlpha;
                priorStackBG = thisStackBG.getOverlayColor(priorStackBG);
            }
            retVal.fg = fg;
            retVal.bg = priorStackBG;
            if (cStyle.textShadow && cStyle.textShadow !== 'none')
                retVal.textShadow = true;
            return retVal;
        }
        catch (err) {
            // something happened, then...
            return null;
        }
    };
    ;
    ColorUtil.CSSColorLookup = {
        "aliceblue": "#f0f8ff",
        "antiquewhite": "#faebd7",
        "aqua": "#00ffff",
        "aquamarine": "#7fffd4",
        "azure": "#f0ffff",
        "beige": "#f5f5dc",
        "bisque": "#ffe4c4",
        "black": "#000000",
        "blanchedalmond": "#ffebcd",
        "blue": "#0000ff",
        "blueviolet": "#8a2be2",
        "brown": "#a52a2a",
        "burlywood": "#deb887",
        "cadetblue": "#5f9ea0",
        "chartreuse": "#7fff00",
        "chocolate": "#d2691e",
        "coral": "#ff7f50",
        "cornflowerblue": "#6495ed",
        "cornsilk": "#fff8dc",
        "crimson": "#dc143c",
        "cyan": "#00ffff",
        "darkblue": "#00008b",
        "darkcyan": "#008b8b",
        "darkgoldenrod": "#b8860b",
        "darkgray": "#a9a9a9",
        "darkgreen": "#006400",
        "darkkhaki": "#bdb76b",
        "darkmagenta": "#8b008b",
        "darkolivegreen": "#556b2f",
        "darkorange": "#ff8c00",
        "darkorchid": "#9932cc",
        "darkred": "#8b0000",
        "darksalmon": "#e9967a",
        "darkseagreen": "#8fbc8f",
        "darkslateblue": "#483d8b",
        "darkslategray": "#2f4f4f",
        "darkturquoise": "#00ced1",
        "darkviolet": "#9400d3",
        "deeppink": "#ff1493",
        "deepskyblue": "#00bfff",
        "dimgray": "#696969",
        "dodgerblue": "#1e90ff",
        "firebrick": "#b22222",
        "floralwhite": "#fffaf0",
        "forestgreen": "#228b22",
        "fuchsia": "#ff00ff",
        "gainsboro": "#dcdcdc",
        "ghostwhite": "#f8f8ff",
        "gold": "#ffd700",
        "goldenrod": "#daa520",
        "gray": "#808080",
        "green": "#008000",
        "greenyellow": "#adff2f",
        "honeydew": "#f0fff0",
        "hotpink": "#ff69b4",
        "indianred": "#cd5c5c",
        "indigo": "#4b0082",
        "ivory": "#fffff0",
        "khaki": "#f0e68c",
        "lavender": "#e6e6fa",
        "lavenderblush": "#fff0f5",
        "lawngreen": "#7cfc00",
        "lemonchiffon": "#fffacd",
        "lightblue": "#add8e6",
        "lightcoral": "#f08080",
        "lightcyan": "#e0ffff",
        "lightgoldenrodyellow": "#fafad2",
        "lightgrey": "#d3d3d3",
        "lightgreen": "#90ee90",
        "lightpink": "#ffb6c1",
        "lightsalmon": "#ffa07a",
        "lightseagreen": "#20b2aa",
        "lightskyblue": "#87cefa",
        "lightslategray": "#778899",
        "lightsteelblue": "#b0c4de",
        "lightyellow": "#ffffe0",
        "lime": "#00ff00",
        "limegreen": "#32cd32",
        "linen": "#faf0e6",
        "magenta": "#ff00ff",
        "maroon": "#800000",
        "mediumaquamarine": "#66cdaa",
        "mediumblue": "#0000cd",
        "mediumorchid": "#ba55d3",
        "mediumpurple": "#9370d8",
        "mediumseagreen": "#3cb371",
        "mediumslateblue": "#7b68ee",
        "mediumspringgreen": "#00fa9a",
        "mediumturquoise": "#48d1cc",
        "mediumvioletred": "#c71585",
        "midnightblue": "#191970",
        "mintcream": "#f5fffa",
        "mistyrose": "#ffe4e1",
        "moccasin": "#ffe4b5",
        "navajowhite": "#ffdead",
        "navy": "#000080",
        "oldlace": "#fdf5e6",
        "olive": "#808000",
        "olivedrab": "#6b8e23",
        "orange": "#ffa500",
        "orangered": "#ff4500",
        "orchid": "#da70d6",
        "palegoldenrod": "#eee8aa",
        "palegreen": "#98fb98",
        "paleturquoise": "#afeeee",
        "palevioletred": "#d87093",
        "papayawhip": "#ffefd5",
        "peachpuff": "#ffdab9",
        "peru": "#cd853f",
        "pink": "#ffc0cb",
        "plum": "#dda0dd",
        "powderblue": "#b0e0e6",
        "purple": "#800080",
        "red": "#ff0000",
        "rosybrown": "#bc8f8f",
        "royalblue": "#4169e1",
        "saddlebrown": "#8b4513",
        "salmon": "#fa8072",
        "sandybrown": "#f4a460",
        "seagreen": "#2e8b57",
        "seashell": "#fff5ee",
        "sienna": "#a0522d",
        "silver": "#c0c0c0",
        "skyblue": "#87ceeb",
        "slateblue": "#6a5acd",
        "slategray": "#708090",
        "snow": "#fffafa",
        "springgreen": "#00ff7f",
        "steelblue": "#4682b4",
        "tan": "#d2b48c",
        "teal": "#008080",
        "thistle": "#d8bfd8",
        "tomato": "#ff6347",
        "turquoise": "#40e0d0",
        "violet": "#ee82ee",
        "wheat": "#f5deb3",
        "white": "#ffffff",
        "whitesmoke": "#f5f5f5",
        "yellow": "#ffff00",
        "yellowgreen": "#9acd32",
        "buttontext": "rgba(0, 0, 0, 0.847)",
        "buttonface": "#ffffff",
        "graytext": "rgba(0, 0, 0, 0.247)"
    };
    return ColorUtil;
}());
exports.ColorUtil = ColorUtil;
var ColorObj = /** @class */ (function () {
    function ColorObj(red, green, blue, alpha) {
        function fixComponent(comp) {
            if (typeof (comp) != typeof (""))
                return comp;
            var compStr = comp;
            compStr = compStr.trim();
            if (compStr[compStr.length - 1] != "%")
                return parseInt(compStr);
            return Math.round(parseFloat(compStr.substring(0, compStr.length - 1)) * 2.55);
        }
        this.red = fixComponent(red);
        this.green = fixComponent(green);
        this.blue = fixComponent(blue);
        if (typeof (alpha) != "undefined") {
            this.alpha = (typeof (alpha) === typeof ("")) ? parseFloat(alpha) : alpha;
        }
    }
    ColorObj.prototype.toHexHelp = function (value) {
        var retVal = Math.round(value).toString(16);
        if (retVal.length === 1)
            return "0" + retVal;
        return retVal;
    };
    ;
    ColorObj.prototype.toHex = function () {
        return "#" + this.toHexHelp(this.red) + this.toHexHelp(this.green) + this.toHexHelp(this.blue);
    };
    ;
    ColorObj.prototype.contrastRatio = function (bgColor) {
        var fgColor = this;
        if (typeof (this.alpha) != "undefined")
            fgColor = this.getOverlayColor(bgColor);
        var lum1 = fgColor.relativeLuminance();
        if (!bgColor.relativeLuminance) {
            var s = "";
            for (var key in bgColor) {
                s += key + "\n";
            }
            alert(bgColor);
            alert(s);
        }
        var lum2 = bgColor.relativeLuminance();
        var ratio = (lum1 > lum2) ? (lum1 + .05) / (lum2 + .05) : (lum2 + .05) / (lum1 + .05);
        return ratio;
    };
    ;
    ColorObj.prototype.relativeLuminance = function () {
        var R = this.red / 255.0;
        var G = this.green / 255.0;
        var B = this.blue / 255.0;
        R = R <= .04045 ? R / 12.92 : Math.pow((R + .055) / 1.055, 2.4);
        G = G <= .04045 ? G / 12.92 : Math.pow((G + .055) / 1.055, 2.4);
        B = B <= .04045 ? B / 12.92 : Math.pow((B + .055) / 1.055, 2.4);
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    };
    ;
    ColorObj.prototype.mix = function (color2, percThis) {
        if (typeof (this.alpha) === "undefined" && typeof (color2.alpha) === "undefined") {
            return new ColorObj(percThis * this.red + (1 - percThis) * color2.red, percThis * this.green + (1 - percThis) * color2.green, percThis * this.blue + (1 - percThis) * color2.blue);
        }
        else {
            var alphaThis = this.alpha ? this.alpha : 1;
            var alphaOther = color2.alpha ? color2.alpha : 1;
            return new ColorObj(percThis * this.red + (1 - percThis) * color2.red, percThis * this.green + (1 - percThis) * color2.green, percThis * this.blue + (1 - percThis) * color2.blue, percThis * alphaThis + (1 - percThis) * alphaOther);
        }
    };
    ;
    ColorObj.prototype.getOverlayColor = function (bgColor) {
        if (typeof (this.alpha) === "undefined" || this.alpha >= 1) {
            // No mixing required - it's opaque
            return this;
        }
        if (this.alpha < 0) {
            //		Haac.Error.logError("Invalid alpha value");
            return null;
        }
        if (typeof (bgColor.alpha) != "undefined" && bgColor.alpha < 1) {
            //		Haac.Error.logError("Cannot mix with a background alpha");
            return null;
        }
        var retVal = this.mix(bgColor, this.alpha);
        delete retVal.alpha;
        return retVal;
    };
    ColorObj.fromCSSColor = function (cssStyleColor) {
        var thisRed = -1;
        var thisGreen = -1;
        var thisBlue = -1;
        cssStyleColor = cssStyleColor.toLowerCase();
        if (cssStyleColor.startsWith("rgb(")) {
            var rgbRegex = /\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/;
            var m = cssStyleColor.match(rgbRegex);
            if (m === null)
                return null;
            else {
                thisRed = m[1];
                thisGreen = m[2];
                thisBlue = m[3];
            }
        }
        else if (cssStyleColor.startsWith("rgba(")) {
            var rgbRegex = /\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(.+)\s*\)/;
            var m = cssStyleColor.match(rgbRegex);
            if (m === null)
                return null;
            else {
                thisRed = m[1];
                thisGreen = m[2];
                thisBlue = m[3];
            }
        }
        else {
            if (cssStyleColor.charAt(0) != "#") {
                if (cssStyleColor in ColorUtil.CSSColorLookup)
                    cssStyleColor = ColorUtil.CSSColorLookup[cssStyleColor];
                else
                    return null;
            }
            var fromHex = function (val) {
                var lookup = {
                    "a": 10,
                    "b": 11,
                    "c": 12,
                    "d": 13,
                    "e": 14,
                    "f": 15
                };
                var retVal = 0;
                for (var i = 0; i < val.length; ++i) {
                    retVal = retVal * 16 +
                        parseInt(val.charAt(i) in lookup ? lookup[val.charAt(i)] : val.charAt(i));
                }
                return retVal;
            };
            if (cssStyleColor.length === 4) {
                // The three-digit RGB (#rgb) is converted to six-digit form (#rrggbb) by replicating digits
                // (https://www.w3.org/TR/css-color-3/#rgb-color)
                cssStyleColor = "#" + cssStyleColor.charAt(1).repeat(2) +
                    cssStyleColor.charAt(2).repeat(2) +
                    cssStyleColor.charAt(3).repeat(2);
            }
            thisRed = fromHex(cssStyleColor.substring(1, 3));
            thisGreen = fromHex(cssStyleColor.substring(3, 5));
            thisBlue = fromHex(cssStyleColor.substring(5, 7));
        }
        return new ColorObj(thisRed, thisGreen, thisBlue);
    };
    return ColorObj;
}());
exports.ColorObj = ColorObj;


/***/ }),

/***/ 5697:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DOMMapper = void 0;
var CommonMapper_1 = __webpack_require__(1794);
var DOMMapper = /** @class */ (function (_super) {
    __extends(DOMMapper, _super);
    function DOMMapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DOMMapper.prototype.getRole = function (node) {
        return node.nodeName.toLowerCase();
    };
    DOMMapper.prototype.getNamespace = function () {
        return "dom";
    };
    DOMMapper.prototype.getAttributes = function (node) {
        var retVal = {};
        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
            var elem = node;
            for (var idx = 0; idx < elem.attributes.length; ++idx) {
                var attrInfo = elem.attributes[idx];
                retVal[attrInfo.name.toLowerCase()] = attrInfo.nodeValue;
            }
        }
        return retVal;
    };
    DOMMapper.prototype.getBounds = function (node) {
        if (node.nodeType === 1 /*Node.ELEMENT_NODE*/) {
            var adjustment = 1;
            if (node.ownerDocument && node.ownerDocument.defaultView && node.ownerDocument.defaultView.devicePixelRatio) {
                adjustment = node.ownerDocument.defaultView.devicePixelRatio;
            }
            var bounds = node.getBoundingClientRect();
            // Do a check whether bounds has value as we use different tool (htmlUnit, browser) to call this function
            if (bounds) {
                var scrollX_1 = node && node.ownerDocument && node.ownerDocument.defaultView && node.ownerDocument.defaultView.scrollX || 0;
                var scrollY_1 = node && node.ownerDocument && node.ownerDocument.defaultView && node.ownerDocument.defaultView.scrollY || 0;
                return {
                    "left": Math.ceil((bounds.left + scrollX_1) * adjustment),
                    "top": Math.ceil((bounds.top + scrollY_1) * adjustment),
                    "height": Math.ceil(bounds.height * adjustment),
                    "width": Math.ceil(bounds.width * adjustment)
                };
            }
        }
        return null;
    };
    return DOMMapper;
}(CommonMapper_1.CommonMapper));
exports.DOMMapper = DOMMapper;


/***/ }),

/***/ 295:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DOMUtil = void 0;
var DOMWalker_1 = __webpack_require__(7440);
var DOMUtil = /** @class */ (function () {
    function DOMUtil() {
    }
    DOMUtil.hasParent = function (node, names) {
        var p = DOMWalker_1.DOMWalker.parentElement(node);
        while (p && !names.includes(p.nodeName)) {
            p = DOMWalker_1.DOMWalker.parentElement(p);
        }
        return !!p;
    };
    DOMUtil.getAncestor = function (node, names) {
        var p = DOMWalker_1.DOMWalker.parentElement(node);
        while (p && !names.includes(p.nodeName.toLowerCase())) {
            p = DOMWalker_1.DOMWalker.parentElement(p);
        }
        return p;
    };
    DOMUtil.sameNode = function (a, b) {
        if (a === b) {
            return true;
        }
        else if (a.isSameNode) {
            return a.isSameNode(b);
        }
        else if (a.compareDocumentPosition) {
            return a.compareDocumentPosition(b) === 0;
        }
        else {
            // Not supported in this environment - try our best
            return true;
        }
    };
    DOMUtil.cleanWhitespace = function (s) {
        var retVal = s.replace(/[ \t\r\n]/g, " ").replace(/ +/g, " ");
        return retVal;
    };
    DOMUtil.cleanSpace = function (s) {
        var retVal = s.replace(/ +/g, " ");
        return retVal;
    };
    // return true if element1 and element2 (cells) are in the same table
    DOMUtil.isInSameTable = function (element1, element2) {
        if (element1 && element2) {
            var parentName = ['table'];
            var parent1 = DOMUtil.getAncestor(element1, parentName);
            var parent2 = DOMUtil.getAncestor(element2, parentName);
            if (parent1 !== null && parent2 != null && DOMUtil.sameNode(parent1, parent2))
                return true;
        }
        return false;
    };
    DOMUtil.shadowRootNode = function (node) {
        var nd = node;
        while (nd != null && nd.nodeType !== Node.DOCUMENT_FRAGMENT_NODE)
            nd = nd.parentNode;
        return nd;
    };
    /**
     * Copies objects, but retains Node attributes as references
     * @param rhs
     */
    DOMUtil.objectCopyWithNodeRefs = function (rhs) {
        if (!rhs)
            return rhs;
        if (typeof rhs !== "object") {
            if (typeof rhs === "function") {
                return rhs;
            }
            else {
                return JSON.parse(JSON.stringify(rhs));
            }
        }
        else if (rhs instanceof Node || !!rhs.nodeType) {
            return rhs;
        }
        else {
            var retVal = void 0;
            if (rhs.constructor.name === "Array") {
                retVal = [];
                for (var _i = 0, rhs_1 = rhs; _i < rhs_1.length; _i++) {
                    var item = rhs_1[_i];
                    retVal.push(this.objectCopyWithNodeRefs(item));
                }
            }
            else {
                retVal = {};
                for (var key in rhs) {
                    retVal[key] = this.objectCopyWithNodeRefs(rhs[key]);
                }
            }
            return retVal;
        }
    };
    DOMUtil.getAncestorWithAttribute = function (element, attrName, attrValue) {
        var walkNode = DOMWalker_1.DOMWalker.parentNode(element);
        while (walkNode !== null) {
            if (walkNode.nodeType === Node.ELEMENT_NODE && walkNode.getAttribute(attrName) === attrValue)
                return walkNode;
            walkNode = DOMWalker_1.DOMWalker.parentNode(walkNode);
        }
        return null;
    };
    return DOMUtil;
}());
exports.DOMUtil = DOMUtil;


/***/ }),

/***/ 7440:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DOMWalker = void 0;
/**
 * Walks in a DOM order
 *
 * See also ../aria/ARIAWalker
 */
var DOMWalker = /** @class */ (function () {
    function DOMWalker(element, bEnd, root) {
        this.root = root || element;
        this.node = element;
        this.bEndTag = (bEnd == undefined ? false : bEnd == true);
    }
    DOMWalker.parentNode = function (node) {
        if (node === null)
            return null;
        var p = node.parentNode;
        if (node.slotOwner) {
            p = node.slotOwner;
        }
        else if (node.ownerElement) {
            p = node.ownerElement;
        }
        else if (p && p.nodeType === 11) {
            if (p.host) {
                p = p.host;
            }
            else {
                p = null;
            }
        }
        return p;
    };
    DOMWalker.parentElement = function (node) {
        var elem = node;
        do {
            elem = DOMWalker.parentNode(elem);
        } while (elem && elem.nodeType !== 1);
        return elem;
    };
    DOMWalker.isNodeVisible = function (node) {
        if (node === null)
            return false;
        try {
            var vis = null;
            while (node && node.nodeType !== 1 /* Node.ELEMENT_NODE */) {
                node = DOMWalker.parentElement(node);
            }
            var elem = node;
            var w = elem.ownerDocument.defaultView;
            do {
                var cs = w.getComputedStyle(elem);
                if (cs.display === "none")
                    return false;
                if (vis === null && cs.visibility) {
                    vis = cs.visibility;
                    if (vis === "hidden")
                        return false;
                }
                elem = DOMWalker.parentElement(elem);
            } while (elem);
            return true;
        }
        catch (err) {
            return false;
        }
    };
    DOMWalker.prototype.atRoot = function () {
        if (this.ownerElement)
            return false;
        if (this.root === this.node) {
            return true;
        }
        else if (this.root.isSameNode) {
            return this.root.isSameNode(this.node);
        }
        else if (this.root.compareDocumentPosition) {
            return this.root.compareDocumentPosition(this.node) === 0;
        }
        else {
            // Not supported in this environment - try our best
            return this.node.parentNode === null;
        }
    };
    DOMWalker.prototype.nextNode = function () {
        do {
            // console.log(this.node.nodeName, this.bEndTag?"END":"START", this.node.nodeType === 1 && (this.node as any).getAttribute("id"));
            if (!this.bEndTag) {
                var iframeNode = this.node;
                var elementNode = this.node;
                var slotElement = this.node;
                if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && this.node.nodeName.toUpperCase() === "IFRAME"
                    && DOMWalker.isNodeVisible(iframeNode)
                    && iframeNode.contentDocument
                    && iframeNode.contentDocument.documentElement) {
                    var ownerElement = this.node;
                    this.node = iframeNode.contentDocument.documentElement;
                    this.node.ownerElement = ownerElement;
                }
                else if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && DOMWalker.isNodeVisible(elementNode)
                    && elementNode.shadowRoot
                    && elementNode.shadowRoot.firstChild) {
                    var ownerElement = this.node;
                    this.node = elementNode.shadowRoot;
                    this.node.ownerElement = ownerElement;
                }
                else if (this.node.nodeType === 1
                    && elementNode.nodeName.toLowerCase() === "slot"
                    && slotElement.assignedNodes().length > 0) {
                    var slotOwner = this.node;
                    this.node = slotElement.assignedNodes()[0];
                    this.node.slotOwner = slotOwner;
                    this.node.slotIndex = 0;
                }
                else if ((this.node.nodeType === 1 /* Node.ELEMENT_NODE */ || this.node.nodeType === 11) /* Node.ELEMENT_NODE */ && this.node.firstChild) {
                    this.node = this.node.firstChild;
                }
                else {
                    this.bEndTag = true;
                }
            }
            else {
                if (this.atRoot()) {
                    return false;
                }
                else if (this.node.slotOwner) {
                    var slotOwner = this.node.slotOwner;
                    var nextSlotIndex = this.node.slotIndex + 1;
                    delete this.node.slotOwner;
                    delete this.node.slotIndex;
                    if (nextSlotIndex < slotOwner.assignedNodes().length) {
                        this.node = slotOwner.assignedNodes()[nextSlotIndex];
                        this.node.slotOwner = slotOwner;
                        this.node.slotIndex = nextSlotIndex;
                        this.bEndTag = false;
                    }
                    else {
                        this.node = slotOwner;
                        this.bEndTag = true;
                    }
                }
                else if (this.node.ownerElement) {
                    this.node = this.node.ownerElement;
                    this.bEndTag = true;
                }
                else if (this.node.nextSibling) {
                    this.node = this.node.nextSibling;
                    this.bEndTag = false;
                }
                else if (this.node.parentNode) {
                    this.node = this.node.parentNode;
                    this.bEndTag = true;
                }
                else {
                    return false;
                }
            }
        } while ((this.node.nodeType !== 1 /* Node.ELEMENT_NODE */ && this.node.nodeType !== 11 && this.node.nodeType !== 3 /* Node.TEXT_NODE */)
            || (this.node.nodeType === 1 && this.node.getAttribute("aChecker") === "ACE"));
        return true;
    };
    DOMWalker.prototype.prevNode = function () {
        do {
            if (this.bEndTag) {
                var iframeNode = this.node;
                var elementNode = this.node;
                if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && this.node.nodeName.toUpperCase() === "IFRAME"
                    && DOMWalker.isNodeVisible(iframeNode)
                    && iframeNode.contentDocument
                    && iframeNode.contentDocument.documentElement) {
                    var ownerElement = this.node;
                    this.node = iframeNode.contentDocument.documentElement;
                    this.node.ownerElement = ownerElement;
                }
                else if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && DOMWalker.isNodeVisible(elementNode)
                    && elementNode.shadowRoot
                    && elementNode.shadowRoot.lastChild) {
                    var ownerElement = this.node;
                    this.node = elementNode.shadowRoot;
                    this.node.ownerElement = ownerElement;
                }
                else if ((this.node.nodeType === 1 /* Node.ELEMENT_NODE */ || this.node.nodeType === 11) && this.node.lastChild) {
                    this.node = this.node.lastChild;
                }
                else {
                    this.bEndTag = false;
                }
            }
            else {
                if (this.atRoot()) {
                    return false;
                }
                else if (this.node.previousSibling) {
                    this.node = this.node.previousSibling;
                    this.bEndTag = true;
                }
                else if (this.node.ownerElement) {
                    this.node = this.node.ownerElement;
                    this.bEndTag = false;
                }
                else if (this.node.parentNode) {
                    this.node = this.node.parentNode;
                    this.bEndTag = false;
                }
                else {
                    return false;
                }
            }
        } while ((this.node.nodeType !== 1 /* Node.ELEMENT_NODE */ && this.node.nodeType !== 11)
            || (this.node.nodeType === 1 && this.node.getAttribute("aChecker") === "ACE"));
        return true;
    };
    return DOMWalker;
}());
exports.DOMWalker = DOMWalker;


/***/ }),

/***/ 8174:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VisUtil = void 0;
var CacheUtil_1 = __webpack_require__(7788);
var DOMUtil_1 = __webpack_require__(295);
var DOMWalker_1 = __webpack_require__(7440);
var VisUtil = /** @class */ (function () {
    function VisUtil() {
    }
    /**
     * This function is responsible for checking if the node that is provied is
     * visible or not. Following is how the check is performed:
     *    1. Check if the current node is hidden with the following options:
     *       CSS --> dislay: none
     *       CSS --> visibility: hidden
     *       attribute --> hidden
     *    2. Check if the any of the current nodes parents are hidden with the same
     *       options listed in 1.
     *
     *    Note: If either current node or any of the parent nodes are hidden then this
     *          function will return false (node is not visible).
     *
     * @parm {element} node The node which should be checked if it is visible or not.
     * @return {bool} false if the node is NOT visible, true otherwise
     *
     * @memberOf VisUtil
     */
    VisUtil.isNodeVisible = function (nodeIn) {
        // Check the nodeType if this node, if this node is a text node then
        // we get the parentnode and set that as the node as a text nodes,
        // visibility is directly related to the parent node.
        if (nodeIn.nodeType === 3) {
            nodeIn = DOMWalker_1.DOMWalker.parentNode(nodeIn);
        }
        var node = nodeIn;
        // Set PT_NODE_HIDDEN to false for all the nodes, before the check and this will be changed to
        // true when we detect that the node is hidden. We have to set it to false so that we know
        // the rules has already been checked.
        (0, CacheUtil_1.setCache)(node, "PT_NODE_HIDDEN", (0, CacheUtil_1.getCache)(node, "PT_NODE_HIDDEN", false));
        // We should only allow nodeType element, and TextNode all other nodesTypes
        // we can return the visibility as visible.
        // Following nodes will be returned as visable by default, since we can not
        // actually change their visibility.
        //  Node.PROCESSING_INSTRUCTION_NODE --> 7
        //  Node.COMMENT_NODE                --> 8
        //  9 /* Node.DOCUMENT_NODE */               --> 9
        //  Node.DOCUMENT_TYPE_NODE          --> 10
        //  Node.DOCUMENT_FRAGMENT_NODE      --> 11
        if (node.nodeType !== 1) {
            return true;
        }
        // Make sure that the ownerDocument is present before moving forward
        // in detecting if the node is visible or not. In the case that ownerDocument
        // does not exist then we simply return node is visible by default.
        if (!node.ownerDocument) {
            return true;
        }
        // Variable Declaration
        var compStyle;
        var nodeName = node.nodeName.toLowerCase();
        // In the case this node is a script, link or style node, right away return node is visible
        // because scripts, links and style nodes can not be hidden by HTML attribute or CSS or are hidden by default. But we want to scan
        // the elements everytime as they render content still which is still visible to users.
        //  script --> script elements have display: none by default
        //  link --> link elements have display: none by default, but the actually CSS script is still executed so we have to
        //            mark this element as visible at all times.
        //  style --> style elements have display: none by default, but the actually CSS script is still executed so we have to
        //            mark this element as visible at all times.
        if (VisUtil.hiddenByDefaultElements != null && VisUtil.hiddenByDefaultElements != undefined && VisUtil.hiddenByDefaultElements.indexOf(nodeName) > -1) {
            return true;
        }
        // Check if this node is visible, we check couple of CSS properties and hidden attribute.
        // area, param and audio elements we do not check if they are hidden as it does not apply to them.
        // Check the unhideableElements array which is part of the rules, to check if this element is allowed to be hidden or not
        // in the case that the element is part of the unhideableElements array then we do not run the hidden check on this element,
        // and go stright to the parent node.
        // Array check elements like:
        //  area --> area element is part of a map element and it can not be hidden because it is used to
        //           make an certian parts of an map interactive.
        //  param --> element can only be part of object elment and it cannot be hidden directly, it
        //            can only be hidden if the parent is hidden.
        //  audio --> If this element is hidden it will still play the music, so we should still trigger
        //            violations for this element.
        // In the case that unhideableElements array is not defined then we just scan all elements and do no filtering at all.
        if (VisUtil.unhideableElements === null || VisUtil.unhideableElements === undefined || VisUtil.unhideableElements.indexOf(nodeName) === -1) {
            // Check if defaultView exists for this node, if it does then use this to run the getComputedStyle
            // function to get the CSS style for the node.
            if (node.ownerDocument.defaultView) {
                // Run the getComputedStyle on this node to fetch the CSS compuation of the node
                compStyle = node.ownerDocument.defaultView.getComputedStyle(node, null);
            }
            // In the case that defaultView does not exists return true to identify that this
            // node is visible, because were not able to detect if it was not.
            else {
                return true;
            }
            // Get the hidden element property and hidden attribute
            var hiddenAttribute = node.getAttribute("hidden");
            var hiddenPropertyCustom = (0, CacheUtil_1.getCache)(node, "PT_NODE_HIDDEN", undefined);
            // To get the hidden property we need to perform a special check as in some cases the hidden property will not be
            // a boolean, for theses cases we set it to false as we are not able to determine the true hidden condition.
            // The reason for this is because form elements are able to perform an override, so when we have id="hidden" for an element
            // which is under the form element then, node.hidden gives the element/list of elements which have id="hidden". Refer to
            // mozilla bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1267356
            var hiddenProperty = typeof node.hidden === "boolean" ? node.hidden : false;
            // If compStyle object is empty, node does't have hidden property, node does't have hidden attribute and does't have custom PT
            // hidden property then we can just return true (node visible) at this point.
            if (!compStyle &&
                !hiddenProperty && // this covers false, null, or undefined
                (hiddenAttribute === null || hiddenAttribute === undefined) &&
                !hiddenPropertyCustom // This covers false, null or undefined
            ) {
                return true;
            }
            // In the case that the compStyle is defined we check the following:
            //  CSS style display set to none
            //  CSS style visibility set to hidden
            //    Note: For this property since it is inherited, need to skip the check on parents as
            //          the parent can have hidden but the child can be visible. So we only check this property
            //          on child elements/elements that are passed to this function the first time.
            //  node hidden property set (node.hidden)
            //  node attribute hidden set (to any value)
            //  node custom hidden property ser (node.PT_NODE_HIDDEN)
            // If any of the above conditions are true then we return false as this element is not visible
            if ((compStyle !== null && ((compStyle.getPropertyValue('display') === 'none' ||
                (!(0, CacheUtil_1.getCache)(node, "Visibility_Check_Parent", null) && compStyle.getPropertyValue('visibility') === 'hidden'))) ||
                (compStyle.getPropertyValue('display') !== 'block' && (hiddenProperty || hiddenAttribute != null || hiddenPropertyCustom)))) {
                // Set a custom expandos property on the the node to identify that it is hidden, so that we can uses
                // use this in the rules to determine if the node is hidden or not, if we need to.
                // Use expandos property instead of a hash map which stores the elements, adding/checking expandos
                // properties is a lot faster performance whise. For Hash map we need to store based on xpath, and to calculate
                // xpath it is more performance impact.
                (0, CacheUtil_1.setCache)(node, "PT_NODE_HIDDEN", true);
                return false;
            }
        }
        // Get the parentNode for this node, becuase we have to check all parents to make sure they do not have
        // the hidden CSS, property or attribute. Only keep checking until we are all the way back to the parentNode
        // element.
        var parentElement = DOMWalker_1.DOMWalker.parentNode(node);
        // If the parent node exists and the nodetype is element (1), then run recursive call to perform the check
        // all the way up to the very parent node. Use recursive call here instead of a while loop so that we do not
        // have to duplicate the logic for checking if the node is visible or not for all the parents starting with
        // child node.
        if (parentElement != null && parentElement.nodeType === 1) {
            // When we have a parent element going through the isNodeVisible function we have to mark it as such
            // so that in the function we can skip checking visibility: hidden for parent elements since visibility: hidden
            // is inherited, which allows a child to have a different setting then the child. This property only needs to be checked
            // once for the first element that is passed down and that is all. Ignore it for all the parents that we iterate over.
            (0, CacheUtil_1.setCache)(parentElement, "Visibility_Check_Parent", true);
            // Check upwards recursively, and save the results in an variable
            var nodeVisible = VisUtil.isNodeVisible(parentElement);
            // If the node is found to not be visible then add the custom PT_NODE_HIDDEN to true.
            // so that we can use this in the rules.
            if (!nodeVisible) {
                (0, CacheUtil_1.setCache)(node, "PT_NODE_HIDDEN", true);
            }
            // Check upwards recursively
            return nodeVisible;
        }
        // Return true (node is visible)
        return true;
    };
    /**
     * return true if the node or its ancestor is natively hidden or aria-hidden = 'true'
     * @param node
     */
    VisUtil.isNodeHiddenFromAT = function (node) {
        if (!VisUtil.isNodeVisible(node) || node.getAttribute("aria-hidden") === 'true')
            return true;
        var ancestor = DOMUtil_1.DOMUtil.getAncestorWithAttribute(node, "aria-hidden", "true");
        if (ancestor)
            return true;
        return false;
    };
    // This list contains a list of element tags which can not be hidden, when hidden is
    // added to theses elements it does not do anything at all.
    //  area --> area element is part of a map element and it can not be hidden because it is used to
    //           make an certian parts of an map interactive.
    //  param --> element can only be part of object elment and it cannot be hidden directly, it
    //            can only be hidden if the parent is hidden.
    //  audio --> If this element is hidden it will still play the music, so we should still trigger
    //            violations for this element.
    // Note: All element tags that are added here should be added as lowercase, as we are using indexOf to do the check.
    VisUtil.unhideableElements = ['area', 'param', 'audio'];
    // This list contains a list of elements tags which have display: none by default, since we have rules triggering
    // on theses elements we need to make then visible by default so that the rules can trigger regardless of the
    // Check Hidden Content option in the tools.
    //  script --> script elements have display: none by default
    //  link --> link elements have display: none by default, but the actually CSS script is still executed so we have to
    //            mark this element as visible at all times.
    //  style --> style elements have display: none by default, but the actually CSS script is still executed so we have to
    //            mark this element as visible at all times.
    //  head --> head elements have display: none by default, but it will still behave correct
    //  title --> title elements have display: none by default, but it will still display the title
    //  meta --> meta elements have display: none by default, but it will still perform the action that meta is suppose to
    //  base --> base elements have display: none by default, but it will still perform the action that meta is suppose to
    //  noscript --> noscript elements have display: none by default, but it will still perform the action that meta is suppose to
    //  template --> template elements have display: none by default, because they are just a mechanism for holding client-side content
    //               that is not to be rendered when a page is loaded. https://developer.mozilla.org/en/docs/Web/HTML/Element/template
    //  datalist --> datalist elements have display: none by default,
    VisUtil.hiddenByDefaultElements = ['script', 'link', 'style', 'head', 'title', 'meta', 'base', 'noscript', 'template', 'datalist'];
    return VisUtil;
}());
exports.VisUtil = VisUtil;


/***/ }),

/***/ 1970:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StyleMapper = void 0;
var CommonMapper_1 = __webpack_require__(1794);
var StyleMapper = /** @class */ (function (_super) {
    __extends(StyleMapper, _super);
    function StyleMapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StyleMapper.prototype.getRole = function (node) {
        return "computed";
    };
    StyleMapper.prototype.getNamespace = function () {
        return "css";
    };
    StyleMapper.prototype.getAttributes = function (node) {
        var retVal = {};
        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
            var elem = node;
            var style = elem.ownerDocument.defaultView.getComputedStyle(elem);
            for (var idx = 0; idx < style.length; ++idx) {
                var name_1 = style[idx].toLowerCase();
                retVal[name_1] = style[name_1];
            }
        }
        return retVal;
    };
    return StyleMapper;
}(CommonMapper_1.CommonMapper));
exports.StyleMapper = StyleMapper;


/***/ }),

/***/ 4377:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RuleManual = exports.RulePotential = exports.RuleFail = exports.RuleRender = exports.RulePass = exports.eRulesetType = exports.eRuleCategory = exports.eToolkitLevel = exports.eRulePolicy = exports.eRuleConfidence = void 0;
var eRuleConfidence;
(function (eRuleConfidence) {
    eRuleConfidence["PASS"] = "PASS";
    eRuleConfidence["FAIL"] = "FAIL";
    eRuleConfidence["POTENTIAL"] = "POTENTIAL";
    eRuleConfidence["MANUAL"] = "MANUAL";
})(eRuleConfidence = exports.eRuleConfidence || (exports.eRuleConfidence = {}));
var eRulePolicy;
(function (eRulePolicy) {
    eRulePolicy["VIOLATION"] = "VIOLATION";
    eRulePolicy["RECOMMENDATION"] = "RECOMMENDATION";
    eRulePolicy["INFORMATION"] = "INFORMATION";
})(eRulePolicy = exports.eRulePolicy || (exports.eRulePolicy = {}));
var eToolkitLevel;
(function (eToolkitLevel) {
    eToolkitLevel["LEVEL_ONE"] = "1";
    eToolkitLevel["LEVEL_TWO"] = "2";
    eToolkitLevel["LEVEL_THREE"] = "3";
    eToolkitLevel["LEVEL_FOUR"] = "4";
})(eToolkitLevel = exports.eToolkitLevel || (exports.eToolkitLevel = {}));
var eRuleCategory;
(function (eRuleCategory) {
    eRuleCategory["ACCESSIBILITY"] = "Accessibility";
    eRuleCategory["DESIGN"] = "Design";
    eRuleCategory["OTHER"] = "Other";
})(eRuleCategory = exports.eRuleCategory || (exports.eRuleCategory = {}));
var eRulesetType;
(function (eRulesetType) {
    eRulesetType["DEFAULT"] = "default";
    eRulesetType["EXTENSION"] = "extension";
})(eRulesetType = exports.eRulesetType || (exports.eRulesetType = {}));
function RulePass(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.PASS],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RulePass = RulePass;
function RuleRender(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.PASS],
        reasonId: 0,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RuleRender = RuleRender;
function RuleFail(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.FAIL],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RuleFail = RuleFail;
function RulePotential(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.POTENTIAL],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RulePotential = RulePotential;
function RuleManual(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.MANUAL],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RuleManual = RuleManual;


/***/ }),

/***/ 7884:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Checker = void 0;
var IEngine_1 = __webpack_require__(9077);
var Engine_1 = __webpack_require__(9324);
var ARIAMapper_1 = __webpack_require__(4944);
var StyleMapper_1 = __webpack_require__(1970);
var rulesets_1 = __webpack_require__(1070);
var checkRulesV4 = __webpack_require__(8081);
var checkRules = [];
var checkNls = {};
var checkHelp = {};
function _initialize() {
    var langs = Engine_1.Engine.getLanguages();
    // Process V4 rules into the V2 format
    for (var rulename in checkRulesV4) {
        // Convert rule
        var v4Rule = checkRulesV4[rulename];
        checkRules.push(v4Rule);
        for (var _i = 0, langs_1 = langs; _i < langs_1.length; _i++) {
            var langId = langs_1[_i];
            if (langId in v4Rule.messages) {
                checkNls[v4Rule.id] = v4Rule.messages[langId];
                checkNls[v4Rule.id][0] = checkNls[v4Rule.id].group;
            }
            if (langId in v4Rule.help) {
                checkHelp[v4Rule.id] = {};
                for (var reasonId in v4Rule.help[langId]) {
                    checkHelp[v4Rule.id][reasonId] = "/".concat(langId, "/").concat(v4Rule.help[langId][reasonId]);
                }
                checkNls[v4Rule.id][0] = checkNls[v4Rule.id].group;
            }
        }
        // Convert RS
        for (var _a = 0, _b = v4Rule.rulesets; _a < _b.length; _a++) {
            var rsSection = _b[_a];
            for (var _c = 0, _d = rulesets_1.a11yRulesets; _c < _d.length; _c++) {
                var rs = _d[_c];
                var checkRsIds = typeof rsSection.id === "string" ? [rsSection.id] : rsSection.id;
                if (checkRsIds.includes(rs.id)) {
                    for (var _e = 0, _f = rs.checkpoints; _e < _f.length; _e++) {
                        var cp = _f[_e];
                        var checkCPIds = typeof rsSection.num === "string" ? [rsSection.num] : rsSection.num;
                        if (checkCPIds.includes(cp.num)) {
                            cp.rules = cp.rules || [];
                            cp.rules.push({
                                id: v4Rule.id,
                                level: rsSection.level,
                                toolkitLevel: rsSection.toolkitLevel
                            });
                        }
                    }
                }
            }
        }
    }
}
_initialize();
var Checker = /** @class */ (function () {
    function Checker() {
        this.rulesets = [];
        this.rulesetIds = [];
        this.rulesetRules = {};
        this.ruleLevels = {};
        this.ruleCategory = {};
        var engine = this.engine = new Engine_1.Engine();
        engine.addMapper(new ARIAMapper_1.ARIAMapper());
        engine.addMapper(new StyleMapper_1.StyleMapper());
        engine.addRules(checkRules);
        engine.addNlsMap(checkNls);
        engine.addHelpMap(checkHelp);
        for (var _i = 0, a11yRulesets_1 = rulesets_1.a11yRulesets; _i < a11yRulesets_1.length; _i++) {
            var rs = a11yRulesets_1[_i];
            this.addRuleset(rs);
        }
    }
    Checker.prototype.addRuleset = function (rs) {
        this.rulesets.push(rs);
        this.rulesetIds.push(rs.id);
        var ruleIds = [];
        for (var _i = 0, _a = rs.checkpoints; _i < _a.length; _i++) {
            var cp = _a[_i];
            cp.rules = cp.rules || [];
            for (var _b = 0, _c = cp.rules; _b < _c.length; _b++) {
                var rule = _c[_b];
                ruleIds.push(rule.id);
                this.ruleLevels[rule.id] = this.ruleLevels[rule.id] || {};
                this.ruleLevels[rule.id][rs.id] = rule.level;
                this.ruleCategory[rule.id] = this.ruleCategory[rule.id] || {};
                this.ruleCategory[rule.id][rs.id] = rs.category;
            }
        }
        this.rulesetRules[rs.id] = ruleIds;
    };
    Checker.prototype.check = function (node, rsIds) {
        // Determine which rules to run
        var ruleIds = [];
        // Fix the input
        if (!rsIds) {
            ruleIds = this.engine.getRulesIds();
        }
        else {
            if (typeof rsIds === "string") {
                rsIds = [rsIds];
            }
            for (var _i = 0, rsIds_1 = rsIds; _i < rsIds_1.length; _i++) {
                var rsId = rsIds_1[_i];
                if (rsId in this.rulesetRules) {
                    ruleIds = ruleIds.concat(this.rulesetRules[rsId]);
                }
            }
        }
        this.engine.enableRules(ruleIds);
        // Add the report levels
        var myThis = this;
        return this.engine.run(node)
            .then(function (report) {
            report.nls = {};
            for (var _i = 0, _a = report.results; _i < _a.length; _i++) {
                var result = _a[_i];
                if (result.ruleId in checkNls) {
                    report.nls[result.ruleId] = report.nls[result.ruleId] || {
                        0: checkNls[result.ruleId][0]
                    };
                    if (result.reasonId in checkNls[result.ruleId]) {
                        report.nls[result.ruleId][result.reasonId] = checkNls[result.ruleId][result.reasonId];
                    }
                }
                result.value[0] = myThis.getLevel(rsIds, result.ruleId);
                result.category = myThis.getCategory(rsIds, result.ruleId);
                delete result.path.css;
            }
            return report;
        });
    };
    Checker.prototype.getLevel = function (rsIds, ruleId) {
        if (!rsIds)
            return IEngine_1.eRulePolicy.INFORMATION;
        var rsInfo = this.ruleLevels[ruleId];
        var retVal = null;
        if (rsIds) {
            if (!(ruleId in this.ruleLevels)) {
                throw new Error("Rule triggered for which we have no rule level information: " + ruleId);
            }
            for (var _i = 0, rsIds_2 = rsIds; _i < rsIds_2.length; _i++) {
                var rsId = rsIds_2[_i];
                if (rsId in rsInfo) {
                    if (rsInfo[rsId] === IEngine_1.eRulePolicy.VIOLATION) {
                        retVal = IEngine_1.eRulePolicy.VIOLATION;
                    }
                    else if (rsInfo[rsId] === IEngine_1.eRulePolicy.RECOMMENDATION && retVal === null) {
                        retVal = IEngine_1.eRulePolicy.RECOMMENDATION;
                    }
                    else if (retVal === null) {
                        retVal = IEngine_1.eRulePolicy.INFORMATION;
                    }
                }
            }
        }
        if (retVal === null) {
            throw new Error("Rule triggered for which we have no rule level information: " + ruleId);
        }
        return retVal;
    };
    Checker.prototype.getCategory = function (rsIds, ruleId) {
        var rsInfo = this.ruleCategory[ruleId];
        var retVal = "";
        if (!(ruleId in this.ruleCategory)) {
            return IEngine_1.eRuleCategory.OTHER;
        }
        if (!rsIds) {
            rsIds = this.rulesetIds;
        }
        for (var _i = 0, rsIds_3 = rsIds; _i < rsIds_3.length; _i++) {
            var rsId = rsIds_3[_i];
            if (rsId in rsInfo) {
                return rsInfo[rsId];
            }
        }
        return IEngine_1.eRuleCategory.OTHER;
    };
    return Checker;
}());
exports.Checker = Checker;


/***/ }),

/***/ 8980:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.a_target_warning = void 0;
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.a_target_warning = {
    id: "a_target_warning",
    context: "dom:a[target],dom:area[target],dom:base[target]",
    refactor: {
        "WCAG20_A_TargetAndText": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "a_target_warning.html",
            "Pass_0": "a_target_warning.html",
            "Potential_1": "a_target_warning.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Users should be warned in advance if their input action will open a new window or otherwise change their context",
            "Pass_0": "Rule Passed",
            "Potential_1": "Inform the user when their input action will open a new window or otherwise change their context"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "3.2.2",
            level: IRule_2.eRulePolicy.RECOMMENDATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // skip the rule if it's AT hidden and not tabbable
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) && !legacy_1.RPTUtil.isTabbable(ruleContext))
            return null;
        var params = {
            paramWinText: {
                value: ["new window", "new tab"],
                type: "array"
            }
        };
        var tStr = ruleContext.getAttribute("target");
        var passed = tStr == "_parent" || tStr == "_self" || tStr == "_top" || legacy_1.RPTUtil.getFrameByName(ruleContext, tStr) != null;
        if (!passed) {
            // Name is not part of this frameset – must have potential to create new window?
            // See if a new window is mentioned
            var textStr = legacy_1.RPTUtil.getInnerText(ruleContext);
            if (ruleContext.hasAttribute("title"))
                textStr += " " + ruleContext.getAttribute("title");
            for (var i = 0; !passed && i < params.paramWinText.value.length; ++i)
                if (textStr.indexOf(params.paramWinText.value[i]) != -1)
                    passed = true;
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 3961:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.a_text_purpose = void 0;
var ARIAMapper_1 = __webpack_require__(4944);
var IRule_1 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
var IRule_2 = __webpack_require__(4377);
exports.a_text_purpose = {
    id: "a_text_purpose",
    // doc-biblioref is a link
    context: "aria:link,aria:doc-biblioref",
    refactor: {
        "WCAG20_A_HasText": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "a_text_purpose.html",
            "Pass_0": "a_text_purpose.html",
            "Fail_1": "a_text_purpose.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Hyperlinks must have a text description of their purpose",
            "Pass_0": "Hyperlink has a description of its purpose",
            "Fail_1": "Hyperlink has no link text, label or image with a text alternative"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "2.4.4",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: "c487ae",
    run: function (context, options) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
            return null;
        }
        // Rule only passes if an element has inner content,
        // in the case that there is only hidden content under the the element it is a violation
        var passed = ARIAMapper_1.ARIAMapper.computeName(ruleContext).trim().length > 0
            || legacy_1.RPTUtil.nonTabableChildCheck(ruleContext);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 1445:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.applet_alt_exists = void 0;
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.applet_alt_exists = {
    id: "applet_alt_exists",
    context: "dom:applet",
    refactor: {
        "WCAG20_Applet_HasAlt": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
        }
    },
    help: {
        "en-US": {
            "group": "applet_alt_exists.html",
            "Pass_0": "applet_alt_exists.html",
            "Fail_1": "applet_alt_exists.html",
            "Fail_2": "applet_alt_exists.html",
            "Fail_3": "applet_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "<applet> elements must provide an 'alt' attribute and an alternative description",
            "Pass_0": "Rule Passed",
            "Fail_1": "An <applet> element does not have an 'alt' attribute that provides a short text alternative",
            "Fail_2": "The 'alt' attribute value for an <applet> element duplicates the 'code' attribute",
            "Fail_3": "An <applet> element provides alternative text, but does not provide inner content"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "1.1.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        // JCH - NO OUT OF SCOPE hidden in context
        if (!legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "alt")) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            var alt = ruleContext.getAttribute("alt").trim();
            if (ruleContext.hasAttribute("code") && alt == ruleContext.getAttribute("code").trim()) {
                return (0, IRule_1.RuleFail)("Fail_2");
            }
            else if (!legacy_1.RPTUtil.hasInnerContentHidden(ruleContext)) {
                return (0, IRule_1.RuleFail)("Fail_3");
            }
            else {
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
    }
};


/***/ }),

/***/ 876:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.application_content_accessible = void 0;
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.application_content_accessible = {
    id: "application_content_accessible",
    context: "aria:application",
    refactor: {
        "HAAC_Application_Role_Text": {
            0: "HAAC_Application_Role_Text.html",
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            0: "application_content_accessible.html",
            "Pass_0": "application_content_accessible.html",
            "Potential_1": "application_content_accessible.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Non-decorative static text and image content within an element with \"application\" role must be accessible",
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that the non-decorative static text and image content within an element with \"application\" role are accessible"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "2.1.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = true;
        var children = ruleContext.childNodes;
        for (var i = 0; passed && i < children.length; i++) {
            if (children[i].nodeType === 1) {
                if (VisUtil_1.VisUtil.isNodeVisible(children[i])) {
                    passed = legacy_1.RPTUtil.hasRoleInSemantics(children[i], "document") || legacy_1.RPTUtil.hasRoleInSemantics(children[i], "article");
                }
            }
            else if (children[i].nodeType === 3) {
                passed = children[i].nodeValue.trim().length === 0;
            }
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 2768:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.area_alt_exists = void 0;
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.area_alt_exists = {
    id: "area_alt_exists",
    context: "dom:area",
    refactor: {
        "WCAG20_Area_HasAlt": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "area_alt_exists.html",
            "Pass_0": "area_alt_exists.html",
            "Fail_1": "area_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "<area> elements in an image map must have a text alternative",
            "Pass_0": "Rule Passed",
            "Fail_1": "<area> element in an image map has no text alternative"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "1.1.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        // JCH - NO OUT OF SCOPE hidden in context
        if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "alt")) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
    }
};


/***/ }),

/***/ 7178:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_activedescendant_tabindex_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.aria_activedescendant_tabindex_valid = {
    id: "aria_activedescendant_tabindex_valid",
    context: "dom:*[aria-activedescendant]",
    refactor: {
        "Rpt_Aria_InvalidTabindexForActivedescendant": {
            "pass": "pass",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_activedescendant_tabindex_valid.html",
            "Fail_1": "aria_activedescendant_tabindex_valid.html",
            "group": "aria_activedescendant_tabindex_valid.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "Fail_1": "The <{0}> element using 'aria-activedescendant' set to \"{1}\" is not tabbable",
            "group": "Element using 'aria-activedescendant' property should be tabbable"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = false;
        var nodeName = ruleContext.nodeName.toLowerCase();
        // Rule not supported on mobile
        if (ruleContext.hasAttribute("class") && ruleContext.getAttribute("class").substring(0, 3) == "mbl") {
            return null;
        }
        // Handle the case where the element is hidden by disabled html5 attribute or aria-disabled:
        //  1. In the case that this element has a disabled attribute and the element supports it, we mark this rule as passed.
        //  2. In the case that this element has a aria-disabled attribute then, we mark this rule as passed.
        // For both of the cases above we do not need to perform any further checks, as the element is disabled in some form or another.
        if (legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
            return null;
        }
        //check if the attribute 'aria-activedescendant' is valid for the role of the element
        // If the tabindex attribute is provided then verify that it is 0 or -1
        passed = legacy_1.RPTUtil.isTabbable(ruleContext);
        // Build array for node token
        var retToken1 = new Array();
        retToken1.push(nodeName);
        // Build array for id referenced by aria-activedescendant
        var retToken2 = new Array();
        retToken2.push(ruleContext.getAttribute("aria-activedescendant").split(" ").join(", "));
        //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [retToken1, retToken2]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [retToken1.toString(), retToken2.toString()]);
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 9745:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_activedescendant_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var fragment_1 = __webpack_require__(482);
var VisUtil_1 = __webpack_require__(8174);
exports.aria_activedescendant_valid = {
    id: "aria_activedescendant_valid",
    context: "dom:*[aria-activedescendant]",
    refactor: {
        "HAAC_ActiveDescendantCheck": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3",
            "Fail_4": "Fail_4"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_activedescendant_valid.html",
            "Fail_1": "aria_activedescendant_valid.html",
            "Fail_2": "aria_activedescendant_valid.html",
            "Fail_3": "aria_activedescendant_valid.html",
            "Fail_4": "aria_activedescendant_valid.html",
            "group": "aria_activedescendant_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The 'aria-activedescendant' property is empty",
            "Fail_2": "The 'aria-activedescendant' property references a hidden node",
            "Fail_3": "Element is not a combobox, and the referenced active-descendant element is not a valid descendant",
            "Fail_4": "Element is a combobox, and the referenced active-descendant element is not controlled by this component",
            "group": "The 'aria-activedescendant' property must reference the 'id' of a non-empty, non-hidden active child element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // combobox active descendants handled by 'combobox_active_descendant'
        if (legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "combobox")) {
            return null;
        }
        var descendant_id = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-activedescendant");
        // POF1: The attribute is empty
        if (!descendant_id || descendant_id.trim() === "") {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        var descendant = fragment_1.FragmentUtil.getById(ruleContext, descendant_id.trim());
        if (!descendant) {
            // The referenced element doesn't exist. We let 1077 to trigger the error
            return null;
        }
        if (!VisUtil_1.VisUtil.isNodeVisible(descendant)) {
            // POF2: aria-activedescendant references a hidden node
            return (0, IRule_1.RuleFail)("Fail_2");
        }
        // 1. The value of aria-activedescendant refers to an element that is either a descendant of 
        // the element with DOM focus
        if (ruleContext.contains(descendant)) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        var pofId = 2;
        // or is a logical descendant as indicated by the aria-owns attribute.
        if (ruleContext.hasAttribute("aria-owns")) {
            var owned_ids = legacy_1.RPTUtil.normalizeSpacing(ruleContext.getAttribute("aria-owns").trim()).split(" ");
            for (var i = 0; i < owned_ids.length; i++) {
                var owned_ele = fragment_1.FragmentUtil.getById(ruleContext, owned_ids[i]);
                if (owned_ele.contains(descendant)) {
                    return (0, IRule_1.RulePass)("Pass_0");
                }
            }
        }
        // 2. The element with DOM focus is a textbox with aria-controls referring to an element that 
        //  supports aria-activedescendant, and the value of aria-activedescendant specified for the 
        //  textbox refers to either a descendant of the element controlled by the textbox or is a logical 
        //  descendant of that controlled element as indicated by the aria-owns attribute.
        //
        if (legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "textbox") && ruleContext.hasAttribute("aria-controls")) {
            pofId = 3;
            var controlled_ids = legacy_1.RPTUtil.normalizeSpacing(ruleContext.getAttribute("aria-controls").trim()).split(" ");
            for (var i = 0; i < controlled_ids.length; i++) {
                var controlled_ele = fragment_1.FragmentUtil.getById(ruleContext, controlled_ids[i]);
                if (controlled_ele.contains(descendant)) {
                    return (0, IRule_1.RulePass)("Pass_0");
                }
                if (controlled_ele.hasAttribute("aria-owns")) {
                    var owns_ids = legacy_1.RPTUtil.normalizeSpacing(controlled_ele.getAttribute("aria-owns").trim()).split(" ");
                    for (var j = 0; j < owns_ids.length; j++) {
                        var owned_ele = fragment_1.FragmentUtil.getById(ruleContext, owns_ids[j]);
                        if (owned_ele.contains(descendant)) {
                            return (0, IRule_1.RulePass)("Pass_0");
                        }
                    }
                }
            }
        }
        // POF3: I'm not a combobox, and the referenced active-descendant is not a descendant and not owned by the element 
        // that referenced it.
        if (pofId == 3) {
            return (0, IRule_1.RuleFail)("Fail_3");
        }
        return null;
    }
};


/***/ }),

/***/ 8019:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_application_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_application_label_unique = {
    id: "aria_application_label_unique",
    context: "aria:application",
    refactor: {
        "Rpt_Aria_MultipleApplicationLandmarks": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_application_label_unique.html",
            "Fail_1": "aria_application_label_unique.html",
            "group": "aria_application_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"application\" role do not have unique labels",
            "group": "Each element with \"application\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Consider the Check Hidden Content setting that is set by the rules
        // Also, consider Implicit role checking.
        var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "application", true, true);
        if (landmarks.length === 0 || landmarks.length === 1) {
            return null;
        }
        var dupes = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "aria_application_label_unique", null);
        if (!dupes) {
            dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "aria_application_label_unique", dupes);
        }
        var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
        var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
        //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [myLabel]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 6505:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_application_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.aria_application_labelled = {
    id: "aria_application_labelled",
    context: "aria:application",
    refactor: {
        "Rpt_Aria_ApplicationLandmarkLabel": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_application_labelled.html",
            "Fail_1": "aria_application_labelled.html",
            "group": "aria_application_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Element with \"application\" role does not have a label",
            "group": "An element with \"application\" role must have a label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = legacy_1.RPTUtil.hasAriaLabel(ruleContext);
        // return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 8910:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_article_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_article_label_unique = {
    id: "aria_article_label_unique",
    context: "aria:article",
    refactor: {
        "Rpt_Aria_MultipleArticleRoles_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_article_label_unique.html",
            "Fail_1": "aria_article_label_unique.html",
            "group": "aria_article_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"article\" role do not have unique labels",
            "group": "Each element with \"article\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Consider the Check Hidden Content setting that is set by the rules
        // Also, consider Implicit role checking.
        var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "article", true, true);
        if (landmarks.length === 0 || landmarks.length === 1) {
            return null;
        }
        var dupes = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "aria_article_label_unique", null);
        if (!dupes) {
            dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "aria_article_label_unique", dupes);
        }
        var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
        var passed = myLabel === "" || !(myLabel in dupes) || dupes[myLabel] <= 1;
        //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [myLabel]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 3492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_allowed = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var ARIADefinitions_1 = __webpack_require__(8235);
var legacy_1 = __webpack_require__(8422);
exports.aria_attribute_allowed = {
    id: "aria_attribute_allowed",
    context: "dom:*",
    refactor: {
        "Rpt_Aria_ValidProperty": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_attribute_allowed.html",
            "Pass_0": "aria_attribute_allowed.html",
            "Fail_1": "aria_attribute_allowed.html"
        }
    },
    messages: {
        "en-US": {
            "group": "ARIA attributes must be valid for the element's role",
            "Pass_0": "Rule Passed",
            "Fail_1": "The attribute(s) '{0}' referenced by the element <{1}> is not a valid ARIA state or property"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "4.1.2",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "5f99a7",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var contextAttributes = ruleContext.attributes;
        // This gets all elements with attributes so we still have some
        // Out of Scope since not all attributes are aria 
        if (contextAttributes) {
            var propertyDataTypes = ARIADefinitions_1.ARIADefinitions.propertyDataTypes;
            var failedProperties = "";
            var testedProperties = 0;
            for (var i = 0, length_1 = contextAttributes.length; i < length_1; i++) {
                var attrName = contextAttributes[i].name;
                if (legacy_1.RPTUtil.isDefinedAriaAttribute(ruleContext, attrName)) {
                    testedProperties++;
                    // Now we just have aria attributes which can
                    // pass or fail based on whether there property is valid
                    var dataTypes = propertyDataTypes[attrName];
                    if (!dataTypes) { // if property is not in valid property list
                        // create failedProperties comma sep list
                        if (failedProperties.length == 0) {
                            failedProperties = attrName;
                        }
                        else {
                            failedProperties = failedProperties + ", " + attrName;
                        }
                    }
                }
            }
            if (testedProperties == 0) {
                return null;
            }
            else if (failedProperties.length != 0) {
                return (0, IRule_1.RuleFail)("Fail_1", [failedProperties, ruleContext.nodeName.toLowerCase()]);
            }
            else {
                //return RulePass(1);
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
        else {
            return null;
        }
        // JCH - passing is based on all attributes not just aria attributes
        //       leading to OVER COUNTING so moved pass up
        //return RulePass(1);
    }
};


/***/ }),

/***/ 5316:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_conflict = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CommonUtil_1 = __webpack_require__(8137);
exports.aria_attribute_conflict = {
    id: "aria_attribute_conflict",
    context: "dom:*[aria-required], dom:*[aria-autocomplete], dom:*[aria-readonly], dom:*[aria-disabled], dom:*[aria-placeholder]"
        + ", dom:*[aria-checked], dom:*[aria-hidden], dom:*[aria-valuemax], dom:*[aria-valuemin], dom:*[aria-colspan]"
        + ", dom:*[aria-rowspan]",
    help: {
        "en-US": {
            "pass": "aria_attribute_conflict.html",
            "fail_conflict": "aria_attribute_conflict.html",
            "group": "aria_attribute_conflict.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "fail_conflict": "The ARIA attribute \"{0}\" is in conflict with the corresponding HTML attribute \"{1}\"",
            "group": "An ARIA attribute must not conflict with the corresponding HTML attribute"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // dependency check: if the ARIA attribute is completely invalid, skip this check
        var invalidAttributes = (0, CommonUtil_1.getInvalidAriaAttributes)(ruleContext);
        if (invalidAttributes && invalidAttributes.length > 0)
            return null;
        var ret = [];
        var ariaAttributes = legacy_1.RPTUtil.getUserDefinedAriaAttributes(ruleContext);
        if (!ariaAttributes || ariaAttributes.length === 0)
            return null;
        var conflictAttributes = (0, CommonUtil_1.getConflictAriaAndHtmlAttributes)(ruleContext);
        for (var i = 0; i < conflictAttributes.length; i++) {
            ret.push((0, IRule_1.RuleFail)("fail_conflict", [conflictAttributes[i]['ariaAttr'], conflictAttributes[i]['htmlAttr']]));
            if (ariaAttributes.includes(conflictAttributes[i]['ariaAttr']))
                legacy_1.RPTUtil.reduceArrayItemList([conflictAttributes[i]['ariaAttr']], ariaAttributes);
        }
        for (var i = 0; i < ariaAttributes.length; i++)
            ret.push((0, IRule_1.RulePass)("pass"));
        if (ret.length > 0)
            return ret;
        return null;
    }
};


/***/ }),

/***/ 8412:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_deprecated = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var ARIADefinitions_1 = __webpack_require__(8235);
exports.aria_attribute_deprecated = {
    id: "aria_attribute_deprecated",
    context: "dom:*",
    help: {
        "en-US": {
            "pass": "aria_attribute_deprecated.html",
            "fail_aria_role": "aria_attribute_deprecated.html",
            "fail_aria_attr": "aria_attribute_deprecated.html",
            "fail_role_attr": "aria_attribute_deprecated.html",
            "group": "aria_attribute_deprecated.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The ARIA roles and attribute are used per specification",
            "fail_aria_role": "The ARIA role \"{0}\" is deprecated in the ARIA specification",
            "fail_aria_attr": "The ARIA attributes \"{0}\" are deprecated in the ARIA specification",
            "fail_role_attr": "The ARIA attributes \"{0}\" are deprecated for the role \"{1}\" in the ARIA specification",
            "group": "No deprecated ARIA role or attribute should be used"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var domAttributes = ruleContext.attributes;
        var ariaAttrs = [];
        if (domAttributes) {
            for (var i = 0; i < domAttributes.length; i++) {
                var attrName = domAttributes[i].name;
                if (attrName.substring(0, 5) === 'aria-')
                    ariaAttrs.push(attrName);
            }
        }
        var roles = legacy_1.RPTUtil.getRoles(ruleContext, false);
        var ret = [];
        if (roles && roles.length > 0) {
            var globalDeprecatedRoles = ARIADefinitions_1.ARIADefinitions.globalDeprecatedRoles;
            var globalDeprecatedAttributes = ARIADefinitions_1.ARIADefinitions.globalDeprecatedProperties;
            for (var i = 0; i < roles.length; i++) {
                var passed = true;
                if (globalDeprecatedRoles.includes(roles[i])) {
                    ret.push((0, IRule_1.RuleFail)('fail_aria_role', [roles[i]]));
                    passed = false;
                }
                var roleWithDeprecatedAttributes = ARIADefinitions_1.ARIADefinitions.designPatterns[roles[i]];
                if (roleWithDeprecatedAttributes) {
                    var deprecatedAttriNames = roleWithDeprecatedAttributes['deprecatedProps'];
                    if (deprecatedAttriNames && deprecatedAttriNames.length > 0) {
                        for (var i_1 = 0; i_1 < ariaAttrs.length; i_1++) {
                            if (globalDeprecatedAttributes.includes(ariaAttrs[i_1])) {
                                ret.push((0, IRule_1.RuleFail)('fail_aria_attr', [ariaAttrs[i_1]]));
                                passed = false;
                            }
                            else if (deprecatedAttriNames.includes(ariaAttrs[i_1])) {
                                ret.push((0, IRule_1.RuleFail)('fail_role_attr', [ariaAttrs[i_1], roles[i_1]]));
                                passed = false;
                            }
                        }
                    }
                }
                if (passed)
                    ret.push((0, IRule_1.RulePass)("pass"));
            }
        }
        if (ret.length > 0)
            return ret;
        return null;
    }
};


/***/ }),

/***/ 172:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var ARIADefinitions_1 = __webpack_require__(8235);
var VisUtil_1 = __webpack_require__(8174);
exports.aria_attribute_exists = {
    id: "aria_attribute_exists",
    context: "dom:*[role]",
    dependencies: ["aria_role_allowed"],
    refactor: {
        "Rpt_Aria_EmptyPropertyValue": {
            "pass": "pass",
            "fail_empty_attribute": "fail_empty_attribute"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_attribute_exists.html",
            "fail_empty_attribute": "aria_attribute_exists.html",
            "group": "aria_attribute_exists.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "fail_empty_attribute": "The element attribute(s): '{0}' value is empty",
            "group": "When specifying a required ARIA attribute, the value must not be empty"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: ["6a7281"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return;
        var attrNameArr = new Array();
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        var hasAttribute = legacy_1.RPTUtil.hasAttribute;
        var testedProperties = 0;
        var roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
        for (var j = 0; j < roles.length; ++j) {
            if (designPatterns[roles[j]] && legacy_1.RPTUtil.getRoleRequiredProperties(roles[j], ruleContext) != null) {
                var requiredRoleProps = legacy_1.RPTUtil.getRoleRequiredProperties(roles[j], ruleContext);
                for (var i = 0, length_1 = requiredRoleProps.length; i < length_1; i++) {
                    var attribute = requiredRoleProps[i];
                    if (hasAttribute(ruleContext, attribute)) {
                        testedProperties++;
                        var nodeValue = legacy_1.RPTUtil.normalizeSpacing(ruleContext.getAttribute(requiredRoleProps[i]));
                        if (nodeValue.length == 0)
                            attrNameArr.push(requiredRoleProps[i]);
                    }
                    else if (requiredRoleProps[i] == "aria-labelledby") {
                        if ((roles[i] == "radiogroup") && (hasAttribute(ruleContext, "aria-label"))) {
                            testedProperties++;
                            var nodeValue = legacy_1.RPTUtil.normalizeSpacing(ruleContext.getAttribute("aria-label"));
                            if (nodeValue.length == 0)
                                attrNameArr.push("aria-label");
                        }
                    }
                    else if (requiredRoleProps[i] == "aria-valuenow") {
                        if ((roles[i] == "progressbar") && (hasAttribute(ruleContext, "aria-valuetext"))) {
                            testedProperties++;
                            var nodeValue = legacy_1.RPTUtil.normalizeSpacing(ruleContext.getAttribute("aria-valuetext"));
                            if (nodeValue.length == 0)
                                attrNameArr.push("aria-valuetext");
                        }
                    }
                }
            }
            if (designPatterns[roles[j]]) {
                var tagProperty = legacy_1.RPTUtil.getElementAriaProperty(ruleContext);
                var permittedRoles = [];
                permittedRoles.push(roles[j]);
                var allowedAttributes = legacy_1.RPTUtil.getAllowedAriaAttributes(ruleContext, permittedRoles, tagProperty);
                for (var i = 0, length_2 = allowedAttributes.length; i < length_2; i++) {
                    var attribute = allowedAttributes[i];
                    if (attribute == "aria-checked" || attribute == "aria-selected" ||
                        attribute == "aria-expanded" || attribute == "aria-orientation" ||
                        attribute == "aria-level") {
                        if (hasAttribute(ruleContext, attribute)) {
                            testedProperties++;
                            var nodeValue = legacy_1.RPTUtil.normalizeSpacing(ruleContext.getAttribute(attribute));
                            if (nodeValue.length == 0 && !attrNameArr.includes(attribute)) {
                                attrNameArr.push(attribute);
                            }
                        }
                    }
                }
            }
        }
        var retMsg = new Array();
        var passed = attrNameArr.length == 0;
        retMsg.push(attrNameArr.join(", "));
        //return new ValidationResult(passed, [ruleContext], attrNameArr, '', retMsg);
        if (testedProperties == 0) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("fail_empty_attribute", retMsg);
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 9844:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_redundant = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CommonUtil_1 = __webpack_require__(8137);
exports.aria_attribute_redundant = {
    id: "aria_attribute_redundant",
    context: "dom:*[aria-required], dom:*[aria-autocomplete], dom:*[aria-readonly], dom:*[aria-disabled], dom:*[aria-placeholder]"
        + ", dom:*[aria-checked], dom:*[aria-hidden], dom:*[aria-valuemax], dom:*[aria-valuemin], dom:*[aria-colspan]"
        + ", dom:*[aria-rowspan]",
    help: {
        "en-US": {
            "pass": "aria_attribute_redundant.html",
            "fail_redundant": "aria_attribute_redundant.html",
            "group": "aria_attribute_redundant.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "fail_redundant": "The ARIA attribute \"{0}\" is redundant with the HTML attribute \"{1}\"",
            "group": "An ARIA attribute should not be used when there is a corresponding HTML attribute"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // dependency check: if the ARIA attribute is completely invalid, skip this check
        var invalidAttributes = (0, CommonUtil_1.getInvalidAriaAttributes)(ruleContext);
        if (invalidAttributes && invalidAttributes.length > 0)
            return null;
        // if conflict already reported, ignore reporting overlap
        var conflictAttributes = (0, CommonUtil_1.getConflictAriaAndHtmlAttributes)(ruleContext);
        if (conflictAttributes && conflictAttributes.length > 0)
            return null;
        var domAttributes = ruleContext.attributes;
        var ariaAttrs = [];
        var htmlAttrs = [];
        if (domAttributes) {
            for (var i = 0; i < domAttributes.length; i++) {
                var attrName = domAttributes[i].name.trim().toLowerCase();
                var attrValue = ruleContext.getAttribute(attrName);
                if (attrValue === '')
                    attrValue = null;
                if (attrName.substring(0, 5) === 'aria-')
                    ariaAttrs.push({ name: attrName, value: attrValue });
                else
                    htmlAttrs.push({ name: attrName, value: attrValue });
            }
        }
        var ret = [];
        var _loop_1 = function (i) {
            var examinedHtmlAtrNames = legacy_1.RPTUtil.getConflictOrOverlappingHtmlAttribute(ariaAttrs[i], htmlAttrs, 'overlapping');
            if (examinedHtmlAtrNames === null)
                return "continue";
            examinedHtmlAtrNames.forEach(function (item) {
                if (item['result'] === 'Pass') { //pass
                    ret.push((0, IRule_1.RulePass)("pass"));
                }
                else if (item['result'] === 'Failed') { //failed
                    ret.push((0, IRule_1.RuleFail)("fail_redundant", [ariaAttrs[i]['name'], item['attr']]));
                }
            });
        };
        for (var i = 0; i < ariaAttrs.length; i++) {
            _loop_1(i);
        }
        if (ret.length > 0)
            return ret;
        return null;
    }
};


/***/ }),

/***/ 9695:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_required = void 0;
var ARIADefinitions_1 = __webpack_require__(8235);
var legacy_1 = __webpack_require__(8422);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.aria_attribute_required = {
    id: "aria_attribute_required",
    context: "dom:*[role]",
    dependencies: ["aria_role_allowed"],
    refactor: {
        "Rpt_Aria_RequiredProperties": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_attribute_required.html",
            "Pass_0": "aria_attribute_required.html",
            "Fail_1": "aria_attribute_required.html"
        }
    },
    messages: {
        "en-US": {
            "group": "When using a ARIA role on an element, the required attributes for that role must be defined",
            "Pass_0": "Rule Passed",
            "Fail_1": "An element with ARIA role '{0}' does not have the required ARIA attribute(s): '{1}'"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "4.1.2",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "4e8ab6",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var attrNameArr = new Array();
        var roleNameArr = new Array();
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        var roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
        //let implicitRole = ARIAMapper.elemToImplicitRole(ruleContext);
        var implicitRole = legacy_1.RPTUtil.getImplicitRole(ruleContext);
        var hasAttribute = legacy_1.RPTUtil.hasAttribute;
        var testedRoles = 0;
        for (var j = 0, rolesLength = roles.length; j < rolesLength; ++j) {
            if (implicitRole.length > 0 && implicitRole.includes(roles[j]))
                continue;
            if (designPatterns[roles[j]] && legacy_1.RPTUtil.getRoleRequiredProperties(roles[j], ruleContext) != null) {
                var requiredRoleProps = legacy_1.RPTUtil.getRoleRequiredProperties(roles[j], ruleContext);
                var roleMissingReqProp = false;
                testedRoles++;
                for (var i = 0, propertiesLength = requiredRoleProps.length; i < propertiesLength; i++) {
                    if (!hasAttribute(ruleContext, requiredRoleProps[i])) {
                        // If an aria-labelledby isn't present, an aria-label will meet the requirement.
                        if (requiredRoleProps[i] == "aria-labelledby") {
                            if ((!hasAttribute(ruleContext, "aria-label")) || (roles[i] != "radiogroup")) {
                                attrNameArr.push(requiredRoleProps[i]);
                                roleMissingReqProp = true;
                            }
                        }
                        else if (requiredRoleProps[i] == "aria-valuenow") {
                            if ((!hasAttribute(ruleContext, "aria-valuetext")) || (roles[i] != "progressbar")) {
                                attrNameArr.push(requiredRoleProps[i]);
                                roleMissingReqProp = true;
                            }
                        }
                        else if (requiredRoleProps[i] == "aria-controls" && roles[j] == "combobox") {
                            // Skip this check since aria-controls in the textbox of a combobox is already handled in rule HAAC_Combobox_Must_have_Text_Input
                        }
                        else {
                            attrNameArr.push(requiredRoleProps[i]);
                            roleMissingReqProp = true;
                        }
                    }
                }
                if (roleMissingReqProp == true) {
                    roleNameArr.push(roles[j]);
                }
            }
        }
        var retToken = new Array();
        var passed = attrNameArr.length == 0; // only aria attributes so NO OUT OF SCOPE
        retToken.push(roleNameArr.join(", "));
        retToken.push(attrNameArr.join(", "));
        //return new ValidationResult(passed, [ruleContext], attrNameArr, '', passed == true ? [] : retToken);
        if (testedRoles === 0) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", retToken);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 1699:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_value_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var ARIADefinitions_1 = __webpack_require__(8235);
exports.aria_attribute_value_valid = {
    id: "aria_attribute_value_valid",
    context: "dom:*",
    dependencies: ["aria_attribute_allowed"],
    refactor: {
        "Rpt_Aria_ValidPropertyValue": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_attribute_value_valid.html",
            "Pass_0": "aria_attribute_value_valid.html",
            "Fail_1": "aria_attribute_value_valid.html"
        }
    },
    messages: {
        "en-US": {
            "group": "ARIA property values must be valid",
            "Pass_0": "Rule Passed",
            "Fail_1": "The value \"{0}\" specified for attribute '{1}' on element <{2}> is not valid"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "6a7281",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var valueArr = new Array();
        var attrNameArr = new Array();
        var dataTypeArr = new Array();
        var propertyDataTypes = ARIADefinitions_1.ARIADefinitions.propertyDataTypes;
        var contextAttributes = ruleContext.attributes;
        var testedPropertyValues = 0;
        if (contextAttributes) {
            for (var i = 0, length_1 = contextAttributes.length; i < length_1; i++) {
                var attrName = contextAttributes[i].name;
                if (legacy_1.RPTUtil.isDefinedAriaAttribute(ruleContext, attrName)) {
                    var dataTypes = propertyDataTypes[attrName];
                    var nodeValue = legacy_1.RPTUtil.normalizeSpacing(contextAttributes[i].nodeValue);
                    testedPropertyValues++;
                    if (dataTypes && dataTypes.values) {
                        if (dataTypes.values.indexOf(nodeValue) == -1) {
                            if (dataTypes.values.indexOf('undefined') != -1 && nodeValue.length == 0) {
                                //translate 'undefined' to mean ''
                            }
                            else {
                                // aria-relevant is represented as a space delimited list of the following values: 
                                // additions, removals, text; or a single catch-all value all.
                                if (dataTypes.type === "http://www.w3.org/2001/XMLSchema#nmtokens") {
                                    var attrValues = contextAttributes[i].nodeValue.trim().split(" ");
                                    // if the value all is specified, it cannot have any other value
                                    if (attrValues.length > 1 && attrValues.includes("all")) {
                                        valueArr.push(contextAttributes[i].nodeValue.split(" "));
                                        attrNameArr.push(attrName);
                                        dataTypeArr.push(dataTypes.values.toString());
                                    }
                                    else {
                                        var hash = {};
                                        for (var j = 0; j < attrValues.length; j++) {
                                            // if the individual value is not in the list of allowed values
                                            if (attrValues[j] != "" && !dataTypes.values.includes(attrValues[j])) {
                                                if (!hash.hasOwnProperty(attrName)) {
                                                    hash[attrName] = true;
                                                    attrNameArr.push(attrName);
                                                }
                                                valueArr.push(attrValues[j]);
                                                dataTypeArr.push(dataTypes.values.toString());
                                            }
                                        }
                                    }
                                }
                                else {
                                    valueArr.push(contextAttributes[i].nodeValue.split(" "));
                                    attrNameArr.push(attrName);
                                    dataTypeArr.push(dataTypes.values.toString());
                                }
                            }
                        }
                    }
                    else if (dataTypes && dataTypes.type && dataTypes.type === "http://www.w3.org/2001/XMLSchema#int") {
                        var iVal = parseInt(nodeValue);
                        if (isNaN(iVal) || ("" + iVal !== nodeValue)) {
                            valueArr.push(nodeValue);
                            attrNameArr.push(attrName);
                        }
                    }
                    else if (dataTypes && dataTypes.type && dataTypes.type == "http://www.w3.org/2001/XMLSchema#decimal") {
                        var fVal = parseFloat(nodeValue);
                        if (isNaN(fVal)) {
                            valueArr.push(nodeValue);
                            attrNameArr.push(attrName);
                        }
                    }
                    else if (dataTypes && dataTypes.type && (dataTypes.type == "http://www.w3.org/2001/XMLSchema#boolean")) {
                        var tmpV = nodeValue.trim().toLowerCase();
                        if (tmpV !== "true" && tmpV !== "false") {
                            valueArr.push(nodeValue);
                            attrNameArr.push(attrName);
                        }
                    }
                    else if (dataTypes && dataTypes.type && (dataTypes.type == "http://www.w3.org/2001/XMLSchema#string")) {
                    }
                    else {
                        testedPropertyValues--;
                    }
                }
            }
        }
        var retMsg = new Array();
        var passed = attrNameArr.length == 0;
        retMsg.push(valueArr.join(", "));
        retMsg.push(attrNameArr.join(", "));
        retMsg.push(ruleContext.nodeName.toLowerCase());
        // retMsg.push (dataTypeArr.join(", "));
        //return new ValidationResult(passed, [ruleContext], attrNameArr, '', retMsg);
        if (testedPropertyValues == 0) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", retMsg);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4974:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_banner_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_banner_label_unique = {
    id: "aria_banner_label_unique",
    context: "aria:banner",
    refactor: {
        "Rpt_Aria_MultipleBannerLandmarks_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_banner_label_unique.html",
            "Fail_1": "aria_banner_label_unique.html",
            "group": "aria_banner_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"banner\" role do not have unique labels",
            "group": "Each element with \"banner\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Consider the Check Hidden Content setting that is set by the rules
        // Also, consider Implicit role checking.
        var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "banner", true, true);
        if (landmarks.length === 0 || landmarks.length === 1) {
            return null;
        }
        var dupes = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "aria_banner_label_unique", null);
        if (!dupes) {
            dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "aria_banner_label_unique", dupes);
        }
        var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
        var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
        //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [myLabel]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 3054:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_banner_single = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.aria_banner_single = {
    id: "aria_banner_single",
    context: "dom:*[role], dom:header",
    refactor: {
        "Rpt_Aria_OneBannerInSiblingSet_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_banner_single.html",
            "Fail_1": "aria_banner_single.html",
            "group": "aria_banner_single.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "There is more than one element with \"banner\" role on the page",
            "group": "There must be only one element with \"banner\" role on the page"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "banner")) {
            return null;
        }
        var passed = legacy_1.RPTUtil.getSiblingWithRoleHidden(ruleContext, "banner", true, true) === null;
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
    }
};


/***/ }),

/***/ 4649:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_child_tabbable = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var ARIADefinitions_1 = __webpack_require__(8235);
var VisUtil_1 = __webpack_require__(8174);
exports.aria_child_tabbable = {
    id: "aria_child_tabbable",
    context: "dom:*[role]",
    dependencies: ["aria_role_allowed"],
    refactor: {
        "Rpt_Aria_MissingFocusableChild": {
            "pass": "pass",
            "fail_missing_child": "fail_missing_child"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_child_tabbable.html",
            "fail_missing_child": "aria_child_tabbable.html",
            "group": "aria_child_tabbable.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "fail_missing_child": "None of the descendent elements with \"{1}\" role is tabbable",
            "group": "UI component must have at least one tabbable descendant for keyboard access"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || legacy_1.RPTUtil.isNodeDisabled(ruleContext))
            return;
        //skip the check if the element requires presentational children only
        if (legacy_1.RPTUtil.containsPresentationalChildrenOnly(ruleContext) || legacy_1.RPTUtil.shouldBePresentationalChild(ruleContext))
            return;
        // An ARIA list is not interactive
        if (legacy_1.RPTUtil.hasRole(ruleContext, { "list": true, "row": true, "rowgroup": true, "table": true, "grid": true })) {
            return null;
        }
        // Not a valid message for mobile because all elements are focusable in iOS when VoiceOver is enabled.
        if (ruleContext.hasAttribute("class") && ruleContext.getAttribute("class").substring(0, 3) == "mbl") {
            return null;
        }
        // Determine if this is referenced by a combobox. If so, focus is controlled by the combobox
        var id = ruleContext.getAttribute("id");
        if (id && id.trim().length > 0) {
            if (ruleContext.ownerDocument.querySelector("*[aria-controls='".concat(id, "'][role='combobox']"))) {
                return null;
            }
        }
        var passed = true;
        var doc = ruleContext.ownerDocument;
        var hasAttribute = legacy_1.RPTUtil.hasAttribute;
        var roleNameArr = new Array();
        var nodeName = "";
        var inScope = false;
        var roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
        for (var j = 0; j < roles.length; ++j) {
            if (ARIADefinitions_1.ARIADefinitions.containers.includes(roles[j])) {
                var disabled = hasAttribute(ruleContext, 'aria-disabled') ? ruleContext.getAttribute("aria-disabled") : '';
                if (disabled != 'true' && !hasAttribute(ruleContext, 'aria-activedescendant') && !legacy_1.RPTUtil.isTabbable(ruleContext)) {
                    var reqChildren = ARIADefinitions_1.ARIADefinitions.designPatterns[roles[j]].reqChildren;
                    if (reqChildren) {
                        inScope = true;
                        passed = false;
                        var xp = "descendant::*[";
                        for (var i = 0; i < reqChildren.length; i++) {
                            xp += "@role='" + reqChildren[i] + "' or ";
                        }
                        xp = xp.substring(0, xp.length - 4) + ']';
                        var xpathResult = doc.evaluate(xp, ruleContext, legacy_1.RPTUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                        var r = xpathResult.iterateNext();
                        while (r && !passed) {
                            // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                            // or not.
                            //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                            //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                            //     add it to the roleToElems hash at all or even do any checking for it at all.
                            //
                            // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                            //       so on and so forth.
                            if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(r)) {
                                r = xpathResult.iterateNext();
                                continue;
                            }
                            passed = legacy_1.RPTUtil.isTabbable(r);
                            // Required child is not focusable via tabindex.  See if there is a grandchild that is focusable by default or by tabindex.
                            if (!passed) {
                                var xp2 = "descendant::*";
                                var xpathResult2 = doc.evaluate(xp2, r, legacy_1.RPTUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                                var r2 = xpathResult2.iterateNext();
                                while (r2 && !passed) {
                                    // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                                    // or not.
                                    //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                                    //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                                    //     add it to the roleToElems hash at all or even do any checking for it at all.
                                    //
                                    // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                                    //       so on and so forth.
                                    if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(r2)) {
                                        r2 = xpathResult2.iterateNext();
                                        continue;
                                    }
                                    passed = legacy_1.RPTUtil.isTabbable(r);
                                    r2 = xpathResult2.iterateNext();
                                }
                            }
                            if (!passed) {
                                roleNameArr = r.getAttribute("role").trim().split(" ");
                                nodeName = r.nodeName.toLowerCase();
                            }
                            r = xpathResult.iterateNext();
                        }
                    }
                }
            }
        }
        // Variable Decleration
        var retToken1 = new Array();
        var retToken2 = new Array();
        // In the case the arrays/strings are empty, that means that there is no violation so we can reset it back to passed, the reason for this
        // is that we are setting passed=false while we perform a loop which causes violation to trigger even if there is no issues. Instead of
        // updating the whole rule to switch from using passed in that way simply do the check at this point.
        if (nodeName.length > 0 && roleNameArr.length > 0) {
            retToken1.push(nodeName);
            retToken2.push(roleNameArr.join(", "));
        }
        else {
            passed = true;
        }
        //return new ValidationResult(passed, [ruleContext], 'role', '', passed == true ? [] : [retToken1, retToken2]);
        if (!inScope) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("fail_missing_child", [retToken1.toString(), retToken2.toString()]);
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 4193:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_child_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.aria_child_valid = {
    id: "aria_child_valid",
    //context: "dom:*[role]",
    //dependencies: ["Rpt_Aria_ValidRole"],
    context: "dom:*",
    dependencies: ["aria_role_valid", "aria_descendant_valid"],
    help: {
        "en-US": {
            "group": "aria_child_valid.html",
            "Pass": "aria_child_valid.html",
            "Fail_no_child": "aria_child_valid.html",
            "Fail_invalid_child": "aria_child_valid.html"
        }
    },
    messages: {
        "en-US": {
            "group": "An element with a ARIA role must own a required child",
            "Pass": "An element with a ARIA role owns a required child",
            "Fail_no_child": "The element with role \"{0}\" does not own any child element with any of the following role(s): \"{1}\"",
            "Fail_invalid_child": "The element with role \"{0}\" owns the child element with the role \"{1}\" that is not one of the allowed role(s): \"{2}\""
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    // TODO: ACT: Verify mapping
    act: ["bc4a75"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || legacy_1.RPTUtil.isNodeDisabled(ruleContext))
            return;
        //skip the check if the element requires presentational children only
        if (legacy_1.RPTUtil.containsPresentationalChildrenOnly(ruleContext))
            return;
        var roles = legacy_1.RPTUtil.getRoles(ruleContext, false);
        // if explicit role doesn't exist, get the implicit one
        if (!roles || roles.length === 0)
            roles = legacy_1.RPTUtil.getImplicitRole(ruleContext);
        //ignore if the element doesn't have any explicit or implicit role, shouldn't happen
        if (!roles || roles.length === 0)
            return null;
        // ignore if the element contains none or presentation role
        var presentationRoles = ["none", "presentation"];
        var found = roles.some(function (r) { return presentationRoles.includes(r); });
        if (found)
            return null;
        //  For combobox, we have g1193 ... g1199 to check the values etc.
        //  We don't want to trigger 1152 again. So, we bypass it here.
        if (roles.includes("combobox"))
            return null;
        var requiredChildRoles = legacy_1.RPTUtil.getRequiredChildRoles(ruleContext, true);
        // a 'group' role is allowed but not required for some elements so remove it if exists
        if (requiredChildRoles.includes('group')) {
            var index = requiredChildRoles.indexOf('group');
            if (index > -1)
                requiredChildRoles.splice(index, 1);
        }
        /**
         * ignore if a role doesn't require a child with any specific role
         * the reverse might be not true - parent will be checked in Rpt_Aria_RequiredParent_Native_Host_Sematics rule
        */
        if (requiredChildRoles.length == 0)
            return null;
        // get all the children from accessibility tree, 
        // including ones with aria-owns    
        var directATChildren = legacy_1.RPTUtil.getDirectATChildren(ruleContext);
        if (!directATChildren || directATChildren.length == 0) {
            // the element with at least one required role dosen't contain any accessible child
            /**
             * When a widget is missing required owned elements due to script execution or loading,
             * authors MUST mark a containing element with 'aria-busy' equal to true.
             */
            var busy = ruleContext.getAttribute("aria-busy");
            if (!busy || busy !== 'true') {
                var retToken = new Array();
                retToken.push(roles.join(", "));
                retToken.push(requiredChildRoles.join(", "));
                return (0, IRule_1.RuleFail)("Fail_no_child", retToken);
            }
            // it's 'busy' loading, ignore it 
            return null;
        }
        var violateElemRoles = new Array();
        for (var j = 0; j < directATChildren.length; j++) {
            var childRoles = legacy_1.RPTUtil.getRoles(directATChildren[j], false);
            // if explicit role doesn't exist, get the implicit one
            if (!childRoles || childRoles.length == 0)
                childRoles = legacy_1.RPTUtil.getImplicitRole(directATChildren[j]);
            if (childRoles && childRoles.length > 0) {
                /**
                 * when multiple roles are specified as required owned elements for a role, at least one instance of one required owned element is expected.
                 * the specification does not require an instance of each of the listed owned roles.
                 * therefore, the requirement is met if it has any one of the required roles.
                 */
                var found_1 = childRoles.some(function (r) { return requiredChildRoles.includes(r); });
                if (!found_1)
                    violateElemRoles.push(childRoles.join(", "));
            }
            else {
                // ignore the element since it's not semantic, shouldn't happen 
            }
        }
        if (violateElemRoles.length > 0) {
            var retValues = [];
            for (var i = 0; i < violateElemRoles.length; i++) {
                var retToken = new Array();
                retToken.push(roles.join(", "));
                retToken.push(violateElemRoles[i]);
                retToken.push(requiredChildRoles.join(", "));
                retValues.push((0, IRule_1.RuleFail)("Fail_invalid_child", retToken));
            }
            return retValues;
        }
        return (0, IRule_1.RulePass)("Pass");
    }
};


/***/ }),

/***/ 3188:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_complementary_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_complementary_label_unique = {
    id: "aria_complementary_label_unique",
    context: "aria:complementary",
    refactor: {
        "Rpt_Aria_MultipleComplementaryLandmarks_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_complementary_label_unique.html",
            "Fail_1": "aria_complementary_label_unique.html",
            "group": "aria_complementary_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"complementary\" role do not have unique labels",
            "group": "Each element with \"complementary\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Consider the Check Hidden Content setting that is set by the rules
        // Also, consider Implicit role checking.
        var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "complementary", true, true);
        if (landmarks.length === 0 || landmarks.length === 1) {
            return null;
        }
        var dupes = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "aria_complementary_label_unique", null);
        if (!dupes) {
            dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "aria_complementary_label_unique", dupes);
        }
        var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
        var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
        //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [myLabel]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4176:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_complementary_label_visible = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.aria_complementary_label_visible = {
    id: "aria_complementary_label_visible",
    context: "dom:*[role], dom:aside",
    dependencies: ["aria_complementary_labelled"],
    refactor: {
        "Rpt_Aria_ComplementaryLandmarkLabel_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_complementary_label_visible.html",
            "Fail_1": "aria_complementary_label_visible.html",
            "group": "aria_complementary_label_visible.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The element with \"complementary\" role does not have a visible label",
            "group": "Each element with \"complementary\" role should have a visible label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "complementary")) {
            return null;
        }
        var passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "aria-labelledby");
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
    }
};


/***/ }),

/***/ 7964:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_complementary_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.aria_complementary_labelled = {
    id: "aria_complementary_labelled",
    context: "dom:*[role], dom:aside",
    refactor: {
        "Rpt_Aria_ComplementaryRequiredLabel_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_complementary_labelled.html",
            "Fail_1": "aria_complementary_labelled.html",
            "group": "aria_complementary_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The element with \"complementary\" role does not have a label",
            "group": "An element with \"complementary\" role must have a label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "complementary")) {
            return null;
        }
        var passed = legacy_1.RPTUtil.hasAriaLabel(ruleContext);
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
    }
};


/***/ }),

/***/ 2554:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_content_in_landmark = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
var DOMWalker_1 = __webpack_require__(7440);
var VisUtil_1 = __webpack_require__(8174);
exports.aria_content_in_landmark = {
    id: "aria_content_in_landmark",
    context: "dom:*",
    refactor: {
        "Rpt_Aria_OrphanedContent_Native_Host_Sematics": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_content_in_landmark.html",
            "Fail_1": "aria_content_in_landmark.html",
            "group": "aria_content_in_landmark.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Content is not within a landmark element",
            "group": "All content must reside within an element with a landmark role"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        },
        {
            "id": ["WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var params = (0, CacheUtil_1.getCache)(context.dom.node.ownerDocument, "aria_content_in_landmark", null);
        if (!params) {
            params = {
                landmarks: {
                    value: ["banner", "complementary", "contentinfo", "form", "main", "navigation", "region", "search"],
                    type: "array"
                },
                possibleOrphanedWidgets: {
                    value: ["button", "combobox", "checkbox", "grid", "heading", "link", "list",
                        "listbox", "menu", "menubar", "progressbar", "radio", "tablist", "textbox", "toolbar", "tree",
                        "treegrid"
                    ],
                    type: "array"
                },
                possibleOrphanedElements: {
                    value: ["p", "table", "input", "textarea", "select", "button", "a", "ol", "ul", "dl", "h1", "h2", "h3", "h4", "h5",
                        "h6", "embed", "object", "area"
                    ],
                    type: "array"
                },
                noLandmarkedRoles: {
                    // These roles don't require landmarks
                    value: ["alert", "alertdialog", "dialog", "tooltip"],
                    type: "array"
                },
                mapLandmarks: {},
                mapPossibleOrphanedWidgets: {},
                mapPossibleOrphanedElements: {},
                mapNoLandmarkedRoles: {}
            };
            // Convert arrays to maps
            params.mapLandmarks = {};
            for (var i = 0; i < params.landmarks.value.length; ++i) {
                params.mapLandmarks[params.landmarks.value[i]] = true;
            }
            params.mapPossibleOrphanedWidgets = {};
            for (var i = 0; i < params.possibleOrphanedWidgets.value.length; ++i) {
                params.mapPossibleOrphanedWidgets[params.possibleOrphanedWidgets.value[i]] = true;
            }
            params.mapPossibleOrphanedElements = {};
            for (var i = 0; i < params.possibleOrphanedElements.value.length; ++i) {
                params.mapPossibleOrphanedElements[params.possibleOrphanedElements.value[i]] = true;
            }
            params.mapNoLandmarkedRoles = {};
            for (var i = 0; i < params.noLandmarkedRoles.value.length; ++i) {
                params.mapNoLandmarkedRoles[params.noLandmarkedRoles.value[i]] = true;
            }
            (0, CacheUtil_1.setCache)(context.dom.node.ownerDocument, "aria_content_in_landmark", params);
        }
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) || // avoid diagnosing g1157 for non-visible nodes
            (VisUtil_1.VisUtil.hiddenByDefaultElements != null &&
                VisUtil_1.VisUtil.hiddenByDefaultElements != undefined &&
                VisUtil_1.VisUtil.hiddenByDefaultElements.indexOf(nodeName) > -1)) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        var elemsWithoutContent = ["area", "input", "embed", "button", "textarea", "select"];
        if (!legacy_1.RPTUtil.hasInnerContentHidden(ruleContext) && //only trigger the rule on elements that have content
            elemsWithoutContent.indexOf(nodeName) === -1) { // a few elems wihout content should not be skipped
            return (0, IRule_1.RulePass)("Pass_0");
        }
        // Short circuit for layout tables
        if (nodeName == "table" && legacy_1.RPTUtil.isLayoutTable(ruleContext)) {
            return null;
        }
        // Check if it is a possible orphan
        var passed = true;
        var isPossibleOrphanedWidget = legacy_1.RPTUtil.hasRole(ruleContext, params.mapPossibleOrphanedWidgets, true);
        //exclude <link rel="stylesheet" href="xyz.css"> in the <head> and <body>(#608)
        //having link in the head could cause lot of violaions                    
        if (nodeName === 'link') {
            isPossibleOrphanedWidget = false;
        }
        var isPossibleOrphanedElement = nodeName in params.mapPossibleOrphanedElements;
        if (isPossibleOrphanedWidget || isPossibleOrphanedElement) {
            // See if ancestor has landmark roles or implicit land mark roles
            var parentRoles = contextHierarchies["aria"].map(function (info) { return info.role; });
            passed = parentRoles.filter(function (role) { return role in params.mapLandmarks; }).length > 0;
            if (!passed) {
                // Don't fail elements when a parent or sibling has failed - causes too many messages.
                var walkElement = DOMWalker_1.DOMWalker.parentElement(ruleContext);
                while (!passed && walkElement != null) {
                    passed = (0, CacheUtil_1.getCache)(walkElement, "Rpt_Aria_OrphanedContent", false);
                    walkElement = DOMWalker_1.DOMWalker.parentElement(walkElement);
                }
                walkElement = ruleContext.nextElementSibling;
                while (!passed && walkElement != null) {
                    passed = (0, CacheUtil_1.getCache)(walkElement, "Rpt_Aria_OrphanedContent", false);
                    walkElement = walkElement.nextElementSibling;
                }
                walkElement = ruleContext.previousElementSibling;
                while (!passed && walkElement != null) {
                    passed = (0, CacheUtil_1.getCache)(walkElement, "Rpt_Aria_OrphanedContent", false);
                    walkElement = walkElement.previousElementSibling;
                }
                if (!passed) {
                    (0, CacheUtil_1.setCache)(ruleContext, "Rpt_Aria_OrphanedContent", true);
                    // Don't trigger rule if element is a stand-alone widget
                    passed = (0, CacheUtil_1.getCache)(ruleContext, "Rpt_Aria_OrphanedContent_NoTrigger", false) ||
                        legacy_1.RPTUtil.hasRole(ruleContext, params.mapNoLandmarkedRoles, true) ||
                        legacy_1.RPTUtil.getAncestorWithRole(ruleContext, params.mapNoLandmarkedRoles, true);
                    if (passed) {
                        (0, CacheUtil_1.setCache)(ruleContext, "Rpt_Aria_OrphanedContent_NoTrigger", true);
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
        }
        else {
            return null;
        }
        //return new ValidationResult(passed, [ruleContext], '', '', []);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 1229:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_contentinfo_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_contentinfo_label_unique = {
    id: "aria_contentinfo_label_unique",
    context: "aria:contentinfo",
    refactor: {
        "Rpt_Aria_MultipleContentinfoLandmarks_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_contentinfo_label_unique.html",
            "Fail_1": "aria_contentinfo_label_unique.html",
            "group": "aria_contentinfo_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"contentinfo\" role do not have unique labels",
            "group": "Each element with \"contentinfo\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Consider the Check Hidden Content setting that is set by the rules
        // Also, consider Implicit role checking.
        var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "contentinfo", true, true);
        if (landmarks.length === 0 || landmarks.length === 1) {
            return null;
        }
        var dupes = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "aria_contentinfo_label_unique", null);
        if (!dupes) {
            dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "aria_contentinfo_label_unique", dupes);
        }
        var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
        var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
        //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [myLabel]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 8523:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_contentinfo_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.aria_contentinfo_misuse = {
    id: "aria_contentinfo_misuse",
    context: "dom:*[role], dom:footer, dom:address",
    refactor: {
        "Rpt_Aria_ContentinfoWithNoMain_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_contentinfo_misuse.html",
            "Fail_1": "aria_contentinfo_misuse.html",
            "group": "aria_contentinfo_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The element with \"contentinfo\" role is present without an element with \"main\" role",
            "group": "An element with \"contentinfo\" role is only permitted with an element with \"main\" role"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //consider implicit role
        if (!legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "contentinfo")) {
            return null;
        }
        // Consider the Check Hidden Content setting that is set by the rules
        var passed = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "main", true, true).length > 0;
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 3781:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_contentinfo_single = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.aria_contentinfo_single = {
    id: "aria_contentinfo_single",
    context: "dom:*[role], dom:footer, dom:address",
    refactor: {
        "Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_contentinfo_single.html",
            "Fail_1": "aria_contentinfo_single.html",
            "group": "aria_contentinfo_single.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"contentinfo\" role found on a page",
            "group": "A page, document or application should only have one element with \"contentinfo\" role"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //find out if <footer> element has siblings as <footer> has implicit contentinfo role
        if (!legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "contentinfo")) {
            return null;
        }
        var passed = !legacy_1.RPTUtil.getSiblingWithRoleHidden(ruleContext, "contentinfo", true, true);
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 8509:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_descendant_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.aria_descendant_valid = {
    id: "aria_descendant_valid",
    context: "dom:*",
    dependencies: ["aria_role_valid"],
    help: {
        "en-US": {
            "group": "aria_descendant_valid.html",
            "pass": "aria_descendant_valid.html",
            "potential_child_implicit_role": "aria_descendant_valid.html",
            "fail_child_explicit_role": "aria_descendant_valid.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Browsers ignore the explicit and implicit ARIA roles of the descendants of certain elements",
            "pass": "The element contains valid descendants",
            "potential_child_implicit_role": "The element with role \"{0}\" contains descendants with implicit roles \"{1}\" which are ignored by browsers",
            "fail_child_explicit_role": "The element with role \"{0}\" contains descendants with roles \"{1}\" which are ignored by browsers"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    // TODO: ACT: Verify mapping
    act: ["307n5z"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || legacy_1.RPTUtil.isNodeDisabled(ruleContext))
            return;
        //skip the check if the element doesn't require presentational children only
        if (!legacy_1.RPTUtil.containsPresentationalChildrenOnly(ruleContext))
            return;
        var roles = legacy_1.RPTUtil.getRoles(ruleContext, false);
        // if explicit role doesn't exist, get the implicit one
        if (!roles || roles.length === 0)
            roles = legacy_1.RPTUtil.getImplicitRole(ruleContext);
        //ignore if the element doesn't have any explicit or implicit role, shouldn't happen
        if (!roles || roles.length === 0)
            return null;
        var tagName = ruleContext.tagName.toLowerCase();
        // get all the children from accessibility tree, 
        // including ones with aria-owns    
        var directATChildren = legacy_1.RPTUtil.getDirectATChildren(ruleContext);
        if (directATChildren && directATChildren.length > 0) {
            // the element with at least one non-presentational children
            var explicitRoles = new Array();
            var implicitRoles = new Array();
            for (var j = 0; j < directATChildren.length; j++) {
                // ignore <img> and <svg>
                var tag = directATChildren[j].nodeName.toLowerCase();
                if (tag === 'img' || tag === 'svg')
                    continue;
                // get explicit role if exists
                var childRoles = legacy_1.RPTUtil.getRoles(directATChildren[j], false);
                if (childRoles && childRoles.length > 0) {
                    explicitRoles.push(childRoles.join(", "));
                }
                else {
                    // get implicit role if exists
                    childRoles = legacy_1.RPTUtil.getImplicitRole(directATChildren[j]);
                    if (childRoles && childRoles.length > 0)
                        implicitRoles.push(childRoles.join(", "));
                }
            }
            if (explicitRoles.length > 0) {
                var retValues = [];
                for (var i = 0; i < explicitRoles.length; i++) {
                    var retToken = new Array();
                    retToken.push(roles.join(", "));
                    retToken.push(explicitRoles[i]);
                    retValues.push((0, IRule_1.RuleFail)("fail_child_explicit_role", retToken));
                }
                return retValues;
            }
            if (implicitRoles.length > 0) {
                var retValues = [];
                for (var i = 0; i < implicitRoles.length; i++) {
                    var retToken = new Array();
                    retToken.push(roles.join(", "));
                    retToken.push(implicitRoles[i]);
                    retValues.push((0, IRule_1.RulePotential)("potential_child_implicit_role", retToken));
                }
                return retValues;
            }
        }
        else
            return (0, IRule_1.RulePass)("pass");
    }
};


/***/ }),

/***/ 3234:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_document_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_document_label_unique = {
    id: "aria_document_label_unique",
    context: "aria:document",
    refactor: {
        "Rpt_Aria_MultipleDocumentRoles": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_document_label_unique.html",
            "Fail_1": "aria_document_label_unique.html",
            "group": "aria_document_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with a \"document\" role do not have unique labels",
            "group": "All elements with a \"document\" role must have unique labels"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Consider the Check Hidden Content setting that is set by the rules
        // Also, consider Implicit role checking.
        var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "document", true, true);
        if (landmarks.length === 0 || landmarks.length === 1) {
            return null;
        }
        var dupes = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "aria_document_label_unique", null);
        if (!dupes) {
            dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "aria_document_label_unique", dupes);
        }
        var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
        var passed = myLabel === "" || !(myLabel in dupes) || dupes[myLabel] <= 1;
        // return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [myLabel]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 5217:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_eventhandler_role_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.aria_eventhandler_role_valid = {
    id: "aria_eventhandler_role_valid",
    context: "dom:*[onclick],dom:*[onblur], dom:*[ondblclick], dom:*[onfocus], dom:*[onkeydown],dom:*[onkeypress], dom:*[onkeyup], dom:*[onmousedown], dom:*[onmouseup], dom:*[onmousemove], dom:*[onmouseout], dom:*[onmouseover], dom:*[onresize], dom:*[onchange]",
    refactor: {
        "Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_eventhandler_role_valid.html",
            "Fail_1": "aria_eventhandler_role_valid.html",
            "group": "aria_eventhandler_role_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The <{0}> element with '{1}' does not have a valid ARIA role specified",
            "group": "Elements with event handlers must have a valid ARIA role"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Don't trigger this for SVG element for now until a determination is made (by Rich)
        // to support SVG at a point when the SVG a11y spec is ready.
        if (legacy_1.RPTUtil.getAncestor(ruleContext, "svg")) {
            return null;
        }
        //this rule is passed if a element has attribut role 
        //also, passed of element has any implicit roles. 
        if (legacy_1.RPTUtil.hasAnyRole(ruleContext, true)) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        //pass if this element is received focus by default
        if (legacy_1.RPTUtil.isfocusableByDefault(ruleContext)) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        //validate if this element has any of the given event handler's
        var retToken1 = new Array();
        retToken1.push(ruleContext.nodeName.toLowerCase());
        var eventArr = new Array();
        // From WCAG20_Script_UseW3CDomFunctions
        //let events = ["onblur", "onfocus", "onchange", "onclick", "oncontextmenu", "ondblclick", "onkeydown",
        //              "onkeypress", "onkeyup", "onload", "onmousedown", "onmouseup", "onmousemove", "onmouseout",
        //              "onmouseover", "onmousewheel", "onreset", "onpaste", "onresize", "onscroll",
        //              "onselect", "onsubmit", "onactivate", "ondeactivate", "onmouseenter", "onmouseleave"];
        var events = ["onblur", "onfocus", "onchange", "onclick", "ondblclick", "onkeydown",
            "onkeypress", "onkeyup", "onmousedown", "onmouseup", "onmousemove", "onmouseout",
            "onmouseover", "onresize"
        ];
        for (var i = 0; i < events.length; ++i) {
            if (ruleContext.hasAttribute(events[i]))
                eventArr.push(events[i]);
        }
        var retToken2 = new Array();
        retToken2.push(eventArr.join(", "));
        //return new ValidationResult(false, [ruleContext], '', '', [retToken1, retToken2]);
        return (0, IRule_1.RuleFail)("Fail_1", [retToken1.toString(), retToken2.toString()]);
    }
};


/***/ }),

/***/ 4050:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_form_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_form_label_unique = {
    id: "aria_form_label_unique",
    context: "aria:form",
    refactor: {
        "Rpt_Aria_MultipleFormLandmarks_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_form_label_unique.html",
            "Fail_1": "aria_form_label_unique.html",
            "group": "aria_form_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"form\" role do not have unique labels",
            "group": "Each element with \"form\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Per https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/landmarks/HTML5.html
        // form element should only be considered if it has an aria label or title
        if (ruleContext.getAttribute("role") === "form" ||
            ruleContext.hasAttribute("aria-label") ||
            ruleContext.hasAttribute("aria-labelledby") ||
            ruleContext.hasAttribute("title")) {
            // Consider the Check Hidden Content setting that is set by the rules
            // Also, consider Implicit role checking.
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "form", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var dupes = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "aria_form_label_unique", null);
            if (!dupes) {
                dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "aria_form_label_unique", dupes);
            }
            var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            var passed = myLabel !== "" &&
                (!(myLabel in dupes) || dupes[myLabel] <= 1);
            if (!passed) {
                return (0, IRule_1.RuleFail)("Fail_1", [myLabel]);
            }
            else {
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
        else {
            return null;
        }
    }
};


/***/ }),

/***/ 4275:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_graphic_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.aria_graphic_labelled = {
    id: "aria_graphic_labelled",
    context: "aria:graphics-document,aria:graphics-symbol",
    refactor: {
        "HAAC_Aria_SvgAlt": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
        }
    },
    help: {
        "en-US": {
            "group": "aria_graphic_labelled.html",
            "Pass_0": "aria_graphic_labelled.html",
            "Fail_1": "aria_graphic_labelled.html",
            "Fail_2": "aria_graphic_labelled.html",
            "Fail_3": "aria_graphic_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "group": "An element with a graphics role must have a non-empty label",
            "Pass_0": "Rule Passed",
            "Fail_1": "Element with \"{0}\" graphics role has no label",
            "Fail_2": "Element with \"{0}\" graphics role has no label or an empty label",
            "Fail_3": "Element with \"{0}\" graphics role missing non-empty 'aria-label' or 'aria-labelledby'"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [{
            "7d6734": {
                "Pass_0": "pass",
                "Fail_1": "inapplicable",
                "Fail_2": "fail",
                "Fail_3": "inapplicable"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        if (!ruleContext.hasAttribute("role") || !ruleContext.getAttribute("role").includes("graphics-"))
            return null;
        /* removed the role check role= presentation since if an element has role=img, then there needs to be a check for alt attribute regardless of the presecne of role=presentation
        if (RPTUtil.hasRole(ruleContext, "presentation") || RPTUtil.hasRole(ruleContext, "none")){
                return RulePass(1);
        }*/
        /* JCH - Points of failure
         *    0. Missing alt attr with value
         *    1. Missing aria-label or aria-labelledby
         *    2. Missing title attr with value
         */
        // Skip an image with a structural role - img must be in the role list at least
        if (ruleContext.getAttribute("aria-hidden") === "true")
            return null;
        // If role === img, you must use an aria label
        //check attributes aria-label and aria-labelledby for other tags (e.g. <div>, <span>, etc)
        var passed = legacy_1.RPTUtil.getAriaLabel(ruleContext).length > 0;
        if (!passed && ruleContext.nodeName.toLowerCase() === "svg") {
            var svgTitle = ruleContext.querySelector("title");
            passed = svgTitle && legacy_1.RPTUtil.hasInnerContent(svgTitle);
        }
        if (!passed) {
            //check title attribute
            passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title");
            // We should guide people to use alt or label - this is just a secondary approach to silence the rule.
            // So, we should keep the POF from above.
            // if (!passed) POF = "Fail_3";
        }
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_2", [ruleContext.getAttribute("role")]);
        }
    }
};


/***/ }),

/***/ 1465:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_hidden_nontabbable = void 0;
var legacy_1 = __webpack_require__(8422);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.aria_hidden_nontabbable = {
    id: "aria_hidden_nontabbable",
    context: "dom:*[aria-hidden=true], dom:*[aria-hidden=true] dom:*",
    refactor: {
        "aria_hidden_focus_misuse": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_hidden_nontabbable.html",
            "Pass_0": "aria_hidden_nontabbable.html",
            "Fail_1": "aria_hidden_nontabbable.html"
        }
    },
    messages: {
        "en-US": {
            "group": "A focusable element should not be within the subtree of an element with 'aria-hidden' set to \"true\"",
            "Pass_0": "Rule Passed",
            "Fail_1": "Element \"{0}\" should not be focusable within the subtree of an element with an 'aria-hidden' attribute with value 'true'"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: ["1.3.1", "4.1.2"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    // TODO: ACT: Handle testcase with focus jumping away
    act: "6cfa84",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (legacy_1.RPTUtil.isTabbable(ruleContext)) {
            return (0, IRule_1.RuleFail)("Fail_1", [nodeName]);
        }
        return (0, IRule_1.RulePass)("Pass_0");
    }
};


/***/ }),

/***/ 405:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_id_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var fragment_1 = __webpack_require__(482);
var ARIADefinitions_1 = __webpack_require__(8235);
var VisUtil_1 = __webpack_require__(8174);
exports.aria_id_unique = {
    id: "aria_id_unique",
    context: "dom:*",
    refactor: {
        "Rpt_Aria_ValidIdRef": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_id_unique.html",
            "Fail_1": "aria_id_unique.html",
            "group": "aria_id_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The 'id' \"{0}\" specified for the ARIA property '{1}' value is not valid",
            "group": "The ARIA property must reference a non-empty unique id of an existing element that is visible"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    // TODO: ACT: 6a7281 - Need a separate reason code when the property is not required. ACT says it's okay to be
    // invalid when not required. I think we should still fail, but flag it as a different reason so that we can have a subset
    // aligns with ACT.
    act: ["59796f", "6a7281"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var pass = true;
        var attrNameArr = new Array();
        var nonExistantIDs = new Array();
        var ownerDocument = fragment_1.FragmentUtil.getOwnerFragment(ruleContext);
        var contextAttributes = ruleContext.attributes;
        var idTokens = new Array();
        var testedReferences = 0;
        if (contextAttributes) {
            for (var i = 0, attrLength = contextAttributes.length; i < attrLength; i++) {
                pass = true;
                var attrName = contextAttributes[i].name;
                if (legacy_1.RPTUtil.isDefinedAriaAttribute(ruleContext, attrName)) {
                    var dataTypes = ARIADefinitions_1.ARIADefinitions.propertyDataTypes[attrName];
                    if (dataTypes && dataTypes.type) {
                        var supportsOneIDRef = (dataTypes.type == "http://www.w3.org/2001/XMLSchema#idref") ? true : false;
                        //If the data type supports one or more id refs do error checking
                        if (supportsOneIDRef || (dataTypes.type == "http://www.w3.org/2001/XMLSchema#idrefs")) {
                            testedReferences++;
                            var nodeValueLength = legacy_1.RPTUtil.normalizeSpacing(contextAttributes[i].nodeValue).length;
                            var idArray = contextAttributes[i].nodeValue.split(" ");
                            // Check for an empty ID Ref
                            if (nodeValueLength < 1) {
                                pass = false;
                                idTokens.push("\"" + contextAttributes[i].nodeValue + "\"");
                            }
                            // check to see if too many IDRefs
                            else if (supportsOneIDRef) {
                                //If has too many IDRefs it is an error
                                if (nodeValueLength >= 1) {
                                    if (idArray.length > 1) {
                                        pass = false;
                                        // Need to capture all the IDRefs for idTokens
                                        for (var z = 0, length_1 = idArray.length; z < length_1; ++z) {
                                            if (idArray[z] != "") {
                                                idTokens.push(idArray[z]);
                                            }
                                        }
                                    }
                                }
                            }
                            // check to see if id refs are invalid
                            if (pass && nodeValueLength >= 1) {
                                for (var j = 0, length_2 = idArray.length; j < length_2; ++j) {
                                    if (idArray[j].length > 0) { // it is an empty string if spaces are one after the other
                                        // Get the element by Id
                                        var elementById = ownerDocument.getElementById(idArray[j]);
                                        // Pass if the element exists
                                        pass = elementById != null;
                                        // If the element exists and this is an aria attribute that doesn't support hidden ID reference
                                        // then perform a isNodeVisible check, in the case the node is not visible then we return
                                        // false and true otherwise.
                                        if (pass && !dataTypes.hiddenIDRefSupported) {
                                            pass = VisUtil_1.VisUtil.isNodeVisible(elementById);
                                        }
                                        if (!pass) {
                                            if (idArray[j] != "") {
                                                idTokens.push(idArray[j]);
                                            }
                                        }
                                        // Only one of the id references need to be valid to mark the rule as passed.
                                        // Therefore if we find a single visible element then stop checking and mark as
                                        // passed.
                                        else {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (!pass)
                        attrNameArr.push(attrName);
                }
            }
        }
        var passed = attrNameArr.length == 0;
        var retToken1 = new Array();
        var retToken2 = new Array();
        var retToken3 = new Array();
        if (!passed) {
            retToken2.push(attrNameArr.join(", "));
            retToken3.push(ruleContext.nodeName.toLowerCase());
            if (idTokens.length > 0) {
                retToken1.push(idTokens.join(", "));
            }
        }
        //return new ValidationResult(passed, [ruleContext], attrNameArr, '', passed == true ? [] : [retToken1, retToken2, retToken3]);
        if (testedReferences == 0) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [retToken1.toString(), retToken2.toString(), retToken3.toString()]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 9136:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_img_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.aria_img_labelled = {
    id: "aria_img_labelled",
    context: "aria:img",
    refactor: {
        "HAAC_Aria_ImgAlt": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
        }
    },
    help: {
        "en-US": {
            "group": "aria_img_labelled.html",
            "Pass_0": "aria_img_labelled.html",
            "Fail_1": "aria_img_labelled.html",
            "Fail_2": "aria_img_labelled.html",
            "Fail_3": "aria_img_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "group": "An element with \"img\" role must have a non-empty label",
            "Pass_0": "Rule Passed",
            "Fail_1": "Element with \"img\" role has no label",
            "Fail_2": "Element with \"img\" role has no label or an empty label",
            "Fail_3": "Element with \"img\" role missing non-empty 'aria-label' or 'aria-labelledby'"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: ["23a2a8", {
            "7d6734": {
                "Pass_0": "pass",
                "Fail_1": "inapplicable",
                "Fail_2": "fail",
                "Fail_3": "inapplicable"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        if (!ruleContext.hasAttribute("role")) {
            // If no role, this is implicit, and covered by WCAG20_Img_HasAlt
            return null;
        }
        /* removed the role check role= presentation since if an element has role=img, then there needs to be a check for alt attribute regardless of the presecne of role=presentation
        if (RPTUtil.hasRole(ruleContext, "presentation") || RPTUtil.hasRole(ruleContext, "none")){
                return RulePass(1);
        }*/
        /* JCH - Points of failure
         *    0. Missing alt attr with value
         *    1. Missing aria-label or aria-labelledby
         *    2. Missing title attr with value
         */
        // Skip an image with a structural role - img must be in the role list at least
        if (ruleContext.getAttribute("aria-hidden") === "true")
            return null;
        // If role === img, you must use an aria label
        //check attributes aria-label and aria-labelledby for other tags (e.g. <div>, <span>, etc)
        var passed = legacy_1.RPTUtil.getAriaLabel(ruleContext).length > 0;
        if (!passed && ruleContext.nodeName.toLowerCase() === "svg") {
            var svgTitle = ruleContext.querySelector("title");
            passed = svgTitle && legacy_1.RPTUtil.hasInnerContent(svgTitle);
        }
        if (!passed) {
            //check title attribute
            passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title");
            // We should guide people to use alt or label - this is just a secondary approach to silence the rule.
            // So, we should keep the POF from above.
            // if (!passed) POF = "Fail_3";
        }
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_2");
        }
    }
};


/***/ }),

/***/ 5117:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_keyboard_handler_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var ARIADefinitions_1 = __webpack_require__(8235);
exports.aria_keyboard_handler_exists = {
    id: "aria_keyboard_handler_exists",
    context: "dom:*[role]",
    dependencies: ["aria_role_allowed"],
    refactor: {
        "Rpt_Aria_MissingKeyboardHandler": {
            "pass": "pass",
            "potential_no_keyboard_access": "potential_no_keyboard_access"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_keyboard_handler_exists.html",
            "potential_no_keyboard_access": "aria_keyboard_handler_exists.html",
            "group": "aria_keyboard_handler_exists.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "potential_no_keyboard_access": "Verify the <{0}> element with \"{1}\" role has keyboard access",
            "group": "Interactive WAI_ARIA UI components must provide keyboard access"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = true;
        var savedPassed = passed;
        var doc = ruleContext.ownerDocument;
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        var roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
        var nodeName = ruleContext.nodeName.toLowerCase();
        //if an explicit role is specified, the 'aria_role_redundant' rule should be triggered and addressed first,
        // and the current rule should be ignored
        if (nodeName === 'datalist' && roles && roles.includes("listbox"))
            return null;
        var hasAttribute = legacy_1.RPTUtil.hasAttribute;
        // Composite user interface widget roles. They act as containers that manage other, contained widgets.
        var roleContainers = ["combobox", "grid", "listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"];
        var roleNameArr = new Array();
        for (var j = 0; j < roles.length; ++j) {
            var pattern = designPatterns[roles[j]];
            if (roleContainers.indexOf(roles[j]) >= 0) {
                var disabled = hasAttribute(ruleContext, 'aria-disabled') ? ruleContext.getAttribute("aria-disabled") : '';
                if (!disabled) {
                    // See if there is a keyboard event handler on the parent element.
                    passed = (ruleContext.hasAttribute("onkeydown") || ruleContext.hasAttribute("onkeypress"));
                    // No keyboard event handler found on parent.  See if keyboard event handlers are on required child elements.
                    if (!passed) {
                        if (!hasAttribute(ruleContext, 'aria-activedescendant')) {
                            var reqChildren = ARIADefinitions_1.ARIADefinitions.designPatterns[roles[j]].reqChildren;
                            if (reqChildren) { /* SMF TODO menubar does not have any reqChildren */
                                for (var i = 0, requiredChildrenLength = reqChildren.length; i < requiredChildrenLength; i++) {
                                    var xp = "*[contains(@role,'" + reqChildren[i] + "')]";
                                    var xpathResult = doc.evaluate(xp, ruleContext, legacy_1.RPTUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                                    var r = xpathResult.iterateNext();
                                    while (r) {
                                        passed = (r.hasAttribute("onkeydown") || r.hasAttribute("onkeypress"));
                                        if (!passed) {
                                            // Child did not have a key handler.  See if any of the grandchildren do.
                                            var xp2 = "descendant::*";
                                            var xpathResult2 = doc.evaluate(xp2, r, legacy_1.RPTUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                                            var r2 = xpathResult2.iterateNext();
                                            while (r2 && !passed) {
                                                // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                                                // or not.
                                                //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                                                //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                                                //     add it to the roleToElems hash at all or even do any checking for it at all.
                                                //
                                                // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                                                //       so on and so forth.
                                                if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(r2)) {
                                                    r2 = xpathResult2.iterateNext();
                                                    continue;
                                                }
                                                passed = legacy_1.RPTUtil.isTabbable(r2) &&
                                                    (r2.hasAttribute("onkeydown") || r2.hasAttribute("onkeypress"));
                                                if (!passed) {
                                                    // Is this an action link?
                                                    if (r2.nodeName.toLowerCase() == "a" && r2.hasAttribute("href")) {
                                                        var href = r2.getAttribute("href");
                                                        // Action link must start with "javascript:", must not contain a "void" and
                                                        // must have a function name following "javascript:" (i.e., href.length > 11)
                                                        passed = (href.startsWith("javascript:") && href.indexOf("void") == -1 && href.length > 11);
                                                    }
                                                }
                                                r2 = xpathResult2.iterateNext();
                                            }
                                        }
                                        if (!passed) {
                                            // All the required children (or any descendants of the required children) must have keypress/keydown
                                            // If not, it is a failure, no need to keep checking any more.
                                            break;
                                        }
                                        r = xpathResult.iterateNext();
                                    }
                                }
                            }
                            else {
                                // The current element failed the keydown/keypress, and it does not have required children, such as menubar.
                                // Let's check its descendants.
                                var xp2 = "descendant::*";
                                var xpathResult2 = doc.evaluate(xp2, ruleContext, legacy_1.RPTUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                                var r2 = xpathResult2.iterateNext();
                                while (r2 && !passed) {
                                    // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                                    // or not.
                                    //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                                    //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                                    //     add it to the roleToElems hash at all or even do any checking for it at all.
                                    //
                                    // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                                    //       so on and so forth.
                                    if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(r2)) {
                                        r2 = xpathResult2.iterateNext();
                                        continue;
                                    }
                                    passed = legacy_1.RPTUtil.isTabbable(r2) &&
                                        (r2.hasAttribute("onkeydown") || r2.hasAttribute("onkeypress"));
                                    if (!passed) {
                                        // Is this an action link?
                                        if (r2.nodeName.toLowerCase() == "a" && r2.hasAttribute("href")) {
                                            var href = r2.getAttribute("href");
                                            // Action link must start with "javascript:", must not contain a "void" and
                                            // must have a function name following "javascript:" (i.e., href.length > 11)
                                            passed = (href.startsWith("javascript:") && href.indexOf("void") == -1 && href.length > 11);
                                        }
                                    }
                                    r2 = xpathResult2.iterateNext();
                                }
                            }
                        }
                        else {
                            // Attribute 'aria-activedescendant' is specified.
                            passed = true;
                        }
                    }
                }
            }
            if (!passed) {
                roleNameArr.push(roles[j]);
            }
            if (!passed && savedPassed) {
                savedPassed = passed;
            }
        }
        var retToken1 = new Array();
        retToken1.push(ruleContext.nodeName.toLowerCase());
        var retToken2 = new Array();
        retToken2.push(roleNameArr.join(", "));
        // Determine if this is referenced by a combobox. If so, leave it to the combobox rules to check
        var id = ruleContext.getAttribute("id");
        if (id && id.trim().length > 0) {
            if (ruleContext.ownerDocument.querySelector("*[aria-controls='".concat(id, "'][role='combobox']"))) {
                return null;
            }
        }
        return savedPassed ? (0, IRule_1.RulePass)("pass") : (0, IRule_1.RulePotential)("potential_no_keyboard_access", [retToken1.toString(), retToken2.toString()]);
    }
};


/***/ }),

/***/ 9062:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_landmark_name_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var ARIAMapper_1 = __webpack_require__(4944);
var DOMUtil_1 = __webpack_require__(295);
var fragment_1 = __webpack_require__(482);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_landmark_name_unique = {
    id: "aria_landmark_name_unique",
    context: "aria:complementary, aria:banner, aria:contentinfo, aria:main, aria:navigation, aria:region, aria:search, aria:form",
    refactor: {
        "landmark_name_unique": {
            "Pass_0": "Pass_0",
            "Fail_0": "Fail_0"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_landmark_name_unique.html",
            "Fail_0": "aria_landmark_name_unique.html",
            "group": "aria_landmark_name_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Multiple \"{0}\" landmarks with the same parent region are distinguished by unique 'aria-label' or 'aria-labelledby'",
            "Fail_0": "Multiple \"{0}\" landmarks with the same parent region are not distinguished from one another because they have the same \"{1}\" label",
            "group": "Multiple landmarks should have a unique 'aria-labelledby' or 'aria-label' or be nested in a different parent regions"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        },
        {
            "id": ["WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        // TODO do I need to fiter out bad contentinfo nodes: The footer element is not a contentinfo landmark when it is a descendant of the following HTML5 sectioning elements: https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/landmarks/HTML5.html
        var ruleContext = context["dom"].node;
        // Checking if this landmark is inside a dialog element. If it is we are going to skip checking it. 
        var copyOfRuleContext = ruleContext;
        var parnetNodesOfRuleContext = [];
        while (copyOfRuleContext) {
            parnetNodesOfRuleContext.unshift(copyOfRuleContext);
            copyOfRuleContext = copyOfRuleContext.parentElement;
        }
        parnetNodesOfRuleContext.forEach(function (elem) {
            if (elem !== null) {
                if (elem.tagName == "DIALOG" || elem.getAttribute('role') == "dialog") {
                    return null; // Skipping checking landmarks that happen to be inside dialog elements
                }
            }
        });
        // Begining formCache work
        var ownerDocument = fragment_1.FragmentUtil.getOwnerFragment(ruleContext);
        var formCache = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "aria_landmark_name_unique", null);
        if (!formCache) {
            // console.log("---------ENTERING FORM CACHE")
            formCache = {
                navigationNodes: [],
                navigationNodesComputedLabels: [],
                navigationNodesParents: [],
                navigationNodesMatchFound: []
            };
            var navigationNodesTemp = ownerDocument.querySelectorAll('aside,[role="complementary"], footer,[role="contentinfo"], header,[role="banner"], main,[role="main"], nav,[role="navigation"], form,[role="form"], section,[role="region"],[role="search"]');
            var navigationNodes = Array.from(navigationNodesTemp);
            var navigationNodesParents = [];
            var navigationNodesMatchFound = [];
            // This block of code filters out any nav elements that are under an dialog. As those are not ones we want to test against as we consider dialogs are separate locations from the rest of the main page.    
            var navigationNodesWithoutDialogs = [];
            for (var i = 0; i < navigationNodes.length; i++) {
                var a = navigationNodes[i];
                var dialogNodeFoundFlag = false;
                while (a) {
                    a = a.parentElement;
                    if (a !== null) {
                        if (a.tagName == "DIALOG" || a.getAttribute('role') == "dialog") {
                            dialogNodeFoundFlag = true;
                        }
                    }
                }
                if (!dialogNodeFoundFlag) {
                    navigationNodesWithoutDialogs.push(navigationNodes[i]);
                }
            }
            navigationNodes = navigationNodesWithoutDialogs;
            for (var i = 0; i < navigationNodes.length; i++) {
                // Loop over all the landmark nodes
                var els = [];
                var a = navigationNodes[i].parentElement;
                while (a) {
                    els.push(a);
                    a = a.parentElement;
                }
                for (var j = 0; j < els.length; j++) {
                    // Loop over all the parents of the landmark nodes
                    // Find nearest landmark parent based on the tagName or the role attribute
                    var tagNameTrigger = [
                        "ASIDE",
                        "FOOTER",
                        "FORM",
                        "HEADER",
                        "MAIN",
                        "NAV",
                        "SECTION",
                    ].includes(els[j].tagName);
                    var roleNameTrigger = false;
                    if (els[j].hasAttribute("role")) {
                        roleNameTrigger = [
                            "complementary",
                            "contentinfo",
                            "form",
                            "banner",
                            "main",
                            "navigation",
                            "region",
                            "search",
                        ].includes(els[j].getAttribute("role")); // TODO we are not covering the case where a elemenent with multiple roles. E.g. role = "form banner". This is a improvment we might want to add in the future.
                    }
                    if (tagNameTrigger || roleNameTrigger) {
                        // Nearest parent-landmark found
                        navigationNodesParents.push(els[j]);
                        break;
                    }
                    if (j === els.length - 1) {
                        // This node is at the head of the file so it does not have a parent
                        navigationNodesParents.push(null);
                        break;
                    }
                }
            }
            var navigationNodesComputedLabels = [];
            for (var i = 0; i < navigationNodes.length; i++) {
                // Loop over all the landmark nodes
                navigationNodesComputedLabels.push(ARIAMapper_1.ARIAMapper.computeName(navigationNodes[i]));
            }
            for (var i = 0; i < navigationNodesParents.length; i++) {
                // Loop over all the parents of the landmark nodes to find duplicates
                var matchFound = false;
                var pass_0_flag = false;
                for (var j = 0; j < navigationNodesParents.length; j++) {
                    if (j === i) {
                        // We do not want to compare against ourselfs
                        continue;
                    }
                    // This if statement focus on the case where the parent landmark is null
                    if (navigationNodesParents[i] === null &&
                        navigationNodesParents[j] === null) {
                        // We are looking at two root nodes, so we should compare them.
                        if (ARIAMapper_1.ARIAMapper.nodeToRole(navigationNodes[i]) ===
                            ARIAMapper_1.ARIAMapper.nodeToRole(navigationNodes[j])) {
                            // Both nodes have the same role AND
                            if (navigationNodesComputedLabels[i] ===
                                navigationNodesComputedLabels[j]) {
                                // both have the same (computed) aria-label/aria-labelledby
                                // if (navigationNodesComputedLabels[i] === "") {
                                navigationNodesMatchFound.push("Fail_0"); // Fail 0
                                matchFound = true;
                                break;
                                // }
                            }
                            else {
                                // Same parents && same node roles BUT different computed aria-label/aria-labelledby
                                // We have at least a Pass_0. But we need to check all nodes to see if another one fails. So set a flag.
                                pass_0_flag = true;
                            }
                        }
                        else {
                            // Same parents but different node roles // Not applicable
                        }
                    }
                    else if (navigationNodesParents[i] === null ||
                        navigationNodesParents[j] === null) {
                        // We are looking at a single root node
                        continue;
                    }
                    // This if statement focus on the case where the parent landmark is NOT null
                    if (DOMUtil_1.DOMUtil.sameNode(navigationNodesParents[i], navigationNodesParents[j])) {
                        // We have the same parent-landmark AND
                        if (ARIAMapper_1.ARIAMapper.nodeToRole(navigationNodes[i]) ===
                            ARIAMapper_1.ARIAMapper.nodeToRole(navigationNodes[j])) {
                            // Both nodes have the same role AND
                            if (navigationNodesComputedLabels[i] ===
                                navigationNodesComputedLabels[j]) {
                                // both have the same (computed) aria-label/aria-labelledby
                                // if (navigationNodesComputedLabels[i] === "") {
                                navigationNodesMatchFound.push("Fail_0"); // Fail 0
                                matchFound = true;
                                break;
                                // }
                            }
                            else {
                                // Same parents && same node roles BUT different computed aria-label/aria-labelledby
                                // We have at least a Pass_0. But we need to check all nodes to see if another one fails. So set a flag.
                                pass_0_flag = true;
                            }
                        }
                        else {
                            // Same parents but different node roles // Not applicable
                        }
                    }
                    else {
                        // Different parents // Not applicable
                    }
                }
                if (!matchFound) {
                    if (pass_0_flag) {
                        navigationNodesMatchFound.push("Pass_0");
                    }
                    else {
                        navigationNodesMatchFound.push("null"); // This is not the keyword null on purpose. It is a spaceholder in the array so indexes match up.
                    }
                }
            }
            formCache.navigationNodesComputedLabels =
                navigationNodesComputedLabels;
            formCache.navigationNodes = navigationNodes;
            formCache.navigationNodesParents = navigationNodesParents;
            formCache.navigationNodesMatchFound = navigationNodesMatchFound;
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "aria_landmark_name_unique", formCache);
            // TODO Add validation that all 3 arrays are the same length
            // console.log("-------------End formCache")
        } // End formCache
        var indexToCheck = -1;
        for (var i = 0; i < formCache.navigationNodes.length; i++) {
            if (ruleContext.isSameNode(formCache.navigationNodes[i])) {
                indexToCheck = i;
            }
        }
        if (indexToCheck === -1) {
            return null;
        }
        if (formCache.navigationNodesMatchFound[indexToCheck] === "Pass_0") {
            return (0, IRule_1.RulePass)("Pass_0", [
                ARIAMapper_1.ARIAMapper.nodeToRole(formCache.navigationNodes[indexToCheck]),
            ]);
        }
        else if (formCache.navigationNodesMatchFound[indexToCheck] === "Fail_0") {
            return (0, IRule_1.RuleFail)("Fail_0", [
                ARIAMapper_1.ARIAMapper.nodeToRole(formCache.navigationNodes[indexToCheck]),
                formCache.navigationNodesComputedLabels[indexToCheck],
            ]);
        }
        else {
            return null;
        }
    }
};


/***/ }),

/***/ 5746:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_main_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.aria_main_label_unique = {
    id: "aria_main_label_unique",
    context: "aria:main",
    refactor: {
        "Rpt_Aria_MultipleMainsRequireLabel_Implicit_2": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_main_label_unique.html",
            "Fail_1": "aria_main_label_unique.html",
            "group": "aria_main_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"main\" role do not have unique labels",
            "group": "Elements with \"main\" role must have unique labels"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var contextLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
        var parentDocRole = legacy_1.RPTUtil.getAncestorWithRole(ruleContext, "document", true);
        var mains = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "main", true, true);
        var result = null;
        for (var i = 0; i < mains.length; ++i) {
            if (mains[i] === ruleContext)
                continue;
            result = (0, IRule_1.RulePass)("Pass_0");
            var thisParentDocRole = legacy_1.RPTUtil.getAncestorWithRole(mains[i], "document", true);
            if (thisParentDocRole === parentDocRole) {
                if (legacy_1.RPTUtil.getAriaLabel(mains[i]) === contextLabel) {
                    result = (0, IRule_1.RuleFail)("Fail_1");
                    break;
                }
            }
        }
        return result;
    }
};


/***/ }),

/***/ 8685:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_main_label_visible = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.aria_main_label_visible = {
    id: "aria_main_label_visible",
    context: "dom:body",
    refactor: {
        "Rpt_Aria_MultipleMainsVisibleLabel_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_main_label_visible.html",
            "Fail_1": "aria_main_label_visible.html",
            "group": "aria_main_label_visible.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"main\" role do not have unique visible labels",
            "group": "Each element with \"main\" role should have a unique visible label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Consider the Check Hidden Content setting that is set by the rules
        //call getElementsByRoleHidden with considerImplicit flag as true
        //so that the method returs <main> elements
        var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "main", true, true);
        if (landmarks.length === 0 || landmarks.length === 1) {
            return null;
        }
        var passed = legacy_1.RPTUtil.hasUniqueAriaLabelledby(landmarks);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 2678:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_navigation_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_navigation_label_unique = {
    id: "aria_navigation_label_unique",
    context: "aria:navigation",
    refactor: {
        "Rpt_Aria_MultipleNavigationLandmarks_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_navigation_label_unique.html",
            "Fail_1": "aria_navigation_label_unique.html",
            "group": "aria_navigation_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"navigation\" role do not have unique labels",
            "group": "Each element with \"navigation\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Consider the Check Hidden Content setting that is set by the rules
        var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "navigation", true, true);
        if (landmarks.length === 0 || landmarks.length === 1) {
            return null;
        }
        var dupes = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "aria_navigation_label_unique", null);
        if (!dupes) {
            dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "aria_navigation_label_unique", dupes);
        }
        var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
        var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
        //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [myLabel]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 971:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_parent_required = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var ARIADefinitions_1 = __webpack_require__(8235);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.aria_parent_required = {
    id: "aria_parent_required",
    context: "dom:*[role]",
    dependencies: ["aria_role_allowed"],
    refactor: {
        "Rpt_Aria_RequiredParent_Native_Host_Sematics": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_parent_required.html",
            "Pass_0": "aria_parent_required.html",
            "Fail_1": "aria_parent_required.html"
        }
    },
    messages: {
        "en-US": {
            "group": "An element with an implicit or explicit role must be contained within a valid element",
            "Pass_0": "Rule Passed",
            "Fail_1": "The element with role \"{0}\" is not contained in or owned by an element with one of the following roles: \"{1}\""
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    // TODO: ACT: Check Fail 3
    act: "ff89c9",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || legacy_1.RPTUtil.isNodeDisabled(ruleContext))
            return;
        //skip the check if the element should be a presentational child of an element
        if (legacy_1.RPTUtil.shouldBePresentationalChild(ruleContext))
            return;
        var roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
        // ignore if the element contains none or presentation role
        var presentationRoles = ["none", "presentation"];
        var found = roles.some(function (r) { return presentationRoles.includes(r); });
        if (found)
            return null;
        var passed = true;
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        var roleNameArr = new Array();
        var containerRoles = new Array();
        var testedContainer = 0;
        var ancestorRoles = contextHierarchies["aria"].map(function (info) { return info.role; });
        var parentRole = ancestorRoles[ancestorRoles.length - 2];
        var count = 2;
        while (parentRole === 'none') {
            count++;
            parentRole = ancestorRoles[ancestorRoles.length - count];
        }
        for (var j = 0, length_1 = roles.length; j < length_1; ++j) {
            if (designPatterns[roles[j]] && designPatterns[roles[j]].container != null) {
                testedContainer++;
                passed = false;
                containerRoles = designPatterns[roles[j]].container;
                for (var i = 0, containersLength = containerRoles.length; !passed && i < containersLength; i++) {
                    passed = parentRole === containerRoles[i];
                    if (passed)
                        break;
                }
                if (passed == false) {
                    roleNameArr.push(roles[j]);
                }
            }
        }
        var retToken1 = new Array();
        retToken1.push(roleNameArr.join(", "));
        var retToken2 = new Array();
        retToken2.push(containerRoles.join(", "));
        //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [retToken1, retToken2]);
        if (testedContainer == 0) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [retToken1.toString(), retToken2.toString()]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 3709:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_region_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_region_label_unique = {
    id: "aria_region_label_unique",
    context: "aria:region",
    refactor: {
        "Rpt_Aria_MultipleRegionsUniqueLabel_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_region_label_unique.html",
            "Fail_1": "aria_region_label_unique.html",
            "group": "aria_region_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"region\" role do not have unique labels",
            "group": "Each element with a \"region\" role must have a unique label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Per https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/landmarks/HTML5.html
        // form element should only be considered if it has an aria label or title
        if (ruleContext.getAttribute("role") === "region" ||
            ruleContext.hasAttribute("aria-label") ||
            ruleContext.hasAttribute("aria-labelledby") ||
            ruleContext.hasAttribute("title")) {
            // Consider the Check Hidden Content setting that is set by the rules
            // Also, consider Implicit role checking.
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "region", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var dupes = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "aria_region_label_unique", null);
            if (!dupes) {
                dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "aria_region_label_unique", dupes);
            }
            var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            var passed = myLabel !== "" &&
                (!(myLabel in dupes) || dupes[myLabel] <= 1);
            if (!passed) {
                return (0, IRule_1.RuleFail)("Fail_1", [myLabel]);
            }
            else {
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
        else {
            return null;
        }
    }
};


/***/ }),

/***/ 6486:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_region_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.aria_region_labelled = {
    id: "aria_region_labelled",
    context: "dom:*[role], dom:section",
    refactor: {
        "Rpt_Aria_RegionLabel_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_region_labelled.html",
            "Fail_1": "aria_region_labelled.html",
            "Fail_2": "aria_region_labelled.html",
            "group": "aria_region_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Section element with an implicit \"region\" role is not labeled with an 'aria-label' or 'aria-labelledby'",
            "Fail_2": "The element with \"region\" role is not labeled with an 'aria-label' or 'aria-labelledby'",
            "group": "Each element with \"region\" role must have a label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var tagName = ruleContext.tagName.toLowerCase();
        if (tagName === "section" &&
            !legacy_1.RPTUtil.hasRole(ruleContext, "region", false)) {
            return null;
        }
        if (tagName !== "section" &&
            !legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "region")) {
            return null;
        }
        var passed = legacy_1.RPTUtil.hasAriaLabel(ruleContext);
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return tagName === "section" ? (0, IRule_1.RuleFail)("Fail_1") : (0, IRule_1.RuleFail)("Fail_2");
        }
    }
};


/***/ }),

/***/ 4151:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_role_allowed = void 0;
var ARIADefinitions_1 = __webpack_require__(8235);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.aria_role_allowed = {
    id: "aria_role_allowed",
    context: "dom:*[role]",
    refactor: {
        "Rpt_Aria_ValidRole": {
            "Pass_0": "Pass_0",
            "Fail_2": "Fail_2",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_role_allowed.html",
            "Pass_0": "aria_role_allowed.html",
            "Fail_2": "aria_role_allowed.html",
            "Potential_1": "aria_role_allowed.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Elements must have a valid 'role' per ARIA specification",
            "Pass_0": "Rule Passed",
            "Fail_2": "The role '{0}' defined on the element is not valid per ARIA specification",
            "Potential_1": "Some of the roles, '{0}', defined on the element are not valid per ARIA specification"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "4.1.2",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    // TODO: ACT: Recheck
    act: "674b10",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var roleStr = ruleContext.getAttribute("role").trim().toLowerCase();
        if (roleStr.length === 0) {
            return null;
        }
        if (ruleContext.hasAttribute("aria-hidden") && ruleContext.getAttribute("aria-hidden").toLowerCase() === "true") {
            return null;
        }
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        var roles = roleStr.split(/\s+/);
        // now we have all role attributes
        var invalidRoles = [];
        for (var _i = 0, roles_1 = roles; _i < roles_1.length; _i++) {
            var role = roles_1[_i];
            if (!(role.toLowerCase() in designPatterns)) {
                invalidRoles.push(role);
            }
        }
        //return new ValidationResult(passed, [ruleContext], 'role', '', [roles[i]]);
        if (invalidRoles.length === roles.length) {
            return (0, IRule_1.RuleFail)("Fail_2", [invalidRoles.join(",")]);
        }
        else if (invalidRoles.length > 0) {
            return (0, IRule_1.RulePotential)("Potential_1", [invalidRoles.join(",")]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 8545:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_role_redundant = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CommonUtil_1 = __webpack_require__(8137);
exports.aria_role_redundant = {
    id: "aria_role_redundant",
    context: "dom:*[role]",
    help: {
        "en-US": {
            "pass": "aria_role_redundant.html",
            "fail_redundant": "aria_role_redundant.html",
            "group": "aria_role_redundant.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "An explicitly-assigned ARIA role is not redundant with the implicit role of the element",
            "fail_redundant": "The explicitly-assigned ARIA role \"{0}\" is redundant with the implicit role of the element <{1}>",
            "group": "An explicitly-assigned ARIA role should not be redundant with the implicit role of the element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var elemName = ruleContext.tagName.toLowerCase();
        var ariaRoles = legacy_1.RPTUtil.getRoles(ruleContext, false);
        if (!ariaRoles || ariaRoles.length === 0)
            return;
        // the invalid role case: handled by Rpt_Aria_ValidRole. Ignore to avoid duplicated report
        var role_defined = (0, CommonUtil_1.areRolesDefined)(ariaRoles);
        if (!role_defined)
            return null;
        // dependency check: if it's already failed in the parent relation, then skip this check
        if (["td", "th", "tr"].includes(elemName)) {
            var parentRole = (0, CommonUtil_1.isTableDescendant)(contextHierarchies);
            if (parentRole !== null && parentRole.length > 0)
                return null;
        }
        var implicitRoles = legacy_1.RPTUtil.getImplicitRole(ruleContext);
        if (!implicitRoles || implicitRoles.length === 0)
            return (0, IRule_1.RulePass)("pass");
        var ret = [];
        for (var i = 0; i < ariaRoles.length; i++) {
            if (!implicitRoles.includes(ariaRoles[i]))
                ret.push((0, IRule_1.RulePass)("pass"));
            else
                ret.push((0, IRule_1.RuleFail)("fail_redundant", [ariaRoles[i], elemName]));
        }
        if (ret.length > 0)
            return ret;
        return null;
    }
};


/***/ }),

/***/ 8538:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_search_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_search_label_unique = {
    id: "aria_search_label_unique",
    context: "aria:search",
    refactor: {
        "Rpt_Aria_MultipleSearchLandmarks": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_search_label_unique.html",
            "Fail_1": "aria_search_label_unique.html",
            "group": "aria_search_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"search\" role do not have unique labels",
            "group": "Each element with \"search\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Consider the Check Hidden Content setting that is set by the rules
        var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "search", true, true);
        if (landmarks.length === 0 || landmarks.length === 1) {
            return null;
        }
        var dupes = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "aria_search_label_unique", null);
        if (!dupes) {
            dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "aria_search_label_unique", dupes);
        }
        var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
        var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
        // return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [myLabel]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 1908:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_valid = exports.aria_role_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CommonUtil_1 = __webpack_require__(8137);
exports.aria_role_valid = {
    id: "aria_role_valid",
    context: "dom:*",
    dependencies: ["aria_attribute_allowed"],
    refactor: {
        "aria_semantics_role": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_role_valid.html",
            "Fail_1": "aria_role_valid.html",
            "Fail_2": "aria_role_valid.html",
            "group": "aria_role_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The ARIA role '{0}' is not valid for the element <{1}>",
            "Fail_2": "The ARIA role '{0}' is not valid for the element <{1}> and may be ignored by the browser since the element is focusable",
            "group": "ARIA roles must be valid for the element to which they are assigned"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var tagName = ruleContext.tagName.toLowerCase();
        // only chek element (1) and fragment nodes (11)
        if (ruleContext.nodeType !== Node.ELEMENT_NODE)
            return null;
        // dependency check: if it's already failed, then skip
        if (["td", "th", "tr"].includes(tagName)) {
            var parentRole = (0, CommonUtil_1.isTableDescendant)(contextHierarchies);
            if (parentRole !== null && parentRole.length > 0)
                return null;
        }
        var domRoles = legacy_1.RPTUtil.getUserDefinedRoles(ruleContext);
        if (!domRoles || domRoles.length === 0)
            return null;
        // check the 'generic' role first
        if (domRoles.includes('generic'))
            return (0, IRule_1.RuleFail)("Fail_1", ["generic", tagName]);
        // the invalid role case: handled by Rpt_Aria_ValidRole. Ignore to avoid duplicated report
        var role_defined = (0, CommonUtil_1.areRolesDefined)(domRoles);
        if (!role_defined)
            return null;
        var invalidRoles = (0, CommonUtil_1.getInvalidRoles)(ruleContext);
        if (invalidRoles === null || invalidRoles.length === 0)
            return (0, IRule_1.RulePass)("Pass_0", [domRoles.join(", "), tagName]);
        if (invalidRoles.includes("presentation") || invalidRoles.includes("none") && legacy_1.RPTUtil.isTabbable(ruleContext))
            return (0, IRule_1.RuleFail)("Fail_2", [invalidRoles.join(", "), tagName]);
        if (invalidRoles.length > 0)
            return (0, IRule_1.RuleFail)("Fail_1", [invalidRoles.join(", "), tagName]);
        if (domRoles.length > 0)
            return (0, IRule_1.RulePass)("Pass_0", [domRoles.join(", "), tagName]);
        return null;
    }
};
// This rule is in the same file because there is a dependency that aria_role_valid runs first,
// and the info is passed by cache, but there isn't a dependency in the Fail_2 scenario, so regular
// dependency cannot be used
exports.aria_attribute_valid = {
    id: "aria_attribute_valid",
    context: "dom:*",
    // The the ARIA role is completely invalid, skip this check
    dependencies: ["aria_attribute_deprecated", "aria_role_valid"],
    refactor: {
        "aria_attribute_allowed": {
            "Pass": "Pass",
            "Fail_invalid_role_attr": "Fail_invalid_role_attr",
            "Fail_invalid_implicit_role_attr": "Fail_invalid_implicit_role_attr"
        }
    },
    help: {
        "en-US": {
            "group": "aria_attribute_valid.html",
            "Pass": "aria_attribute_valid.html",
            "Fail_invalid_role_attr": "aria_attribute_valid.html",
            "Fail_invalid_implicit_role_attr": "aria_attribute_valid.html"
        }
    },
    messages: {
        "en-US": {
            "group": "ARIA attributes must be valid for the element and ARIA role to which they are assigned",
            "Pass": "ARIA attributes are valid for the element and ARIA role",
            "Fail_invalid_role_attr": "The ARIA attributes \"{0}\" are not valid for the element <{1}> with ARIA role \"{2}\"",
            "Fail_invalid_implicit_role_attr": "The ARIA attributes \"{0}\" are not valid for the element <{1}> with implicit ARIA role \"{2}\""
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: ["5c01ea", { "46ca7f": { "Pass": "pass", "Fail_invalid_role_attr": "fail", "Fail_invalid_implicit_role_attr": "fail" } }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // only chek element (1)
        if (ruleContext.nodeType !== Node.ELEMENT_NODE)
            return null;
        // ignore if no aria attribute
        var ariaAttributes = legacy_1.RPTUtil.getUserDefinedAriaAttributes(ruleContext);
        if (ariaAttributes === null || ariaAttributes.length === 0)
            return null;
        var roles = legacy_1.RPTUtil.getUserDefinedRoles(ruleContext);
        var explicit = true;
        if (roles && roles.length > 0) {
            // the invalid role case: handled by Rpt_Aria_ValidRole. Ignore to avoid duplicated report
            if (!(0, CommonUtil_1.areRolesDefined)(roles))
                return null;
        }
        else {
            //no explicit role defined
            roles = legacy_1.RPTUtil.getImplicitRole(ruleContext);
            explicit = false;
        }
        var tagName = ruleContext.tagName.toLowerCase();
        var failedAttributes = (0, CommonUtil_1.getInvalidAriaAttributes)(ruleContext);
        if (!failedAttributes || failedAttributes.length === 0)
            return (0, IRule_1.RulePass)("Pass", [ariaAttributes.join(", "), tagName, roles.join(", ")]);
        if (roles.length > 0) {
            if (explicit)
                return (0, IRule_1.RuleFail)("Fail_invalid_role_attr", [failedAttributes.join(", "), tagName, roles.join(", ")]);
            else
                return (0, IRule_1.RuleFail)("Fail_invalid_implicit_role_attr", [failedAttributes.join(", "), tagName, roles.join(", ")]);
        }
        return (0, IRule_1.RuleFail)("Fail_invalid_role_attr", [failedAttributes.join(", "), tagName, "none"]);
    }
};


/***/ }),

/***/ 6360:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_toolbar_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_toolbar_label_unique = {
    id: "aria_toolbar_label_unique",
    context: "aria:toolbar",
    refactor: {
        "Rpt_Aria_MultipleToolbarUniqueLabel": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_toolbar_label_unique.html",
            "Fail_1": "aria_toolbar_label_unique.html",
            "group": "aria_toolbar_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple toolbar components do not have unique labels",
            "group": "All toolbar components on a page must have unique labels specified"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Consider the Check Hidden Content setting that is set by the rules
        // Also, consider Implicit role checking.
        var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "toolbar", true, true);
        if (landmarks.length === 0 || landmarks.length === 1) {
            return null;
        }
        var dupes = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "aria_toolbar_label_unique", null);
        if (!dupes) {
            dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "aria_toolbar_label_unique", dupes);
        }
        var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
        var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [myLabel]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 5386:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_widget_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var ARIAMapper_1 = __webpack_require__(4944);
var fragment_1 = __webpack_require__(482);
var ARIADefinitions_1 = __webpack_require__(8235);
var DOMUtil_1 = __webpack_require__(295);
exports.aria_widget_labelled = {
    id: "aria_widget_labelled",
    context: "dom:*",
    refactor: {
        "Rpt_Aria_WidgetLabels_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_widget_labelled.html",
            "Pass_0": "aria_widget_labelled.html",
            "Fail_1": "aria_widget_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Interactive component must have a programmatically associated name",
            "Pass_0": "Rule Passed",
            "Fail_1": "Interactive component with ARIA role '{0}' does not have a programmatically associated name"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "m6b1q3",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        /* removed the role check role= presentation and role=none since these 2 roles are not in the list of widget type roles */
        if ((ruleContext.hasAttribute("type") &&
            ruleContext.getAttribute("type") === "hidden") ||
            (legacy_1.RPTUtil.getAncestorWithRole(ruleContext, "combobox") &&
                !(legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "textbox") ||
                    legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "searchbox")))) {
            // we need to diagnose that a combobox input textbox has a label(github issue #1104)
            return null;
        }
        var elemRole = ARIAMapper_1.ARIAMapper.nodeToRole(ruleContext);
        var tagName = ruleContext.nodeName.toLowerCase();
        // Handled by input_label_exists
        var skipRoles = [
            "button",
            "checkbox",
            "combobox",
            "listbox",
            "menuitemcheckbox",
            "menuitemradio",
            "radio",
            "searchbox",
            "slider",
            "spinbutton",
            "switch",
            "textbox",
            "progressbar",
            "link",
        ];
        if (skipRoles.includes(elemRole))
            return null;
        if (tagName === "output" ||
            (tagName === "input" &&
                ruleContext.getAttribute("type") === "file")) {
        }
        if (!ruleContext.hasAttribute("role")) {
            // Form/input elements are checked by G41, we skip them from this rule. Github issue 449
            var skipElements = [
                "input",
                "textarea",
                "select",
                "button",
                "datalist",
                "optgroup",
                "option",
                "keygen",
                "output",
                "progress",
                "meter",
            ];
            if (skipElements.indexOf(ruleContext.nodeName.toLowerCase()) !=
                -1) {
                return null;
            }
        }
        // avoid diagnosing the popup list of a combobox.
        var rolesToCheck = ["listbox", "tree", "grid", "dialog"];
        for (var j = 0; j < rolesToCheck.length; j++) {
            if (legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, rolesToCheck[j])) {
                var comboboxes = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "combobox", true, true);
                for (var k = 0; k < comboboxes.length; k++) {
                    var combobox = comboboxes[k];
                    var aria_owns = legacy_1.RPTUtil.getElementAttribute(combobox, "aria-owns");
                    if (aria_owns) {
                        var owns = legacy_1.RPTUtil.normalizeSpacing(aria_owns.trim()).split(" ");
                        for (var i = 0; i < owns.length; i++) {
                            var owned = fragment_1.FragmentUtil.getById(ruleContext, owns[i]);
                            if (owned === ruleContext) {
                                return null;
                            }
                        }
                    }
                }
            }
        }
        var passed = true;
        var prohibited = false;
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        //get attribute roles as well as implicit roles.
        var roles = legacy_1.RPTUtil.getRoles(ruleContext, true);
        var numWidgetsTested = 0;
        var interactiveRoleTypes = ["widget", "liveRegion", "window"];
        for (var i = 0, length_1 = roles.length; passed && i < length_1; ++i) {
            var pattern = designPatterns[roles[i]];
            if (pattern &&
                pattern.nameRequired &&
                pattern.roleType &&
                interactiveRoleTypes.includes(pattern.roleType)) {
                ++numWidgetsTested;
                // All widgets may have an author supplied accessible name.
                // Title is legal, but don't advertise its use in documentation.
                // Encourage use of aria-label, aria-labelledby or html label element.
                passed =
                    legacy_1.RPTUtil.hasAriaLabel(ruleContext) ||
                        legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title") ||
                        legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true);
                if (!passed &&
                    pattern.nameFrom &&
                    pattern.nameFrom.indexOf("contents") >= 0) {
                    // See if widget's accessible name is supplied by element's inner text
                    // nameFrom: ["author", "contents"]
                    passed = legacy_1.RPTUtil.hasInnerContentOrAlt(ruleContext);
                }
                if (!passed) {
                    // check if it has implicit label, like <label><input ....>abc </label>
                    passed = legacy_1.RPTUtil.hasImplicitLabel(ruleContext);
                }
                if (!passed &&
                    ruleContext.tagName.toLowerCase() === "img" &&
                    !ruleContext.hasAttribute("role") &&
                    ruleContext.hasAttribute("alt")) {
                    passed =
                        DOMUtil_1.DOMUtil.cleanWhitespace(ruleContext.getAttribute("alt")).trim().length > 0;
                }
                if (pattern.nameFrom.indexOf("prohibited") >= 0) {
                    prohibited = true;
                }
            }
        }
        if (numWidgetsTested === 0) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [elemRole]);
        }
        else {
            //TODO
            //                if (prohibited) {
            //                    return RuleFail("Fail_2");
            //                } else {
            return (0, IRule_1.RulePass)("Pass_0");
            //                }
        }
    }
};


/***/ }),

/***/ 8752:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asciiart_alt_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.asciiart_alt_exists = {
    id: "asciiart_alt_exists",
    context: "dom:pre, dom:listing, dom:xmp, dom:plaintext",
    refactor: {
        "RPT_Pre_ASCIIArt": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "asciiart_alt_exists.html",
            "Potential_1": "asciiart_alt_exists.html",
            "group": "asciiart_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that ASCII art has a text alternative",
            "group": "ASCII art must have a text alternative"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Fix for IDWB writers. Don't trigger if content is in a code element.  The code element is searched for
        // in various places because of the weird way various browsers render <code><pre></pre></code.  Firefox,
        // HtmlUnit and Chrome all render differently.  Firefox: <code></code><pre></pre>  HtmlUnit: </code><pre><code></code></pre>
        // See unit test CodeElementAbovePreElement.html.  Don't know how RPT renders, so cover all the bases.
        if (ruleContext.nodeName.toLowerCase() == "pre") {
            if ((ruleContext.previousSibling && ruleContext.previousSibling.nodeName.toLowerCase() == "code") ||
                ruleContext.getElementsByTagName("code").length > 0 ||
                legacy_1.RPTUtil.getAncestor(ruleContext, "code")) {
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
        var passed = true;
        var txtValue = legacy_1.RPTUtil.getInnerText(ruleContext);
        var nonAlphaNumericNorSpaceCount = 0;
        var alphNumSameCharacterCount = 0;
        var lastCharacter = "";
        // Iterate through the text content
        for (var idx = 0; passed && (idx < txtValue.length); ++idx) {
            var chStr = txtValue.substr(idx, 1);
            // Check if it is alphanumeric or punctuation
            if (/[\w!@#$%&\*().,?\[\]{}<>=":\/\\-]/.test(chStr)) {
                // Detect same character sequence
                if (lastCharacter == chStr) {
                    alphNumSameCharacterCount = alphNumSameCharacterCount + 1;
                    ;
                }
                else {
                    alphNumSameCharacterCount = 0;
                }
            }
            else if (/\s/.test(chStr)) {
                alphNumSameCharacterCount = 0;
            }
            else {
                nonAlphaNumericNorSpaceCount = nonAlphaNumericNorSpaceCount + 1;
                alphNumSameCharacterCount = 0;
            }
            lastCharacter = chStr;
            // Make the decision
            if (nonAlphaNumericNorSpaceCount >= 5 || alphNumSameCharacterCount >= 4) {
                passed = false;
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 4392:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.blink_css_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.blink_css_review = {
    id: "blink_css_review",
    context: "dom:style, dom:*[style]",
    refactor: {
        "RPT_Blink_CSSTrigger1": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "blink_css_review.html",
            "Pass_0": "blink_css_review.html",
            "Potential_1": "blink_css_review.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Do not use the \"blink\" value of the 'text-decoration' property for longer than five seconds",
            "Pass_0": "Rule Passed",
            "Potential_1": "Check the \"blink\" value of the CSS 'text-decoration' property is not used for more than than five seconds"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "2.2.2",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var textValue = legacy_1.RPTUtil.getInnerText(ruleContext);
        if (ruleContext.hasAttribute('style')) {
            textValue = ruleContext.getAttribute('style');
        }
        var passed = textValue.toLowerCase().indexOf("text-decoration:blink") == -1;
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 932:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.blink_elem_deprecated = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.blink_elem_deprecated = {
    id: "blink_elem_deprecated",
    context: "dom:blink",
    refactor: {
        "WCAG20_Blink_AlwaysTrigger": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "blink_elem_deprecated.html",
            "Pass_0": "blink_elem_deprecated.html",
            "Fail_1": "blink_elem_deprecated.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Content that blinks persistently must not be used",
            "Pass_0": "Rule Passed",
            "Fail_1": "Content found that blinks persistently"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "2.2.2",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        // const ruleContext = context["dom"].node as Element;
        return (0, IRule_1.RuleFail)("Fail_1");
    }
};


/***/ }),

/***/ 6255:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.blockquote_cite_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.blockquote_cite_exists = {
    id: "blockquote_cite_exists",
    context: "dom:blockquote",
    refactor: {
        "RPT_Blockquote_HasCite": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "blockquote_cite_exists.html",
            "Potential_1": "blockquote_cite_exists.html",
            "group": "blockquote_cite_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that <blockquote> should not be used only for quotations, not indentation",
            "group": "Use <blockquote> only for quotations, not indentation"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "cite");
        if (!passed) {
            var citeElems = legacy_1.RPTUtil.getDocElementsByTag(ruleContext, "cite");
            passed = citeElems != null && citeElems.length > 0;
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5743:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.canvas_content_described = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8174);
exports.canvas_content_described = {
    id: "canvas_content_described",
    context: "dom:canvas",
    refactor: {
        "HAAC_Canvas": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "canvas_content_described.html",
            "Manual_1": "canvas_content_described.html",
            "group": "canvas_content_described.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Verify accessibility of the <canvas> element",
            "group": "The <canvas> element may not be accessible"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1", "4.1.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = ruleContext.innerHTML.trim().length > 0;
        if (passed)
            return (0, IRule_1.RulePass)(1);
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 2671:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.caption_track_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.caption_track_exists = {
    id: "caption_track_exists",
    context: "dom:video",
    refactor: {
        "HAAC_Video_HasNoTrack": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "caption_track_exists.html",
            "Potential_1": "caption_track_exists.html",
            "group": "caption_track_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that captions are available for any meaningful audio or provide a caption track for the <video> element",
            "group": "A <video> element must have a text alternative for any meaningful audio content"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.2.1", "1.2.2", "1.2.4"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = false;
        // ignore decorative video if user uses aria-hidden
        if (ruleContext.getAttribute("aria-hidden") === "true") {
            return null;
        }
        var tracks = ruleContext.getElementsByTagName("track");
        for (var i = 0; i < tracks.length; ++i) {
            passed = passed || tracks[i].getAttribute("kind") === 'captions';
        }
        // checks for addition of dynamic tracks
        if (ruleContext.textTracks && ruleContext.textTracks.length > 0) {
            for (var i = 0; i < ruleContext.textTracks.length; i++) {
                passed = passed || ruleContext.textTracks[i].kind === 'captions';
            }
        }
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RulePotential)("Potential_1");
        }
    }
};


/***/ }),

/***/ 3974:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combobox_active_descendant = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var fragment_1 = __webpack_require__(482);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8174);
exports.combobox_active_descendant = {
    id: "combobox_active_descendant",
    context: "aria:combobox",
    dependencies: ["combobox_popup_reference"],
    help: {
        "en-US": {
            "Pass": "combobox_active_descendant.html",
            "Fail_missing": "combobox_active_descendant.html",
            "Fail_not_in_popup": "combobox_active_descendant.html",
            "Fail_active_role_invalid": "combobox_active_descendant.html",
            "Fail_active_not_selected": "combobox_active_descendant.html",
            "group": "combobox_active_descendant.html"
        }
    },
    messages: {
        "en-US": {
            "Pass": "'aria-activedescendant' is used appropriately for this combobox",
            "Fail_missing": "The element referenced by 'aria-activedescendant' \"{0}\" does not exist",
            "Fail_not_in_popup": "The element referenced by 'aria-activedescendant' \"{0}\" does not exist within the popup referenced by 'id' \"{1}\"",
            "Fail_active_role_invalid": "The 'aria-activedescendant' \"{0}\" references an element with the roles \"{1}\", which does not have a valid ARIA role of 'option', 'gridcell', 'row', or 'treeitem'",
            "Fail_active_not_selected": "The 'aria-activedescendant' \"{0}\" references an element that does not have 'aria-selected' set to true",
            "group": "'aria-activedescendant' must be used to define focus within the combobox popup, except when using a dialog popup"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var cache = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "combobox", {});
        var cachedElem = cache[context["dom"].rolePath];
        if (!cachedElem)
            return null;
        var popupElement = cachedElem.popupElement, popupId = cachedElem.popupId;
        // If this isn't defined, the combobox is probably collapsed. A reference error is
        // detected in combobox_popup_reference
        if (!popupElement)
            return null;
        // This rule only applies if the activedescendant is specified
        var activeId = ruleContext.getAttribute("aria-activedescendant");
        if (!activeId || activeId.trim().length === 0) {
            return null;
        }
        var activeElem = fragment_1.FragmentUtil.getById(ruleContext, activeId);
        if (!activeElem) {
            return (0, IRule_1.RuleFail)("Fail_missing", [activeId]);
        }
        var found = false;
        // examine the children
        if (popupElement) {
            var nw = new legacy_1.NodeWalker(popupElement);
            while (!found && nw.nextNode() && nw.node != popupElement && nw.node != popupElement.nextSibling) {
                if (nw.node.nodeType === 1 && VisUtil_1.VisUtil.isNodeVisible(nw.node)) {
                    found = nw.elem().getAttribute("id") === activeId;
                }
            }
        }
        var retVal = [];
        if (!found) {
            retVal.push((0, IRule_1.RulePass)("Fail_not_in_popup", [activeId, popupId]));
        }
        var activeRoles = legacy_1.RPTUtil.getRoles(activeElem, true);
        var validRoles = ["option", "gridcell", "row", "treeitem"].filter(function (validRole) { return activeRoles.includes(validRole); });
        if (validRoles.length === 0) {
            retVal.push((0, IRule_1.RuleFail)("Fail_active_role_invalid", [activeId, activeRoles.join(",")]));
        }
        if (activeElem.getAttribute("aria-selected") !== "true") {
            retVal.push((0, IRule_1.RuleFail)("Fail_active_not_selected", [activeId]));
        }
        if (retVal.length === 0) {
            return (0, IRule_1.RulePass)("Pass");
        }
        else {
            return retVal;
        }
    }
};


/***/ }),

/***/ 9881:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combobox_autocomplete_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8174);
exports.combobox_autocomplete_valid = {
    id: "combobox_autocomplete_valid",
    context: "aria:combobox",
    dependencies: ["combobox_popup_reference"],
    refactor: {
        "combobox_autocomplete": {
            "Pass": "Pass",
            "Fail_1": "Fail_1",
            "Fail_inline": "Fail_inline"
        }
    },
    help: {
        "en-US": {
            "Pass": "combobox_autocomplete_valid.html",
            "Fail_1": "combobox_autocomplete_valid.html",
            "Fail_inline": "combobox_autocomplete_valid.html",
            "group": "combobox_autocomplete_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass": "The combobox does not use 'aria-autocomplete' value '\"inline\"' nor does it have 'aria-autocomplete' defined within the popup",
            "Fail_1": "The combobox has the 'aria-autocomplete' attribute incorrectly set on an element within the popup referenced by \"{0}\"",
            "Fail_inline": "The combobox does not support an 'aria-autocomplete' attribute value set to '\"inline\"' ",
            "group": "A combobox that supports autocompletion behavior must have the 'aria-autocomplete' attribute only on its text input element with a valid value; a value of '\"inline\"' is not supported"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var cache = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "combobox", {});
        var cachedElem = cache[context["dom"].rolePath];
        if (!cachedElem)
            return null;
        var popupId = cachedElem.popupId, popupElement = cachedElem.popupElement;
        var retVal = [];
        if (ruleContext.getAttribute("aria-autocomplete") === "inline") {
            retVal.push((0, IRule_1.RuleFail)("Fail_inline"));
        }
        var passed = true;
        // examine the children
        if (popupElement && VisUtil_1.VisUtil.isNodeVisible(popupElement)) {
            // if popupElement itself has "aria-autocomplete"
            passed = !popupElement.hasAttribute("aria-autocomplete");
            // if any child of popupElement has "aria-autocomplete"
            if (passed && popupElement.children && popupElement.children.length > 0) {
                var nw = new legacy_1.NodeWalker(popupElement);
                while (passed && nw.nextNode()) {
                    if (nw.node.nodeType === 1 && VisUtil_1.VisUtil.isNodeVisible(nw.node)) {
                        passed = !nw.elem().hasAttribute("aria-autocomplete");
                        if (nw.bEndTag && nw.node === popupElement.lastElementChild)
                            break;
                    }
                }
            }
        }
        if (!passed) {
            retVal.push((0, IRule_1.RuleFail)("Fail_1", [popupId]));
        }
        if (retVal.length > 0) {
            return retVal;
        }
        else {
            return (0, IRule_1.RulePass)("Pass");
        }
    }
};


/***/ }),

/***/ 1226:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combobox_design_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8174);
function patternDetect(elem) {
    // check 'explicit' role combobox and that it is not <select>. 
    if (elem.tagName.toLowerCase() === "select" && elem.getAttribute("role") !== "combobox") {
        return "implicit";
    }
    else if (elem.nodeName.toLowerCase() === "input"
        && (!elem.hasAttribute("type") || elem.getAttribute("type") === "text")
        && elem.hasAttribute("aria-owns") && !elem.hasAttribute("aria-controls")) {
        // Looks like this is an ARIA 1.0 pattern, which the ARIA 1.2 spec says to continue to allow
        return "1.0";
    }
    else if (elem.nodeName.toLowerCase() !== "input"
        && elem.hasAttribute("aria-owns") && !elem.hasAttribute("aria-controls")) {
        // Looks like this is an ARIA 1.1 pattern, which the ARIA 1.2 spec says is now invalid
        return "1.1";
    }
    // Assume they're trying to do the latest, 1.2 pattern
    return "1.2";
}
exports.combobox_design_valid = {
    id: "combobox_design_valid",
    context: "aria:combobox",
    refactor: {
        "combobox_version": {
            "Pass_1.0": "Pass_1.0",
            "Fail_1.1": "Fail_1.1",
            "Pass_1.2": "Pass_1.2"
        }
    },
    help: {
        "en-US": {
            "Pass_1.0": "combobox_design_valid.html",
            "Fail_1.1": "combobox_design_valid.html",
            "Pass_1.2": "combobox_design_valid.html",
            "group": "combobox_design_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_1.0": "The combobox design pattern is detected as ARIA 1.0, which is allowed by ARIA 1.2",
            "Fail_1.1": "The combobox design pattern is detected as ARIA 1.1, which is not allowed by ARIA 1.2",
            "Pass_1.2": "The combobox design pattern is detected as ARIA 1.2",
            "group": "The combobox design pattern must be valid for ARIA 1.2"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) || legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
            return null;
        }
        var pattern = patternDetect(ruleContext);
        // We don't assess native select elements here
        if (pattern === "implicit") {
            return null;
        }
        var tagName = ruleContext.tagName.toLowerCase();
        var expanded = (legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-expanded") || "").trim().toLowerCase() === "true";
        var editable = tagName === "input" && (!ruleContext.hasAttribute("type") || ruleContext.getAttribute("type").toLowerCase() === "text");
        var key = context["dom"].rolePath;
        if (key) {
            var cache = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "combobox", {});
            cache[key] = {
                "inputElement": editable ? ruleContext : null,
                "pattern": pattern,
                "expanded": expanded
            };
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "combobox", cache);
        }
        else {
            // No xpath?
            return null;
        }
        if (pattern === "1.0") {
            return (0, IRule_1.RulePass)("Pass_1.0");
        }
        else if (pattern === "1.1") {
            return (0, IRule_1.RuleFail)("Fail_1.1");
        }
        else if (pattern === "1.2") {
            return (0, IRule_1.RulePass)("Pass_1.2");
        }
    }
};


/***/ }),

/***/ 7369:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combobox_focusable_elements = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8174);
exports.combobox_focusable_elements = {
    id: "combobox_focusable_elements",
    context: "aria:combobox",
    dependencies: ["combobox_popup_reference"],
    help: {
        "en-US": {
            "Pass": "combobox_focusable_elements.html",
            "Fail_not_tabbable": "combobox_focusable_elements.html",
            "Fail_tabbable_child": "combobox_focusable_elements.html",
            "group": "combobox_focusable_elements.html"
        }
    },
    messages: {
        "en-US": {
            "Pass": "DOM focus is allowed only on the combobox element as required",
            "Fail_not_tabbable": "The combobox element does not allow DOM focus as required",
            "Fail_tabbable_child": "The popup of the combobox has DOM focus or has 'aria-activedescendant' defined, which is not allowed",
            "group": "Tabbable focus for the combobox must be allowed only on the text input, except when using a dialog popup"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var cache = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "combobox", {});
        var cachedElem = cache[context["dom"].rolePath];
        if (!cachedElem)
            return null;
        var popupElement = cachedElem.popupElement, expanded = cachedElem.expanded;
        // If this isn't defined, the combobox is probably collapsed. A reference error is
        // detected in combobox_popup_reference
        if (!popupElement)
            return null;
        var popupRole = legacy_1.RPTUtil.getRoles(popupElement, true)[0];
        var retVal = [];
        if (!legacy_1.RPTUtil.isTabbable(ruleContext)) {
            retVal.push((0, IRule_1.RuleFail)("Fail_not_tabbable"));
        }
        // Only makes sense to check the popup when expanded
        // this does not apply to dialogs, return pass since the main element was focusable above
        if (expanded === false || popupRole === "dialog") {
            return (0, IRule_1.RulePass)("Pass");
        }
        var passed = true;
        // examine the children
        if (popupElement && VisUtil_1.VisUtil.isNodeVisible(popupElement)) {
            // if popupElement itself has "aria-activedescendant"
            passed = !legacy_1.RPTUtil.isTabbable(popupElement) && !legacy_1.RPTUtil.getAriaAttribute(popupElement, "aria-activedescendant");
            ;
            // if any child of popupElement has "aria-autocomplete"
            if (passed && popupElement.children && popupElement.children.length > 0) {
                var nw = new legacy_1.NodeWalker(popupElement);
                while (passed && nw.nextNode()) {
                    if (nw.node.nodeType === 1 && VisUtil_1.VisUtil.isNodeVisible(nw.node)) {
                        passed = !legacy_1.RPTUtil.isTabbable(nw.node) &&
                            !legacy_1.RPTUtil.getAriaAttribute(nw.node, "aria-activedescendant");
                        if (nw.bEndTag && nw.node === popupElement.lastElementChild)
                            break;
                    }
                }
            }
        }
        if (!passed) {
            retVal.push((0, IRule_1.RuleFail)("Fail_tabbable_child"));
        }
        if (retVal.length === 0) {
            return (0, IRule_1.RulePass)("Pass");
        }
        else {
            return retVal;
        }
    }
};


/***/ }),

/***/ 2633:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combobox_haspopup_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.combobox_haspopup_valid = {
    id: "combobox_haspopup_valid",
    context: "aria:combobox",
    dependencies: ["combobox_popup_reference"],
    refactor: {
        "combobox_haspopup": {
            "Pass": "Pass",
            "Fail_popup_role_invalid": "Fail_popup_role_invalid",
            "Fail_combobox_popup_role_mismatch": "Fail_combobox_popup_role_mismatch"
        }
    },
    help: {
        "en-US": {
            "Pass": "combobox_haspopup_valid.html",
            "Fail_popup_role_invalid": "combobox_haspopup_valid.html",
            "Fail_combobox_popup_role_mismatch": "combobox_haspopup_valid.html",
            "group": "combobox_haspopup_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass": "The 'aria-controls' (ARIA 1.2) or 'aria-owns' (ARIA 1.0) appropriately references a valid popup 'id' value",
            "Fail_popup_role_invalid": "The 'role' value \"{0}\" of the popup element \"{1}\" should be one of \"listbox\", \"grid\", \"tree\" or \"dialog\"",
            "Fail_combobox_popup_role_mismatch": "The value of the combobox 'aria-haspopup' attribute \"{0}\" does not match the 'role' value of the popup element \"{1}\"",
            "group": "The combobox attribute 'aria-haspopup' value must be appropriate for the role of the element referenced by 'aria-controls' (ARIA 1.2) or 'aria-owns' (ARIA 1.0)"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var cache = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "combobox", {});
        var cacheKey = context["dom"].rolePath;
        var cachedElem = cache[cacheKey];
        if (!cachedElem)
            return null;
        var popupElement = cachedElem.popupElement, popupId = cachedElem.popupId;
        // If this isn't defined, the combobox is probably collapsed. A reference error is
        // detected in combobox_popup_reference
        if (!popupElement)
            return null;
        // Check that popup role is listbox, grid, tree, or dialog and that it matches the combobox
        var popupRoles = legacy_1.RPTUtil.getRoles(popupElement, true);
        var validRoles = ["listbox", "grid", "tree", "dialog"].filter(function (validRole) { return popupRoles.includes(validRole); });
        if (validRoles.length === 0) {
            return (0, IRule_1.RuleFail)("Fail_popup_role_invalid", [popupRoles.join(","), popupId]);
        }
        else {
            var popupRole = validRoles[0];
            var haspopupVal = ruleContext.getAttribute("aria-haspopup") || "listbox";
            // Popup role must match aria-haspopup unless popupRole is listbox, then aria-haspopup should not be defined                
            if (haspopupVal !== popupRole) {
                if (popupRole !== "listbox" || ruleContext.hasAttribute("aria-haspopup")) {
                    return (0, IRule_1.RuleFail)("Fail_combobox_popup_role_mismatch", [haspopupVal, popupRole]);
                }
            }
        }
        return (0, IRule_1.RulePass)("Pass");
    }
};


/***/ }),

/***/ 2429:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combobox_popup_reference = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var fragment_1 = __webpack_require__(482);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8174);
exports.combobox_popup_reference = {
    id: "combobox_popup_reference",
    context: "aria:combobox",
    dependencies: ["combobox_design_valid"],
    help: {
        "en-US": {
            "group": "combobox_popup_reference.html",
            "Pass_1.0_expanded": "combobox_popup_reference.html",
            "Pass_1.0_collapsed": "combobox_popup_reference.html",
            "Pass_1.2_expanded": "combobox_popup_reference.html",
            "Pass_1.2_collapsed": "combobox_popup_reference.html",
            "Fail_1.0_missing_owns": "combobox_popup_reference.html",
            "Fail_1.2_missing_controls": "combobox_popup_reference.html",
            "Fail_1.0_popup_reference_missing": "combobox_popup_reference.html",
            "Fail_1.2_popup_reference_missing": "combobox_popup_reference.html",
            "Fail_combobox_expanded_hidden": "combobox_popup_reference.html",
            "Fail_combobox_collapsed_visible": "combobox_popup_reference.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The 'aria-controls' (for ARIA 1.2) or the 'aria-owns' (for ARIA 1.0) attribute of the expanded combobox must reference a valid popup 'id' value",
            "Pass_1.0_expanded": "The combobox popup referenced by 'aria-owns' (ARIA 1.0) exists and is visible",
            "Pass_1.0_collapsed": "The combobox popup in its collapsed state does not reference any visible popup as required",
            "Pass_1.2_expanded": "The combobox popup referenced by 'aria-controls' (ARIA 1.2) exists and is visible",
            "Pass_1.2_collapsed": "The combobox popup in its collapsed state does not reference any visible popup as required",
            "Fail_1.0_missing_owns": "The 'aria-owns' attribute of the expanded combobox is missing",
            "Fail_1.2_missing_controls": "The 'aria-controls' attribute of the expanded combobox is missing",
            "Fail_1.0_popup_reference_missing": "The 'aria-owns' attribute \"{0}\" of the expanded combobox does not reference a valid popup 'id' value",
            "Fail_1.2_popup_reference_missing": "The 'aria-controls' attribute \"{0}\" of the expanded combobox does not reference a valid popup 'id' value",
            "Fail_combobox_expanded_hidden": "The combobox 'aria-expanded' attribute is true, but the combobox popup is not visible",
            "Fail_combobox_collapsed_visible": "The combobox 'aria-expanded' attribute is false, but the combobox popup is visible"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [{
            "4e8ab6": {
                "Pass_1.0_expanded": "fail",
                "Pass_1.0_collapsed": "fail",
                "Pass_1.2_expanded": "pass",
                "Pass_1.2_collapsed": "pass",
                "Fail_1.0_missing_owns": "inapplicable",
                "Fail_1.2_missing_controls": "fail",
                "Fail_1.0_popup_reference_missing": "inapplicable",
                "Fail_1.2_popup_reference_missing": "fail",
                "Fail_combobox_expanded_hidden": "inapplicable",
                "Fail_combobox_collapsed_visible": "inapplicable"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var cache = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "combobox", {});
        var cacheKey = context["dom"].rolePath;
        var cachedElem = cache[cacheKey];
        if (!cachedElem)
            return null;
        var pattern = cachedElem.pattern, expanded = cachedElem.expanded;
        var popupId;
        var popupElement;
        if (pattern === "1.0") {
            if (!ruleContext.hasAttribute("aria-owns")) {
                // If the combobox isn't expanded, this attribute isn't required
                return !expanded ? null : (0, IRule_1.RuleFail)("Fail_1.0_missing_owns");
            }
            popupId = ruleContext.getAttribute("aria-owns");
            popupElement = fragment_1.FragmentUtil.getById(ruleContext, popupId);
            if (!popupElement) {
                // If the combobox isn't expanded, this attribute isn't required
                return !expanded ? null : (0, IRule_1.RuleFail)("Fail_1.0_popup_reference_missing", [popupId]);
            }
        }
        else if (pattern === "1.2") {
            if (!ruleContext.hasAttribute("aria-controls")) {
                // If the combobox isn't expanded, this attribute isn't required
                return !expanded ? null : (0, IRule_1.RuleFail)("Fail_1.2_missing_controls");
            }
            popupId = ruleContext.getAttribute("aria-controls");
            popupElement = fragment_1.FragmentUtil.getById(ruleContext, popupId);
            if (!popupElement) {
                // If the combobox isn't expanded, this attribute isn't required
                return !expanded ? null : (0, IRule_1.RuleFail)("Fail_1.2_popup_reference_missing", [popupId]);
            }
        }
        else {
            return null;
        }
        // We have an element, stick it in the cache and then check its role
        cachedElem.popupId = popupId;
        cachedElem.popupElement = popupElement;
        if (expanded && !VisUtil_1.VisUtil.isNodeVisible(popupElement)) {
            return (0, IRule_1.RuleFail)("Fail_combobox_expanded_hidden");
        }
        else if (!expanded && VisUtil_1.VisUtil.isNodeVisible(popupElement)) {
            return (0, IRule_1.RuleFail)("Fail_combobox_collapsed_visible");
        }
        if (pattern === "1.0") {
            return (0, IRule_1.RulePass)(expanded ? "Pass_1.0_expanded" : "Pass_1.0_collapsed");
        }
        else {
            return (0, IRule_1.RulePass)(expanded ? "Pass_1.2_expanded" : "Pass_1.2_collapsed");
        }
    }
};


/***/ }),

/***/ 7874:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debug_paths = void 0;
var IRule_1 = __webpack_require__(4377);
exports.debug_paths = {
    id: "debug_paths",
    context: "dom:*",
    help: {
        "en-US": {
            "group": "",
            "Pass_0": ""
        }
    },
    messages: {
        "en-US": {
            "group": "",
            "Pass_0": ""
        }
    },
    rulesets: [{
            id: ["DEBUG"],
            num: "1",
            level: IRule_1.eRulePolicy.INFORMATION,
            toolkitLevel: IRule_1.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        ruleContext.setAttribute("domPath", context["dom"].rolePath);
        ruleContext.setAttribute("ariaPath", context["aria"].rolePath);
        return null;
    }
};


/***/ }),

/***/ 3334:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.detector_tabbable = void 0;
var legacy_1 = __webpack_require__(8422);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.detector_tabbable = {
    id: "detector_tabbable",
    context: "dom:*",
    help: {
        "en-US": {
            "group": "",
            "Pass_0": ""
        }
    },
    messages: {
        "en-US": {
            "group": "",
            "Pass_0": ""
        }
    },
    rulesets: [{
            id: ["EXTENSIONS"],
            num: "1",
            level: IRule_2.eRulePolicy.INFORMATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!legacy_1.RPTUtil.isTabbable(ruleContext)) {
            return null;
        }
        var hierContext = contextHierarchies.aria[contextHierarchies.aria.length - 1];
        return (0, IRule_1.RulePass)("Pass_0", [], [{
                name: hierContext.attributes.name,
                role: hierContext.role,
                tabindex: parseInt(ruleContext.getAttribute("tabindex") || "0")
            }]);
    }
};


/***/ }),

/***/ 4298:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dir_attribute_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.dir_attribute_valid = {
    id: "dir_attribute_valid",
    context: "dom:*[dir]",
    refactor: {
        "Valerie_Elem_DirValid": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "dir_attribute_valid.html",
            "Fail_1": "dir_attribute_valid.html",
            "group": "dir_attribute_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Invalid value used for the 'dir' attribute",
            "group": "'dir' attribute value must be \"ltr\", \"rtl\", or \"auto\""
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var dirStr = ruleContext.getAttribute("dir").toLowerCase();
        var passed = dirStr == "ltr" || dirStr == "rtl" || dirStr == "auto";
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4435:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.download_keyboard_controllable = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.download_keyboard_controllable = {
    id: "download_keyboard_controllable",
    context: "dom:a[href],dom:area[href]",
    refactor: {
        "HAAC_Media_DocumentTrigger2": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "download_keyboard_controllable.html",
            "Manual_1": "download_keyboard_controllable.html",
            "group": "download_keyboard_controllable.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Verify that the file download mechanism does not cause a keyboard trap",
            "group": "File download mechanisms should be keyboard-operable and preserve page focus location"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.1.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var href = ruleContext.getAttribute("href");
        var ext = legacy_1.RPTUtil.getFileExt(href);
        var passed = ![".docx", ".doc", ".pdf", ".odt"].includes(ext);
        if (passed)
            return null;
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 6313:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_accesskey_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var DOMWalker_1 = __webpack_require__(7440);
exports.element_accesskey_labelled = {
    id: "element_accesskey_labelled",
    context: "dom:*[accesskey]",
    refactor: {
        "HAAC_Accesskey_NeedLabel": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "element_accesskey_labelled.html",
            "Potential_1": "element_accesskey_labelled.html",
            "group": "element_accesskey_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "The HTML element with an assigned 'accesskey' attribute does not have an associated label",
            "group": "An HTML element with an assigned 'accesskey' attribute must have an associated label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.3.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = false;
        if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title")) {
            passed = true;
        }
        else if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "aria-label")) {
            passed = true;
        }
        else if (legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true)) { // ignore hidden
            passed = true;
        }
        else if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "aria-labelledby")) {
            // assume the validity of the id (of aria-labelledby) is checked by a different rule
            passed = true;
        }
        else if (ruleContext.nodeName.toLowerCase() === "input"
            && DOMWalker_1.DOMWalker.parentNode(ruleContext).nodeName.toLowerCase() === "label") {
            // assume the validity of the label, e.g. empty label, is checked by a different rule
            passed = true;
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9109:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_accesskey_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CacheUtil_1 = __webpack_require__(7788);
exports.element_accesskey_unique = {
    id: "element_accesskey_unique",
    context: "dom:*[accesskey]",
    refactor: {
        "WCAG20_Elem_UniqueAccessKey": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "element_accesskey_unique.html",
            "Fail_1": "element_accesskey_unique.html",
            "group": "element_accesskey_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "'accesskey' attribute value on the element is not unique",
            "group": "'accesskey' attribute values on each element must be unique for the page"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var map = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "element_accesskey_unique", {});
        var key = ruleContext.getAttribute("accesskey");
        var passed = !(key in map);
        map[key] = true;
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 9918:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_attribute_deprecated = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var DEPRECATED_ELEMENTS = [
    /** original */
    "applet", "basefont", "center", "dir", "font", "isindex", "listing",
    "plaintext", "spacer", "s", "strike", "u", "xmp",
    /** added from https://dev.w3.org/html5/pf-summary/obsolete.html */
    "acronym", "frame", "frameset", "noframes", "noembed", "big", "blink", "marquee", "tt",
];
var DEPRECATED_HTML_GLOBAL_ATTRIBUTES = [
    /** original */
    "align", "link", "archive", "background", "bgcolor", "clear", "code", "color",
    "compact", "face", "hspace", "language", "link", "noshade", "nowrap", "object",
    "prompt", "start", "text", "version", "vlink", "vspace"
];
var DEPRECATED_ELEMENT_ATTRIBUTES = {
    /** original */
    "td": ["height", "width", "abbr", "axis", "char", "charoff", "height", "nowrap", "valign", "width", "align", "bgcolor"],
    "th": ["height", "width", "abbr", "axis", "charoff", "height", "bgcolor", "align", "nowrap", "char", "valign", "width"],
    "li": ["type", "value", "type"],
    "ul": ["type", "compact"],
    "pre": ["width"],
    /** added from https://dev.w3.org/html5/pf-summary/obsolete.html */
    "meta": ["http-equiv"],
    "a": ["charset", "coords", "shape", "rev", "scheme"],
    "link": ["rev", "charset", "target"],
    "img": ["name", "longdesc", "align", "hspace", "vspace", "border"],
    "area": ["nohref"],
    "head": ["profile"],
    "html": ["version"],
    "iframe": ["longdesc", "align", "frameborder", "marginheight", "marginwidth", "scrolling"],
    "object": ["archive", "code", "codebase", "codetype", "declare", "standby", "align", "hspace", "vspace", "border"],
    "param": ["type", "valuetype"],
    "script": ["language"],
    "body": ["alink", "background", "bgcolor", "link", "text", "vlink"],
    "br": ["clear"],
    "caption": ["align"],
    "col": ["align", "char", "charoff", "valign", "width"],
    "div": ["align"],
    "dl": ["compact"],
    "hr": ["align", "noshade", "size", "width", "align"],
    "h2": ["align"],
    "h3": ["align"],
    "h4": ["align"],
    "h5": ["align"],
    "h6": ["align"],
    "input": ["align", "usemap"],
    "legend": ["align"],
    "menu": ["compact"],
    "ol": ["compact", "type", "type"],
    "p": ["align"],
    "table": ["bgcolor", "cellpadding", "cellspacing", "frame", "rules", "width", "align"],
    "tbody": ["align", "char", "valign", "charoff"],
    "tfoot": ["align", "charoff", "char", "valign"],
    "thead": ["char", "charoff", "valign", "align"],
    "tr": ["align", "bgcolor", "char", "charoff", "valign"]
};
function arrayToContextStr(obj, type) {
    var str = "";
    for (var _i = 0, obj_1 = obj; _i < obj_1.length; _i++) {
        var prop = obj_1[_i];
        if (str !== '' && !str.endsWith(', '))
            str += ", ";
        if (type === 'HTML_ELEMENTS')
            str += 'dom:' + prop;
        else if (type === 'HTML_ATTRIBUTES')
            str += 'dom:*[' + prop + "]";
    }
    return str;
}
function objToContextStr(obj, type) {
    var str = "";
    for (var prop in obj) {
        if (str !== '' && !str.endsWith(', '))
            str += ", ";
        if (type === 'HTML_ELEMENT_ATTRIBUTES') {
            for (var _i = 0, _a = obj[prop]; _i < _a.length; _i++) {
                var item = _a[_i];
                if (str !== '' && !str.endsWith(", "))
                    str += ", ";
                str += 'dom:' + prop + '[' + item + ']';
            }
        }
    }
    return str;
}
exports.element_attribute_deprecated = {
    id: "element_attribute_deprecated",
    context: "dom:applet, dom:basefont, dom:center, dom:dir, dom:font, dom:isindex, dom:listing, dom:menu, dom:plaintext, dom:spacer, dom:s, dom:strike, dom:u, dom:xmp, dom:acronym, dom:frame, dom:frameset, dom:noframes, dom:noembed, dom:big, dom:blink, dom:marquee, dom:ttNaNdom:*[align], dom:*[link], dom:*[archive], dom:*[background], dom:*[bgcolor], dom:*[clear], dom:*[code], dom:*[color], dom:*[compact], dom:*[face], dom:*[hspace], dom:*[language], dom:*[link], dom:*[noshade], dom:*[nowrap], dom:*[object], dom:*[prompt], dom:*[start], dom:*[text], dom:*[version], dom:*[vlink], dom:*[vspace]NaNdom:td[height], dom:td[width], dom:td[abbr], dom:td[axis], dom:td[char], dom:td[charoff], dom:td[height], dom:td[nowrap], dom:td[valign], dom:td[width], dom:td[align], dom:td[bgcolor], dom:th[height], dom:th[width], dom:th[abbr], dom:th[axis], dom:th[charoff], dom:th[height], dom:th[bgcolor], dom:th[align], dom:th[nowrap], dom:th[char], dom:th[valign], dom:th[width], dom:li[type], dom:li[value], dom:li[type], dom:ul[type], dom:ul[compact], dom:pre[width], dom:meta[http-equiv], dom:a[charset], dom:a[coords], dom:a[shape], dom:a[rev], dom:a[scheme], dom:link[rev], dom:link[charset], dom:link[target], dom:img[name], dom:img[longdesc], dom:img[align], dom:img[hspace], dom:img[vspace], dom:img[border], dom:area[nohref], dom:head[profile], dom:html[version], dom:iframe[longdesc], dom:iframe[align], dom:iframe[frameborder], dom:iframe[marginheight], dom:iframe[marginwidth], dom:iframe[scrolling], dom:object[archive], dom:object[code], dom:object[codebase], dom:object[codetype], dom:object[declare], dom:object[standby], dom:object[align], dom:object[hspace], dom:object[vspace], dom:object[border], dom:param[type], dom:param[valuetype], dom:script[language], dom:body[alink], dom:body[background], dom:body[bgcolor], dom:body[link], dom:body[text], dom:body[vlink], dom:br[clear], dom:caption[align], dom:col[align], dom:col[char], dom:col[charoff], dom:col[valign], dom:col[width], dom:div[align], dom:dl[compact], dom:hr[align], dom:hr[noshade], dom:hr[size], dom:hr[width], dom:hr[align], dom:h2[align], dom:h3[align], dom:h4[align], dom:h5[align], dom:h6[align], dom:input[align], dom:input[usemap], dom:legend[align], dom:menu[compact], dom:ol[compact], dom:ol[type], dom:ol[type], dom:p[align], dom:table[bgcolor], dom:table[cellpadding], dom:table[cellspacing], dom:table[frame], dom:table[rules], dom:table[width], dom:table[align], dom:tbody[align], dom:tbody[char], dom:tbody[valign], dom:tbody[charoff], dom:tfoot[align], dom:tfoot[charoff], dom:tfoot[char], dom:tfoot[valign], dom:thead[char], dom:thead[charoff], dom:thead[valign], dom:thead[align], dom:tr[align], dom:tr[bgcolor], dom:tr[char], dom:tr[charoff], dom:tr[valign]",
    help: {
        "en-US": {
            "pass": "element_attribute_deprecated.html",
            "fail_elem": "element_attribute_deprecated.html",
            "fail_attr": "element_attribute_deprecated.html",
            "fail_elem_attr": "element_attribute_deprecated.html",
            "group": "element_attribute_deprecated.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "fail_elem": "The <{0}> element is deprecated in HTML 5",
            "fail_attr": "The HTML attribute(s) \"{0}\" is deprecated in HTML 5",
            "fail_elem_attr": "The HTML attribute(s) \"{0}\" is deprecated for the <{1}> element in HTML 5",
            "group": "Avoid use of obsolete features if possible"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // HTMLUnit auto adds a tbody[align=left] to tables if tbody is missing!
        if (ruleContext.nodeName.toLowerCase() === "tbody" && ruleContext.hasAttribute("align")) {
            return (0, IRule_1.RulePass)("pass");
        }
        if (ruleContext.nodeName.includes("-")) {
            // This is a webcomponent element, HTML doesn't define what's deprecated
            return null;
        }
        var nodeName = ruleContext.nodeName.toLowerCase();
        var ret = [];
        // check if it's a deprecated element
        if (DEPRECATED_ELEMENTS.includes(nodeName)) {
            return (0, IRule_1.RuleFail)("fail_elem", [nodeName]);
        }
        // check if it's a deprecated HTML global attribute
        var attrs = ruleContext.getAttributeNames();
        var violations = '';
        for (var _i = 0, attrs_1 = attrs; _i < attrs_1.length; _i++) {
            var attr = attrs_1[_i];
            if (DEPRECATED_HTML_GLOBAL_ATTRIBUTES.includes(attr)) {
                if (violations !== '')
                    violations += ', ';
                violations += attr;
            }
        }
        if (violations !== '') {
            return (0, IRule_1.RuleFail)("fail_attr", [violations]);
        }
        // check if it's a deprecated HTML element & attribute
        violations = '';
        if (nodeName in DEPRECATED_ELEMENT_ATTRIBUTES) {
            for (var _a = 0, attrs_2 = attrs; _a < attrs_2.length; _a++) {
                var attr = attrs_2[_a];
                if (DEPRECATED_ELEMENT_ATTRIBUTES[nodeName] && DEPRECATED_ELEMENT_ATTRIBUTES[nodeName].includes(attr)) {
                    if (violations !== '')
                        violations += ', ';
                    violations += attr;
                }
            }
            if (violations !== '') {
                return (0, IRule_1.RuleFail)("fail_elem_attr", [violations, nodeName]);
            }
        }
        return (0, IRule_1.RulePass)("pass");
    }
};


/***/ }),

/***/ 8105:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_id_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var fragment_1 = __webpack_require__(482);
exports.element_id_unique = {
    id: "element_id_unique",
    context: "dom:*[id]",
    refactor: {
        "RPT_Elem_UniqueId": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "group": "element_id_unique.html",
            "Pass_0": "element_id_unique.html",
            "Fail_1": "element_id_unique.html",
            "Fail_2": "element_id_unique.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Element 'id' attribute values must be unique within a document",
            "Pass_0": "Rule Passed",
            "Fail_1": "The <{0}> element has the id \"{1}\" that is empty",
            "Fail_2": "The <{0}> element has the id \"{1}\" that is already in use"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [{
            "3ea0c8": {
                "Pass_0": "pass",
                "Fail_1": "pass",
                "Fail_2": "fail"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // JCH - NO OUT OF SCOPE hidden in context
        var id = ruleContext.getAttribute("id");
        // In the case that id is empty we should trigger a violation right away with out checking 
        // for uniqueness.
        if (id === "") {
            //return new ValidationResult(false, [ruleContext], '', '', [ruleContext.nodeName.toLowerCase(), id]);
            return (0, IRule_1.RuleFail)("Fail_1", [ruleContext.nodeName.toLowerCase(), id]);
        }
        var element = fragment_1.FragmentUtil.getById(ruleContext, id);
        var passed = element === ruleContext;
        //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [ruleContext.nodeName.toLowerCase(), id]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_2", [ruleContext.nodeName.toLowerCase(), id]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 8687:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_lang_valid = exports.html_lang_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var lang_1 = __webpack_require__(2527);
var VisUtil_1 = __webpack_require__(8174);
var DOMWalker_1 = __webpack_require__(7440);
var ARIAMapper_1 = __webpack_require__(4944);
var validateLang = function (context, options, contextHierarchies) {
    var ruleContext = context["dom"].node;
    var nodeName = ruleContext.nodeName.toLowerCase();
    if (ruleContext.hasAttribute("lang")) {
        if (nodeName !== "html" && ruleContext.getAttribute("lang") === "") {
            // It's okay to have a lang="" if not on html
        }
        else {
            var langStr = ruleContext.getAttribute("lang");
            if (!lang_1.LangUtil.validPrimaryLang(langStr)) {
                return (0, IRule_1.RuleFail)("Fail_1");
            }
            if (!lang_1.LangUtil.isBcp47(langStr)) {
                return (0, IRule_1.RuleFail)("Fail_2");
            }
        }
    }
    if (ruleContext.hasAttribute("xml:lang")) {
        if (nodeName !== "html" && ruleContext.getAttribute("xml:lang") === "") {
            // It's okay to have a lang="" if not on html
        }
        else {
            var langStr = ruleContext.getAttribute("xml:lang");
            if (!lang_1.LangUtil.validPrimaryLang(langStr)) {
                return (0, IRule_1.RuleFail)("Fail_3");
            }
            if (!lang_1.LangUtil.isBcp47(langStr)) {
                return (0, IRule_1.RuleFail)("Fail_4");
            }
        }
    }
    return (0, IRule_1.RulePass)("Pass_0");
};
exports.html_lang_valid = {
    id: "html_lang_valid",
    context: "dom:html[lang], dom:html[xml:lang]",
    help: {
        "en-US": {
            "Pass_0": "html_lang_valid.html",
            "Fail_1": "html_lang_valid.html",
            "Fail_2": "html_lang_valid.html",
            "Fail_3": "html_lang_valid.html",
            "Fail_4": "html_lang_valid.html",
            "group": "html_lang_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Lang has a valid primary lang and conforms to BCP 47",
            "Fail_1": "Specified 'lang' attribute does not include a valid primary language",
            "Fail_2": "Specified 'lang' attribute does not conform to BCP 47",
            "Fail_3": "Specified 'xml:lang' attribute does not include a valid primary language",
            "Fail_4": "Specified 'xml:lang' attribute does not conform to BCP 47",
            "group": "The default human language of the page must be valid and specified in accordance with BCP 47"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [{
            "b5c3f8": {
                "Pass_0": "pass",
                "Fail_1": "fail",
                "Fail_2": "inapplicable",
                "Fail_3": "inapplicable",
                "Fail_4": "inapplicable"
            },
            "bf051a": {
                "Pass_0": "pass",
                "Fail_1": "fail",
                "Fail_2": "pass",
                "Fail_3": "fail",
                "Fail_4": "inapplicable"
            },
            // TODO: ACT: Mismatch because they don't check the html element in the same rule
            // "de46e4": {
            //     "Pass_0": "pass",
            //     "Fail_1": "fail",
            //     "Fail_2": "pass",
            //     "Fail_3": "inapplicable",
            //     "Fail_4": "inapplicable"
            // }
        }],
    run: validateLang
};
exports.element_lang_valid = {
    id: "element_lang_valid",
    context: "dom:*[lang], dom:*[xml:lang]",
    help: {
        "en-US": {
            "Pass_0": "element_lang_valid.html",
            "Fail_1": "element_lang_valid.html",
            "Fail_2": "element_lang_valid.html",
            "Fail_3": "element_lang_valid.html",
            "Fail_4": "element_lang_valid.html",
            "group": "element_lang_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Lang has a valid primary lang and conforms to BCP 47",
            "Fail_1": "Specified 'lang' attribute does not include a valid primary language",
            "Fail_2": "Specified 'lang' attribute does not conform to BCP 47",
            "Fail_3": "Specified 'xml:lang' attribute does not include a valid primary language",
            "Fail_4": "Specified 'xml:lang' attribute does not conform to BCP 47",
            "group": "The change in language of specific content must be valid and specified in accordance with BCP 47"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [{
            // "b5c3f8": {
            //     "Pass_0": "pass",
            //     "Fail_1": "fail",
            //     "Fail_2": "inapplicable",
            //     "Fail_3": "inapplicable",
            //     "Fail_4": "inapplicable"
            // },
            // "bf051a": {
            //     "Pass_0": "pass",
            //     "Fail_1": "fail",
            //     "Fail_2": "pass",
            //     "Fail_3": "fail",
            //     "Fail_4": "inapplicable"
            // },
            // TODO: ACT: Mismatch because they don't check the html element in the same rule
            "de46e4": {
                "Pass_0": "pass",
                "Fail_1": "fail",
                "Fail_2": "pass",
                "Fail_3": "inapplicable",
                "Fail_4": "inapplicable"
            }
        }],
    run: function (context, options, contextHierarchies) {
        // If it's the HTML node, that's handled by html_lang_valid
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (nodeName === "html")
            return null;
        var retVal = validateLang(context, options, contextHierarchies);
        if (retVal.value[1] !== IRule_1.eRuleConfidence.PASS) {
            // Ensure that there's actually content of this element - skip subtrees that have other lang attributes
            var hasContent = false;
            if (ruleContext.firstChild !== null) {
                var nw = new DOMWalker_1.DOMWalker(ruleContext);
                while (!hasContent && nw.nextNode()) {
                    // Skip hidden
                    if (nw.node.nodeType === 1) {
                        var element = nw.node;
                        if (!VisUtil_1.VisUtil.isNodeVisible(element) || element.hasAttribute("lang")) {
                            nw.bEndTag = true;
                        }
                        else {
                            hasContent = hasContent
                                || element.nodeName.toLowerCase() === "img" && ARIAMapper_1.ARIAMapper.computeName(element).trim().length > 0;
                        }
                    }
                    else {
                        hasContent = hasContent
                            || nw.node.nodeType === 3 && nw.node.nodeValue.trim().length > 0;
                    }
                }
            }
            if (!hasContent)
                return null;
        }
        return retVal;
    }
};


/***/ }),

/***/ 2150:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_mouseevent_keyboard = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.element_mouseevent_keyboard = {
    id: "element_mouseevent_keyboard",
    context: "dom:*[ondblclick], dom:*[onmousemove], dom:*[onmousedown], dom:*[onmouseup], dom:*[onmouseover], dom:*[onmouseout], dom:*[onclick]",
    refactor: {
        "RPT_Elem_EventMouseAndKey": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "element_mouseevent_keyboard.html",
            "Manual_1": "element_mouseevent_keyboard.html",
            "group": "element_mouseevent_keyboard.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Confirm the <{0}> element with mouse event handler(s) '{1}' has a corresponding keyboard handler(s)",
            "group": "All interactive content with mouse event handlers must have equivalent keyboard access"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var passed = ruleContext.hasAttribute("href") ||
            (!ruleContext.hasAttribute("ondblclick") &&
                !ruleContext.hasAttribute("onmousemove") &&
                (!ruleContext.hasAttribute("onmousedown") || ruleContext.hasAttribute("onkeydown")) &&
                (!ruleContext.hasAttribute("onmouseup") || ruleContext.hasAttribute("onkeyup")) &&
                (!ruleContext.hasAttribute("onmouseover") || ruleContext.hasAttribute("onfocus")) &&
                (!ruleContext.hasAttribute("onmouseout") || ruleContext.hasAttribute("onblur")) &&
                (!ruleContext.hasAttribute("onclick") || ruleContext.hasAttribute("onkeypress") ||
                    nodeName == "a" || nodeName == "button"));
        var failedMouseEvents = new Array();
        if (!passed) {
            //store and display event name and node name in the tokens
            if (ruleContext.hasAttribute("ondblclick")) {
                failedMouseEvents.push("ondblclick");
            }
            if (ruleContext.hasAttribute("onmousemove")) {
                failedMouseEvents.push("onmousemove");
            }
            if (ruleContext.hasAttribute("onmousedown") && !ruleContext.hasAttribute("onkeydown")) {
                failedMouseEvents.push("onmousedown");
            }
            if (ruleContext.hasAttribute("onmouseup") && !ruleContext.hasAttribute("onkeyup")) {
                failedMouseEvents.push("onmouseup");
            }
            if (ruleContext.hasAttribute("onmouseover") && !ruleContext.hasAttribute("onfocus")) {
                failedMouseEvents.push("onmouseover");
            }
            if (ruleContext.hasAttribute("onmouseout") && !ruleContext.hasAttribute("onblur")) {
                failedMouseEvents.push("onmouseout");
            }
            if (ruleContext.hasAttribute("onclick") && !ruleContext.hasAttribute("onkeypress")) {
                if (!(nodeName == "a" || nodeName == "button"))
                    failedMouseEvents.push("onclick");
            }
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RuleManual)("Manual_1", [nodeName, failedMouseEvents.join(", ")]);
    }
};


/***/ }),

/***/ 4557:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_orientation_unlocked = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CSSUtil_1 = __webpack_require__(1775);
var VisUtil_1 = __webpack_require__(8174);
var CacheUtil_1 = __webpack_require__(7788);
var fragment_1 = __webpack_require__(482);
var legacy_1 = __webpack_require__(8422);
exports.element_orientation_unlocked = {
    id: "element_orientation_unlocked",
    context: "dom:*",
    help: {
        "en-US": {
            "pass": "element_orientation_unlocked.html",
            "fail_locked": "element_orientation_unlocked.html",
            "group": "element_orientation_unlocked.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element is not restricted to either landscape or portrait orientation using CSS transform property",
            "fail_locked": "The element <{0}> is restricted to either landscape or portrait orientation using CSS transform property",
            "group": "Elements should not be restricted to either landscape or portrait orientation using CSS transform property"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.4"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: ['b33eff'],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip invisible element
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext))
            return null;
        //skip elements
        if (legacy_1.RPTUtil.getAncestor(ruleContext, ["script", "meta", "title"]))
            return null;
        var nodeName = ruleContext.nodeName.toLowerCase();
        // cache the orientation ressult for all the elements in the page
        var doc = fragment_1.FragmentUtil.getOwnerFragment(ruleContext);
        var orientationTransforms = (0, CacheUtil_1.getCache)(doc, "RPTUtil_MEDIA_ORIENTATION_TRANSFROM", null);
        if (!orientationTransforms) {
            orientationTransforms = (0, CSSUtil_1.getMediaOrientationTransform)(doc);
            (0, CacheUtil_1.setCache)(doc, "RPTUtil_MEDIA_ORIENTATION_TRANSFROM", orientationTransforms);
        }
        // find if the element matches orientation selector(s)
        var media_transforms = [];
        Object.keys(orientationTransforms).forEach(function (key) {
            Object.keys(orientationTransforms[key]).forEach(function (tag) {
                if (Object.keys(orientationTransforms[key][tag]).length > 0 && (0, CSSUtil_1.selectorMatchesElem)(ruleContext, tag))
                    media_transforms.push(orientationTransforms[key][tag].transform);
            });
        });
        // no match, the elemenet is not in media orientation transform
        if (media_transforms.length === 0)
            return null;
        var ret = [];
        var _loop_1 = function (i) {
            var media_transform = media_transforms[i];
            var containsRotation = false;
            ['rotate', 'rotate3d', 'rotateZ', 'matrix', 'matrix3d'].forEach(function (rotation) {
                if (media_transform.includes(rotation))
                    containsRotation = true;
            });
            // no rotation transform, skip
            if (!containsRotation)
                return "continue";
            var degree = (0, CSSUtil_1.getRotationDegree)(media_transform);
            // no or 360n degree rotation 
            if (degree === 0) {
                ret.push((0, IRule_1.RulePass)("pass"));
                return "continue";
            }
            /**
             * calculate the original page rotation transformation, example
             *  html { transform: rotate(2.5deg); }
            */
            var definedStyle = (0, CSSUtil_1.getDefinedStyles)(ruleContext);
            /**
             * compensate the media orientation with the page orientation
             */
            if (definedStyle['transform']) {
                var page_degree = (0, CSSUtil_1.getRotationDegree)(definedStyle['transform']);
                degree -= page_degree;
            }
            // allow 1 degree floating range for the right angle
            if ((degree > 89 && degree < 91) || (degree > -91 && degree < -89))
                ret.push((0, IRule_1.RuleFail)("fail_locked", [nodeName]));
            else
                ret.push((0, IRule_1.RulePass)("pass"));
        };
        for (var i = 0; i < media_transforms.length; i++) {
            _loop_1(i);
        }
        if (ret.length > 0)
            return ret;
        return null;
    }
};


/***/ }),

/***/ 4721:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_scrollable_tabbable = void 0;
var legacy_1 = __webpack_require__(8422);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8174);
var CSSUtil_1 = __webpack_require__(1775);
exports.element_scrollable_tabbable = {
    id: "element_scrollable_tabbable",
    context: "dom:*",
    dependencies: [],
    help: {
        "en-US": {
            "group": "element_scrollable_tabbable.html",
            "pass_tabbable": "element_scrollable_tabbable.html",
            "pass_interactive": "element_scrollable_tabbable.html",
            "fail_scrollable": "element_scrollable_tabbable.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Scrollable elements should be tabbable or contain tabbable content",
            "pass_tabbable": "The scrollable element is tabbable",
            "pass_interactive": "The scrollable element has tabbable content",
            "fail_scrollable": "The scrollable element <{0}> with non-interactive content is not tabbable"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            num: ["2.1.1"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: ["ossw9k"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) || legacy_1.RPTUtil.isNodeDisabled(ruleContext))
            return;
        //skip elements
        if (legacy_1.RPTUtil.getAncestor(ruleContext, ["iframe", "svg", "script", "meta"]))
            return null;
        //skip if no visible content
        if (!legacy_1.RPTUtil.hasInnerContent(ruleContext))
            return null;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var styles = (0, CSSUtil_1.getComputedStyle)(ruleContext);
        // not scrollable, inapplicable
        if ((styles.overflowX === 'visible' || styles.overflowX === 'hidden')
            && (styles.overflowY === 'visible' || styles.overflowY === 'hidden'))
            return null;
        // ignore if the overall scrollable element (clientWidth + scrollbarWidth and clientHeight + scrollbarHeight) is too small to be visible on screen
        if (Math.max(ruleContext.offsetWidth, ruleContext.offsetHeight) < 30 || Math.min(ruleContext.offsetWidth, ruleContext.offsetHeight) < 15)
            return null;
        // ignore if both x and y scroll distances < element's horizontal/vertical padding
        var padding_x = (0, CSSUtil_1.getPixelsFromStyle)(styles.paddingLeft, ruleContext) + (0, CSSUtil_1.getPixelsFromStyle)(styles.paddingRight, ruleContext);
        var padding_y = (0, CSSUtil_1.getPixelsFromStyle)(styles.paddingTop, ruleContext) + (0, CSSUtil_1.getPixelsFromStyle)(styles.paddingBottom, ruleContext);
        if (ruleContext.scrollWidth - ruleContext.clientWidth < 1 + padding_x
            && ruleContext.scrollHeight - ruleContext.clientHeight < 1 + padding_y)
            return null;
        // pass iframe element has a tabindex attribute value that is not negative
        if (ruleContext.hasAttribute("tabindex") && parseInt(ruleContext.getAttribute("tabindex")) >= 0)
            return (0, IRule_1.RulePass)("pass_tabbable");
        // check if element content is tabbable
        var count = legacy_1.RPTUtil.getTabbableChildren(ruleContext);
        if (count > 0)
            return (0, IRule_1.RulePass)("pass_interactive");
        // ignore in Firefox if no tabindex at all (not tested in embedded or any simulator)
        if (!ruleContext.hasAttribute("tabindex") && navigator.userAgent.indexOf("Firefox") > -1)
            return null;
        return (0, IRule_1.RuleFail)("fail_scrollable", [nodeName]);
    }
};


/***/ }),

/***/ 2814:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_tabbable_role_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var ARIADefinitions_1 = __webpack_require__(8235);
var CSSUtil_1 = __webpack_require__(1775);
var DOMWalker_1 = __webpack_require__(7440);
var VisUtil_1 = __webpack_require__(8174);
exports.element_tabbable_role_valid = {
    id: "element_tabbable_role_valid",
    context: "dom:*",
    help: {
        "en-US": {
            "pass": "element_tabbable_role_valid.html",
            "fail_invalid_role": "element_tabbable_role_valid.html",
            "group": "element_tabbable_role_valid.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The tabbable element has a widget role",
            "fail_invalid_role": "The tabbable element's role '{0}' is not a widget role",
            "group": "A tabbable element must have a valid widget role"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        },
        {
            "id": ["WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (legacy_1.RPTUtil.isNodeDisabled(ruleContext) || VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var nodeName = ruleContext.nodeName.toLowerCase();
        // if the element is tabbable by default with or without tabindex, let the other rules (such as widget_tabbable_single) to handle it
        if (nodeName in legacy_1.RPTUtil.tabTagMap) {
            var value = legacy_1.RPTUtil.tabTagMap[nodeName];
            if (typeof (value) === "function") {
                value = value(ruleContext);
            }
            if (value)
                return null;
        }
        // handle the case: no tabindex or tabindex < 0
        if (!ruleContext.hasAttribute("tabindex") || parseInt(ruleContext.getAttribute("tabindex")) < 0)
            return null;
        // ignore elements with CSS overflow: scroll or auto
        var styles = (0, CSSUtil_1.getDefinedStyles)(ruleContext);
        if (styles['overflow-x'] === 'scroll' || styles['overflow-y'] === 'scroll'
            || styles['overflow-x'] === 'auto' || styles['overflow-y'] === 'auto')
            return null;
        var roles = legacy_1.RPTUtil.getRoles(ruleContext, false);
        // ignore 'application' role that contains one or more focusable elements that do not follow a standard interaction pattern supported by a widget role:https://www.w3.org/TR/2023/PR-WAI-ARIA-1.2-20230328/#application 
        if (roles && roles.includes("application"))
            return null;
        // elements whose roles allow no descendants that are interactive or with a tabindex >= 0 
        // this case should be handled in widget_tabbable_single and aria_child_tabbable
        var roles_no_interactive_child = ["button", "checkbox", "img", "link", "menuitem", "menuitemcheckbox", "menuitemradio",
            "option", "radio", "switch", "tab"];
        if (!roles || roles.length === 0) {
            roles = legacy_1.RPTUtil.getImplicitRole(ruleContext);
        }
        var parent = DOMWalker_1.DOMWalker.parentNode(ruleContext);
        var parent_roles = legacy_1.RPTUtil.getRoles(parent, true);
        // ignore if one of the parent roles is in roles_no_interactive_child
        for (var i = 0; i < parent_roles.length; i++) {
            if (roles_no_interactive_child.includes(parent_roles[i]))
                return null;
        }
        // handle the case: tabindex >= 0 to examine whether a widget role is setup or not 
        // pass if one of the roles is a widget type
        for (var i = 0; i < roles.length; i++) {
            // Row is weird. It's structure, but can also be widget
            if (roles[i] === "row" || ARIADefinitions_1.ARIADefinitions.designPatterns[roles[i]].roleType === 'widget') {
                return (0, IRule_1.RulePass)("pass");
            }
            // Focusable separators are widgets
            if (roles[i] === "separator") {
                return (0, IRule_1.RulePass)("pass");
            }
        }
        return (0, IRule_1.RuleFail)("fail_invalid_role", [roles.length === 0 ? 'none' : roles.join(', ')]);
    }
};


/***/ }),

/***/ 7601:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_tabbable_visible = void 0;
var legacy_1 = __webpack_require__(8422);
var CSSUtil_1 = __webpack_require__(1775);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.element_tabbable_visible = {
    id: "element_tabbable_visible",
    context: "dom:*",
    dependencies: [],
    help: {
        "en-US": {
            "group": "element_tabbable_visible.html",
            "pass": "element_tabbable_visible.html",
            "potential_visible": "element_tabbable_visible.html"
        }
    },
    messages: {
        "en-US": {
            "group": "A tabbable element should be visible on the screen when it has keyboard focus",
            "pass": "The tabbable element is visible on the screen",
            "potential_visible": "Confirm the element should be tabbable, and is visible on the screen when it has keyboard focus"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            num: ["2.4.7"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!legacy_1.RPTUtil.isTabbable(ruleContext))
            return null;
        var nodeName = ruleContext.nodeName.toLocaleLowerCase();
        var bounds = context["dom"].bounds;
        //in case the bounds not available
        if (!bounds)
            return null;
        // defined styles only give the styles that changed
        var defined_styles = (0, CSSUtil_1.getDefinedStyles)(ruleContext);
        var onfocus_styles = (0, CSSUtil_1.getDefinedStyles)(ruleContext, ":focus");
        if (bounds['height'] === 0 || bounds['width'] === 0
            || (defined_styles['position'] === 'absolute' && defined_styles['clip'] && defined_styles['clip'].replaceAll(' ', '') === 'rect(0px,0px,0px,0px)'
                && !onfocus_styles['clip']))
            return (0, IRule_1.RulePotential)("potential_visible", []);
        if (bounds['top'] >= 0 && bounds['left'] >= 0)
            return (0, IRule_1.RulePass)("pass");
        var default_styles = (0, CSSUtil_1.getComputedStyle)(ruleContext);
        var top = bounds['top'];
        var left = bounds['left'];
        if (Object.keys(onfocus_styles).length === 0) {
            // no onfocus position change, but could be changed from js 
            return (0, IRule_1.RulePotential)("potential_visible", []);
        }
        else {
            // with onfocus position change
            var positions = ['absolute', 'fixed'];
            if (typeof onfocus_styles['top'] !== 'undefined') {
                if (positions.includes(onfocus_styles['position']) || (typeof onfocus_styles['position'] === 'undefined' && positions.includes(default_styles['position']))) {
                    top = onfocus_styles['top'].replace(/\D/g, '');
                }
                else {
                    // the position is undefined and the parent's position is 'relative'
                    top = Number.MIN_VALUE;
                }
            }
            if (typeof onfocus_styles['left'] !== 'undefined') {
                if (positions.includes(onfocus_styles['position']) || (typeof onfocus_styles['position'] === 'undefined' && positions.includes(default_styles['position']))) {
                    left = onfocus_styles['left'].replace(/\D/g, '');
                }
                else {
                    // the position is undefined and the parent's position is 'relative'
                    left = Number.MIN_VALUE;
                }
            }
        }
        if (top >= 0 && left >= 0)
            return (0, IRule_1.RulePass)("pass");
        else
            return (0, IRule_1.RulePotential)("potential_visible", []);
    }
};


/***/ }),

/***/ 4497:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.embed_alt_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.embed_alt_exists = {
    id: "embed_alt_exists",
    context: "dom:embed",
    refactor: {
        "RPT_Embed_HasAlt": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "embed_alt_exists.html",
            "Potential_1": "embed_alt_exists.html",
            "group": "embed_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that the <embed> element has alternative content",
            "group": "Provide alternative content for <embed> elements"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "alt");
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 152:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.embed_noembed_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.embed_noembed_exists = {
    id: "embed_noembed_exists",
    context: "dom:embed",
    refactor: {
        "WCAG20_Embed_HasNoEmbed": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "embed_noembed_exists.html",
            "Potential_1": "embed_noembed_exists.html",
            "group": "embed_noembed_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that the <embed> element is immediately followed by a non-embedded element",
            "group": "<embed> elements should be immediately followed by a non-embedded element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = ruleContext.getElementsByTagName("noembed").length > 0;
        if (!passed) {
            var walkNode = ruleContext.nextSibling;
            while (!passed && walkNode !== null) {
                if (walkNode.nodeName.toLowerCase() == "noembed")
                    passed = true;
                else if (walkNode.nodeName.toLowerCase() == "#text" && walkNode.nodeValue.trim().length > 0)
                    break;
                else if (walkNode.nodeType == 1)
                    break;
                walkNode = walkNode.nextSibling;
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 935:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.emoticons_alt_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.emoticons_alt_exists = {
    id: "emoticons_alt_exists",
    context: "dom:*",
    refactor: {
        "WCAG20_Text_Emoticons": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "emoticons_alt_exists.html",
            "Potential_1": "emoticons_alt_exists.html",
            "group": "emoticons_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that emoticons have a text alternative",
            "group": "Emoticons must have a short text alternative that describes their purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            emoticons: {
                value: [":-)", ":)", ":o)", ":]", ":3", ":c)", ":>", "=]", "8)", "=)", ":D", "C:",
                    ":-D", ":D", "8D", "XD", "=D", "=3", "<=3", "<=8", "--!--", ":-(", ":(", ":c", ":<", ":[",
                    "D:", "D8", "D;", "D=", "DX", "v.v", ":-9", ";-)", ";)", "*)", ";]", ";D", ":-P", ":P",
                    ":-p", ":p", "=p", ":-Þ", ":Þ", ":-b", ":b", ":-O", ":O", "O_O", "o_o", "8O", "OwO", "O-O",
                    "0_o", "O_o", "O3O", "o0o ;o_o;", "o...o", "0w0", ":-/", ":/", ":\\", "=/", "=\\", ":S", ":|",
                    "d:-)", "qB-)", ":)~", ":-)>....", ":-X", ":X", ":-#", ":#", "O:-)", "0:3", "O:)", ":'(", ";*(",
                    "T_T", "TT_TT", "T.T", ":-*", ":*", "^o)", ">:)", ">;)", ">:-)", "B)", "B-)", "8)", "8-)",
                    "^>.>^", "^<.<^", "^>_>^", "^<_<^", "D:<", ">:(", "D-:<", ">:-(", ":-@[1]", ";(", "`_´", "D<",
                    "<3", "<333", "=^_^=", "=>.>=", "=<_<=", "=>.<=", "\\,,/", "\\m/", "\\m/\\>.</\\m/", "\\o/", "\\o o/",
                    "o/\\o", ":&", ":u"
                ],
                type: "[string]"
            }
        };
        var ruleContext = context["dom"].node;
        var emoticons = validateParams.emoticons.value;
        var passed = true;
        var testText = "";
        var walkNode = ruleContext.firstChild;
        while (walkNode) {
            // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
            // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
            // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
            // a node walk only on siblings so it would not get text nodes from other siblings at all.
            // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
            // if.
            if (walkNode.nodeName == "#text") {
                testText += " " + walkNode.nodeValue;
            }
            walkNode = walkNode.nextSibling;
        }
        if (testText.trim().length > 0) {
            for (var j = 0; passed && j < emoticons.length; ++j) {
                var emotIdx = testText.indexOf(emoticons[j]);
                var eLngth = emoticons[j].length;
                while (passed && emotIdx != -1) {
                    // Passes if: the emoticon is not preceded by whitespace,
                    // or the emoticon is not followed by whitespace unless it's punctuation,
                    // or it's in a pre, code, or script
                    passed =
                        (emotIdx > 0 && !/\s/.test(testText.substring(emotIdx - 1, emotIdx))) ||
                            (emotIdx < testText.length - eLngth && !/\s/.test(testText.substring(emotIdx + eLngth, emotIdx + eLngth + 1)) &&
                                !/[.,!'"?]/.test(testText.substring(emotIdx + eLngth, emotIdx + eLngth + 1)));
                    // Allow usage of (: stuff :) since this is a comment in some languages
                    passed = passed || ((emoticons[j] == ":)" || emoticons[j] == "(:") && /\(\:.*\:\)/.test(testText));
                    passed = passed || ((emoticons[j] == ";)" || emoticons[j] == "(;") && /\(\;.*\;\)/.test(testText));
                    emotIdx = testText.indexOf(emoticons[j], emotIdx + 1);
                }
            }
        }
        if (!passed) {
            // Don't trigger if we're not in the body or if we're in a script, pre, code
            var checkAncestor = legacy_1.RPTUtil.getAncestor(ruleContext, ["pre", "code", "script", "body"]);
            passed = checkAncestor == null || checkAncestor.nodeName.toLowerCase() != "body";
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9719:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.error_message_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var fragment_1 = __webpack_require__(482);
var VisUtil_1 = __webpack_require__(8174);
exports.error_message_exists = {
    id: "error_message_exists",
    context: "dom:*[aria-invalid=true]",
    refactor: {
        "HAAC_Aria_ErrorMessage": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "error_message_exists.html",
            "Fail_1": "error_message_exists.html",
            "Fail_2": "error_message_exists.html",
            "group": "error_message_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Custom error message has invalid reference 'id' value",
            "Fail_2": "Custom error message is not visible",
            "group": "A custom error message must reference a valid 'id' value and when triggered the message must be appropriately exposed"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var aria_errMsgId = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-errormessage");
        // If aria-errormessage is not provided, then OUT_OF_SCOPE
        if (!aria_errMsgId) {
            return null;
        }
        var msg_ele = fragment_1.FragmentUtil.getById(ruleContext, aria_errMsgId);
        // POF0: Invalid id reference
        if (!msg_ele) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        // POF1: Referenced element is not visible
        if (!VisUtil_1.VisUtil.isNodeVisible(msg_ele)) {
            return (0, IRule_1.RuleFail)("Fail_2");
        }
        return (0, IRule_1.RulePass)("Pass_0");
    }
};


/***/ }),

/***/ 5625:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fieldset_label_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var ARIAMapper_1 = __webpack_require__(4944);
var fragment_1 = __webpack_require__(482);
var CacheUtil_1 = __webpack_require__(7788);
exports.fieldset_label_valid = {
    id: "fieldset_label_valid",
    context: "aria:group",
    refactor: {
        "group_withInputs_hasName": {
            "Pass_1": "Pass_1",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_1": "fieldset_label_valid.html",
            "Fail_1": "fieldset_label_valid.html",
            "Fail_2": "fieldset_label_valid.html",
            "group": "fieldset_label_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_1": "Group/Fieldset \"{0}\" with an input has a unique name",
            "Fail_1": "Group/Fieldset does not have an accessible name",
            "Fail_2": "Group/Fieldset \"{0}\" has a duplicate name to another group",
            "group": "Groups with nested inputs must have unique accessible name"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1", "3.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var ownerDocument = fragment_1.FragmentUtil.getOwnerFragment(ruleContext);
        var formCache = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "landmark_group_input", null);
        if (!formCache) {
            formCache = {
                groupsWithInputs: [],
                groupsWithInputsComputedLabels: [],
            };
            var allGroupsTemp = ownerDocument.querySelectorAll('fieldset,[role="group"]');
            var allGroups = Array.from(allGroupsTemp);
            var groupsWithInputs = [];
            for (var i = 0; i < allGroups.length; i++) {
                // Loop over all the group nodes
                if (allGroups[i].querySelector("input")) {
                    groupsWithInputs.push(allGroups[i]);
                }
            }
            var groupsWithInputsComputedLabels = [];
            for (var i = 0; i < groupsWithInputs.length; i++) {
                // Loop over all the landmark nodes
                groupsWithInputsComputedLabels.push(ARIAMapper_1.ARIAMapper.computeName(groupsWithInputs[i]));
            }
            formCache.groupsWithInputs = groupsWithInputs;
            formCache.groupsWithInputsComputedLabels =
                groupsWithInputsComputedLabels;
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "landmark_group_input", formCache);
        }
        // formCache.groupsWithInputs.forEach(element => {
        //     console.log("formCache.groupsWithInputs: " +element.id)
        // });
        // console.log("formCache.groupsWithInputsComputedLabels: " +formCache.groupsWithInputsComputedLabels)
        // console.log("formCache.groupsWithInputsComputedLabels: " +formCache.groupsWithInputsComputedLabels.length)
        var ruleContextFoundIngroupsWithInputsFlag = false;
        var computedName = "";
        if (!formCache.groupsWithInputs) {
            // We do not have any groups with inputs. Therefore we should skip this rule trigger.
            return null;
        }
        for (var i = 0; i < formCache.groupsWithInputs.length; i++) {
            if (ruleContext.isSameNode(formCache.groupsWithInputs[i])) {
                // We have found our ruleContext in the cache
                ruleContextFoundIngroupsWithInputsFlag = true;
                if (formCache.groupsWithInputsComputedLabels[i] === "" ||
                    formCache.groupsWithInputsComputedLabels[i] === null) {
                    // console.log("Fail_1")
                    return (0, IRule_1.RuleFail)("Fail_1");
                }
                var foundSameNameFlag = false;
                for (var j = 0; j < formCache.groupsWithInputsComputedLabels.length; j++) {
                    if (i == j) {
                        continue;
                    } // We do not want to compare against ourselfs
                    if (formCache.groupsWithInputsComputedLabels[i] ===
                        formCache.groupsWithInputsComputedLabels[j]) {
                        foundSameNameFlag = true;
                    }
                }
                if (foundSameNameFlag) {
                    // console.log("Fail_2")
                    return (0, IRule_1.RuleFail)("Fail_2", [
                        formCache.groupsWithInputsComputedLabels[i],
                    ]);
                }
                computedName = formCache.groupsWithInputsComputedLabels[i];
            }
        }
        if (!ruleContextFoundIngroupsWithInputsFlag) {
            // console.log("null return")
            return null;
        }
        // console.log("Pass_1")
        return (0, IRule_1.RulePass)("Pass_1", [computedName]);
    }
};


/***/ }),

/***/ 9115:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fieldset_legend_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.fieldset_legend_valid = {
    id: "fieldset_legend_valid",
    context: "dom:fieldset",
    refactor: {
        "WCAG20_Fieldset_HasLegend": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "fieldset_legend_valid.html",
            "Fail_1": "fieldset_legend_valid.html",
            "Fail_2": "fieldset_legend_valid.html",
            "Fail_3": "fieldset_legend_valid.html",
            "group": "fieldset_legend_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "<fieldset> element does not have a <legend>",
            "Fail_2": "<fieldset> element has more than one <legend>",
            "Fail_3": "<fieldset> element <legend> is empty",
            "group": " <fieldset> elements must have a single, non-empty <legend> as a label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // In the case a legend is hidden, we should still trigger a violations for this
        var legends = legacy_1.RPTUtil.getChildByTagHidden(ruleContext, "legend", true, false);
        if (legends.length === 0) {
            // Fieldset has NO Legend
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else if (legends.length > 1) {
            // Fieldset has more than one legend
            return (0, IRule_1.RuleFail)("Fail_2");
        }
        else if (legacy_1.RPTUtil.getInnerText(legends[0]).trim().length === 0) {
            // Fieldset has legend but legend is empty
            return (0, IRule_1.RuleFail)("Fail_3");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 6072:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.figure_label_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8174);
exports.figure_label_exists = {
    id: "figure_label_exists",
    context: "dom:figure",
    refactor: {
        "HAAC_Figure_label": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "figure_label_exists.html",
            "Fail_1": "figure_label_exists.html",
            "group": "figure_label_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The <figure> element does not have an associated label",
            "group": "A <figure> element must have an associated label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = false;
        var figures = ruleContext.getElementsByTagName("figcaption");
        // Loop over all the figcaption elements to make sure there is at least one that is not empty and not hidden.
        for (var i = 0; !passed && i < figures.length; ++i) {
            // Mark this rule as passed if any one of the figurecaption element has content and is visible
            if (figures[i].innerHTML.trim().length > 0 && VisUtil_1.VisUtil.isNodeVisible(figures[i])) {
                passed = true;
            }
        }
        if (!passed) {
            // we only check if the "aria-labelledby" is there. There is a different rule to check if the id is valid.
            passed = ruleContext.hasAttribute("aria-labelledby") && ruleContext.getAttribute("aria-labelledby").trim().length > 0;
        }
        //return new ValidationResult(passed, [ruleContext], '', '', []);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", []);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 6923:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.form_font_color = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.form_font_color = {
    id: "form_font_color",
    context: "dom:form",
    refactor: {
        "RPT_Font_ColorInForm": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "form_font_color.html",
            "Potential_1": "form_font_color.html",
            "group": "form_font_color.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Check color is not used as the only visual means to convey which fields are required",
            "group": "Combine color and descriptive markup to indicate required form fields"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = true;
        var fonts = ruleContext.getElementsByTagName("font");
        if (fonts != null) {
            for (var i = 0; i < fonts.length; ++i) {
                passed = !fonts[i].hasAttribute("color");
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9015:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.form_interaction_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.form_interaction_review = {
    id: "form_interaction_review",
    context: "dom:form[target]",
    refactor: {
        "WCAG20_Form_TargetAndText": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "form_interaction_review.html",
            "Potential_1": "form_interaction_review.html",
            "group": "form_interaction_review.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that interacting with content will not open pop-up windows or change the active window without informing the user",
            "group": "User should be informed in advance when interacting with content causes a change of context"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.2.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            paramWinText: {
                value: ["new window"],
                type: "array"
            }
        };
        var ruleContext = context["dom"].node;
        var tStr = ruleContext.getAttribute("target");
        var passed = tStr === "_parent" || tStr === "_self" || tStr === "_top" || legacy_1.RPTUtil.getFrameByName(ruleContext, tStr) != null;
        if (!passed) {
            // Name is not part of this frameset – must have potential to create new window?
            // See if a new window is mentioned
            var textStr = legacy_1.RPTUtil.getInnerText(ruleContext);
            if (ruleContext.hasAttribute("title"))
                textStr += " " + ruleContext.getAttribute("title");
            for (var i = 0; !passed && i < validateParams.paramWinText.value.length; ++i)
                if (textStr.indexOf(validateParams.paramWinText.value[i]) != -1)
                    passed = true;
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 3611:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.form_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var fragment_1 = __webpack_require__(482);
var CacheUtil_1 = __webpack_require__(7788);
exports.form_label_unique = {
    id: "form_label_unique",
    context: "dom:label[for]",
    refactor: {
        "RPT_Label_UniqueFor": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "form_label_unique.html",
            "Fail_1": "form_label_unique.html",
            "group": "form_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Form control has more than one label",
            "group": "Form controls should have exactly one label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // JCH - NO OUT OF SCOPE hidden in context
        var labelIds = (0, CacheUtil_1.getCache)(fragment_1.FragmentUtil.getOwnerFragment(ruleContext), "RPT_Label_Single", {});
        var id = ruleContext.getAttribute("for");
        var passed = !(id in labelIds);
        labelIds[id] = true;
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.form_submit_button_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.form_submit_button_exists = {
    id: "form_submit_button_exists",
    context: "dom:form",
    refactor: {
        "WCAG20_Form_HasSubmit": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "form_submit_button_exists.html",
            "Potential_1": "form_submit_button_exists.html",
            "group": "form_submit_button_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify the <form> element has a submit button or an image button",
            "group": "A <form> element should have a submit button or an image button"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.2.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = false;
        if (ruleContext.firstChild) {
            // submit buttons are usually at the bottom - walk backwards
            var nw = new legacy_1.NodeWalker(ruleContext, true);
            while (!passed && nw.prevNode() && nw.node != ruleContext) {
                if (!nw.bEndTag) {
                    var nodeName = nw.node.nodeName.toLowerCase();
                    if (nodeName === "input") {
                        var type = nw.elem().getAttribute("type");
                        if (type) {
                            type = type.toLowerCase();
                        }
                        passed = type === "submit" || type === "image";
                    }
                    else if (nodeName === "button") {
                        passed = nw.elem().hasAttribute("type") && nw.elem().getAttribute("type").toLowerCase() === "submit";
                    }
                    else if (nw.node.nodeType === 1) {
                        passed = legacy_1.RPTUtil.hasRole(nw.node, "button");
                    }
                }
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 3277:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.form_submit_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.form_submit_review = {
    id: "form_submit_review",
    context: "dom:select[onchange], dom:input[onchange]",
    refactor: {
        "RPT_Form_ChangeEmpty": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "form_submit_review.html",
            "Potential_1": "form_submit_review.html",
            "group": "form_submit_review.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Confirm the form does not submit automatically without warning",
            "group": "A form should not be submitted automatically without warning the user"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.2.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = ruleContext.getAttribute("onchange").trim().length === 0;
        if (passed)
            return null;
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 4525:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.frame_src_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.frame_src_valid = {
    id: "frame_src_valid",
    context: "dom:frame, dom:iframe",
    refactor: {
        "Valerie_Frame_SrcHtml": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "frame_src_valid.html",
            "Potential_1": "frame_src_valid.html",
            "group": "frame_src_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify <frame> content is accessible",
            "group": "A <frame> containing non-HTML content must be made accessible"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "src") &&
            legacy_1.RPTUtil.isHtmlExt(legacy_1.RPTUtil.getFileExt(ruleContext.getAttribute("src")));
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 7114:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.frame_title_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var ARIAMapper_1 = __webpack_require__(4944);
exports.frame_title_exists = {
    id: "frame_title_exists",
    context: "dom:frame, dom:iframe",
    refactor: {
        "WCAG20_Frame_HasTitle": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "frame_title_exists.html",
            "Pass_0": "frame_title_exists.html",
            "Fail_1": "frame_title_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Inline frames must have a unique, non-empty 'title' attribute",
            "Pass_0": "Rule Passed",
            "Fail_1": "Inline frame does not have a 'title' attribute",
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: "cae760",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // JCH - NO OUT OF SCOPE hidden in context
        /*removed only the check for role=none. Although role=presentation is not allowed in the
         https://www.w3.org/TR/html-aria/#docconformance  table, the check has been kept due to the
         decisions taken in DAP "Check iframes with role="presentation" should consider role="none" also (96395)*/
        if (legacy_1.RPTUtil.hasRole(ruleContext, "presentation") || legacy_1.RPTUtil.hasRole(ruleContext, "none") || !legacy_1.RPTUtil.isTabbable(ruleContext)) {
            return null;
        }
        else if (ARIAMapper_1.ARIAMapper.computeName(ruleContext).trim().length > 0) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
    }
};


/***/ }),

/***/ 3751:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.heading_content_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.heading_content_exists = {
    id: "heading_content_exists",
    context: "dom:h1, dom:h2, dom:h3, dom:h4, dom:h5, dom:h6",
    refactor: {
        "RPT_Header_HasContent": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "heading_content_exists.html",
            "Fail_1": "heading_content_exists.html",
            "group": "heading_content_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Heading element has descriptive text",
            "Fail_1": "Heading element has no descriptive content",
            "group": "Heading elements must provide descriptive text"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.6"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = legacy_1.RPTUtil.hasInnerContentHidden(ruleContext);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 7084:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.heading_markup_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.heading_markup_misuse = {
    id: "heading_markup_misuse",
    context: "dom:h1, dom:h2, dom:h3, dom:h4, dom:h5, dom:h6",
    dependencies: ["heading_content_exists"],
    refactor: {
        "RPT_Headers_FewWords": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "heading_markup_misuse.html",
            "Potential_1": "heading_markup_misuse.html",
            "group": "heading_markup_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that the heading element is a genuine heading",
            "group": "Heading elements must not be used for presentation"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            headingLengthThresh: {
                value: 20,
                type: "integer"
            }
        };
        var ruleContext = context["dom"].node;
        var headingLengthThresh = validateParams.headingLengthThresh.value;
        var passed = legacy_1.RPTUtil.wordCount(legacy_1.RPTUtil.getInnerText(ruleContext)) <= headingLengthThresh;
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 3981:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.html_lang_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var ancestor_1 = __webpack_require__(9193);
var lang_1 = __webpack_require__(2527);
exports.html_lang_exists = {
    id: "html_lang_exists",
    context: "dom:html",
    refactor: {
        "WCAG20_Html_HasLang": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3",
            "Fail_4": "Fail_4",
            "Fail_5": "Fail_5",
            "Potential_5": "Potential_5",
            "Potential_6": "Potential_6"
        }
    },
    help: {
        "en-US": {
            "group": "html_lang_exists.html",
            "Pass_0": "html_lang_exists.html",
            "Fail_1": "html_lang_exists.html",
            "Fail_2": "html_lang_exists.html",
            "Fail_3": "html_lang_exists.html",
            "Fail_4": "html_lang_exists.html",
            "Fail_5": "html_lang_exists.html",
            "Potential_5": "html_lang_exists.html",
            "Potential_6": "html_lang_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Page must identify the default language of the document with a 'lang' attribute",
            "Pass_0": "Page language detected as \"{0}\"",
            "Fail_1": "Page detected as XHTML 1.0, but has neither 'lang' nor 'xml:lang' attributes",
            "Fail_2": "Page detected as XHTML, but does not have an 'xml:lang' attribute",
            "Fail_3": "Page detected as HTML, but does not have a 'lang' attribute",
            "Fail_4": "Page detected with 'lang' and 'xml:lang' attributes and primary languages do not match: \"{0}\", \"{1}\"",
            "Fail_5": "Page detected with 'lang' and 'xml:lang' attributes that do not match: \"{0}\", \"{1}\"",
            "Potential_5": "Page detected as XHTML 1.0 with only a 'lang' attribute. Confirm that page is only delivered via text/html mime type",
            "Potential_6": "Page detected as XHTML 1.0 with only an 'xml:lang' attribute. Confirm that page is only delivered via xml mime type"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "3.1.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [{
            "b5c3f8": {
                "Pass_0": "pass",
                "Fail_1": "inapplicable",
                "Fail_2": "inapplicable",
                "Fail_3": "fail",
                "Fail_4": "inapplicable",
                "Fail_5": "inapplicable",
                "Potential_5": "inapplicable",
                "Potential_6": "inapplicable"
            },
            "5b7ae0": {
                "Pass_0": "pass",
                "Fail_1": "inapplicable",
                "Fail_2": "inapplicable",
                "Fail_3": "inapplicable",
                "Fail_4": "fail",
                "Fail_5": "pass",
                "Potential_5": "inapplicable",
                "Potential_6": "inapplicable"
            }
        }],
    run: function (context, options, contextHierarchies) {
        // This rule does not apply inside a presentational frame
        if (ancestor_1.AncestorUtil.isPresentationFrame(contextHierarchies)) {
            return null;
        }
        var ruleContext = context["dom"].node;
        var doctypeString = ruleContext.ownerDocument.doctype ? ruleContext.ownerDocument.doctype.publicId : "";
        if (!doctypeString)
            doctypeString = "";
        var lang = ruleContext.getAttribute("lang");
        var langXML = ruleContext.getAttribute("xml:lang");
        if (doctypeString.includes('XHTML') && !doctypeString.includes("1.0")) {
            if (!langXML) {
                // XHTML != 1.0 (must have xml:lang
                return (0, IRule_1.RuleFail)("Fail_2");
            }
            else {
                return (0, IRule_1.RulePass)("Pass_0", [langXML]);
            }
        }
        else if (doctypeString.includes('XHTML') && doctypeString.includes("1.0")) {
            // Handle XHTML 1.0
            // If neither is provided, it's a failure
            if (!lang && !langXML) {
                // XHTML and no lang
                return (0, IRule_1.RuleFail)("Fail_1");
            }
            else if (lang && langXML) {
                if (lang !== langXML) {
                    if (!lang_1.LangUtil.validPrimaryLang(lang) || !lang_1.LangUtil.validPrimaryLang(langXML)) {
                        // Let Elem_Lang_Valid handle this
                        return null;
                    }
                    if (!lang_1.LangUtil.matchPrimaryLang(lang, langXML)) {
                        // XHTML and lang and xml:lang, but they don't match
                        return (0, IRule_1.RuleFail)("Fail_4", [lang, langXML], []);
                    }
                    else {
                        return (0, IRule_1.RuleFail)("Fail_5", [lang, langXML], []);
                    }
                }
                else {
                    // XHTML and lang and xml:lang match
                    return (0, IRule_1.RulePass)("Pass_0", [lang]);
                }
            }
            else if (lang) {
                // XHTML and only lang (okay if only delivered via text/html)
                return (0, IRule_1.RulePotential)("Potential_5");
            }
            else {
                // XHTML and only xml:lang (okay if only delivered via xml mime type)
                return (0, IRule_1.RulePotential)("Potential_6");
            }
        }
        else {
            if (!lang) {
                return (0, IRule_1.RuleFail)("Fail_3");
            }
            else if (lang && langXML) {
                // HTML5 polyglot documents
                if (lang !== langXML) {
                    if (!lang_1.LangUtil.validPrimaryLang(lang) || !lang_1.LangUtil.validPrimaryLang(langXML)) {
                        // Let Elem_Lang_Valid handle this
                        return null;
                    }
                    if (!lang_1.LangUtil.matchPrimaryLang(lang, langXML)) {
                        // XHTML and lang and xml:lang, but they don't match
                        return (0, IRule_1.RuleFail)("Fail_4", [lang, langXML], []);
                    }
                    else {
                        return (0, IRule_1.RuleFail)("Fail_5", [lang, langXML], []);
                    }
                }
                else {
                    // XHTML and lang and xml:lang match
                    return (0, IRule_1.RulePass)("Pass_0", [lang]);
                }
            }
            else {
                return (0, IRule_1.RulePass)("Pass_0", [lang]);
            }
        }
    }
};


/***/ }),

/***/ 9788:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.html_skipnav_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var fragment_1 = __webpack_require__(482);
exports.html_skipnav_exists = {
    id: "html_skipnav_exists",
    context: "dom:html",
    refactor: {
        "RPT_Html_SkipNav": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "html_skipnav_exists.html",
            "Pass_0": "html_skipnav_exists.html",
            "Potential_1": "html_skipnav_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Provide a way to bypass blocks of content that are repeated on multiple Web pages",
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify there is a way to bypass blocks of content that are repeated on multiple Web pages"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "2.4.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = false;
        var frames = legacy_1.RPTUtil.getDocElementsByTag(ruleContext, "frame");
        var headers = legacy_1.RPTUtil.getDocElementsByTag(ruleContext, "h1");
        if ((frames != null && frames.length > 0) || (headers != null && headers.length > 0)) {
            // If frames or headings are used, pass
            passed = true;
        }
        else {
            // Look for skip anchors
            var anchors = legacy_1.RPTUtil.getDocElementsByTag(ruleContext, "a");
            var targets = {};
            for (var idx = 0; !passed && idx < anchors.length; ++idx) {
                if (anchors[idx].hasAttribute("href")) {
                    var href = anchors[idx].href;
                    if (typeof href !== typeof "") {
                        if (href.baseVal) {
                            href = href.baseVal;
                        }
                        else {
                            href = "";
                        }
                    }
                    var tmpLocation = void 0;
                    if (typeof (ruleContext.ownerDocument.locationFromDAP) != "undefined" && ruleContext.ownerDocument.locationFromDAP != null) { // DAP sets it
                        tmpLocation = ruleContext.ownerDocument.locationFromDAP;
                    }
                    else { // server scan has the location object
                        tmpLocation = ruleContext.ownerDocument.location;
                    }
                    var docHref = "";
                    if (tmpLocation) {
                        docHref = tmpLocation.href;
                    }
                    // Fix weird bugs with how various parsers report on file: url's:
                    if (href.startsWith("file:///"))
                        href = "file:/" + href.substring("file:///".length);
                    if (docHref.startsWith("file:///"))
                        docHref = "file:/" + docHref.substring("file:///".length);
                    if (href.charAt(0) == "#" || href.startsWith(docHref + "#")) {
                        var target = legacy_1.RPTUtil.getFileAnchor(href);
                        if (fragment_1.FragmentUtil.getById(ruleContext, target) != null)
                            passed = true;
                        else
                            targets[target] = true;
                    }
                }
                else if (anchors[idx].hasAttribute("name")) {
                    // Assume forward jumping targets
                    var name_1 = anchors[idx].getAttribute("name");
                    if (name_1.indexOf("#") != -1)
                        name_1 = legacy_1.RPTUtil.getFileAnchor(name_1);
                    passed = name_1 in targets;
                }
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 4419:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iframe_interactive_tabbable = void 0;
var legacy_1 = __webpack_require__(8422);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8174);
exports.iframe_interactive_tabbable = {
    id: "iframe_interactive_tabbable",
    context: "dom:iframe",
    dependencies: [],
    help: {
        "en-US": {
            "group": "iframe_interactive_tabbable.html",
            "pass": "iframe_interactive_tabbable.html",
            "fail_invalid": "iframe_interactive_tabbable.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Iframe with interactive content should not be excluded from tab order using tabindex",
            "pass": "The iframe with interactive content is not excluded from the tab order using tabindex",
            "fail_invalid": "The <iframe> with interactive content is excluded from tab order using tabindex"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            num: ["2.1.1"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: ["akn7bn"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || legacy_1.RPTUtil.isNodeDisabled(ruleContext))
            return;
        var bounds = context["dom"].bounds;
        //in case the bounds not available
        if (!bounds)
            return null;
        // ignore if iframe is too small to be visible on screen
        if (Math.max(bounds['height'], bounds['width']) < 30 || Math.min(bounds['height'], bounds['width']) < 15)
            return null;
        // pass iframe element does not have a tabindex attribute value that is a negative number
        if (!ruleContext.hasAttribute("tabindex") || parseInt(ruleContext.getAttribute("tabindex")) >= 0)
            return (0, IRule_1.RulePass)("pass");
        // check iframe content
        var iframElem = ruleContext;
        if (!iframElem || !iframElem.contentDocument || !iframElem.contentDocument.documentElement)
            return null;
        var count = legacy_1.RPTUtil.getTabbableChildren(ruleContext);
        if (count > 0)
            return (0, IRule_1.RuleFail)("fail_invalid");
        return null;
    }
};


/***/ }),

/***/ 2575:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.imagebutton_alt_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.imagebutton_alt_exists = {
    id: "imagebutton_alt_exists",
    context: "dom:input",
    refactor: {
        "WCAG20_Input_ExplicitLabelImage": {
            "Pass_0": "Pass_0",
            "Pass_1": "Pass_1",
            "Pass_2": "Pass_2",
            "Fail": "Fail"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "imagebutton_alt_exists.html",
            "Pass_1": "imagebutton_alt_exists.html",
            "Pass_2": "imagebutton_alt_exists.html",
            "Fail": "imagebutton_alt_exists.html",
            "group": "imagebutton_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Image button provides alternative text using the 'alt' attribute",
            "Pass_1": "Image button provides alternative text using a ARIA label",
            "Pass_2": "Image button provides alternative text using the 'title' attribute",
            "Fail": "The <input> element of type \"image\" has no text alternative",
            "group": "The <input> element of type \"image\" should have a text alternative"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "59796f",
    run: function (context, options, contextHierarchies) {
        // See https://www.w3.org/WAI/WCAG21/Techniques/failures/F65
        var ruleContext = context["dom"].node;
        if (!ruleContext.hasAttribute("type") || ruleContext.getAttribute("type").toLowerCase() != "image") {
            return null;
        }
        if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "alt")) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else if (legacy_1.RPTUtil.hasAriaLabel(ruleContext)) {
            return (0, IRule_1.RulePass)("Pass_1");
        }
        else if (ruleContext.hasAttribute("title") && ruleContext.getAttribute("title").length > 0) {
            return (0, IRule_1.RulePass)("Pass_2");
        }
        return (0, IRule_1.RuleFail)("Fail");
    }
};


/***/ }),

/***/ 8124:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.imagemap_alt_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.imagemap_alt_exists = {
    id: "imagemap_alt_exists",
    context: "dom:img[usemap], dom:img[ismap]",
    refactor: {
        "HAAC_Img_UsemapAlt": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "imagemap_alt_exists.html",
            "Fail_1": "imagemap_alt_exists.html",
            "group": "imagemap_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Image map or child <area> has no text alternative",
            "group": "An image map and each <area> element in an image map must have text alternative(s)"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "alt") ||
            (!ruleContext.hasAttribute("ismap") && !legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "usemap"));
        if (!passed) {
            return (0, IRule_1.RuleFail)("Pass_0");
        }
        else {
            return (0, IRule_1.RulePass)("Fail_1");
        }
    }
};


/***/ }),

/***/ 3440:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_alt_background = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8174);
exports.img_alt_background = {
    id: "img_alt_background",
    context: "dom:*",
    refactor: {
        "HAAC_BackgroundImg_HasTextOrTitle": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_alt_background.html",
            "Manual_1": "img_alt_background.html",
            "group": "img_alt_background.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Verify important background image information has a text alternative in system high contrast mode",
            "group": "Background images that convey important information must have a text alternative that describes the image"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var doc = ruleContext.ownerDocument;
        var style = doc.defaultView.getComputedStyle(ruleContext);
        if (style == null) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        var backgroundImgs = style.backgroundImage;
        var passed = true;
        if (backgroundImgs != null && backgroundImgs != "" && backgroundImgs != 'none' && backgroundImgs != 'inherit') {
            if (ruleContext.innerHTML != null && ruleContext.innerHTML.trim().length != 0) {
                passed = false;
            }
            else {
                var title = ruleContext.getAttribute('title');
                if (title != null && title.length != 0)
                    passed = false;
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 2193:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_alt_decorative = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.img_alt_decorative = {
    id: "img_alt_decorative",
    context: "dom:img[alt]",
    refactor: {
        "WCAG20_Img_PresentationImgHasNonNullAlt": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_alt_decorative.html",
            "Fail_1": "img_alt_decorative.html",
            "group": "img_alt_decorative.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Image designated as decorative has non-null 'alt' attribute",
            "group": "Image designated as decorative must have 'alt=\"\""
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = true;
        if (legacy_1.RPTUtil.hasRole(ruleContext, "presentation") || legacy_1.RPTUtil.hasRole(ruleContext, "none")) {
            passed = ruleContext.getAttribute("alt").length == 0;
        }
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 309:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_alt_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8174);
exports.img_alt_misuse = {
    id: "img_alt_misuse",
    context: "dom:img, dom:area, dom:input",
    refactor: {
        "RPT_Img_AltCommonMisuse": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_alt_misuse.html",
            "Potential_1": "img_alt_misuse.html",
            "group": "img_alt_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that the file name serves as a good inline replacement for the image",
            "group": "'alt' attribute value must be a good inline replacement for the image"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            badText: {
                value: ["short description"],
                type: "[string]"
            }
        };
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var passed = true;
        // Alt text check are elsewhere (See 41, 240, 455)
        if (ruleContext.hasAttribute("alt")) {
            var altText = ruleContext.getAttribute("alt").trim();
            if (altText.length > 0) {
                var badText = validateParams.badText.value;
                for (var i = 0; passed && i < badText.length; ++i) {
                    passed = altText.indexOf(badText[i]) == -1;
                }
                if (passed) {
                    var src = ruleContext.getAttribute((nodeName == "area") ? "href" : "src");
                    // Allow it to pass if there's no src - can't determine these.
                    if (src != null) {
                        // Fail if the alt matches the src exactly
                        // Also fail if the alt has a . in it and either the src is in the alt or the alt is in the src
                        passed = src.trim() != altText &&
                            (altText.indexOf(".") == -1 || (altText.indexOf(src) == -1 && src.indexOf(altText) == -1));
                    }
                }
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 6281:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_alt_null = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.img_alt_null = {
    id: "img_alt_null",
    context: "dom:img[alt]",
    refactor: {
        "WCAG20_Img_TitleEmptyWhenAltNull": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_alt_null.html",
            "Fail_1": "img_alt_null.html",
            "group": "img_alt_null.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The image 'alt' attribute is empty, but the 'title' attribute is not empty",
            "group": "When the image 'alt' attribute is empty, the 'title' attribute must also be empty"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        if (ruleContext.getAttribute("alt").trim().length > 0) {
            return null;
        }
        // We have a title, but alt is empty
        if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title")) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 7748:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_alt_redundant = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.img_alt_redundant = {
    id: "img_alt_redundant",
    context: "dom:img[alt]",
    refactor: {
        "WCAG20_Img_LinkTextNotRedundant": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_alt_redundant.html",
            "Fail_1": "img_alt_redundant.html",
            "Fail_2": "img_alt_redundant.html",
            "Fail_3": "img_alt_redundant.html",
            "group": "img_alt_redundant.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Link text is repeated in an image 'alt' value within the same link",
            "Fail_2": "Link text of previous link is repeated in image 'alt' value of a link",
            "Fail_3": "Image 'alt' value within a link is repeated in link text of the link after",
            "group": "The text alternative for an image within a link should not repeat the link text or adjacent link text"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var aNode = legacy_1.RPTUtil.getAncestor(ruleContext, "a");
        //If not in an anchor, Out of Scope
        if (aNode == null)
            return null;
        var altText = ruleContext.getAttribute("alt").trim().toLowerCase();
        if (altText.length == 0) {
            // If alt text is empty, there's no text to be redundant - let a_text_purpose
            // trigger in that case.
            // So Out of Scope for this rule
            return null;
        }
        var innerText = aNode.innerText;
        var linkText = "";
        if (innerText != null) {
            linkText = innerText.trim().toLowerCase();
        }
        if (linkText.length > 0) {
            if (altText == linkText) {
                // Text in link
                return (0, IRule_1.RuleFail)("Fail_1");
            }
        }
        else {
            var passed = true;
            //alt is non-zero, but no link text - ensure adjacent link text isn't redundant
            var walk = new legacy_1.NodeWalker(aNode);
            while (passed && walk.prevNode()) {
                // Get the node and nodeName
                var node = walk.node;
                var nodeName = node.nodeName.toLowerCase();
                if ((nodeName == "#text" && node.nodeValue.length > 0) ||
                    (nodeName == "img" && legacy_1.RPTUtil.attributeNonEmpty(node, "alt"))) {
                    break;
                }
                // Comply with the Check Hidden Content Setting if the a element should be checked or not
                else if (nodeName === "a" && !legacy_1.RPTUtil.shouldNodeBeSkippedHidden(node)) {
                    // Text before image link
                    passed = (node.innerText || node.textContent || "").trim().toLowerCase() != altText;
                }
            }
            if (!passed) {
                return (0, IRule_1.RuleFail)("Fail_2");
            }
            walk = new legacy_1.NodeWalker(aNode, true);
            while (passed && walk.nextNode()) {
                // Get the node and nodeName
                var node = walk.node;
                var nodeName = node.nodeName.toLowerCase();
                if ((nodeName == "#text" && node.nodeValue.length > 0) ||
                    (nodeName == "img" && legacy_1.RPTUtil.attributeNonEmpty(node, "alt"))) {
                    break;
                }
                // Comply with the Check Hidden Content Setting if the a element should be checked or not
                else if (nodeName == "a" && !legacy_1.RPTUtil.shouldNodeBeSkippedHidden(node)) {
                    passed = node.innerText.trim().toLowerCase() != altText;
                }
            }
            if (!passed) {
                // Text after image link
                return (0, IRule_1.RuleFail)("Fail_3");
            }
            else {
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
    }
};


/***/ }),

/***/ 8856:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_alt_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.img_alt_valid = {
    id: "img_alt_valid",
    context: "dom:img",
    refactor: {
        "WCAG20_Img_HasAlt": {
            "pass": "pass",
            "fail_blank_alt": "fail_blank_alt",
            "fail_no_alt": "fail_no_alt",
            "fail_blank_title": "fail_blank_title"
        }
    },
    help: {
        "en-US": {
            "pass": "img_alt_valid.html",
            "fail_blank_alt": "img_alt_valid.html",
            "fail_no_alt": "img_alt_valid.html",
            "fail_blank_title": "img_alt_valid.html",
            "group": "img_alt_valid.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Images has required 'alt' attribute, ARIA label or title if they convey meaning, or 'alt=\"\" if decorative",
            "fail_blank_alt": "Image 'alt' attribute value consists only of blank space(s)",
            "fail_no_alt": "The image has neither an alt atttribute nor an ARIA label or title",
            "fail_blank_title": "The image does not have an alt attribute or ARIA label and 'title' attribute value consists only of blank space(s)",
            "group": "Images require an 'alt' attribute with a short text alternative if they convey meaning, or 'alt=\"\" if decorative"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "23a2a8",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // If not visible to the screen reader, ignore
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        //pass if images with a valid 'alt'    
        var alt = ruleContext.getAttribute("alt");
        if (alt !== null) {
            if (alt.trim().length > 0)
                return (0, IRule_1.RulePass)("pass");
            else {
                // alt.trim().length === 0
                if (alt.length > 0) {
                    // alt contains blank space only (alt=" ")
                    return (0, IRule_1.RuleFail)("fail_blank_alt");
                }
                else {
                    // alt.length === 0, presentational image, title is optional, handled by other rule(s)
                    return (0, IRule_1.RulePass)("pass");
                }
            }
        }
        else {
            // no alt
            var label = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            if (label && label.trim().length > 0)
                return (0, IRule_1.RulePass)("pass");
            else {
                var title = ruleContext.getAttribute("title");
                if (title) {
                    if (title.trim().length > 0)
                        return (0, IRule_1.RulePass)("pass");
                    else {
                        // title.trim().length === 0
                        if (title.length > 0) {
                            // title contains blank space only (title=" ")
                            return (0, IRule_1.RuleFail)("fail_blank_title");
                        }
                    }
                }
                else {
                    // neither alt nor aria label or title 
                    return (0, IRule_1.RuleFail)("fail_no_alt");
                }
            }
        }
    }
};


/***/ }),

/***/ 7393:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_ismap_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.img_ismap_misuse = {
    id: "img_ismap_misuse",
    context: "dom:img[ismap]",
    refactor: {
        "RPT_Img_UsemapValid": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_ismap_misuse.html",
            "Potential_1": "img_ismap_misuse.html",
            "group": "img_ismap_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Server-side image map hot-spots do not have duplicate text links",
            "group": "Server-side image map hot-spots must have duplicate text links"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = false;
        if (ruleContext.hasAttribute("usemap")) {
            var usemap = ruleContext.getAttribute("usemap");
            usemap = usemap.trim().toLowerCase();
            var idx = usemap.indexOf("#");
            if (idx != -1)
                usemap = usemap.substr(idx + 1);
            if (usemap.length > 0) {
                var maps = legacy_1.RPTUtil.getDocElementsByTag(ruleContext, "map");
                for (var i = 0; !passed && i < maps.length; ++i) {
                    passed = maps[i].hasAttribute("name") &&
                        maps[i].getAttribute("name").toLowerCase() == usemap;
                }
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9410:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_longdesc_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.img_longdesc_misuse = {
    id: "img_longdesc_misuse",
    context: "dom:img[longdesc]",
    refactor: {
        "RPT_Img_LongDescription2": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_longdesc_misuse.html",
            "Potential_1": "img_longdesc_misuse.html",
            "group": "img_longdesc_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that the file designated by the 'longdesc' attribute contains valid HTML content (file extension not recognized)",
            "group": " The 'longdesc' attribute must reference HTML content"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var longdesc = ruleContext.getAttribute("longdesc");
        // if (longdesc is bad URL) passed = false;
        var ext = legacy_1.RPTUtil.getFileExt(longdesc);
        var passed = ext.length != 0 && legacy_1.RPTUtil.isHtmlExt(ext)
            || longdesc.startsWith("#")
            || longdesc.startsWith("http://")
            || longdesc.startsWith("https://")
            || longdesc.startsWith("data:");
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 8081:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// This file is automatically generated by "npm run prebuild". Do not edit
__exportStar(__webpack_require__(8980), exports);
__exportStar(__webpack_require__(3961), exports);
__exportStar(__webpack_require__(1445), exports);
__exportStar(__webpack_require__(876), exports);
__exportStar(__webpack_require__(2768), exports);
__exportStar(__webpack_require__(7178), exports);
__exportStar(__webpack_require__(9745), exports);
__exportStar(__webpack_require__(8019), exports);
__exportStar(__webpack_require__(6505), exports);
__exportStar(__webpack_require__(8910), exports);
__exportStar(__webpack_require__(3492), exports);
__exportStar(__webpack_require__(5316), exports);
__exportStar(__webpack_require__(8412), exports);
__exportStar(__webpack_require__(172), exports);
__exportStar(__webpack_require__(9844), exports);
__exportStar(__webpack_require__(9695), exports);
__exportStar(__webpack_require__(1699), exports);
__exportStar(__webpack_require__(4974), exports);
__exportStar(__webpack_require__(3054), exports);
__exportStar(__webpack_require__(4649), exports);
__exportStar(__webpack_require__(4193), exports);
__exportStar(__webpack_require__(3188), exports);
__exportStar(__webpack_require__(4176), exports);
__exportStar(__webpack_require__(7964), exports);
__exportStar(__webpack_require__(2554), exports);
__exportStar(__webpack_require__(1229), exports);
__exportStar(__webpack_require__(8523), exports);
__exportStar(__webpack_require__(3781), exports);
__exportStar(__webpack_require__(8509), exports);
__exportStar(__webpack_require__(3234), exports);
__exportStar(__webpack_require__(5217), exports);
__exportStar(__webpack_require__(4050), exports);
__exportStar(__webpack_require__(4275), exports);
__exportStar(__webpack_require__(1465), exports);
__exportStar(__webpack_require__(405), exports);
__exportStar(__webpack_require__(9136), exports);
__exportStar(__webpack_require__(5117), exports);
__exportStar(__webpack_require__(9062), exports);
__exportStar(__webpack_require__(5746), exports);
__exportStar(__webpack_require__(8685), exports);
__exportStar(__webpack_require__(2678), exports);
__exportStar(__webpack_require__(971), exports);
__exportStar(__webpack_require__(3709), exports);
__exportStar(__webpack_require__(6486), exports);
__exportStar(__webpack_require__(4151), exports);
__exportStar(__webpack_require__(8545), exports);
__exportStar(__webpack_require__(8538), exports);
__exportStar(__webpack_require__(1908), exports);
__exportStar(__webpack_require__(6360), exports);
__exportStar(__webpack_require__(5386), exports);
__exportStar(__webpack_require__(8752), exports);
__exportStar(__webpack_require__(4392), exports);
__exportStar(__webpack_require__(932), exports);
__exportStar(__webpack_require__(6255), exports);
__exportStar(__webpack_require__(5743), exports);
__exportStar(__webpack_require__(2671), exports);
__exportStar(__webpack_require__(3974), exports);
__exportStar(__webpack_require__(9881), exports);
__exportStar(__webpack_require__(1226), exports);
__exportStar(__webpack_require__(7369), exports);
__exportStar(__webpack_require__(2633), exports);
__exportStar(__webpack_require__(2429), exports);
__exportStar(__webpack_require__(7874), exports);
__exportStar(__webpack_require__(3334), exports);
__exportStar(__webpack_require__(4298), exports);
__exportStar(__webpack_require__(4435), exports);
__exportStar(__webpack_require__(6313), exports);
__exportStar(__webpack_require__(9109), exports);
__exportStar(__webpack_require__(9918), exports);
__exportStar(__webpack_require__(8105), exports);
__exportStar(__webpack_require__(8687), exports);
__exportStar(__webpack_require__(2150), exports);
__exportStar(__webpack_require__(4557), exports);
__exportStar(__webpack_require__(4721), exports);
__exportStar(__webpack_require__(2814), exports);
__exportStar(__webpack_require__(7601), exports);
__exportStar(__webpack_require__(4497), exports);
__exportStar(__webpack_require__(152), exports);
__exportStar(__webpack_require__(935), exports);
__exportStar(__webpack_require__(9719), exports);
__exportStar(__webpack_require__(5625), exports);
__exportStar(__webpack_require__(9115), exports);
__exportStar(__webpack_require__(6072), exports);
__exportStar(__webpack_require__(6923), exports);
__exportStar(__webpack_require__(9015), exports);
__exportStar(__webpack_require__(3611), exports);
__exportStar(__webpack_require__(4846), exports);
__exportStar(__webpack_require__(3277), exports);
__exportStar(__webpack_require__(4525), exports);
__exportStar(__webpack_require__(7114), exports);
__exportStar(__webpack_require__(3751), exports);
__exportStar(__webpack_require__(7084), exports);
__exportStar(__webpack_require__(3981), exports);
__exportStar(__webpack_require__(9788), exports);
__exportStar(__webpack_require__(4419), exports);
__exportStar(__webpack_require__(2575), exports);
__exportStar(__webpack_require__(8124), exports);
__exportStar(__webpack_require__(3440), exports);
__exportStar(__webpack_require__(2193), exports);
__exportStar(__webpack_require__(309), exports);
__exportStar(__webpack_require__(6281), exports);
__exportStar(__webpack_require__(7748), exports);
__exportStar(__webpack_require__(8856), exports);
__exportStar(__webpack_require__(7393), exports);
__exportStar(__webpack_require__(9410), exports);
__exportStar(__webpack_require__(8589), exports);
__exportStar(__webpack_require__(3366), exports);
__exportStar(__webpack_require__(8929), exports);
__exportStar(__webpack_require__(5403), exports);
__exportStar(__webpack_require__(5937), exports);
__exportStar(__webpack_require__(4452), exports);
__exportStar(__webpack_require__(7209), exports);
__exportStar(__webpack_require__(8262), exports);
__exportStar(__webpack_require__(7017), exports);
__exportStar(__webpack_require__(9980), exports);
__exportStar(__webpack_require__(7733), exports);
__exportStar(__webpack_require__(1256), exports);
__exportStar(__webpack_require__(9532), exports);
__exportStar(__webpack_require__(6698), exports);
__exportStar(__webpack_require__(9632), exports);
__exportStar(__webpack_require__(3692), exports);
__exportStar(__webpack_require__(5430), exports);
__exportStar(__webpack_require__(1018), exports);
__exportStar(__webpack_require__(3433), exports);
__exportStar(__webpack_require__(8012), exports);
__exportStar(__webpack_require__(3881), exports);
__exportStar(__webpack_require__(3106), exports);
__exportStar(__webpack_require__(1276), exports);
__exportStar(__webpack_require__(5424), exports);
__exportStar(__webpack_require__(4248), exports);
__exportStar(__webpack_require__(9526), exports);
__exportStar(__webpack_require__(9379), exports);
__exportStar(__webpack_require__(5495), exports);
__exportStar(__webpack_require__(7753), exports);
__exportStar(__webpack_require__(1252), exports);
__exportStar(__webpack_require__(3576), exports);
__exportStar(__webpack_require__(3617), exports);
__exportStar(__webpack_require__(6110), exports);
__exportStar(__webpack_require__(5681), exports);
__exportStar(__webpack_require__(1922), exports);
__exportStar(__webpack_require__(7906), exports);
__exportStar(__webpack_require__(5451), exports);
__exportStar(__webpack_require__(6349), exports);
__exportStar(__webpack_require__(5393), exports);
__exportStar(__webpack_require__(9887), exports);
__exportStar(__webpack_require__(5102), exports);
__exportStar(__webpack_require__(9977), exports);
__exportStar(__webpack_require__(8454), exports);
__exportStar(__webpack_require__(25), exports);
__exportStar(__webpack_require__(2884), exports);
__exportStar(__webpack_require__(7196), exports);
__exportStar(__webpack_require__(9965), exports);
__exportStar(__webpack_require__(4468), exports);
__exportStar(__webpack_require__(4451), exports);
__exportStar(__webpack_require__(6087), exports);
__exportStar(__webpack_require__(5864), exports);
__exportStar(__webpack_require__(4066), exports);
__exportStar(__webpack_require__(2841), exports);
__exportStar(__webpack_require__(272), exports);
__exportStar(__webpack_require__(1348), exports);
__exportStar(__webpack_require__(5275), exports);
__exportStar(__webpack_require__(7900), exports);
__exportStar(__webpack_require__(5027), exports);
__exportStar(__webpack_require__(3496), exports);
__exportStar(__webpack_require__(1131), exports);
__exportStar(__webpack_require__(8681), exports);
__exportStar(__webpack_require__(4577), exports);
__exportStar(__webpack_require__(8051), exports);


/***/ }),

/***/ 8589:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_autocomplete_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.input_autocomplete_valid = {
    id: "input_autocomplete_valid",
    context: "dom:input[autocomplete], dom:textarea[autocomplete], dom:select[autocomplete]",
    refactor: {
        "WCAG21_Input_Autocomplete": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_attribute_incorrect": "Fail_attribute_incorrect"
        }
    },
    help: {
        "en-US": {
            "group": "input_autocomplete_valid.html",
            "Pass_0": "input_autocomplete_valid.html",
            "Fail_1": "input_autocomplete_valid.html",
            "Fail_2": "input_autocomplete_valid.html",
            "Fail_attribute_incorrect": "input_autocomplete_valid.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The 'autocomplete' attribute's token(s) must be appropriate for the input form field",
            "Pass_0": "Rule Passed",
            "Fail_1": "The 'autocomplete' attribute's token(s) are not appropriate for the input form field",
            "Fail_2": "The 'autocomplete' attribute's token(s) are not appropriate for an input form field of any type",
            "Fail_attribute_incorrect": "The 'autocomplete' attribute has an incorrect value"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.5"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [{
            "73f2c2": {
                "Pass_0": "pass",
                "Fail_1": "fail",
                "Fail_2": "pass",
                "Fail_attribute_incorrect": "fail"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var cache = {
            "tokensOnOff": ["on", "off"],
            "tokenOptionalSection": "section-",
            "tokensOptionalPurpose": ["shipping", "billing"],
            "tokensMandatoryGroup1_password": ["new-password", "current-password"],
            "tokensMandatoryGroup1_multiline": ["street-address"],
            "tokensMandatoryGroup1_month": ["cc-exp"],
            "tokensMandatoryGroup1_numeric": ["cc-exp-month",
                "cc-exp-year",
                "transaction-amount",
                "bday-day",
                "bday-month",
                "bday-year"],
            "tokensMandatoryGroup1_date": ["bday"],
            "tokensMandatoryGroup1_url": ["url", "photo"],
            "tokensMandatoryGroup1_text": ["name",
                "honorific-prefix",
                "given-name",
                "additional-name",
                "family-name",
                "honorific-suffix",
                "nickname",
                "username",
                "organization-title",
                "organization",
                "address-line1",
                "address-line2",
                "address-line3",
                "address-level4",
                "address-level3",
                "address-level2",
                "address-level1",
                "country",
                "country-name",
                "postal-code",
                "cc-name",
                "cc-given-name",
                "cc-additional-name",
                "cc-family-name",
                "cc-number",
                "cc-csc",
                "cc-type",
                "transaction-currency",
                "language",
                "sex"],
            "tokensMandatoryGroup1_all": ["name",
                "honorific-prefix",
                "given-name",
                "additional-name",
                "family-name",
                "honorific-suffix",
                "nickname",
                "username",
                "new-password",
                "current-password",
                "organization-title",
                "organization",
                "street-address",
                "address-line1",
                "address-line2",
                "address-line3",
                "address-level4",
                "address-level3",
                "address-level2",
                "address-level1",
                "country",
                "country-name",
                "postal-code",
                "cc-name",
                "cc-given-name",
                "cc-additional-name",
                "cc-family-name",
                "cc-number",
                "cc-exp",
                "cc-exp-month",
                "cc-exp-year",
                "cc-csc",
                "cc-type",
                "transaction-currency",
                "transaction-amount",
                "language",
                "bday",
                "bday-day",
                "bday-month",
                "bday-year",
                "sex",
                "url",
                "photo"],
            "tokensOptionalGroup2": ["home",
                "work",
                "mobile",
                "fax",
                "pager"],
            "tokensMandatoryGroup2_tel": ["tel"],
            "tokensMandatoryGroup2_email": ["email"],
            "tokensMandatoryGroup2_url": ["impp"],
            "tokensMandatoryGroup2_text": ["tel-country-code",
                "tel-national",
                "tel-area-code",
                "tel-local",
                "tel-local-prefix",
                "tel-local-suffix",
                "tel-extension"],
            "tokensMandatoryGroup2_all": ["tel",
                "tel-country-code",
                "tel-national",
                "tel-area-code",
                "tel-local",
                "tel-local-prefix",
                "tel-local-suffix",
                "tel-extension",
                "email",
                "impp"]
        };
        var valid_values = [];
        for (var key in cache)
            valid_values = valid_values.concat(cache[key]);
        var ruleContext = context["dom"].node;
        var foundMandatoryToken = false;
        var foundRecognizedToken = true;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) ||
            legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
            return null;
        }
        var type = ruleContext.hasAttribute("type") ? ruleContext.getAttribute("type").trim().toLowerCase() : "text";
        var autocompleteAttr = ruleContext.getAttribute("autocomplete").trim().toLowerCase();
        var tokens = autocompleteAttr.split(/\s+/);
        if (tokens.length === 0 || autocompleteAttr.length === 0) {
            return null;
        }
        if (!tokens.every(function (r) { return valid_values.includes(r) || r.startsWith(cache['tokenOptionalSection']); }))
            return (0, IRule_1.RuleFail)("Fail_attribute_incorrect");
        var tokensMandatoryGroup1 = [];
        var tokensMandatoryGroup2 = [];
        if (nodeName === "textarea" || nodeName === "select") {
            // accept all tokens
            tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_all;
            tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_all;
        }
        else if (nodeName === "input") {
            // handle the various 'input' types
            switch (type) {
                // Disable check for input type=hidden for now based on scrum discussion
                /*
                case "hidden":
                    // accept all tokens
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_all;
                    tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_all;
                    break;
                */
                case "text":
                case "search":
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_text.concat(cache.tokensMandatoryGroup1_password, cache.tokensMandatoryGroup1_url, cache.tokensMandatoryGroup1_numeric, cache.tokensMandatoryGroup1_month, cache.tokensMandatoryGroup1_date);
                    tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_all;
                    break;
                case "password":
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_password;
                    break;
                case "url":
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_url;
                    tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_url;
                    break;
                case "email":
                    tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_email;
                    break;
                case "tel":
                    tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_tel;
                    break;
                case "number":
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_numeric;
                    break;
                case "month":
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_month;
                    break;
                case "date":
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_date;
                    break;
                default:
                    // unsupported type for this rule.
                    return null;
            }
        }
        else {
            // should never get here.
            return null;
        }
        // Disable check for input type=hidden for now based on scrum discussion
        var autofillMantle = /* (nodeName==="input" && type==="hidden") ? "anchor" : */ "expectation";
        if (autofillMantle === "expectation") {
            // check on|off for expectation mantle.
            if (tokens.includes("on") || tokens.includes("off")) {
                // on|off should be the only token
                if (tokens.length === 1) {
                    return (0, IRule_1.RulePass)(1);
                }
                else {
                    return (0, IRule_1.RuleFail)(2);
                }
            }
        }
        // check detail autofill tokens
        var currIndex = 0;
        var currRecognizedIndex = 0;
        // check optional 'section-*' tokens
        if (tokens[currIndex].startsWith(cache.tokenOptionalSection) &&
            tokens[currIndex].length > 8) {
            currIndex++; // consume token
            currRecognizedIndex++;
        }
        // check optional 'shipping|billing' tokens
        if (tokens.length > currIndex &&
            cache.tokensOptionalPurpose.includes(tokens[currIndex])) {
            currIndex++; // consume  token
            currRecognizedIndex++;
        }
        // check either mandatory group 1 or 2 tokens
        if (tokens.length > currIndex) {
            // check mandatory group 1
            if (tokensMandatoryGroup1.includes(tokens[currIndex])) {
                foundMandatoryToken = true;
                currIndex++;
            }
            else {
                // check optional tokens for group 2
                if (cache.tokensOptionalGroup2.includes(tokens[currIndex])) {
                    currIndex++;
                }
                // check mandatory group 2
                if (tokensMandatoryGroup2.includes(tokens[currIndex])) {
                    foundMandatoryToken = true;
                    currIndex++;
                }
            }
        }
        // check either mandatory group 1 or 2 tokens
        if (tokens.length > currRecognizedIndex) {
            // check mandatory group 1
            if (cache.tokensMandatoryGroup1_all.includes(tokens[currRecognizedIndex])) {
                foundRecognizedToken = true;
                currRecognizedIndex++;
            }
            else {
                // check optional tokens for group 2
                if (cache.tokensOptionalGroup2.includes(tokens[currRecognizedIndex])) {
                    currRecognizedIndex++;
                }
                // check mandatory group 2
                if (cache.tokensMandatoryGroup2_all.includes(tokens[currRecognizedIndex])) {
                    foundRecognizedToken = true;
                    currRecognizedIndex++;
                }
            }
        }
        // Only pass if we have seen either of the mandatory groups and all tokens have been consumed
        if (foundMandatoryToken && tokens.length === currIndex) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else if (foundRecognizedToken && tokens.length === currRecognizedIndex) {
            return (0, IRule_1.RuleFail)("Fail_2");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
    }
};


/***/ }),

/***/ 3366:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_checkboxes_grouped = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var DOMWalker_1 = __webpack_require__(7440);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8174);
exports.input_checkboxes_grouped = {
    id: "input_checkboxes_grouped",
    context: "dom:input",
    refactor: {
        "WCAG20_Input_RadioChkInFieldSet": {
            "Pass_LoneNogroup": "Pass_LoneNogroup",
            "Pass_Grouped": "Pass_Grouped",
            "Pass_RadioNoName": "Pass_RadioNoName",
            "Fail_ControlNameMismatch": "Fail_ControlNameMismatch",
            "Fail_NotGroupedOtherGrouped": "Fail_NotGroupedOtherGrouped",
            "Fail_NotGroupedOtherNotGrouped": "Fail_NotGroupedOtherNotGrouped",
            "Fail_NotSameGroup": "Fail_NotSameGroup",
            "Potential_LoneCheckbox": "Potential_LoneCheckbox",
            "Potential_UnnamedCheckbox": "Potential_UnnamedCheckbox"
        }
    },
    help: {
        "en-US": {
            "group": "input_checkboxes_grouped.html",
            "Pass_LoneNogroup": "input_checkboxes_grouped.html",
            "Pass_Grouped": "input_checkboxes_grouped.html",
            "Pass_RadioNoName": "input_checkboxes_grouped.html",
            "Fail_ControlNameMismatch": "input_checkboxes_grouped.html",
            "Fail_NotGroupedOtherGrouped": "input_checkboxes_grouped.html",
            "Fail_NotGroupedOtherNotGrouped": "input_checkboxes_grouped.html",
            "Fail_NotSameGroup": "input_checkboxes_grouped.html",
            "Potential_LoneCheckbox": "input_checkboxes_grouped.html",
            "Potential_UnnamedCheckbox": "input_checkboxes_grouped.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Related sets of radio buttons or checkboxes should be programmatically grouped",
            "Pass_LoneNogroup": "{0} grouping not required for a control of this type",
            "Pass_Grouped": "{0} input is grouped with other related controls with the same name",
            "Pass_RadioNoName": "Radio input is not grouped, but passes because it has no name to group with other radio inputs",
            "Fail_ControlNameMismatch": "{0} input found that has the same name, \"{2}\" as a {1} input",
            "Fail_NotGroupedOtherGrouped": "{0} input is not in the group with another {0} with the name \"{1}\"",
            "Fail_NotGroupedOtherNotGrouped": "{0} input and others with the name \"{1}\" are not grouped together",
            "Fail_NotSameGroup": "{0} input is in a different group than another {0} with the name \"{1}\"",
            "Potential_LoneCheckbox": "Verify that this ungrouped checkbox input is not related to other checkboxes",
            "Potential_UnnamedCheckbox": "Verify that this un-named, ungrouped checkbox input is not related to other checkboxes"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (context["aria"].role === 'none' || context["aria"].role === 'presentation')
            return null;
        var getGroup = function (e) {
            var retVal = legacy_1.RPTUtil.getAncestor(e, "fieldset")
                || legacy_1.RPTUtil.getAncestorWithRole(e, "radiogroup")
                || legacy_1.RPTUtil.getAncestorWithRole(e, "group")
                || legacy_1.RPTUtil.getAncestorWithRole(e, "grid")
                || legacy_1.RPTUtil.getAncestorWithRole(e, "table");
            if (!retVal) {
                retVal = legacy_1.RPTUtil.getAncestor(e, "table");
                if (retVal && !legacy_1.RPTUtil.isDataTable(retVal)) {
                    retVal = null;
                }
            }
            return retVal;
        };
        // Only radio buttons and checkboxes are in scope
        var ctxType = ruleContext.hasAttribute("type") ? ruleContext.getAttribute("type").toLowerCase() : "text";
        if (ctxType !== "checkbox" && ctxType !== "radio") {
            return null;
        }
        // Determine which form we're in (if any) to determine our scope
        var ctxForm = legacy_1.RPTUtil.getAncestorWithRole(ruleContext, "form")
            || legacy_1.RPTUtil.getAncestor(ruleContext, "html")
            || ruleContext.ownerDocument.documentElement;
        // Get data about all of the visible checkboxes and radios in the scope of this form
        // and cache it for all of the other inputs in this scope
        var formCache = (0, CacheUtil_1.getCache)(ctxForm, "input_checkboxes_grouped", null);
        if (!formCache) {
            formCache = {
                checkboxByName: {},
                radiosByName: {},
                nameToGroup: {},
                numCheckboxes: 0,
                numRadios: 0
            };
            // Get all of the checkboxes in the form or body (but not nested in something else and not hidden)
            // And get a mapping of these checkboxes to
            var cWalker = new DOMWalker_1.DOMWalker(ctxForm, false, ctxForm);
            var checkboxQ = [];
            var radiosQ = [];
            while (cWalker.nextNode()) {
                if (!cWalker.bEndTag
                    && cWalker.node.nodeType === 1
                    && cWalker.node.nodeName.toLowerCase() === "input"
                    && VisUtil_1.VisUtil.isNodeVisible(cWalker.node)) {
                    var type = cWalker.node.getAttribute("type");
                    if (type === "checkbox") {
                        checkboxQ.push(cWalker.node);
                    }
                    else if (type === "radio") {
                        radiosQ.push(cWalker.node);
                    }
                }
            }
            // let checkboxQ = ctxForm.querySelectorAll("input[type=checkbox]");
            for (var idx = 0; idx < checkboxQ.length; ++idx) {
                var cb = checkboxQ[idx];
                if ((legacy_1.RPTUtil.getAncestorWithRole(cb, "form")
                    || legacy_1.RPTUtil.getAncestor(ruleContext, "html")
                    || ruleContext.ownerDocument.documentElement) === ctxForm
                    && !legacy_1.RPTUtil.shouldNodeBeSkippedHidden(cb)) {
                    var name_1 = cb.getAttribute("name") || "";
                    (formCache.checkboxByName[name_1] = formCache.checkboxByName[name_1] || []).push(cb);
                    formCache.nameToGroup[name_1] = formCache.nameToGroup[name_1] || getGroup(cb);
                    ++formCache.numCheckboxes;
                }
            }
            // Get all of the radios in the form or body (but not nested in something else and not hidden)
            // let radiosQ = ctxForm.querySelectorAll("input[type=radio]");
            for (var idx = 0; idx < radiosQ.length; ++idx) {
                var r = radiosQ[idx];
                var radCtx = (legacy_1.RPTUtil.getAncestorWithRole(r, "form")
                    || legacy_1.RPTUtil.getAncestor(ruleContext, "html")
                    || ruleContext.ownerDocument.documentElement);
                if (radCtx === ctxForm
                    && !legacy_1.RPTUtil.shouldNodeBeSkippedHidden(r)) {
                    var name_2 = r.getAttribute("name") || "";
                    (formCache.radiosByName[name_2] = formCache.radiosByName[name_2] || []).push(r);
                    formCache.nameToGroup[name_2] = formCache.nameToGroup[name_2] || getGroup(r);
                    ++formCache.numRadios;
                }
            }
            (0, CacheUtil_1.setCache)(ctxForm, "input_checkboxes_grouped", formCache);
        }
        ///////////// Calculated everything, now check the various cases
        var ctxName = ruleContext.getAttribute("name");
        var ctxGroup = getGroup(ruleContext);
        ctxType = ctxType === "radio" ? "Radio" : "Checkbox";
        if (!ctxName || ctxName === "") {
            // First process cases where the control is not named
            if (ctxType === "Radio") {
                // Radios without names don't act like groups, so don't enforce grouping
                if (ctxGroup === null) {
                    return (0, IRule_1.RulePass)("Pass_RadioNoName", [ctxType]);
                }
                else {
                    return (0, IRule_1.RulePass)("Pass_Grouped", [ctxType]);
                }
            }
            else {
                // Must be an unnamed checkbox
                if (ctxGroup === null) {
                    if ((formCache.checkboxByName[""] || []).length > 1) {
                        return (0, IRule_1.RulePotential)("Potential_UnnamedCheckbox", [ctxType]);
                    }
                    else {
                        return (0, IRule_1.RulePass)("Pass_LoneNogroup", [ctxType]);
                    }
                }
                else {
                    return (0, IRule_1.RulePass)("Pass_Grouped", [ctxType]);
                }
            }
        }
        else {
            // Considering a named checkbox
            var numRadiosWithName = (formCache.radiosByName[ctxName] || []).length;
            var numCheckboxesWithName = (formCache.checkboxByName[ctxName] || []).length;
            // Capitalize the input type for messages
            if (numRadiosWithName > 0 && numCheckboxesWithName > 0) {
                // We have a naming mismatch between different controls
                return (0, IRule_1.RuleFail)("Fail_ControlNameMismatch", [ctxType, ctxType === "checkbox" ? "radio" : "checkbox", ctxName]);
            }
            else if (ctxType === "Radio" && (formCache.numRadios === 1 || numRadiosWithName === 1)
                || ctxType === "Checkbox" && formCache.numCheckboxes === 1) {
                // This is a lone control (either only control of this type on the page, or a radio button without any others by that name)
                // We pass this control in all cases
                if (ctxGroup === null) {
                    return (0, IRule_1.RulePass)("Pass_LoneNogroup", [ctxType]);
                }
                else {
                    return (0, IRule_1.RulePass)("Pass_Grouped", [ctxType]);
                }
            }
            else if (ctxType === "Checkbox" && formCache.numCheckboxes > 1 && numCheckboxesWithName === 1) {
                // We have only one checkbox with this name, but there are other checkboxes in the form.
                // If we're not grouped, ask them to examine it
                if (ctxGroup === null) {
                    return (0, IRule_1.RulePotential)("Potential_LoneCheckbox", [ctxType]);
                }
                else {
                    return (0, IRule_1.RulePass)("Pass_Grouped", [ctxType]);
                }
            }
            else {
                // We share a name with another similar control. Are we grouped together?
                if (ctxGroup === null) {
                    if (formCache.nameToGroup[ctxName] !== null) {
                        // We're not grouped, but some control with the same name is in a group
                        return (0, IRule_1.RuleFail)("Fail_NotGroupedOtherGrouped", [ctxType, ctxName]);
                    }
                    else {
                        // None of us are grouped
                        return (0, IRule_1.RuleFail)("Fail_NotGroupedOtherNotGrouped", [ctxType, ctxName]);
                    }
                }
                else if (formCache.nameToGroup[ctxName] !== ctxGroup) {
                    // We're not in the main group with the others
                    return (0, IRule_1.RuleFail)("Fail_NotSameGroup", [ctxType, ctxName]);
                }
                else {
                    // We're all grouped up!
                    return (0, IRule_1.RulePass)("Pass_Grouped", [ctxType]);
                }
            }
        }
    }
};


/***/ }),

/***/ 8929:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_fields_grouped = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.input_fields_grouped = {
    id: "input_fields_grouped",
    context: "dom:input, dom:textarea, dom:select",
    refactor: {
        "WCAG20_Input_InFieldSet": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "input_fields_grouped.html",
            "Potential_1": "input_fields_grouped.html",
            "group": "input_fields_grouped.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Use the <fieldset> element to group logically related input elements",
            "group": "Groups of logically related input elements should be contained within a <fieldset> element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Don't trigger for other input types or if we're in a fieldset
        if (ruleContext.nodeName.toLowerCase() == "input" && ruleContext.hasAttribute("type")) {
            var type = ruleContext.getAttribute("type").toLowerCase();
            if (type != "text" && type != "file" && type != "password")
                return (0, IRule_1.RulePass)("Pass_0");
        }
        if (legacy_1.RPTUtil.getAncestor(ruleContext, "fieldset") != null)
            return (0, IRule_1.RulePass)("Pass_0");
        // No fieldset - see if this input is all by itself - no need to group single inputs
        var parent = legacy_1.RPTUtil.getAncestor(ruleContext, ["form", "body"]);
        var checkTypes = ["input", "textarea", "select"];
        var passed = true;
        for (var i = 0; passed && i < checkTypes.length; ++i) {
            var controls = parent.getElementsByTagName(checkTypes[i]);
            for (var j = 0; passed && j < controls.length; ++j) {
                // Check if the node should be skipped or not based on the Check Hidden Content setting and if the node isVisible or
                // not.
                if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(controls[j])) {
                    continue;
                }
                // Note that textareas and selects will be called type='text'
                var type = controls[j].hasAttribute("type") ? controls[j].getAttribute("type").toLowerCase() : "text";
                // Only fail if this is another control in the form and its type is another text-like input
                passed = controls[j] == ruleContext || (type != "text" && type != "password" && type != "file");
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5403:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_haspopup_conflict = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.input_haspopup_conflict = {
    id: "input_haspopup_conflict",
    context: "dom:input[list][aria-haspopup]",
    refactor: {
        "input_haspopup_invalid": {
            "Pass": "Pass",
            "Potential_1": "Potential_1",
            "Potential_2": "Potential_2"
        }
    },
    help: {
        "en-US": {
            "Pass": "input_haspopup_conflict.html",
            "Potential_1": "input_haspopup_conflict.html",
            "Potential_2": "input_haspopup_conflict.html",
            "group": "input_haspopup_conflict.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "<input> element with 'list' attribute does not use 'aria-haspopup' attribute",
            "Potential_1": "<input> element with 'list' attribute also uses 'aria-haspopup' attribute with type=\"{0}\"",
            "Potential_2": "<input> element with 'list' attribute also uses 'aria-haspopup' attribute with missing or invalid input type",
            "group": "<input> element with 'list' attribute should not also use 'aria-haspopup' attribute"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //triggering input types: text, search, tel, url, email, or missing or invalid 
        var yesTypes = ["text", "search", "tel", "url", "email"];
        var noTypes = ["file", "password", "checkbox", "radio", "submit", "reset",
            "date", "number", "range", "time", "color", "image",
            "month", "week", "datetime-local", "hidden", "button"
        ];
        var attrValue = ruleContext.getAttribute("type");
        //missing input type
        if (!attrValue)
            return (0, IRule_1.RulePotential)("Potential_2");
        attrValue = attrValue.toLowerCase();
        // ignore for no triggering input types 
        if (noTypes.includes(attrValue))
            return;
        // failure_1 if any triggering input types    
        if (yesTypes.includes(attrValue))
            return (0, IRule_1.RulePotential)("Potential_1", [attrValue]);
        //invalid input type
        return (0, IRule_1.RulePotential)("Potential_2");
    }
};


/***/ }),

/***/ 5937:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_label_after = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.input_label_after = {
    id: "input_label_after",
    context: "dom:input",
    refactor: {
        "WCAG20_Input_LabelAfter": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "input_label_after.html",
            "Fail_1": "input_label_after.html",
            "Fail_2": "input_label_after.html",
            "group": "input_label_after.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Checkbox or radio button is nested in label, so label is not after the input control",
            "Fail_2": "Label text is located before its associated checkbox or radio button element",
            "group": "Checkboxes and radio buttons must have a label after the input control"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var type = "";
        if (ruleContext.hasAttribute("type"))
            type = ruleContext.getAttribute("type").toLowerCase();
        if (type != "checkbox" && type != "radio") {
            return null;
        }
        // Get only the non-hidden labels for element
        var labelElem = legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true);
        if (labelElem === null || !legacy_1.RPTUtil.hasInnerContentHidden(labelElem)) {
            // Due to dependency, label must be done via title - this rule doesn't apply
            return null;
        }
        var value = legacy_1.RPTUtil.compareNodeOrder(labelElem, ruleContext);
        var passed;
        if (value === -2) {
            // input nested in label
            passed = false;
            var walkNode = new legacy_1.NodeWalker(labelElem);
            walkNode.node = ruleContext;
            while (!passed && walkNode.nextNode()) {
                passed = ((walkNode.node.nodeName.toLowerCase() === "#text" && walkNode.node.nodeValue.trim().length > 0)
                    || (walkNode.node.nodeName.toLowerCase() === "span" && walkNode.node.textContent.trim().length > 0));
            }
            if (!passed) {
                // Input nested in label and text before input
                return (0, IRule_1.RuleFail)("Fail_1");
            }
        }
        else {
            if (value != 1) {
                // label is before input
                return (0, IRule_1.RuleFail)("Fail_2");
            }
        }
        return (0, IRule_1.RulePass)("Pass_0");
    }
};


/***/ }),

/***/ 4452:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_label_before = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.input_label_before = {
    id: "input_label_before",
    context: "dom:input, dom:textarea, dom:select",
    refactor: {
        "WCAG20_Input_LabelBefore": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "input_label_before.html",
            "Fail_1": "input_label_before.html",
            "Fail_2": "input_label_before.html",
            "group": "input_label_before.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Text input is nested in label such that input precedes the label text",
            "Fail_2": "Label text is located after its associated text input or <select> element",
            "group": "Text inputs and <select> elements must have a label before the input control"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (ruleContext.nodeName.toLowerCase() == "input" && ruleContext.hasAttribute("type")) {
            var type = ruleContext.getAttribute("type").toLowerCase();
            if (type != "text" && type != "file" && type != "password") {
                return null;
            }
        }
        // Get only the non-hidden labels for element
        var labelElem = legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true);
        if (labelElem == null || !legacy_1.RPTUtil.hasInnerContentHidden(labelElem)) {
            // Due to dependency, label must be done via title - this rule doesn't apply
            return null;
        }
        var value = legacy_1.RPTUtil.compareNodeOrder(labelElem, ruleContext);
        if (value == -2) {
            // input nested in label
            var passed = false;
            var walkNode = ruleContext.previousSibling;
            while (!passed && walkNode !== null) {
                passed = ((walkNode.nodeName.toLowerCase() == "#text" && walkNode.nodeValue.trim().length > 0)
                    || (walkNode.nodeName.toLowerCase() == "span" && walkNode.textContent.trim().length > 0));
                walkNode = walkNode.previousSibling;
            }
            if (!passed) {
                // Input nested in label and text after input
                return (0, IRule_1.RuleFail)("Fail_1");
            }
        }
        else {
            if (value != -1) {
                // label is after input
                return (0, IRule_1.RuleFail)("Fail_2");
            }
        }
        // Haven't returned yet, then I pass
        return (0, IRule_1.RulePass)("Pass_0");
    }
};


/***/ }),

/***/ 7209:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_label_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var fragment_1 = __webpack_require__(482);
var DOMWalker_1 = __webpack_require__(7440);
exports.input_label_exists = {
    id: "input_label_exists",
    context: "aria:button,aria:checkbox,aria:combobox,aria:listbox,aria:menuitemcheckbox,aria:menuitemradio,aria:radio,aria:searchbox,aria:slider,aria:spinbutton,aria:switch,aria:textbox,aria:progressbar,dom:input[type=file],dom:output,dom:meter,dom:input[type=password]",
    refactor: {
        "WCAG20_Input_ExplicitLabel": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "input_label_exists.html",
            "Fail_1": "input_label_exists.html",
            "Fail_2": "input_label_exists.html",
            "group": "input_label_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Form control element <{0}> has no associated label",
            "Fail_2": "Form control with \"{0}\" role has no associated label",
            "group": "Each form control must have an associated label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    // TODO: ACT: https://github.com/IBMa/equal-access/issues/756
    act: ["97a4e1", "e086e5"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (ruleContext.getAttribute("aria-hidden")) {
            return null;
        }
        var nodeName = ruleContext.nodeName.toLowerCase();
        //ignore datalist element check since it will be part of a input element or hidden by default
        if (nodeName === 'datalist')
            return null;
        // Determine the input type
        var passed = true;
        var type = "text";
        if (nodeName == "input" && ruleContext.hasAttribute("type")) {
            type = ruleContext.getAttribute("type").toLowerCase();
        }
        else if (nodeName === "button" || legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "button")) {
            type = "buttonelem";
        }
        if (nodeName == "input" && type == "") {
            type = "text";
        }
        if (type === "image") {
            // Handled by input_label_existsImage
            return null;
        }
        var POF = -1;
        var textTypes = [
            "text", "file", "password",
            "checkbox", "radio",
            "search", "tel", "url", "email",
            "date", "number", "range",
            "time", "color"
        ];
        var buttonTypes = [
            "button", "reset", "submit"
        ];
        var buttonTypesWithDefaults = ["reset", "submit"]; // 'submit' and 'reset' have visible defaults.
        if (textTypes.indexOf(type) !== -1) { // If type is in the list
            // Get only the non-hidden labels for element, in the case that an label is hidden then it is a violation
            // Note: label[for] does not work for ARIA-defined inputs
            var labelElem = ruleContext.hasAttribute("role") ? null : legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true);
            var hasLabelElemContent = false;
            if (labelElem) {
                if (legacy_1.RPTUtil.hasInnerContentHidden(labelElem)) {
                    hasLabelElemContent = true;
                }
                else if ((labelElem.getAttribute("aria-label") || "").trim().length > 0) {
                    hasLabelElemContent = true;
                }
                else if (labelElem.hasAttribute("aria-labelledby")) {
                    var labelledByElem = fragment_1.FragmentUtil.getById(labelElem, labelElem.getAttribute('aria-labelledby'));
                    if (labelledByElem && legacy_1.RPTUtil.hasInnerContent(labelledByElem)) {
                        hasLabelElemContent = true;
                    }
                }
            }
            passed = (!!labelElem && hasLabelElemContent) ||
                (!labelElem && legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title") || legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "placeholder")) ||
                legacy_1.RPTUtil.getAriaLabel(ruleContext).trim().length > 0 || legacy_1.RPTUtil.hasImplicitLabel(ruleContext);
            if (!passed)
                POF = 2 + textTypes.indexOf(type);
        }
        else if (buttonTypes.indexOf(type) !== -1) { // If type is a button
            if (buttonTypesWithDefaults.indexOf(type) !== -1 && !ruleContext.hasAttribute("value")) {
                // 'submit' and 'reset' have visible defaults so pass if there is no 'value' attribute
                passed = true;
            }
            else {
                passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "value") || legacy_1.RPTUtil.hasAriaLabel(ruleContext) || legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title");
                if (!passed)
                    POF = 2 + textTypes.length + buttonTypes.indexOf(type);
            }
        }
        else if (type == "buttonelem") {
            // If I am an image and I have alt text - accessibility-web-engine#269
            var bAlt = false;
            if (ruleContext.nodeName.toLowerCase() === "img" && ruleContext.hasAttribute("alt")) {
                var alt = ruleContext.getAttribute("alt");
                if (alt.trim().length === 0) {
                    bAlt = false;
                }
                else {
                    bAlt = true;
                }
            }
            ;
            passed = legacy_1.RPTUtil.hasInnerContentHidden(ruleContext) || legacy_1.RPTUtil.hasAriaLabel(ruleContext) || bAlt || legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title");
            if (!passed)
                POF = 2 + textTypes.length + buttonTypes.length + 1;
        }
        // Rpt_Aria_ValidIdRef determines if the aria-labelledby id points to a valid element
        if (!passed && (buttonTypes.indexOf(type) !== -1)) {
            if (ruleContext.hasAttribute("class") && ruleContext.getAttribute("class") == "dijitOffScreen" && DOMWalker_1.DOMWalker.parentElement(ruleContext).hasAttribute("widgetid")) {
                // Special handling for dijit buttons
                var labelId = DOMWalker_1.DOMWalker.parentElement(ruleContext).getAttribute("widgetid") + "_label";
                var label = fragment_1.FragmentUtil.getById(ruleContext, labelId);
                if (label != null) {
                    passed = legacy_1.RPTUtil.hasInnerContentHidden(label);
                    // This means I failed above also
                    if (!passed)
                        POF = 2 + textTypes.length + buttonTypes.length + 4 + buttonTypes.indexOf(type);
                }
            }
        }
        if (!passed && nodeName == "optgroup") {
            passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "label");
            if (!passed)
                POF = 2 + textTypes.length + buttonTypes.length + 2;
        }
        if (!passed && nodeName == "option") {
            // Is a non-empty value attribute also enough for an option element?
            passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "label") || ruleContext.innerHTML.trim().length > 0;
            if (!passed)
                POF = 2 + textTypes.length + buttonTypes.length + 3;
        }
        if (!passed) {
            // check aria role
            //any more roles for input? 
            var nameFromBoth = legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "menuitemcheckbox") || legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "menuitemradio")
                || legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "radio") || legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "checkbox");
            var nameFromAuthorOnly = legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "listbox") || legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "searchbox")
                || legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "textbox") || legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "combobox")
                || !legacy_1.RPTUtil.hasAnyRole(ruleContext, true);
            if (nameFromBoth)
                passed = legacy_1.RPTUtil.getInnerText(ruleContext) && legacy_1.RPTUtil.getInnerText(ruleContext).trim().length > 0;
            if (!passed) {
                if (nameFromBoth || nameFromAuthorOnly)
                    passed = legacy_1.RPTUtil.getAriaLabel(ruleContext).trim().length > 0 || legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title");
            }
        }
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else if (ruleContext.hasAttribute("role") && ruleContext.getAttribute("role").trim().length > 0) {
            return (0, IRule_1.RuleFail)("Fail_2", ruleContext.getAttribute("role").split(" "));
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1", [nodeName]);
        }
    }
};


/***/ }),

/***/ 8262:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_label_visible = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var fragment_1 = __webpack_require__(482);
var VisUtil_1 = __webpack_require__(8174);
exports.input_label_visible = {
    id: "input_label_visible",
    context: "aria:button,aria:checkbox,aria:combobox,aria:listbox,aria:menuitemcheckbox,aria:menuitemradio,aria:radio,aria:searchbox,aria:slider,aria:spinbutton,aria:switch,aria:textbox,aria:progressbar,dom:input[type=file],dom:output",
    dependencies: ["input_label_exists"],
    refactor: {
        "WCAG20_Input_VisibleLabel": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "input_label_visible.html",
            "Potential_1": "input_label_visible.html",
            "group": "input_label_visible.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "The input element does not have an associated visible label",
            "group": "An input element must have an associated visible label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        //ignore datalist element check since it will be part of a input element or hidden by default
        if (nodeName === 'datalist')
            return null;
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) ||
            legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
            return null;
        }
        // when in a combobox, only look at the input textbox.
        if (legacy_1.RPTUtil.getAncestorWithRole(ruleContext, "combobox") &&
            !(legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "textbox") || legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "searchbox") ||
                nodeName === "input" || (nodeName === "select" && legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "combobox")))) {
            return null;
        }
        // avoid diagnosing the popup list of a combobox.
        var rolesToCheck = ["listbox", "tree", "grid", "dialog"];
        for (var j = 0; j < rolesToCheck.length; j++) {
            if (legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, rolesToCheck[j])) {
                var comboboxes = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "combobox", true, true);
                for (var k = 0; k < comboboxes.length; k++) {
                    var combobox = comboboxes[k];
                    var aria_owns = legacy_1.RPTUtil.getElementAttribute(combobox, "aria-owns");
                    if (aria_owns) {
                        var owns = legacy_1.RPTUtil.normalizeSpacing(aria_owns.trim()).split(" ");
                        for (var i = 0; i < owns.length; i++) {
                            var owned = fragment_1.FragmentUtil.getById(ruleContext, owns[i]);
                            if (owned === ruleContext) {
                                return null;
                            }
                        }
                    }
                }
            }
        }
        // Determine the input type
        var passed = true;
        var type = "text";
        if (nodeName == "input" && ruleContext.hasAttribute("type")) {
            type = ruleContext.getAttribute("type").toLowerCase();
        }
        else if (nodeName === "button" || legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "button")) {
            type = "buttonelem";
        }
        if (nodeName == "input" && type == "") {
            type = "text";
        }
        var textTypes = ["text", "file", "password",
            "checkbox", "radio",
            "search", "tel", "url", "email",
            "date", "number", "range",
            "time", "color",
            "month", "week", "datetime-local"];
        var buttonTypes = ["button", "reset", "submit"];
        var buttonTypesWithDefaults = ["reset", "submit"]; // 'submit' and 'reset' have visible defaults.
        if (textTypes.indexOf(type) !== -1) { // If type is in the list
            // Get only the non-hidden labels for element, in the case that an label is hidden then it is a violation
            var labelElem = legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true);
            passed = (labelElem != null && legacy_1.RPTUtil.hasInnerContentHidden(labelElem)) ||
                legacy_1.RPTUtil.hasImplicitLabel(ruleContext) ||
                type === "file"; // input type=file has a visible default.
        }
        else if (buttonTypes.indexOf(type) !== -1 || type == "buttonelem") {
            // Buttons are not in scope for this success criteria (IBMa/equal-access#204)
            return null;
        }
        // check if there is a visible label pointed to by the aria-labelledby attribute.
        if (!passed && legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "aria-labelledby")) {
            var theLabel = ruleContext.getAttribute("aria-labelledby");
            var labelValues = theLabel.split(/\s+/);
            for (var j = 0; j < labelValues.length; ++j) {
                var elementById = fragment_1.FragmentUtil.getById(ruleContext, labelValues[j]);
                if (elementById && VisUtil_1.VisUtil.isNodeVisible(elementById) && legacy_1.RPTUtil.hasInnerContentHidden(elementById)) {
                    passed = true;
                    break;
                }
            }
        }
        if (!passed && nodeName == "optgroup") {
            passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "label");
        }
        if (!passed && nodeName == "option") {
            passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "label") || ruleContext.innerHTML.trim().length > 0;
        }
        // One last check for roles that support name from content
        if (!passed) {
            // list from https://www.w3.org/TR/wai-aria-1.1/#namefromcontent
            var rolesWithNameFromContent = ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "link",
                "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row",
                "rowgroup", "rowheader", "switch", "tab", "tooltip", /*"tree",*/ "treeitem"];
            //get attribute roles as well as implicit roles.
            var roles = legacy_1.RPTUtil.getRoles(ruleContext, true);
            for (var i = 0; i < roles.length; i++) {
                if (rolesWithNameFromContent.indexOf(roles[i]) !== -1) {
                    passed = legacy_1.RPTUtil.hasInnerContentHidden(ruleContext);
                    break;
                }
            }
        }
        // Determine if this is referenced by a combobox. If so, the label belongs to the combobox
        var id = ruleContext.getAttribute("id");
        if (id && id.trim().length > 0) {
            if (ruleContext.ownerDocument.querySelector("*[aria-controls='".concat(id, "'][role='combobox']"))) {
                return null;
            }
        }
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RulePotential)("Potential_1");
        }
    }
};


/***/ }),

/***/ 7017:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_onchange_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.input_onchange_review = {
    id: "input_onchange_review",
    context: "dom:input, dom:textarea, dom:select",
    refactor: {
        "WCAG20_Input_HasOnchange": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "input_onchange_review.html",
            "Potential_1": "input_onchange_review.html",
            "group": "input_onchange_review.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that any changes of context are explained in advance to the user",
            "group": "Verify that any changes of context are explained in advance to the user"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.2.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (ruleContext.nodeName.toLowerCase() == "input" && ruleContext.hasAttribute("type")) {
            var type = ruleContext.getAttribute("type").toLowerCase();
            if (type != "text" && type != "file" && type != "password" && type != "checkbox" && type != "radio")
                return (0, IRule_1.RulePass)("Pass_0");
        }
        var passed = !ruleContext.hasAttribute("onchange");
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9980:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_placeholder_label_visible = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.input_placeholder_label_visible = {
    id: "input_placeholder_label_visible",
    context: "dom:input[placeholder], dom:textarea[placeholder]",
    refactor: {
        "HAAC_Input_Placeholder": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1",
            "Potential_2": "Potential_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "input_placeholder_label_visible.html",
            "Potential_1": "input_placeholder_label_visible.html",
            "Potential_2": "input_placeholder_label_visible.html",
            "group": "input_placeholder_label_visible.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "HTML5 placeholder is the only visible label",
            "Potential_2": "Additional visible label referenced by 'aria-labelledby' is not valid",
            "group": "HTML5 'placeholder' attribute must not be used as a visible label replacement"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (ruleContext.hasAttribute("type")) {
            var type = ruleContext.getAttribute("type").toLowerCase();
            if (type == "hidden" || type == "button") {
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
        if (ruleContext.hasAttribute("hidden")) {
            var hidden = ruleContext.getAttribute("hidden");
            if (hidden == "" || hidden.toLowerCase() == "hidden") { // when hidden is empty in the element, "" is returned, same as it has a value of "".
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
        if (ruleContext.hasAttribute("aria-label")) {
            return (0, IRule_1.RulePotential)("Potential_1");
        }
        if (ruleContext.hasAttribute("aria-labelledby") && ruleContext.hasAttribute("id")) {
            var id = ruleContext.getAttribute("id").trim();
            var refIds = ruleContext.getAttribute("aria-labelledby").trim().split(/\s+/); // separated by one or more white spaces
            if (!refIds.includes(id)) {
                return (0, IRule_1.RulePass)("Pass_0");
            }
            else {
                return (0, IRule_1.RulePotential)("Potential_2");
            }
        }
        return (0, IRule_1.RulePass)("Pass_0");
    }
};


/***/ }),

/***/ 7733:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.label_content_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var fragment_1 = __webpack_require__(482);
exports.label_content_exists = {
    id: "label_content_exists",
    context: "dom:label",
    refactor: {
        "Valerie_Label_HasContent": {
            "Pass_Regular": "Pass_Regular",
            "Pass_AriaLabel": "Pass_AriaLabel",
            "Pass_LabelledBy": "Pass_LabelledBy",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_Regular": "label_content_exists.html",
            "Pass_AriaLabel": "label_content_exists.html",
            "Pass_LabelledBy": "label_content_exists.html",
            "Fail_1": "label_content_exists.html",
            "group": "label_content_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_Regular": "<label> element has accessible name with inner content",
            "Pass_AriaLabel": "<label> element has accessible name via 'aria-label'",
            "Pass_LabelledBy": "<label> element has accessible name via 'aria-labelledby'",
            "Fail_1": "The <label> element does not have descriptive text that identifies the expected input",
            "group": "A <label> element must have non-empty descriptive text that identifies the purpose of the interactive component"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (legacy_1.RPTUtil.hasInnerContentHidden(ruleContext)) {
            return (0, IRule_1.RulePass)("Pass_Regular");
        }
        else if ((ruleContext.getAttribute("aria-label") || "").trim().length > 0) {
            return (0, IRule_1.RulePass)("Pass_AriaLabel");
        }
        else if (ruleContext.hasAttribute("aria-labelledby")) {
            var labelElem = fragment_1.FragmentUtil.getById(ruleContext, ruleContext.getAttribute('aria-labelledby'));
            if (labelElem && legacy_1.RPTUtil.hasInnerContent(labelElem)) {
                return (0, IRule_1.RulePass)("Pass_LabelledBy");
            }
        }
        return (0, IRule_1.RuleFail)("Fail_1");
    }
};


/***/ }),

/***/ 1256:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.label_name_visible = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var fragment_1 = __webpack_require__(482);
var VisUtil_1 = __webpack_require__(8174);
var CSSUtil_1 = __webpack_require__(1775);
var DOMWalker_1 = __webpack_require__(7440);
exports.label_name_visible = {
    id: "label_name_visible",
    context: "aria:button,aria:checkbox,aria:gridcell,aria:link,aria:menuitem,aria:menuitemcheckbox,aria:menuitemradio,aria:option,aria:radio,aria:switch,aria:tab,aria:treeitem,dom:input,dom:textarea,dom:select,dom:output,dom:meter",
    refactor: {
        "WCAG21_Label_Accessible": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "label_name_visible.html",
            "Fail_1": "label_name_visible.html",
            "group": "label_name_visible.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Accessible name matches or contains the visible label text",
            "Fail_1": "Accessible name does not match or contain the visible label text",
            "group": "Accessible name must match or contain the visible label text"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1"],
            "num": ["2.5.3"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    // TODO: ACT: Review https://github.com/act-rules/act-rules.github.io/issues/1618
    // https://www.w3.org/WAI/WCAG21/Techniques/aria/ARIA24
    act: "2ee8b8",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) ||
            legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
            return null;
        }
        // pass if the visible text uses Material Icon font
        if ((0, CSSUtil_1.isMaterialIconFont)(ruleContext))
            return (0, IRule_1.RulePass)("Pass_0");
        var passed = true;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var isInputButton = false;
        var buttonTypes = ["button", "reset", "submit" /*, "image"*/];
        var inputType = null;
        if (nodeName === "input" && ruleContext.hasAttribute("type")) {
            inputType = ruleContext.getAttribute("type").toLowerCase();
            if (buttonTypes.indexOf(inputType) !== -1) {
                isInputButton = true;
            }
        }
        var theLabelBy = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-labelledby");
        if (theLabelBy && !isInputButton) {
            // skip the checks if it has an aria-labelledby since it takes precedence.
        }
        else {
            var theLabel = null;
            if (theLabelBy) {
                var labelValues = theLabelBy.split(/\s+/);
                for (var j = 0; j < labelValues.length; ++j) {
                    var elementById = fragment_1.FragmentUtil.getById(ruleContext, labelValues[j]);
                    if (elementById) {
                        theLabel = legacy_1.RPTUtil.getInnerText(elementById);
                        break;
                    }
                }
            }
            else {
                theLabel = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-label");
            }
            if (!theLabel) {
                return null;
            }
            var text = null;
            if (isInputButton) {
                /* Note: Disable the alt check in images until we get confirmation
                if (inputType==="image" && ruleContext.hasAttribute("alt")){
                    // use 'alt' attribute as visible text
                    text = ruleContext.getAttribute("alt");
                }else
                */
                if (ruleContext.hasAttribute("value")) {
                    // use 'value' attribute as visible text
                    text = ruleContext.getAttribute("value");
                }
                else {
                    // use default value
                    if (inputType === "submit" /*||inputType==="image"*/) {
                        text = "submit";
                    }
                    else if (inputType === "reset") {
                        text = "reset";
                    }
                }
            }
            if (!text) {
                // look for a <label> element
                var labelElem = legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true);
                if (!labelElem) {
                    var parentNode = DOMWalker_1.DOMWalker.parentNode(ruleContext);
                    if (parentNode.nodeName.toLowerCase() === "label" /*&& RPTUtil.isFirstFormElement(parentNode, ruleContext)*/) {
                        var parentClone = parentNode.cloneNode(true);
                        // exclude all form elements from the label since they might also have inner content
                        labelElem = legacy_1.RPTUtil.removeAllFormElementsFromLabel(parentClone);
                    }
                }
                var element = labelElem ? labelElem : ruleContext;
                var elementsToSkipContentCheck = ["meter", "output", "progress", "select", "textarea"];
                if (!labelElem && elementsToSkipContentCheck.indexOf(nodeName) !== -1) {
                    text = ""; // skip content check for some elements
                }
                else {
                    // get the visible text
                    text = legacy_1.RPTUtil.getInnerText(element);
                }
                /* Note: Disable this alt check in images for now until we get confirmation
                // Look for the alt attribute of an image which is considered visible text.
                let hasImgAlt = false;
                if (element.firstChild != null) {
                    let nw = RPTUtil.new NodeWalker(element);
                    while (!hasImgAlt && nw.nextNode() && nw.node != element && nw.node != element.nextSibling) {
                        hasImgAlt = (nw.node.nodeName.toLowerCase() == "img" && RPTUtil.attributeNonEmpty(nw.node, "alt"));
                        if (hasImgAlt) {
                            text = text ? text + nw.node.getAttribute("alt") : nw.node.getAttribute("alt");
                        }
                    }
                }
                */
            }
            var nonalphanumeric = /[^a-zA-Z0-9]/g;
            text = text.replace(nonalphanumeric, " "); // only consider alphanumeric characters
            var normalizedText = legacy_1.RPTUtil.normalizeSpacing(text).toLowerCase(); // Leading and trailing whitespace and difference in case sensitivity should be ignored.
            theLabel = theLabel.replace(nonalphanumeric, " "); // only consider alphanumeric characters
            var normalizedLabel = legacy_1.RPTUtil.normalizeSpacing(theLabel).toLowerCase();
            if (normalizedText.length > 1) { // skip non-text content. e.g. <button aria-label="close">X</button>
                var location_1 = normalizedLabel.indexOf(normalizedText);
                // Avoid matching partial words.e.g. text "name" should not match 'surname' or 'names'
                if (location_1 >= 0 && normalizedLabel.length > normalizedText.length) {
                    var letters = /^[0-9a-zA-Z]+$/;
                    if ((location_1 + normalizedText.length) < normalizedLabel.length) {
                        // check ending
                        var theChar = normalizedLabel.charAt(location_1 + normalizedText.length);
                        if (theChar.match(letters)) {
                            passed = false;
                        }
                    }
                    if (passed && location_1 > 0) {
                        // check beginning
                        var theChar = normalizedLabel.charAt(location_1 - 1);
                        if (theChar.match(letters)) {
                            passed = false;
                        }
                    }
                }
                if (location_1 === -1) { // check that visible text content of the target is contained within its accessible name.
                    passed = false;
                }
            }
        }
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 9532:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.label_ref_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var fragment_1 = __webpack_require__(482);
var VisUtil_1 = __webpack_require__(8174);
exports.label_ref_valid = {
    id: "label_ref_valid",
    context: "dom:label[for]",
    refactor: {
        "WCAG20_Label_RefValid": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "label_ref_valid.html",
            "Fail_1": "label_ref_valid.html",
            "group": "label_ref_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The value \"{0}\" of the 'for' attribute is not the 'id' of a valid <input> element",
            "group": "The 'for' attribute must reference a non-empty, unique 'id' attribute of an <input> element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var id = ruleContext.getAttribute("for");
        var passed = false;
        var target = fragment_1.FragmentUtil.getById(ruleContext, id);
        if (target) {
            // ignore if both label and control are invisible
            if (!VisUtil_1.VisUtil.isNodeVisible(target) && !VisUtil_1.VisUtil.isNodeVisible(ruleContext))
                return null;
            passed = true;
            // handles null and undefined
            if (!target.hasAttribute("role")) {
                // Fail if we're pointing at something that is labelled by another mechanism
                var nodeName = target.nodeName.toLowerCase();
                passed = nodeName == "input" || nodeName == "select" || nodeName == "textarea"
                    || nodeName == "button" || nodeName == "datalist"
                    || nodeName == "optgroup" || nodeName == "option"
                    || nodeName == "keygen" || nodeName == "output"
                    || nodeName == "progress" || nodeName == "meter"
                    || nodeName == "fieldset" || nodeName == "legend";
                if (target.nodeName.toLowerCase() == "input" && target.hasAttribute("type")) {
                    var type = target.getAttribute("type").toLowerCase();
                    passed = type == "text" || type == "password" || type == "file" ||
                        type == "checkbox" || type == "radio" ||
                        type == "hidden" || type == "search" || type == "tel" || type == "url" || type == "email" || //HTML 5
                        type == "date" || type == "number" || type == "range" || type == "image" || //HTML 5
                        type == "time" || type == "color" || // HTML 5
                        type == "datetime" || type == "month" || type == "week"; //HTML5.1
                }
            }
            // Add one more check to make sure the target element is NOT hidden, in the case the target is hidden
            // flag a violation regardless of what the Check Hidden Content setting is.
            if (passed && !VisUtil_1.VisUtil.isNodeVisible(target)) {
                passed = false;
            }
        }
        var retToken = [];
        if (!passed) {
            retToken.push(id);
        }
        //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [retToken]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", retToken);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 6698:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.list_children_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var DOMWalker_1 = __webpack_require__(7440);
exports.list_children_valid = {
    id: "list_children_valid",
    context: "aria:group",
    refactor: {
        "HAAC_List_Group_ListItem": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "list_children_valid.html",
            "Fail_1": "list_children_valid.html",
            "group": "list_children_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "List component with \"group\" role has children that are not <listitem> elements",
            "group": "List component with \"group\" role must limit children to <listitem> elements"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var parent = DOMWalker_1.DOMWalker.parentElement(ruleContext);
        if (!legacy_1.RPTUtil.hasRoleInSemantics(parent, "list")) {
            return null;
        }
        var passed = true;
        var children = ruleContext.children;
        for (var i = 0; passed && i < children.length; i++) {
            passed = legacy_1.RPTUtil.hasRoleInSemantics(children[i], "listitem");
        }
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 9632:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.list_markup_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.list_markup_review = {
    id: "list_markup_review",
    context: "dom:*",
    refactor: {
        "RPT_List_UseMarkup": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "list_markup_review.html",
            "Potential_1": "list_markup_review.html",
            "group": "list_markup_review.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify whether this is a list that should use HTML list elements",
            "group": "Use proper HTML list elements to create lists"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = true;
        var walkNode = ruleContext.firstChild;
        while (passed && walkNode) {
            // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
            // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
            // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
            // a node walk only on siblings so it would not get text nodes from other siblings at all.
            // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
            // if.
            if (walkNode.nodeName == "#text") {
                var txtVal = walkNode.nodeValue;
                var failure = /^[ \t\r\n]*[( ]*[1-9]*[\*\-).][ \t][A-Z,a-z]+/.test(txtVal);
                passed = !failure;
                if (!passed) {
                    // Ensure that there's some sort of block level element before this
                    // Avoid failures due to things like <i>Some sentence</i>. New sentence.
                    var nw = new legacy_1.NodeWalker(walkNode);
                    while (!passed && nw.prevNode()) {
                        var nodeName = nw.node.nodeName.toLowerCase();
                        if (["blockquote", "center", "dir", "div", "form", "h1",
                            "h2", "h3", "h4", "h5", "h6", "hr", "br", "menu", "p",
                            "pre"].includes(nodeName)) {
                            break;
                        }
                        if (nodeName == "#text") {
                            var txt = nw.node.nodeValue;
                            passed = txt.length > 0 && ![" ", "\t", "\n"].includes(txt.charAt(txt.length - 1));
                        }
                    }
                }
            }
            walkNode = walkNode.nextSibling;
        }
        if (!passed) {
            // Don't trigger if we're not in the body or if we're in a script
            var checkAncestor = legacy_1.RPTUtil.getAncestor(ruleContext, ["body", "script"]);
            passed = checkAncestor == null || checkAncestor.nodeName.toLowerCase() != "body";
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 3692:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.list_structure_proper = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.list_structure_proper = {
    id: "list_structure_proper",
    context: "dom:dl, dom:ul, dom:ol, dom:dir, dom:menu, dom:li, dom:dd, dom:dt",
    refactor: {
        "RPT_List_Misuse": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "list_structure_proper.html",
            "Potential_1": "list_structure_proper.html",
            "group": "list_structure_proper.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "List element is missing or improperly structured",
            "group": "List elements should only be used for lists of related items"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed;
        var nodeName = ruleContext.nodeName.toLowerCase();
        // Get all the childrens of the ruleContext
        var children = ruleContext.children;
        if (nodeName == "dl") {
            var first = "";
            var last = "";
            var walkChildren = ruleContext.firstChild;
            passed = true;
            var presentationalFound = false;
            // If there are no childrens set as passed, since dl elements can have
            // zero or more of: one or more dt elements, followed by one or more dd elements
            if (!ruleContext.children || ruleContext.children.length == 0) {
                passed = true;
            }
            else {
                while (passed && walkChildren != null) {
                    if (walkChildren.nodeType == 1) {
                        var nodeName_1 = walkChildren.nodeName.toLowerCase();
                        // While walking through the elements under dl, if we find a 
                        // presentational element we move to the next element as presentational
                        // elements are allowed under list elements as they are only for
                        // formatting text nodes.
                        if (legacy_1.RPTUtil.isPresentationalElement(walkChildren)) {
                            presentationalFound = true;
                            walkChildren = walkChildren.nextSibling;
                            continue;
                        }
                        // Only set to pass if we find dd or dt element, in the case of
                        // an element that is not supported we will catch it here. i.e. img 
                        // element
                        passed = nodeName_1 == "dd" || nodeName_1 == "dt";
                        // Set the first and last node depending on which is found first and last
                        if (first == "")
                            first = nodeName_1;
                        last = nodeName_1;
                    }
                    walkChildren = walkChildren.nextSibling;
                }
                // In the case that we have found dt and dd elements under dl we pass right away.
                // In the case that there is no dt or dd element, but bunch of presentational elements we mark this as a
                // pass. In the case that there are other elements such as img we will still trigger a violation.
                passed = (passed && first == "dt" && last == "dd") || (passed && presentationalFound);
            }
        }
        else if (nodeName == "li") {
            passed = legacy_1.RPTUtil.getAncestor(ruleContext, ["ul", "ol", "dir", "menu"]) != null;
        }
        else if (nodeName == "dd" || nodeName == "dt") {
            passed = legacy_1.RPTUtil.getAncestor(ruleContext, "dl") != null;
        }
        else {
            var walkChildren = ruleContext.firstChild;
            // Zero or more li elements are permitted inside of <ol>, <ul> or <menu> elements now as per the html5 spec. This handles the case
            // when there are zero elements under the <ol>, <ul> or <menu>.
            if ((nodeName == "ul" || nodeName == "ol" || nodeName == "menu") && (!ruleContext.children || ruleContext.children.length == 0)) {
                passed = true;
            }
            else {
                var liFound = false;
                var presentationalFound = false;
                passed = true;
                while (passed && walkChildren != null) {
                    // While walking through the list elements, if we find a 
                    // presentational element we skip checking as presentational
                    // elements are allowed under list elements as they are only for
                    // formatting text.
                    if (legacy_1.RPTUtil.isPresentationalElement(walkChildren)) {
                        presentationalFound = true;
                        walkChildren = walkChildren.nextSibling;
                        continue;
                    }
                    // Pass if the node type is anything but 1, or in the case that it is a li element. For any other node 
                    // it will be caught here that element is not allowed under list node.
                    // Furthermore in the case that there is a template element with the parent being ul/ol don't flag a violation
                    passed = walkChildren.nodeType != 1 || walkChildren.nodeName.toLowerCase() == "li" || (walkChildren.nodeName.toLowerCase() == "template" && (nodeName == "ul" || nodeName == "ol"));
                    // Set li found to true if the current element (nodeType=1) is an li element
                    liFound = liFound || (walkChildren.nodeType == 1 && walkChildren.nodeName.toLowerCase() == "li");
                    walkChildren = walkChildren.nextSibling;
                }
                // In the case that it has passed and also li element is found under list node, we pass right away.
                // In the case that there is no li element, but bunch of presentational elements we mark this as a
                // pass. In the case that there are other elements such as img we will still trigger a violation.
                passed = (passed && liFound) || (passed && presentationalFound);
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5430:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.marquee_elem_avoid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.marquee_elem_avoid = {
    id: "marquee_elem_avoid",
    context: "dom:marquee",
    refactor: {
        "RPT_Marquee_Trigger": {
            "Passed_0": "Passed_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Passed_0": "marquee_elem_avoid.html",
            "Fail_1": "marquee_elem_avoid.html",
            "group": "marquee_elem_avoid.html"
        }
    },
    messages: {
        "en-US": {
            "Passed_0": "Rule Passed",
            "Fail_1": "Scrolling content found that uses the obsolete <marquee> element",
            "group": "The <marquee> element is obsolete and should not be used"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.2.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // JCH - NO OUT OF SCOPE hidden in context
        return (0, IRule_1.RuleFail)("Fail_1");
    }
};


/***/ }),

/***/ 1018:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_alt_brief = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8174);
exports.media_alt_brief = {
    id: "media_alt_brief",
    context: "dom:img[alt], dom:applet[alt], dom:area[alt], dom:embed[alt], dom:input[type][alt]",
    refactor: {
        "RPT_Media_AltBrief": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "media_alt_brief.html",
            "Potential_1": "media_alt_brief.html",
            "group": "media_alt_brief.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Text alternative is more than 150 characters",
            "group": "Alternative text in 'alt' attribute should be brief (<150 characters)"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            maxAlt: {
                value: 150,
                type: "integer"
            }
        };
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var altLength = ruleContext.getAttribute("alt").trim().length;
        var passed = altLength <= validateParams.maxAlt.value;
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 3433:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_alt_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.media_alt_exists = {
    id: "media_alt_exists",
    context: "dom:area[alt], dom:embed[alt]",
    refactor: {
        "RPT_Media_AudioVideoAltFilename": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "media_alt_exists.html",
            "Potential_1": "media_alt_exists.html",
            "group": "media_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Filename used as label for embedded audio or video",
            "group": "Audio or video on the page must have a short text alternative that describes the media content"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var uri = "";
        if (ruleContext.nodeName.toLowerCase() == "area") {
            uri = ruleContext.getAttribute("href");
        }
        else {
            uri = ruleContext.getAttribute("src");
        }
        if (uri == null)
            uri = "";
        var ext = legacy_1.RPTUtil.getFileExt(uri);
        var isAudVid = ext.length != 0 && (legacy_1.RPTUtil.isAudioExt(ext) || legacy_1.RPTUtil.isVideoExt(ext));
        var altText = ruleContext.getAttribute("alt");
        var passed = !isAudVid || (altText.length > 0 && altText.indexOf(ext) == -1);
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 8012:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_audio_transcribed = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.media_audio_transcribed = {
    id: "media_audio_transcribed",
    context: "dom:bgsound, dom:a[href], dom:area[href], dom:embed, dom:object",
    refactor: {
        "RPT_Media_AudioTrigger": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "media_audio_transcribed.html",
            "Manual_1": "media_audio_transcribed.html",
            "group": "media_audio_transcribed.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Provide transcripts for audio files",
            "group": "Audio information should also be available in text form"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.2.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed;
        var thisNode = ruleContext.nodeName.toLowerCase();
        if (thisNode == "bgsound") {
            passed = false;
        }
        else {
            passed = !legacy_1.RPTUtil.isAudioObjEmbedLink(ruleContext);
        }
        if (passed)
            return null; // Out of Scope
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 3881:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_autostart_controllable = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.media_autostart_controllable = {
    id: "media_autostart_controllable",
    context: "dom:param[name=autoplay], dom:param[name=autostart], dom:embed[flashvars], dom:embed[src], dom:*[autostart=true], dom:*[autostart=1], dom:bgsound",
    refactor: {
        "RPT_Embed_AutoStart": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "media_autostart_controllable.html",
            "Potential_1": "media_autostart_controllable.html",
            "group": "media_autostart_controllable.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify there is a mechanism to pause or stop and control the volume for the audio that plays automatically",
            "group": "Mechanism must be available to pause or stop and control the volume of the audio that plays automatically"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.4.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var passed;
        if (nodeName == "bgsound") {
            passed = false;
        }
        else if (nodeName == "param") {
            var content = "";
            if (ruleContext.hasAttribute("value"))
                content = ruleContext.getAttribute("value").toLowerCase();
            passed = content.indexOf("0;") == 0 ||
                !(content.indexOf("true") != -1 || content.indexOf("1") != -1);
        }
        else if (nodeName == "embed") {
            passed = true;
            if (ruleContext.hasAttribute("flashvars")) {
                var str = ruleContext.getAttribute("flashvars");
                passed = str.indexOf("autostart=true") == -1 &&
                    str.indexOf("autostart=1") == -1;
            }
            if (passed && ruleContext.hasAttribute("src")) {
                var str = ruleContext.getAttribute("src");
                passed = str.indexOf("autostart=true") == -1 &&
                    str.indexOf("autostart=1") == -1;
            }
        }
        if (passed && ruleContext.hasAttribute("autostart")) {
            var val = ruleContext.getAttribute("autostart").toLowerCase();
            passed = val != 'true' && val != '1';
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 3106:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_keyboard_controllable = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8174);
exports.media_keyboard_controllable = {
    id: "media_keyboard_controllable",
    context: "dom:audio, dom:video",
    refactor: {
        "HAAC_Audio_Video_Trigger": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "media_keyboard_controllable.html",
            "Manual_1": "media_keyboard_controllable.html",
            "group": "media_keyboard_controllable.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Verify media using <audio> and/or <video> elements have keyboard accessible controls",
            "group": "Media using <audio> and/or <video> elements must have keyboard accessible controls"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = true;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (nodeName == "audio" || nodeName === "video") {
            passed = false;
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 1276:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_live_captioned = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.media_live_captioned = {
    id: "media_live_captioned",
    context: "dom:embed, dom:object",
    refactor: {
        "RPT_Media_VideoObjectTrigger": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "media_live_captioned.html",
            "Manual_1": "media_live_captioned.html",
            "group": "media_live_captioned.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Verify captions are provided for live media (streaming video with audio)",
            "group": "Live media (streaming video with audio) should have captions for audio content"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.2.4"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = !legacy_1.RPTUtil.isVideoObjEmbedLink(ruleContext);
        if (passed)
            return null;
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 5424:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_track_available = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.media_track_available = {
    id: "media_track_available",
    context: "dom:a[href], dom:area[href], dom:applet, dom:embed, dom:object",
    refactor: {
        "RPT_Media_VideoReferenceTrigger": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "media_track_available.html",
            "Manual_1": "media_track_available.html",
            "group": "media_track_available.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Verify availability of a user-selectable audio track with description of visual content",
            "group": "Pre-recorded media should have an audio track that describes visual information"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.2.3", "1.2.5"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var passed = true;
        if (nodeName == "applet") {
            passed = false;
        }
        else {
            passed = !legacy_1.RPTUtil.isVideoObjEmbedLink(ruleContext);
        }
        if (passed)
            return null;
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 4248:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.meta_redirect_optional = void 0;
var fragment_1 = __webpack_require__(482);
var legacy_1 = __webpack_require__(8422);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.meta_redirect_optional = {
    id: "meta_redirect_optional",
    context: "dom:meta[http-equiv][content]",
    refactor: {
        "WCAG20_Meta_RedirectZero": {
            "pass": "pass",
            "fail": "fail",
            "fail_longrefresh": "fail_longrefresh"
        }
    },
    help: {
        "en-US": {
            "group": "meta_redirect_optional.html",
            "pass": "meta_redirect_optional.html",
            "fail": "meta_redirect_optional.html",
            "fail_longrefresh": "meta_redirect_optional.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Page should not automatically refresh without warning or option to turn it off or adjust the time limit",
            "pass": "Rule Passed",
            "fail": "Check page does not automatically refresh without warning or options",
            "fail_longrefresh": "Check page does not automatically refresh without warning or options"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.2.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: ["bisz58",
        {
            "bc659a": {
                "pass": "pass",
                "fail": "fail",
                "fail_longrefresh": "pass"
            }
        }
    ],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // JCH - NO OUT OF SCOPE hidden in context
        if (ruleContext.getAttribute("http-equiv").toLowerCase() !== 'refresh') {
            return null;
        }
        var content = ruleContext.getAttribute("content").toLowerCase();
        // Invalid content field
        if (!content.match(/^\d+$/) && !content.match(/^\d+;/)) {
            return null;
        }
        // Only check the first one since it takes priority
        if (legacy_1.RPTUtil.triggerOnce(fragment_1.FragmentUtil.getOwnerFragment(ruleContext), "meta_redirect_optional", false)) {
            return null;
        }
        var timeMatch = content.match(/^(\d+); +[^ ]/);
        if (!timeMatch || parseInt(timeMatch[1]) === 0) {
            return (0, IRule_1.RulePass)("pass");
        }
        else {
            var time = parseInt(timeMatch[1]);
            if (time < 72001) {
                return (0, IRule_1.RuleFail)("fail");
            }
            else {
                return (0, IRule_1.RuleFail)("fail_longrefresh");
            }
        }
    }
};


/***/ }),

/***/ 9526:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.meta_refresh_delay = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.meta_refresh_delay = {
    id: "meta_refresh_delay",
    context: "dom:meta[http-equiv][content]",
    refactor: {
        "RPT_Meta_Refresh": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "meta_refresh_delay.html",
            "Pass_0": "meta_refresh_delay.html",
            "Potential_1": "meta_refresh_delay.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Pages should not refresh automatically",
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify page is not being caused to refresh automatically",
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.2.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: ["bisz58", "bc659a"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (ruleContext.getAttribute("http-equiv").toLowerCase() !== 'refresh')
            return null;
        var content = ruleContext.getAttribute("content").toLowerCase();
        // Invalid content field
        if (!content.match(/^\d+$/) && !content.match(/^\d+;/)) {
            return null;
        }
        var fail = !content.match(/^\d+; +[^ ]/);
        return !fail ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9379:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.meta_viewport_zoomable = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.meta_viewport_zoomable = {
    id: "meta_viewport_zoomable",
    context: "dom:meta[name][content]",
    refactor: {
        "meta_viewport_zoom": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "meta_viewport_zoomable.html",
            "Pass_0": "meta_viewport_zoomable.html",
            "Potential_1": "meta_viewport_zoomable.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The 'meta[name=viewport]' should not prevent the browser zooming the content",
            "Pass_0": "The 'meta[name=viewport]' does not prevent the browser zooming the content",
            "Potential_1": "Confirm the 'meta[name=viewport]' with \"{0}\" can be zoomed by user"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.4.4"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        },
        {
            "id": ["IBM_Accessibility", "WCAG_2_1"],
            "num": ["1.4.10"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [{
            "b4f0c3": {
                "Pass_0": "pass",
                "Potential_1": "fail"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (ruleContext.getAttribute("name").toLowerCase() !== 'viewport')
            return null;
        var content = ruleContext.getAttribute("content").toLowerCase();
        // neither maximum-scale nor user-scalable (default yes)
        if (!content || content.trim() === '' || (!content.includes('maximum-scale') && !content.includes('user-scalable')))
            return null;
        var user_msg = null;
        var max_msg = null;
        var props = content.split(",");
        var user_scale_value = 'yes';
        var maximum_scale_value = '2.0';
        for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
            var prop = props_1[_i];
            var pieces = prop.trim().split('=');
            if (pieces.length < 2)
                continue;
            if (prop.includes('user-scalable')) {
                user_msg = prop;
                user_scale_value = pieces[1].trim();
                if (user_scale_value.startsWith("'") || user_scale_value.startsWith('"')) {
                    user_scale_value = user_scale_value.substring(1, user_scale_value.length - 1);
                }
            }
            else if (prop.includes('maximum-scale')) {
                max_msg = prop;
                maximum_scale_value = pieces[1].trim();
                if (maximum_scale_value.startsWith("'") || maximum_scale_value.startsWith('"')) {
                    maximum_scale_value = maximum_scale_value.substring(1, maximum_scale_value.length - 1).trim();
                }
            }
        }
        var value = Number(user_scale_value);
        if (!isNaN(value)) {
            if (value >= 1 || value <= -1)
                user_scale_value = 'yes';
        }
        var maximum_scale = 2.0;
        value = Number(maximum_scale_value);
        if (!isNaN(value)) {
            if (value < 0)
                maximum_scale = 2.0;
            else
                maximum_scale = value;
        }
        else {
            if (maximum_scale_value === 'yes')
                maximum_scale = 1.0;
            else
                maximum_scale = 0.1;
        }
        // user-scalable is not set to 'yes', ignore maximum_scale
        if (user_scale_value !== 'yes') {
            return (0, IRule_1.RulePotential)("Potential_1", [user_msg]);
        }
        // user-scalable is 'yes', but maximum_scale is too small
        if (maximum_scale < 2.0) {
            return (0, IRule_1.RulePotential)("Potential_1", [max_msg]);
        }
        return (0, IRule_1.RulePass)("Pass_0");
    }
};


/***/ }),

/***/ 5495:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.noembed_content_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.noembed_content_exists = {
    id: "noembed_content_exists",
    context: "dom:noembed",
    refactor: {
        "Valerie_Noembed_HasContent": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "noembed_content_exists.html",
            "Potential_1": "noembed_content_exists.html",
            "group": "noembed_content_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Add descriptive text to the <noembed> element",
            "group": "<noembed> elements should contain descriptive text"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = legacy_1.RPTUtil.hasInnerContentHidden(ruleContext);
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 7753:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.object_text_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var ARIAMapper_1 = __webpack_require__(4944);
var VisUtil_1 = __webpack_require__(8174);
exports.object_text_exists = {
    id: "object_text_exists",
    context: "dom:object",
    refactor: {
        "WCAG20_Object_HasText": {
            "pass": "pass",
            "fail_no_text_alternative": "fail_no_text_alternative"
        }
    },
    help: {
        "en-US": {
            "group": "object_text_exists.html",
            "pass": "object_text_exists.html",
            "fail_no_text_alternative": "object_text_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "<object> element must have a text alternative for the content rendered by the object",
            "pass": "<object> element has a text alternative",
            "fail_no_text_alternative": "An <object> element does not have a text alternative"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "8fc3b6",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        // Detect if this object is of type text, by checking the object type in the case it is text then do not trigger this rule
        if (ruleContext.hasAttribute("type") && (ruleContext.getAttribute("type")).indexOf("text") !== -1) {
            return null;
        }
        // ignore if an explicit role is specified: including 'presentation', 'none', 'application', 'document' or 'img'
        // this case will be covered in other rules
        var role = ruleContext.getAttribute("role");
        if (role) {
            return null;
        }
        // Per ACT, ignore embedded HTML files
        var data = ruleContext.getAttribute("data");
        var ext = data && typeof data === typeof "" ? data.substring(data.lastIndexOf(".")) : "";
        if (ext === ".html" || ext === ".htm") {
            return null;
        }
        var passed = ARIAMapper_1.ARIAMapper.computeName(ruleContext).trim().length > 0;
        if (passed) {
            return (0, IRule_1.RulePass)("pass");
        }
        else {
            return (0, IRule_1.RuleFail)("fail_no_text_alternative");
        }
    }
};


/***/ }),

/***/ 1252:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.page_title_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var ancestor_1 = __webpack_require__(9193);
exports.page_title_exists = {
    id: "page_title_exists",
    context: "dom:html",
    refactor: {
        "WCAG20_Doc_HasTitle": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
        }
    },
    help: {
        "en-US": {
            "group": "page_title_exists.html",
            "Pass_0": "page_title_exists.html",
            "Fail_1": "page_title_exists.html",
            "Fail_2": "page_title_exists.html",
            "Fail_3": "page_title_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The page should have a title that correctly identifies the subject of the page",
            "Pass_0": "Rule Passed",
            "Fail_1": "Missing <head> element so there can be no <title> element present",
            "Fail_2": "Missing <title> element in <head> element",
            "Fail_3": "The <title> element is empty (no innerHTML)"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [{
            "2779a5": {
                "Pass_0": "pass",
                "Fail_1": "pass",
                "Fail_2": "fail",
                "Fail_3": "fail"
            }
        }],
    run: function (context, options, contextHierarchies) {
        // This rule does not apply inside a presentational frame
        if (ancestor_1.AncestorUtil.isFrame(contextHierarchies)) {
            return null;
        }
        var ruleContext = context["dom"].node;
        // First, find the head element
        var findHead = ruleContext.firstChild;
        var findTitle = null;
        while (findHead != null) {
            if (findHead.nodeName.toLowerCase() == "head")
                break;
            findHead = findHead.nextSibling;
        }
        var possibleTitles = ruleContext.querySelectorAll("title");
        for (var idx = 0; idx < possibleTitles.length; ++idx) {
            if (!legacy_1.RPTUtil.getAncestor(possibleTitles[idx], ["svg"])) {
                findTitle = possibleTitles[idx];
                break;
            }
        }
        if (findHead === null) {
            if (!findTitle) {
                return (0, IRule_1.RuleFail)("Fail_1");
            }
        }
        if (findTitle === null) { // don't have title second PoF
            return (0, IRule_1.RuleFail)("Fail_2");
        }
        // if we get here we have <head> and <title>
        if (findTitle != null && legacy_1.RPTUtil.getInnerText(findTitle).trim().length > 0) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else { // <title> has no innerHTML third PoF
            return (0, IRule_1.RuleFail)("Fail_3");
        }
    }
};


/***/ }),

/***/ 3576:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.page_title_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.page_title_valid = {
    id: "page_title_valid",
    context: "dom:head dom:title",
    refactor: {
        "RPT_Title_Valid": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Potential_2": "Potential_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "page_title_valid.html",
            "Fail_1": "page_title_valid.html",
            "Potential_2": "page_title_valid.html",
            "group": "page_title_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Page <title> is empty",
            "Potential_2": "Verify that using the filename as the page <title> value is descriptive",
            "group": "Page <title> should be a descriptive title, rather than a filename"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var titleStr = legacy_1.RPTUtil.getInnerText(ruleContext).trim();
        // allow .com, .net and .org
        var titleStrLowercase = titleStr.toLowerCase();
        if (titleStrLowercase.includes(".com") || titleStrLowercase.includes(".net") || titleStrLowercase.includes(".org")) {
            return (0, IRule_1.RulePass)("Pass_0", [titleStr]);
        }
        if (titleStr.length === 0) {
            // This is covered by page_title_exists
            return null; //RuleFail("Fail_1");
        }
        else {
            var passed = !/^\S*\.[a-zA-Z]{1,4}(?!.)|^https?:\/\/\S*/i.test(titleStr);
            if (!passed) {
                return (0, IRule_1.RulePotential)("Potential_2");
            }
            else {
                return (0, IRule_1.RulePass)("Pass_0", [titleStr]);
            }
        }
    }
};


/***/ }),

/***/ 3617:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.script_focus_blur_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.script_focus_blur_review = {
    id: "script_focus_blur_review",
    context: "dom:*[onfocus]",
    refactor: {
        "WCAG20_Script_FocusBlurs": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "script_focus_blur_review.html",
            "Potential_1": "script_focus_blur_review.html",
            "group": "script_focus_blur_review.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify script does not remove focus from content that normally receives focus",
            "group": "Scripting must not remove focus from content that normally receives focus"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.7", "3.2.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = ruleContext.getAttribute("onfocus").indexOf(".blur(") == -1;
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 6110:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.script_onclick_avoid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.script_onclick_avoid = {
    id: "script_onclick_avoid",
    context: "dom:*[onclick]",
    dependencies: ["script_onclick_misuse"],
    refactor: {
        "RPT_Script_OnclickHTML2": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "script_onclick_avoid.html",
            "Potential_1": "script_onclick_avoid.html",
            "group": "script_onclick_avoid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that 'onclick' events are not used in script to emulate a link",
            "group": "Scripts should not be used to emulate links"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Don't trigger this for SVG element for now until a determination is made (by Rich)
        // to support SVG at a point when the SVG a11y spec is ready.
        if (legacy_1.RPTUtil.getAncestor(ruleContext, "svg")) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        // If there's an aria-role specified, don't trigger this.
        if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "role"))
            return (0, IRule_1.RulePass)("Pass_0");
        var nodeName = ruleContext.nodeName.toLowerCase();
        var passed = nodeName == "a" || nodeName == "area" || nodeName == "input";
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.script_onclick_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.script_onclick_misuse = {
    id: "script_onclick_misuse",
    context: "dom:*[onclick]",
    refactor: {
        "RPT_Script_OnclickHTML1": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "script_onclick_misuse.html",
            "Potential_1": "script_onclick_misuse.html",
            "group": "script_onclick_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Possible use of a script to emulate a link",
            "group": "Scripts should not be used to emulate links"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            failSubstring: {
                value: [".asp", ".aspx", ".cfm", ".cfml", ".cgi", ".htm", ".html", ".shtm",
                    ".shtml", ".php", ".pl", ".py", ".shtm", ".shtml", ".xhtml",
                    "location.href"],
                type: "[string]"
            }
        };
        var ruleContext = context["dom"].node;
        // If there's an aria-role specified, don't trigger this.
        var passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "role");
        // If this is an a or area, don't trigger if there's an href.
        var nodeName = ruleContext.nodeName.toLowerCase();
        passed = passed || ((nodeName == "a" || nodeName == "area") && legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "href"));
        // If the guards failed, check to see if they're looking at links
        if (!passed) {
            var failSubstring = validateParams.failSubstring.value;
            ;
            var onclick_1 = ruleContext.getAttribute("onclick").toLowerCase();
            passed = true;
            for (var i = 0; passed && i < failSubstring.length; ++i) {
                passed = onclick_1.indexOf(failSubstring[i]) == -1;
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 1922:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.script_select_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.script_select_review = {
    id: "script_select_review",
    context: "dom:select",
    refactor: {
        "WCAG20_Select_NoChangeAction": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "script_select_review.html",
            "Potential_1": "script_select_review.html",
            "group": "script_select_review.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that no change of context or action occurs when selection options in this component receive focus",
            "group": "No changes of context should occur when a selection value receives focus"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["3.2.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = !ruleContext.hasAttribute("onchange") && !ruleContext.hasAttribute("onfocus");
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 7906:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.select_options_grouped = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.select_options_grouped = {
    id: "select_options_grouped",
    context: "dom:select",
    refactor: {
        "WCAG20_Select_HasOptGroup": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "select_options_grouped.html",
            "Potential_1": "select_options_grouped.html",
            "group": "select_options_grouped.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Group of related options may need <optgroup>",
            "group": "Groups of related options within a selection list should be grouped with <optgroup>"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            paramNumOptions: {
                value: 10,
                type: "integer"
            }
        };
        var ruleContext = context["dom"].node;
        // Handle the cases where optgroup is hidden, which should trigger a violations
        // but in the case that Check hidden option is set then should not trigger a violation.
        var passed = legacy_1.RPTUtil.getChildByTagHidden(ruleContext, "optgroup", false, true).length > 0 ||
            legacy_1.RPTUtil.getChildByTagHidden(ruleContext, "option", false, true).length <=
                validateParams.paramNumOptions.value;
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5451:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skip_main_described = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8174);
exports.skip_main_described = {
    id: "skip_main_described",
    context: "dom:body",
    dependencies: ["skip_main_exists"],
    refactor: {
        "WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "skip_main_described.html",
            "Potential_1": "skip_main_described.html",
            "group": "skip_main_described.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that if this hyperlink skips content, the description communicates where it links to",
            "group": "The description of a hyperlink used to skip content must communicate where it links to"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            paramSkipText: {
                value: ["skip", "jump"],
                type: "[string]"
            }
        };
        var ruleContext = context["dom"].node;
        // Get the anchors on the page
        var doc = ruleContext.ownerDocument;
        // Check for landmarks first
        var passed;
        if ((0, CacheUtil_1.getCache)(ruleContext, "IBM_hasLandmarks_Implicit", null) === null) {
            (0, CacheUtil_1.setCache)(ruleContext, "IBM_hasLandmarks_Implicit", legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, ["application", "banner", "complementary", "contentinfo",
                "form", "main", "navigation", "search"
            ], true, true).length > 0);
        }
        passed = (0, CacheUtil_1.getCache)(ruleContext, "IBM_hasLandmarks_Implicit", false);
        if (!passed) { // No landmarks, check for skip links
            var links = doc.links;
            // Skip link should be the first one on the page with an href attribute (i.e., links[0])
            // also if the first link is hidden then we should also trigger a violation.
            if (links && links.length > 0 && VisUtil_1.VisUtil.isNodeVisible(links[0])) {
                var testText = legacy_1.RPTUtil.getInnerText(doc.links[0]).toLowerCase();
                for (var i = 0; !passed && i < validateParams.paramSkipText.value.length; ++i) {
                    passed = testText.indexOf(validateParams.paramSkipText.value[i]) != -1;
                }
            }
            else
                passed = false;
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 6349:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skip_main_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var ancestor_1 = __webpack_require__(9193);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8174);
exports.skip_main_exists = {
    id: "skip_main_exists",
    context: "dom:body",
    refactor: {
        "WCAG20_Body_FirstASkips_Native_Host_Sematics": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "skip_main_exists.html",
            "Fail_1": "skip_main_exists.html",
            "group": "skip_main_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The page does not provide a way to quickly navigate to the main content (ARIA \"main\" landmark or a skip link)",
            "group": "Pages must provide a way to skip directly to the main content"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        // This rule does not apply inside a presentational frame
        if (ancestor_1.AncestorUtil.isPresentationFrame(contextHierarchies)) {
            return null;
        }
        var ruleContext = context["dom"].node;
        // Get the anchors on the page
        var doc = ruleContext.ownerDocument;
        // Check for landmarks first
        var passed;
        if ((0, CacheUtil_1.getCache)(ruleContext, "IBM_hasLandmarks_Implicit", null) === null) {
            (0, CacheUtil_1.setCache)(ruleContext, "IBM_hasLandmarks_Implicit", legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, ["application", "banner", "complementary", "contentinfo",
                "form", "main", "navigation", "search"
            ], true, true).length > 0);
        }
        passed = (0, CacheUtil_1.getCache)(ruleContext, "IBM_hasLandmarks_Implicit", false);
        if (!passed) { // No landmarks, check for skip links
            var anchors = legacy_1.RPTUtil.getDocElementsByTag(ruleContext, "a");
            // Skip anchor should be the first one on the page with an href attribute
            var testAnchor = null;
            for (var i = 0; i < anchors.length; ++i) {
                if (anchors[i].hasAttribute("href") && VisUtil_1.VisUtil.isNodeVisible(anchors[i])) {
                    testAnchor = anchors[i];
                    break;
                }
            }
            // Pull out the target id
            var targetId = null;
            if (testAnchor != null) {
                var hrefStr = testAnchor.getAttribute("href");
                var idx = hrefStr.indexOf("#");
                if (idx != -1) {
                    targetId = hrefStr.substring(idx + 1);
                }
            }
            // Determine if there is an element id or named anchor on the page with this
            // target id.
            if (targetId != null) {
                passed = doc.getElementById(targetId) != null;
                for (var i = 0; !passed && i < anchors.length; ++i) {
                    if (!anchors[i].hasAttribute("href") &&
                        anchors[i].hasAttribute("name") &&
                        anchors[i].getAttribute("name") == targetId) {
                        passed = true;
                    }
                }
            }
        }
        //return new ValidationResult(passed, [ruleContext], '', '', []);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 5393:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_background_decorative = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.style_background_decorative = {
    id: "style_background_decorative",
    context: "dom:style, dom:*[style]",
    refactor: {
        "RPT_Style_BackgroundImage": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "style_background_decorative.html",
            "Potential_1": "style_background_decorative.html",
            "group": "style_background_decorative.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify the CSS background image does not convey important information",
            "group": "Images included by using CSS alone must not convey important information"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var passed = true;
        if (nodeName === "link" && ruleContext.hasAttribute("rel") &&
            ruleContext.getAttribute("rel").toLowerCase() === "stylesheet") {
            // External stylesheet - trigger
            passed = legacy_1.RPTUtil.triggerOnce(ruleContext, "style_background_decorative", false);
        }
        if (passed && nodeName === "style" || ruleContext.hasAttribute("style")) {
            var styleText = void 0;
            if (nodeName === "style")
                styleText = legacy_1.RPTUtil.getInnerText(ruleContext);
            else
                styleText = ruleContext.getAttribute("style");
            var bgMatches = styleText.match(/background:[^;]*/g);
            if (bgMatches !== null) {
                for (var i = 0; passed && i < bgMatches.length; ++i)
                    passed = bgMatches[i].indexOf("url(") === -1;
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9887:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_before_after_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CSSUtil_1 = __webpack_require__(1775);
/**
 * Description: Trigger if :before and :after are used in CSS (Internal and External) with content
 * Origin: WCAG 2.0 F87
 */
exports.style_before_after_review = {
    id: "style_before_after_review",
    context: "dom:style, dom:link",
    refactor: {
        "WCAG20_Style_BeforeAfter": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "style_before_after_review.html",
            "Pass_0": "style_before_after_review.html",
            "Potential_1": "style_before_after_review.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Do not use CSS '::before' and '::after' pseudo-elements to insert non-decorative content",
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify the '::before' and '::after' pseudo-elements do not insert non-decorative content"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "1.3.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = true;
        //check Internal styles        
        if (ruleContext.nodeName.toLowerCase() === "style") {
            var css = (0, CSSUtil_1.getCSSStyle)(ruleContext);
            for (var i = 0; passed && i < css.length; ++i) {
                // Guard against bad CSS
                if (css[i].selector) {
                    passed = (css[i].selector.indexOf(":before") === -1 && css[i].selector.indexOf(":after") === -1) ||
                        !("content" in css[i].values) || css[i].values["content"].trim().length === 0 || css[i].values["content"].trim() === "\"\""
                        || css[i].values["content"].trim() === "\'\'" || css[i].values["content"].trim() === "none" || css[i].values["content"].trim() === "attr(x)"
                        || css[i].values["content"].trim() === "attr(y)";
                }
            }
            // check special rules in the stylesheets
            if (passed) {
                for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                    var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                    if (sheet.ownerNode === ruleContext) {
                        try {
                            var styleRules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                            if (styleRules) {
                                for (var styleRuleIndex = 0; passed && styleRuleIndex < styleRules.length; styleRuleIndex++) {
                                    var styleRule = styleRules[styleRuleIndex];
                                    // check @media rules 
                                    //
                                    // The check 'if (styleRule instanceof CSSMediaRule)' doesn't work when run in Karma(but works in DAP) 
                                    // so let's access the type directly as a workaround
                                    var styleImportRule = void 0;
                                    if (styleRule.type && styleRule.type === CSSRule.MEDIA_RULE) {
                                        var styleMediaRule = styleRule;
                                        var mediaRules = styleMediaRule.cssRules;
                                        if (mediaRules) {
                                            for (var rIndex = 0; passed && rIndex < mediaRules.length; rIndex++) {
                                                var mRule = mediaRules[rIndex]; // selectorText not recognized
                                                if (mRule.selectorText !== null && mRule.selectorText !== undefined) {
                                                    var rule = mRule.selectorText.toLowerCase();
                                                    if (rule.indexOf(":before") !== -1 || rule.indexOf(":after") !== -1) {
                                                        var content = mRule.style['content'];
                                                        if (content && content.trim().length) {
                                                            if (content.trim() !== "\"\"" &&
                                                                content.trim() !== "\'\'" &&
                                                                content.trim() !== "none" &&
                                                                content.trim() !== "attr(x)" &&
                                                                content.trim() !== "attr(y)") {
                                                                passed = false;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    // check import rules
                                    else if (styleRule.type && styleRule.type === CSSRule.IMPORT_RULE && (styleImportRule = styleRule).styleSheet) {
                                        var rules = styleImportRule.styleSheet.cssRules ?
                                            styleImportRule.styleSheet.cssRules :
                                            styleImportRule.styleSheet.rules;
                                        if (rules) {
                                            for (var rIndex = 0; passed && rIndex < rules.length; rIndex++) {
                                                var importedRule = rules[rIndex];
                                                // check @media rules 
                                                if (importedRule.type && importedRule.type === CSSRule.MEDIA_RULE) {
                                                    var mediaRules = importedRule.cssRules;
                                                    if (mediaRules) {
                                                        for (var mIndex = 0; mIndex < mediaRules.length; mIndex++) {
                                                            var mRule = mediaRules[mIndex]; // selectorText not recognized
                                                            if (mRule.selectorText !== null && mRule.selectorText !== undefined) {
                                                                var rule = mRule.selectorText.toLowerCase();
                                                                if (rule.indexOf(":before") !== -1 || rule.indexOf(":after") !== -1) {
                                                                    var content = mRule.style['content'];
                                                                    if (content && content.trim().length) {
                                                                        if (content.trim() !== "\"\"" &&
                                                                            content.trim() !== "\'\'" &&
                                                                            content.trim() !== "none" &&
                                                                            content.trim() !== "attr(x)" &&
                                                                            content.trim() !== "attr(y)") {
                                                                            passed = false;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (importedRule.selectorText !== null && importedRule.selectorText !== undefined) {
                                                    var rule = importedRule.selectorText.toLowerCase();
                                                    //support both single colon (:) and double colon (::) pseudo                        
                                                    if (rule.indexOf(":before") !== -1 || rule.indexOf(":after") !== -1) {
                                                        var content = importedRule.style['content'];
                                                        if (content && content.trim().length) {
                                                            if (content.trim() !== "\"\"" &&
                                                                content.trim() !== "\'\'" &&
                                                                content.trim() !== "none" &&
                                                                content.trim() !== "attr(x)" &&
                                                                content.trim() !== "attr(y)") {
                                                                passed = false;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        catch (e) {
                            // Ignore css access issues
                        }
                    }
                }
            }
        }
        //check external styles 
        if (ruleContext.nodeName.toLowerCase() === "link" && ruleContext.hasAttribute("rel") &&
            ruleContext.getAttribute("rel").toLowerCase() === "stylesheet" &&
            ruleContext.hasAttribute("href") && ruleContext.getAttribute("href").trim().length !== 0) {
            for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                if (sheet && sheet.ownerNode === ruleContext) {
                    try {
                        var rules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                        if (rules) {
                            for (var rIndex = 0; passed && rIndex < rules.length; rIndex++) {
                                var ruleFromLink = rules[rIndex];
                                // check @media rules 
                                if (ruleFromLink.type && ruleFromLink.type === CSSRule.MEDIA_RULE) {
                                    var mediaRules = ruleFromLink.cssRules;
                                    if (mediaRules) {
                                        for (var mIndex = 0; passed && mIndex < mediaRules.length; mIndex++) {
                                            var mRule = mediaRules[mIndex];
                                            if (mRule.selectorText !== null && mRule.selectorText !== undefined) {
                                                var ruleSelTxt = mRule.selectorText.toLowerCase();
                                                if (ruleSelTxt.indexOf(":before") !== -1 || ruleSelTxt.indexOf(":after") !== -1) {
                                                    var content = mRule.style['content'];
                                                    if (content && content.trim().length) {
                                                        if (content.trim() !== "\"\"" &&
                                                            content.trim() !== "\'\'" &&
                                                            content.trim() !== "none" &&
                                                            content.trim() !== "attr(x)" &&
                                                            content.trim() !== "attr(y)") {
                                                            passed = false;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                else if (rules[rIndex].selectorText !== null && rules[rIndex].selectorText !== undefined) {
                                    var rule = rules[rIndex].selectorText.toLowerCase();
                                    //support both single colon (:) and double colon (::) pseudo                        
                                    if (rule.indexOf(":before") !== -1 || rule.indexOf(":after") !== -1) {
                                        var content = rules[rIndex].style['content'];
                                        if (content && content.trim().length) {
                                            if (content.trim() !== "\"\"" &&
                                                content.trim() !== "\'\'" &&
                                                content.trim() !== "none" &&
                                                content.trim() !== "attr(x)" &&
                                                content.trim() !== "attr(y)") {
                                                passed = false;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (e) {
                        // Ignore css access issues
                    }
                }
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5102:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_color_misuse = void 0;
var legacy_1 = __webpack_require__(8422);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CacheUtil_1 = __webpack_require__(7788);
exports.style_color_misuse = {
    id: "style_color_misuse",
    context: "dom:style, dom:*[style], dom:font[color], dom:link",
    refactor: {
        "RPT_Style_ColorSemantics1": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "style_color_misuse.html",
            "Pass_0": "style_color_misuse.html",
            "Potential_1": "style_color_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Combine color and descriptive markup to convey information",
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify color is not used as the only visual means of conveying information"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "1.4.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var styleText = "";
        if (nodeName === "style") {
            styleText = legacy_1.RPTUtil.getInnerText(ruleContext).toLowerCase();
            // check import
            for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                if (sheet && sheet.ownerNode === ruleContext) {
                    try {
                        var styleRules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                        for (var styleRuleIndex = 0; styleRuleIndex < styleRules.length; styleRuleIndex++) {
                            var styleRule = styleRules[styleRuleIndex];
                            var styleImportRule = void 0;
                            if (styleRule.type && styleRule.type === CSSRule.IMPORT_RULE && (styleImportRule = styleRule).styleSheet) {
                                var importRules = styleImportRule.styleSheet.cssRules ? styleImportRule.styleSheet.cssRules : styleImportRule.styleSheet.rules;
                                for (var rIndex = 0; rIndex < importRules.length; rIndex++) {
                                    var iRule = importRules[rIndex];
                                    styleText += iRule.cssText;
                                }
                            }
                        }
                    }
                    catch (e) {
                        // Silence css access issues
                    }
                }
            }
        }
        else if (ruleContext.hasAttribute("style")) {
            styleText = ruleContext.getAttribute("style").toLowerCase();
        }
        else if (nodeName === "link" && //check external styles
            ruleContext.hasAttribute("rel") &&
            ruleContext.getAttribute("rel").toLowerCase() === "stylesheet" &&
            ruleContext.hasAttribute("href") &&
            ruleContext.getAttribute("href").trim().length !== 0) {
            for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                if (sheet && sheet.ownerNode === ruleContext) {
                    try {
                        var rules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                        for (var rIndex = 0; rIndex < rules.length; rIndex++) {
                            styleText += rules[rIndex].cssText;
                        }
                    }
                    catch (e) {
                        // Silence css access issues
                    }
                }
            }
        }
        var passed = true;
        // Defect 1022: Find uses of 'color' and '*background*' only
        var isBgUsed = styleText.match(/\bbackground\b/i);
        var theColorStyleToCheck = styleText.replace(/-color/g, "");
        var isColorUsed = theColorStyleToCheck.match(/\bcolor\b/i);
        if (ruleContext.hasAttribute("color") || isColorUsed || isBgUsed) {
            var goodTagNames = {
                "em": "", "strong": "", "cite": "", "dfn": "",
                "code": "", "samp": "", "kbd": "", "var": "", "abbr": "", "acronym": ""
            };
            // Color used � are there semantics involved?
            passed = nodeName in goodTagNames ||
                legacy_1.RPTUtil.getAncestor(ruleContext, goodTagNames) !== null;
            if (!passed && ruleContext.hasChildNodes()) {
                var nw = new legacy_1.NodeWalker(ruleContext);
                while (!passed && nw.nextNode() && nw.node !== ruleContext) {
                    passed = nw.node.nodeName.toLowerCase() in goodTagNames;
                }
            }
        }
        // Trigger only once
        if (!passed) {
            var triggered = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "style_color_misuse", false);
            passed = triggered;
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "style_color_misuse", true);
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9977:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_focus_visible = void 0;
var legacy_1 = __webpack_require__(8422);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CSSUtil_1 = __webpack_require__(1775);
exports.style_focus_visible = {
    id: "style_focus_visible",
    context: "dom:*",
    refactor: {
        "RPT_Style_HinderFocus1": {
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "style_focus_visible.html",
            "Potential_1": "style_focus_visible.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The keyboard focus indicator must be highly visible when default border or outline is modified by CSS",
            "Potential_1": "Check the keyboard focus indicator is highly visible when using CSS declaration for 'border' or 'outline'"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "2.4.7",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            skipNodes: {
                value: ["table"],
                type: "[string]"
            },
            checkParams: {
                value: ["border", "border-width", "border-color", "border-style",
                    "outline", "outline-width", "outline-color", "outline-style"],
                type: "[string]"
            }
        };
        var ruleContext = context["dom"].node;
        if (!legacy_1.RPTUtil.isTabbable(ruleContext) || validateParams.skipNodes.value.includes(ruleContext.nodeName.toLowerCase())) {
            return null;
        }
        var arrStyles = [];
        arrStyles.push((0, CSSUtil_1.getDefinedStyles)(ruleContext));
        arrStyles.push((0, CSSUtil_1.getDefinedStyles)(ruleContext, ":focus"));
        arrStyles.push((0, CSSUtil_1.getDefinedStyles)(ruleContext, ":focus-visible"));
        arrStyles.push((0, CSSUtil_1.getDefinedStyles)(ruleContext, ":focus-within"));
        for (var _i = 0, arrStyles_1 = arrStyles; _i < arrStyles_1.length; _i++) {
            var st = arrStyles_1[_i];
            for (var _a = 0, _b = validateParams.checkParams.value; _a < _b.length; _a++) {
                var param = _b[_a];
                if (param in st) {
                    return (0, IRule_1.RulePotential)("Potential_1");
                }
            }
        }
        return null;
    }
};


/***/ }),

/***/ 8454:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_highcontrast_visible = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CacheUtil_1 = __webpack_require__(7788);
exports.style_highcontrast_visible = {
    id: "style_highcontrast_visible",
    context: "dom:style, dom:link, dom:*[style]",
    refactor: {
        "RPT_Style_Trigger2": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "style_highcontrast_visible.html",
            "Manual_1": "style_highcontrast_visible.html",
            "group": "style_highcontrast_visible.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Confirm Windows high contrast mode is supported when using CSS to include, position or alter non-decorative content",
            "group": "Windows high contrast mode must be supported when using CSS to include, position or alter non-decorative content"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        },
        {
            "id": ["WCAG_2_1", "WCAG_2_0"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (nodeName === "link" &&
            (!ruleContext.hasAttribute("rel") || ruleContext.getAttribute("rel").toLowerCase() !== "stylesheet"))
            return (0, IRule_1.RulePass)("Pass_0");
        if (nodeName !== "style" && nodeName !== "link" &&
            ruleContext.hasAttribute("style") && ruleContext.getAttribute("style").trim().length === 0)
            return (0, IRule_1.RulePass)("Pass_0");
        var triggered = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "style_highcontrast_visible", false);
        var passed = triggered;
        //        Packages.java.lang.System.out.println(triggered);
        (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "style_highcontrast_visible", true);
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 25:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_hover_persistent = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.style_hover_persistent = {
    id: "style_hover_persistent",
    context: "dom:style, dom:*[style], dom:*",
    help: {
        "en-US": {
            "Pass_0": "style_hover_persistent.html",
            "Pass_1": "style_hover_persistent.html",
            "Pass_2": "style_hover_persistent.html",
            "Potential_1": "style_hover_persistent.html",
            "Potential_2": "style_hover_persistent.html",
            "Potential_3": "style_hover_persistent.html",
            "group": "style_hover_persistent.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "the hover: pseudo-class is not used to display content",
            "Pass_1": "content displayed via the :hover pseudo-class is a direct child of the trigger element",
            "Pass_2": "content displayed via the :hover pseudo-class is the adjacent sibling of the trigger element",
            "Potential_1": "Confirm the pointer can be positioned over the displayed element, not just the trigger",
            "Potential_2": "Confirm the pointer can be positioned over all the information displayed on hover",
            "Potential_3": "Confirm the margin style attribute has not prevented the pointer from hovering over the displayed element, not just the trigger",
            "group": "The pointer should be able to move over content displayed on hover"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1"],
            "num": ["1.4.13"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var pass0 = false;
        var pass1 = false;
        var pass2 = false; // never happen
        var potential1 = false;
        var potential2 = false;
        var potential3 = false;
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var styleText = "";
        if (nodeName === "style") {
            // console.log("RULE RUN ******************");
            styleText = legacy_1.RPTUtil.getInnerText(ruleContext).toLowerCase();
            // check import
            // console.log("ruleContext.ownerDocument.styleSheets.length = "+ruleContext.ownerDocument.styleSheets.length);
            for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; ++sIndex) {
                var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                if (sheet && sheet.ownerNode === ruleContext) {
                    try {
                        var styleRules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                        // console.log("styleRules.length = "+styleRules.length);
                        for (var styleRuleIndex = 0; styleRuleIndex < styleRules.length; styleRuleIndex++) {
                            // console.log("**********");
                            // console.log("********** FOR LOOP styleRuleIndex = "+styleRuleIndex);
                            var foundHover = false;
                            var hoverElement = "";
                            var plusCombinator = false;
                            var tildeCombinator = false;
                            var afterCombinatorElement = "";
                            var afterCombinatorElementDisplay = false;
                            var afterCombinatorElementDisplayValue = false;
                            var afterCombinatorElementHover = false;
                            var supportingElement = false;
                            var supportingHover = false;
                            var supportingHoverElementDisplayProperty = false;
                            var supportingHoverElementDisplayValue = false;
                            var adjacentPlusSibling = false;
                            var adjacentTildeMultipleSibling = false;
                            var styleRule = styleRules[styleRuleIndex];
                            var ruleText = styleRules[styleRuleIndex].cssText;
                            // console.log("styleRules["+styleRuleIndex+"] = "+ruleText);
                            // 1. Check for :hover
                            if (ruleText.match(/:hover/g)) {
                                foundHover = true;
                                // console.log("1. found :hover = "+ foundHover);
                                // 2. Get hover element
                                hoverElement = ruleText.split(":")[0];
                                // console.log("2. found element that goes with :hover = "+hoverElement);
                            }
                            else {
                                // console.log("1. No hover on css element so skip this rule");
                                continue; // if no :hover skip this rule
                            }
                            // 3a. Check for css combinator +
                            // 4a. if so do we have an after combinator element
                            var plusTempStr = ruleText.substring(ruleText.indexOf("+") + 1);
                            plusTempStr = plusTempStr.trim();
                            if (ruleText.match(/:hover \+/g) || ruleText.match(/:hover\+/g)) {
                                plusCombinator = true;
                                // console.log("3a. Found plusCombinator = "+ plusCombinator);
                                afterCombinatorElement = plusTempStr.split(" ")[0];
                                // console.log("4a. Found plus afterCombinatorElement = "+afterCombinatorElement);
                            }
                            // 3b. Check for css combinator +
                            // 4b. if so do we have an after combinator element
                            if (ruleText.match(/:hover \~/g) || ruleText.match(/:hover\~/g)) {
                                // console.log("match = "+ruleText.match(":hover \~"));
                                tildeCombinator = true;
                                // console.log("3b. Found tildeCombinator = "+ tildeCombinator);
                                var plusTempStr_1 = ruleText.substring(ruleText.indexOf("~") + 1);
                                plusTempStr_1 = plusTempStr_1.trim();
                                afterCombinatorElement = plusTempStr_1.split(" ")[0];
                                // console.log("4b. Found tilde afterCombinatorElement = "+afterCombinatorElement);
                            }
                            if (!plusCombinator && !tildeCombinator) {
                                // NO plusCombinator or tildeCombinator so skip this rule
                                // console.log("NO plusCombinator or tildeCombinator so PASS");
                                // console.log("**** REPORT PASS 0 HERE");
                                return (0, IRule_1.RulePass)("Pass_0"); // JCH: should we have a N/A pass
                            }
                            // So now we have a css element with hover - element:hover so we have problems
                            // to check
                            // 5. Check if the after combinator element has display: property
                            // 6. Check if display property is not none
                            if (afterCombinatorElement) {
                                // get index of display:
                                // console.log("plusTempStr = "+plusTempStr);
                                var index = plusTempStr.indexOf("display:");
                                if (index) {
                                    afterCombinatorElementDisplay = true;
                                    // console.log("5. Found afterCombinatorElementDisplay = "+afterCombinatorElementDisplay);
                                    if (plusTempStr.slice(index + 8).trim().split(" ")[0] !== "none;") {
                                        afterCombinatorElementDisplayValue = true;
                                        // console.log("6. Found afterCombinatorElementDisplayValue not none = "+afterCombinatorElementDisplayValue);
                                    }
                                    else {
                                        // console.log("afterCombinatorElementDisplayValue === none");
                                        // console.log("**** PUT POTENTIAL 0 HERE");
                                        continue;
                                    }
                                }
                                else {
                                    // this is bad css so it won't happen
                                    // console.log("NO afterCombinatorElementDisplay so skip this rule");
                                    continue;
                                }
                            }
                            else {
                                // this is bad css so it won't happen
                                // console.log("NO afterCombinatorElement so skip this rule");
                                continue;
                            }
                            if (afterCombinatorElementDisplayValue)
                                if (sheet && sheet.ownerNode === ruleContext) {
                                    // console.log("**** At this point we have verified that we have a css element with a hover of the format span:hover + div { display: block; } with all the proper properties and values");
                                    // NOTE: At this point we have verified that we have a css element with a hover
                                    //       of the format span:hover + div { display: block; }
                                    //       with all the proper properties and values
                                    try {
                                        var styleRules2 = sheet.cssRules ? sheet.cssRules : sheet.rules;
                                        // console.log("styleRules2.length = "+styleRules2.length);
                                        for (var styleRuleIndex2 = 0; styleRuleIndex2 < styleRules2.length; styleRuleIndex2++) {
                                            // Check rule for afterCominatorElement:hover
                                            // If find afterCombinatorElement:hover see if rule has property display: value where
                                            // value != none
                                            // console.log("**********");
                                            // console.log("********** 2nd FOR styleRuleIndex2 = "+styleRuleIndex2);
                                            var ruleText2 = styleRules[styleRuleIndex2].cssText;
                                            // console.log("ruleText2 = ", ruleText2);
                                            // console.log("afterCombinatorElement = "+afterCombinatorElement);
                                            // Check all supporting elements for margin property
                                            // If find margin STOP and REPORT ERROR
                                            var regExString = afterCombinatorElement + " {";
                                            var trimRuleText2 = ruleText2.trim();
                                            var regIndex = trimRuleText2.indexOf(regExString);
                                            var afterCombinatorElementProperties = trimRuleText2.slice(regIndex).trim();
                                            //if (!afterCombinatorElementProperties.match(/margin/g)) {
                                            if (!trimRuleText2.match(/margin/g)) {
                                                // console.log("No margin problem so continue on...");
                                                // do we have a supporting element css definitions
                                                var supportingHoverElement = ruleText2.split(":")[0];
                                                supportingHoverElement = supportingHoverElement.split(" ")[0];
                                                // console.log("supportingHoverElement = "+supportingHoverElement);
                                                // console.log("afterCombinatorElement = "+afterCombinatorElement);
                                                // NEED TO CHECK FOR afterCominatorElement:hover in ONE STEP
                                                if (supportingHoverElement === afterCombinatorElement && ruleText2.match(/:hover/g)) {
                                                    // console.log("7. Found supporting hover element same as afterCombinatorElement")
                                                    // 7. Found supporting hover element same as afterCombinatorElement
                                                    supportingElement = true;
                                                    // does supporting element have hover
                                                    // console.log("8. Supporting element has hover also = "+ foundHover);
                                                    // 8. Supporting element has hover also
                                                    supportingHover = true;
                                                    var index = ruleText2.indexOf("display:");
                                                    // console.log("index = "+index);
                                                    if (index) {
                                                        // 9. Found supportingHoverElementDisplayProperty
                                                        supportingHoverElementDisplayProperty = true;
                                                        // console.log("9. Found supportingHoverElementDisplayProperty = "+supportingHoverElementDisplayProperty);
                                                        if (plusTempStr.slice(index + 8).trim().split(" ")[0] !== "none;") {
                                                            // 10. Found supportingHoverElementDisplayValue not none
                                                            supportingHoverElementDisplayValue = true;
                                                            // console.log("10. Found supportingHoverElementDisplayValue not none = "+supportingHoverElementDisplayValue);
                                                            // Get list of hover elements and next sibling for +
                                                            // For + there must be at least one ADJACENT sibling
                                                            if (hoverElement !== "" && plusCombinator) {
                                                                var hoverElementList = ruleContext.ownerDocument.getElementsByTagName(hoverElement.toUpperCase());
                                                                // console.log("hoverElementList.length = "+hoverElementList.length);
                                                                // console.log("hoverElementList[0].tagName = "+hoverElementList[0].tagName);
                                                                // Get adjacent sibling
                                                                // console.log("Adjacent sibling = "+hoverElementList[0].nextElementSibling.tagName);
                                                                // console.log("afterCombinatorElement.toUpperCase() = "+afterCombinatorElement.toUpperCase());
                                                                if (afterCombinatorElement.toUpperCase() === hoverElementList[0].nextElementSibling.tagName) {
                                                                    // console.log("11a. Hover with plus has adjacent sibling.")
                                                                    // 11a. Hover with plus has adjacent sibling.
                                                                    adjacentPlusSibling = true;
                                                                    // At this point we have verified a supporting afterCombinatorElement css rule that contains hover and display property that is not equal to none and has a hover element in the body with an adjacent sibling
                                                                    // console.log("**** REPORT PASS 1 HERE");
                                                                    pass0 = true;
                                                                    continue;
                                                                }
                                                            }
                                                            else if (plusCombinator) {
                                                                // console.log("11a. Main hover with + combinator has no adjacent sibling");
                                                                if (!potential1) {
                                                                    // console.log("**** PUT POTENTIAL 1 HERE");
                                                                    potential1 = true;
                                                                    break;
                                                                }
                                                                continue;
                                                            }
                                                            // Get list of hover elements and determine if there are 2 or more adjacent siblings for ~
                                                            // For ~ there must be at least one ADJACENT sibling
                                                            if (hoverElement !== "" && tildeCombinator) {
                                                                // console.log("hoverElement.toUpperCase() = "+hoverElement.toUpperCase());
                                                                var hoverElementList = ruleContext.ownerDocument.getElementsByTagName(hoverElement.toUpperCase());
                                                                // console.log("hoverElementList.length = "+hoverElementList.length);
                                                                // Check for two or more adjacent siblings
                                                                var siblings = [];
                                                                var sibling = hoverElementList[0].nextElementSibling;
                                                                do {
                                                                    // console.log("sibling.tagName = "+sibling.tagName);
                                                                    if (sibling.tagName === afterCombinatorElement.toUpperCase()) {
                                                                        siblings.push(sibling);
                                                                    }
                                                                    else {
                                                                        break;
                                                                    }
                                                                } while ((sibling = sibling.nextElementSibling));
                                                                var siblingCount = siblings.length;
                                                                // console.log("siblingCount = "+siblingCount);
                                                                // JCH TODO: what if sibling count 0
                                                                if (siblingCount === 1) {
                                                                    // console.log("11b. Hover with tilde and one adjacent sibling");
                                                                    adjacentTildeMultipleSibling = true;
                                                                    // console.log("**** REPORT PASS 2 HERE");
                                                                    return (0, IRule_1.RulePass)("Pass_2");
                                                                }
                                                                else if (siblingCount > 1) {
                                                                    // console.log("Main hover with ~ combinator has two or more siblings");
                                                                    if (!potential2) {
                                                                        // console.log("**** PUT POTENTIAL 2 HERE");
                                                                        return (0, IRule_1.RulePotential)("Potential_2");
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else if (plusCombinator) {
                                                            // supportingHoverElementDisplayValue
                                                            // if we make it to the last rule and supportingHoverElementDisplayValue is still false => potential1
                                                            if (styleRuleIndex2 === styleRules2.length - 1 && supportingHoverElementDisplayValue === false) {
                                                                // console.log("NO plus supportingHoverElementDisplayProperty");
                                                                // console.log("**** PUT POTENTIAL 1 HERE");
                                                                return (0, IRule_1.RulePotential)("Potential_1");
                                                            }
                                                            else {
                                                                continue;
                                                            }
                                                        }
                                                        else if (tildeCombinator) {
                                                            // if we make it to the last rule and supportingHoverElementDisplayValue is still false => potential2
                                                            if (styleRuleIndex2 === styleRules2.length - 1 && supportingHoverElementDisplayValue === false) {
                                                                // console.log("NO plus supportingHoverElementDisplayProperty");
                                                                // console.log("**** PUT POTENTIAL 2 HERE");
                                                                return (0, IRule_1.RulePotential)("Potential_1");
                                                            }
                                                            else {
                                                                continue;
                                                            }
                                                        }
                                                        // note at least one of the rules must have a display property
                                                    }
                                                    else if (plusCombinator) {
                                                        // if we make it to the last rule and supportingHoverElementDisplayProperty is still false => potential1
                                                        if (styleRuleIndex2 === styleRules2.length - 1 && supportingHoverElementDisplayProperty === false) {
                                                            // console.log("NO plus supportingHoverElementDisplayProperty");
                                                            // console.log("**** PUT POTENTIAL 1 HERE");
                                                            return (0, IRule_1.RulePotential)("Potential_1");
                                                        }
                                                        else {
                                                            continue;
                                                        }
                                                    }
                                                    else if (tildeCombinator) {
                                                        // if we make it to the last rule and supportingHoverElementDisplayProperty is still false => potential2
                                                        if (styleRuleIndex2 === styleRules2.length - 1 && supportingHoverElementDisplayProperty === false) {
                                                            // console.log("NO tilde supportingHoverElementDisplayProperty");
                                                            // console.log("**** PUT POTENTIAL 2 HERE");
                                                            return (0, IRule_1.RulePotential)("Potential_1");
                                                        }
                                                        else {
                                                            continue;
                                                        }
                                                    }
                                                    // note at least one of the rules must have a supportingElement:hover
                                                }
                                                else if (plusCombinator) {
                                                    // if we make it to the last rule and supportingElement is still false => potential1
                                                    // console.log("styleRuleIndex2 = "+styleRuleIndex2);
                                                    // console.log("styleRules2.length = "+styleRules2.length);
                                                    // console.log("supportingElement = "+supportingHover);
                                                    if (styleRuleIndex2 === styleRules2.length - 1 && supportingHover === false) {
                                                        // console.log("NO plus supportingElement:hover");
                                                        // console.log("**** PUT POTENTIAL 1 HERE");
                                                        return (0, IRule_1.RulePotential)("Potential_1");
                                                    }
                                                    else {
                                                        continue;
                                                    }
                                                }
                                                else if (tildeCombinator) {
                                                    // if we make it to the last rule and supportingElement is still false => potential2
                                                    // console.log("styleRuleIndex2 = "+styleRuleIndex2);
                                                    // console.log("styleRules2.length = "+styleRules2.length);
                                                    // console.log("supportingElement = "+supportingHover);
                                                    if (styleRuleIndex2 === styleRules2.length - 1 && supportingHover === false) {
                                                        // console.log("NO tilde supportingElement:hover");
                                                        // console.log("**** PUT POTENTIAL 2 HERE");
                                                        return (0, IRule_1.RulePotential)("Potential_2");
                                                    }
                                                    else {
                                                        continue;
                                                    }
                                                }
                                            }
                                            else {
                                                // console.log("There is a margin in the supporting element");
                                                if (!potential3) {
                                                    // console.log("**** PUT POTENTIAL 3 HERE");
                                                    potential3 = true;
                                                    return (0, IRule_1.RulePotential)("Potential_3");
                                                }
                                            }
                                        }
                                    }
                                    catch (e) {
                                        // Silence css access issues
                                    }
                                }
                        }
                    }
                    catch (e) {
                        // Silence css access issues
                    }
                }
            }
        }
        // console.log("----------------------");
        // console.log("pass0 = "+pass0);
        // console.log("pass1 = "+pass1);
        // console.log("pass2 = "+pass2);
        // console.log("potential1 = "+potential1);
        // console.log("potential2 = "+potential2);
        // console.log("potential3 = "+potential3);
        if (pass0)
            return (0, IRule_1.RulePass)("Pass_0");
        if (pass1)
            return (0, IRule_1.RulePass)("Pass_2");
        if (pass2)
            return (0, IRule_1.RulePass)("Pass_3");
        if (potential1)
            return (0, IRule_1.RulePotential)("Potential_1");
        if (potential2)
            return (0, IRule_1.RulePotential)("Potential_2");
        if (potential3)
            return (0, IRule_1.RulePotential)("Potential_3");
    }
};


/***/ }),

/***/ 2884:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_viewport_resizable = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
/**
 * Description: Trigger when viewport units are used for font size.
 * Origin: Various
 */
exports.style_viewport_resizable = {
    id: "style_viewport_resizable",
    context: "dom:link, dom:style, dom:*[style]",
    refactor: {
        "WCAG21_Style_Viewport": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "style_viewport_resizable.html",
            "Pass_0": "style_viewport_resizable.html",
            "Potential_1": "style_viewport_resizable.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Text must scale up to 200% without loss of content or functionality",
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that text sized using viewport units can be resized up to 200%"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "1.4.4",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = true;
        var thePattern = /\d+(vw|vh|vmin|vmax)/gi;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (nodeName === "style") {
            for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                if (sheet.ownerNode === ruleContext) {
                    try {
                        var styleRules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                        if (styleRules) {
                            for (var styleRuleIndex = 0; passed && styleRuleIndex < styleRules.length; styleRuleIndex++) {
                                var rule = styleRules[styleRuleIndex];
                                if (rule.type && rule.type === CSSRule.STYLE_RULE) {
                                    var styleRule = rule;
                                    if (styleRule.style['fontSize']) {
                                        var fontSize = styleRule.style['fontSize'].trim();
                                        var found = fontSize.match(thePattern);
                                        if (fontSize.length && found) {
                                            passed = false;
                                        }
                                    }
                                }
                                // check import rules
                                else if (rule.type && rule.type === CSSRule.IMPORT_RULE && rule.styleSheet) {
                                    var importRule = rule;
                                    var rules = importRule.styleSheet.cssRules ? importRule.styleSheet.cssRules : importRule.styleSheet.rules;
                                    if (rules) {
                                        for (var rIndex = 0; passed && rIndex < rules.length; rIndex++) {
                                            var importedRule = rules[rIndex];
                                            if (importedRule.type && importedRule.type === CSSRule.STYLE_RULE) {
                                                if (importedRule.style['fontSize']) {
                                                    var fontSize = importedRule.style['fontSize'].trim();
                                                    var found = fontSize.match(thePattern);
                                                    if (fontSize.length && found) {
                                                        passed = false;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (e) {
                        // Ignore css access issues
                    }
                }
            }
        }
        else if (nodeName === "link") {
            for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                if (sheet && sheet.ownerNode === ruleContext) {
                    try {
                        var rules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                        if (rules) {
                            for (var rIndex = 0; passed && rIndex < rules.length; rIndex++) {
                                var ruleFromLink = rules[rIndex];
                                // check rules 
                                if (ruleFromLink.type && ruleFromLink.type === CSSRule.STYLE_RULE) {
                                    if (ruleFromLink.style['fontSize']) {
                                        var fontSize = ruleFromLink.style['fontSize'].trim();
                                        var found = fontSize.match(thePattern);
                                        if (fontSize.length && found) {
                                            passed = false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (e) {
                        // Ignore css access issues
                    }
                }
            }
        }
        else {
            var styleValue = ruleContext.getAttribute('style');
            if (styleValue) {
                var stylePattern = /font-size:\s*\d+(vw|vh|vmin|vmax)/gi;
                var found = styleValue.match(stylePattern);
                if (found) {
                    passed = false;
                }
            }
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 7196:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_aria_descendants = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.table_aria_descendants = {
    id: "table_aria_descendants",
    context: "aria:table dom:tr[role], aria:table dom:th[role], aria:table dom:td[role], aria:grid dom:tr[role], aria:grid dom:th[role], aria:grid dom:td[role], aria:treegrid dom:tr[role], aria:treegrid dom:th[role], aria:treegrid dom:td[role]",
    help: {
        "en-US": {
            "group": "table_aria_descendants.html",
            "explicit_role": "table_aria_descendants.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Table structure elements cannot specify an explicit 'role' within table containers",
            "explicit_role": "An explicit ARIA 'role' is not valid for <{0}> element within a ARIA role '{1}' per the ARIA in HTML specification"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var parentRole = (0, CommonUtil_1.isTableDescendant)(contextHierarchies);
        // cache the result
        if (parentRole === null || parentRole.length === 0)
            return;
        return (0, IRule_1.RuleFail)("explicit_role", [context["dom"].node.nodeName.toLowerCase(), parentRole[0].role]);
    }
};


/***/ }),

/***/ 9965:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_caption_empty = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.table_caption_empty = {
    id: "table_caption_empty",
    context: "dom:caption",
    refactor: {
        "Valerie_Caption_HasContent": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_caption_empty.html",
            "Fail_1": "table_caption_empty.html",
            "group": "table_caption_empty.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The <table> element has an empty <caption> element",
            "group": "A <caption> element for a <table> element must contain descriptive text"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = legacy_1.RPTUtil.hasInnerContentHidden(ruleContext);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4468:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_caption_nested = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.table_caption_nested = {
    id: "table_caption_nested",
    context: "dom:caption",
    refactor: {
        "Valerie_Caption_InTable": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_caption_nested.html",
            "Fail_1": "table_caption_nested.html",
            "group": "table_caption_nested.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "<caption> element is not nested inside a <table> element",
            "group": "The <caption> element must be nested inside the associated <table> element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = legacy_1.RPTUtil.getAncestor(ruleContext, "table") != null;
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4451:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_headers_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.table_headers_exists = {
    id: "table_headers_exists",
    context: "dom:table",
    refactor: {
        "RPT_Table_DataHeadingsAria": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_headers_exists.html",
            "Fail_1": "table_headers_exists.html",
            "group": "table_headers_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Table has no headers identified",
            "group": "Data table must identify headers"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // If this is a layout table or there are no rows, the rule does not apply.
        var rows = ruleContext.rows;
        if (!legacy_1.RPTUtil.isDataTable(ruleContext) || rows == null || rows.length == 0)
            return null;
        var passed = legacy_1.RPTUtil.isTableHeaderInFirstRowOrColumn(ruleContext);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 6087:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_headers_ref_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var DOMUtil_1 = __webpack_require__(295);
var VisUtil_1 = __webpack_require__(8174);
var ARIAMapper_1 = __webpack_require__(4944);
exports.table_headers_ref_valid = {
    id: "table_headers_ref_valid",
    context: "dom:td[headers], dom:th[headers]",
    help: {
        "en-US": {
            "Pass_0": "table_headers_ref_valid.html",
            "Fail_1": "table_headers_ref_valid.html",
            "Fail_2": "table_headers_ref_valid.html",
            "Fail_3": "table_headers_ref_valid.html",
            "Fail_4": "table_headers_ref_valid.html",
            "group": "table_headers_ref_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The 'headers' attribute value \"{0}\" does not reference a valid 'id' in this document",
            "Fail_2": "The 'headers' attribute value \"{0}\" refers to itself",
            "Fail_3": "The 'headers' attribute value \"{0}\" does not refer to a cell in the same table",
            "Fail_4": "The 'headers' attribute value \"{0}\" does not refer to a cell indicated with <th> or a role of \"columnheader\" or \"rowheader\"",
            "group": "The 'headers' attribute should refer to a valid cell in the same table"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: ["a25f45"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var parentTable = legacy_1.RPTUtil.getAncestor(ruleContext, "table");
        var parentRole = ARIAMapper_1.ARIAMapper.nodeToRole(parentTable);
        // If this is a layout table or a simple table the rule does not apply.
        if (parentTable == null || !VisUtil_1.VisUtil.isNodeVisible(parentTable) || !["table", "grid"].includes(parentRole))
            return null;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var doc = ruleContext.ownerDocument;
        var value = ruleContext.getAttribute("headers");
        if (!value)
            return null;
        var ids = value.split(" ");
        var invalidHeaderValues = [];
        var sameNodeHeaderValues = [];
        var sameTableHeaderValues = [];
        var invalidElemHeaderValues = [];
        for (var i = 0; i < ids.length; i++) {
            var id = ids[i];
            if (id.trim() === '')
                continue;
            var elem = doc.getElementById(id);
            if (!elem)
                invalidHeaderValues.push(id);
            else if (DOMUtil_1.DOMUtil.sameNode(elem, ruleContext))
                sameNodeHeaderValues.push(id);
            else if (!DOMUtil_1.DOMUtil.isInSameTable(elem, ruleContext))
                sameTableHeaderValues.push(id);
            else {
                var elemName = elem.nodeName.toLowerCase();
                if (elemName !== 'th') {
                    var roles = legacy_1.RPTUtil.getRoles(elem, true);
                    if (!roles.includes('columnheader') && !roles.includes('rowheader'))
                        invalidElemHeaderValues.push(id);
                }
            }
        }
        var results = [];
        if (invalidHeaderValues.length != 0)
            results.push((0, IRule_1.RuleFail)("Fail_1", [invalidHeaderValues.toString()]));
        if (sameNodeHeaderValues.length != 0)
            results.push((0, IRule_1.RuleFail)("Fail_2", [sameNodeHeaderValues.toString()]));
        if (sameTableHeaderValues.length != 0)
            results.push((0, IRule_1.RuleFail)("Fail_3", [sameTableHeaderValues.toString()]));
        if (invalidElemHeaderValues.length != 0)
            results.push((0, IRule_1.RuleFail)("Fail_4", [invalidElemHeaderValues.toString()]));
        if (results.length == 0) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return results;
        }
    }
};


/***/ }),

/***/ 5864:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_headers_related = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
exports.table_headers_related = {
    id: "table_headers_related",
    context: "dom:td, dom:th",
    refactor: {
        "Valerie_Table_DataCellRelationships": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_headers_related.html",
            "Fail_1": "table_headers_related.html",
            "group": "table_headers_related.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Complex table does not have headers for each cell properly defined with 'header' or 'scope'",
            "group": "For a complex data table, all <th> and <td> elements must be related via 'header' or 'scope' attributes"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var parentTable = legacy_1.RPTUtil.getAncestor(ruleContext, "table");
        // If this is a layout table or a simple table the rule does not apply.
        if (parentTable == null || !legacy_1.RPTUtil.isComplexDataTable(parentTable))
            return null;
        // If this table hasn't been preprocessed, process it.
        if ((0, CacheUtil_1.getCache)(ruleContext, "table_headers_related", null) === null) {
            // Build a grid that's actually usable (rowspan and colspan elements are duplicated)
            // This builds a real 2d table array.
            var grid = [];
            for (var i = 0; i < parentTable.rows.length; ++i) {
                var row = parentTable.rows[i];
                if (!grid[i])
                    grid[i] = [];
                for (var j = 0; j < row.cells.length; ++j) {
                    var cell = row.cells[j];
                    (0, CacheUtil_1.setCache)(cell, "table_headers_related", i + ":" + j);
                    var width = parseInt(cell.getAttribute("colspan"));
                    if (!width)
                        width = 1;
                    var height = parseInt(cell.getAttribute("rowspan"));
                    if (!height)
                        height = 1;
                    var gX = 0;
                    while (grid[i][gX])
                        gX += 1;
                    for (var k = 0; k < height; ++k) {
                        if (!grid[i + k])
                            grid[i + k] = [];
                        for (var l = 0; l < width; ++l) {
                            grid[i + k][gX + l] = cell;
                        }
                    }
                }
            }
            // Iterate through the table grid and record headers that point to cells and
            // cells that are pointed to by headers
            var doc = ruleContext.ownerDocument;
            var lookup = {};
            var scopedCols = {};
            for (var i = 0; i < grid.length; ++i) {
                var rowScoped = false;
                for (var j = 0; j < grid[i].length; ++j) {
                    var gridCell = grid[i][j];
                    var gridNodeName = gridCell.nodeName.toLowerCase();
                    if (gridNodeName == "th") {
                        if (gridCell.getAttribute("scope") == "row") {
                            rowScoped = true;
                            // If there's an axis attribute, it must be referred to by headers,
                            // scope is not enough.
                            if (!legacy_1.RPTUtil.attributeNonEmpty(gridCell, "axis"))
                                lookup[(0, CacheUtil_1.getCache)(gridCell, "table_headers_related", null)] = true;
                        }
                        else if (gridCell.getAttribute("scope") == "col") {
                            scopedCols[j] = true;
                            // If there's an axis attribute, it must be referred to by headers,
                            // scope is not enough.
                            if (!legacy_1.RPTUtil.attributeNonEmpty(gridCell, "axis"))
                                lookup[(0, CacheUtil_1.getCache)(gridCell, "table_headers_related", null)] = true;
                        }
                        // Headers can refer to other headers
                        if (legacy_1.RPTUtil.attributeNonEmpty(gridCell, "headers")) {
                            var hdrs = gridCell.getAttribute("headers").split(" ");
                            for (var k = 0; k < hdrs.length; ++k) {
                                var headElem = doc.getElementById(hdrs[k].trim());
                                if (headElem && legacy_1.RPTUtil.getAncestor(headElem, "table") == parentTable) {
                                    lookup[(0, CacheUtil_1.getCache)(headElem, "table_headers_related", null)] = true;
                                }
                            }
                        }
                    }
                    else if (gridNodeName == "td") {
                        if (rowScoped || scopedCols[j]) {
                            lookup[(0, CacheUtil_1.getCache)(gridCell, "table_headers_related", null)] = true;
                        }
                        else if (legacy_1.RPTUtil.attributeNonEmpty(gridCell, "headers")) {
                            var hdrs = gridCell.getAttribute("headers").split(" ");
                            for (var k = 0; k < hdrs.length; ++k) {
                                var headElem = doc.getElementById(hdrs[k].trim());
                                if (headElem && legacy_1.RPTUtil.getAncestor(headElem, "table") == parentTable) {
                                    lookup[(0, CacheUtil_1.getCache)(gridCell, "table_headers_related", null)] = true;
                                    lookup[(0, CacheUtil_1.getCache)(headElem, "table_headers_related", null)] = true;
                                }
                            }
                        }
                    }
                }
            }
            (0, CacheUtil_1.setCache)(parentTable, "table_headers_related", lookup);
        }
        var rcInfo = (0, CacheUtil_1.getCache)(ruleContext, "table_headers_related", null);
        var tInfo = (0, CacheUtil_1.getCache)(parentTable, "table_headers_related", null);
        var passed = rcInfo !== null && tInfo !== null && rcInfo in tInfo;
        if (!passed && rcInfo === "0:0" &&
            legacy_1.RPTUtil.getInnerText(ruleContext).trim().length == 0) {
            // We don't test if it's the upper-left cell and it's empty
            return null;
        }
        // If the table has no th's, it may just be that this was supposed to be a layout
        // table, which introduces a lot of noise.  In that case, only trigger this error
        // once per table.
        if (!passed && parentTable.getElementsByTagName("th").length == 0) {
            if ((0, CacheUtil_1.getCache)(parentTable, "table_headers_related_TrigOnce", false) === true) {
                passed = true;
            }
            else {
                (0, CacheUtil_1.setCache)(parentTable, "table_headers_related_TrigOnce", true);
            }
        }
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4066:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_layout_linearized = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.table_layout_linearized = {
    id: "table_layout_linearized",
    context: "dom:table",
    refactor: {
        "RPT_Table_LayoutTrigger": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_layout_linearized.html",
            "Potential_1": "table_layout_linearized.html",
            "group": "table_layout_linearized.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify table is not being used to format text content in columns unless the table can be linearized",
            "group": "Avoid using tables to format text documents in columns unless the table can be linearized"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = !legacy_1.RPTUtil.isLayoutTable(ruleContext);
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 2841:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_scope_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.table_scope_valid = {
    id: "table_scope_valid",
    context: "dom:td[scope], dom:th[scope]",
    refactor: {
        "WCAG20_Table_Scope_Valid": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_scope_valid.html",
            "Fail_1": "table_scope_valid.html",
            "Fail_2": "table_scope_valid.html",
            "group": "table_scope_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Value provided is invalid for the 'scope' attribute",
            "Fail_2": "The 'scope' attribute should only be used on a <th> element",
            "group": "Value for 'scope' attribute must be \"row\", \"col\", \"rowgroup\", or \"colgroup\""
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (nodeName === 'td')
            return (0, IRule_1.RuleFail)("Fail_2");
        //only continue for 'th'
        var scopeVal = ruleContext.getAttribute("scope").trim().toLowerCase();
        var passed = /^(row|col|rowgroup|colgroup)$/.test(scopeVal);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 272:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_structure_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.table_structure_misuse = {
    id: "table_structure_misuse",
    context: "dom:table",
    refactor: {
        "WCAG20_Table_Structure": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_structure_misuse.html",
            "Fail_1": "table_structure_misuse.html",
            "group": "table_structure_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The <{0}> element with \"presentation\" role or \"none\" role has structural element(s) and/or attribute(s) '{1}'",
            "group": "Table elements with 'role=\"presentation\" or 'role=\"none\" should not have structural elements or attributes"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        // JCH - OUT OF SCOPE hidden in context
        if (legacy_1.RPTUtil.isDataTable(ruleContext))
            return null;
        if (legacy_1.RPTUtil.isNodeInGrid(ruleContext))
            return null;
        var errorNodes = [];
        if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "summary"))
            errorNodes.push(ruleContext);
        var captionElems = ruleContext.getElementsByTagName("caption");
        for (var i = 0; i < captionElems.length; ++i) {
            if (legacy_1.RPTUtil.getAncestor(captionElems[i], "table") == ruleContext) {
                // Check if the node should be skipped or not based on the Check Hidden Content setting and if the node isVisible or
                // not.
                if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(captionElems[i])) {
                    continue;
                }
                // Add the node to the errorNodes
                errorNodes.push(captionElems[i]);
                // Since we are not actually making use of theses errorNodes even though they are passed along with
                // ValidationResult, we do not need to keep looping over and getting every single violating node under
                // the rule context. This can be a future enhancenment where we actually make use of the error nodes that
                // are passed along. Adding this break to speed up performance at this point.
                break; // There is no point to keep adding the error nodes, stop after finding the first one
            }
        }
        var thNodes = ruleContext.getElementsByTagName("th");
        for (var i = 0; i < thNodes.length; ++i) {
            if (legacy_1.RPTUtil.getAncestor(thNodes[i], "table") == ruleContext) {
                // Check if the node should be skipped or not based on the Check Hidden Content setting and if the node isVisible or
                // not.
                if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(thNodes[i])) {
                    continue;
                }
                // Add the node to the errorNodes
                errorNodes.push(thNodes[i]);
                // Since we are not actually making use of theses errorNodes even though they are passed along with
                // ValidationResult, we do not need to keep looping over and getting every single violating node under
                // the rule context. This can be a future enhancenment where we actually make use of the error nodes that
                // are passed along. Adding this break to speed up performance at this point.
                break; // There is no point to keep adding the error nodes, stop after finding the first one
            }
        }
        var tdNodes = ruleContext.getElementsByTagName("td");
        for (var i = 0; i < tdNodes.length; ++i) {
            if ((tdNodes[i].hasAttribute("scope") || tdNodes[i].hasAttribute("headers")) &&
                legacy_1.RPTUtil.getAncestor(tdNodes[i], "table") == ruleContext) {
                // Check if the node should be skipped or not based on the Check Hidden Content setting and if the node isVisible or
                // not.
                if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(tdNodes[i])) {
                    continue;
                }
                // Add the node to the errorNodes
                errorNodes.push(tdNodes[i]);
                // Since we are not actually making use of theses errorNodes even though they are passed along with
                // ValidationResult, we do not need to keep looping over and getting every single violating node under
                // the rule context. This can be a future enhancenment where we actually make use of the error nodes that
                // are passed along. Adding this break to speed up performance at this point.
                break; // There is no point to keep adding the error nodes, stop after finding the first one
            }
        }
        // Get the node name for the rule context element in this case it will always be table
        var currentElementToken = ruleContext.nodeName.toLowerCase();
        // Construct a new array which will contan only the element tag for the violation elements
        var structuralElementTokens = new Array();
        // Construct a seen hash that will keep trask of all the elements that were already added to the token array, to make sure
        // we do not duplicate any of the elements. Duplicate element tags in the token message looks bad and confusing.
        var seen = {};
        // Loop through all the violating structural elements and extract the element tag to be used as a token
        for (var i = 0; i < errorNodes.length; i++) {
            // Get the node name (tag name) for the violating structural element
            var nodeName = errorNodes[i].nodeName.toLowerCase();
            // Only need to add the violating element once
            if (!seen.hasOwnProperty(nodeName)) {
                // Since we are adding the token as elements and attributes we need to handle
                // the summary attribute on the ruleContext (table). We only add summary once, same as
                // for elements to avoid duplication in the message. (Summary should not duplicate, but just in case)
                if (nodeName == "table" && !seen.hasOwnProperty["summary"]) {
                    // Mark this as a new attribute
                    seen["summary"] = true;
                    // Since this is a new violating element add it to the structural element tokens array
                    structuralElementTokens.push("summary");
                }
                else {
                    // Mark this as a new element
                    seen[nodeName] = true;
                    // Since this is a new violating element add it to the structural element tokens array
                    structuralElementTokens.push(nodeName);
                }
            }
        }
        // We need to take the array of structural elements and join them with a comma and a space to make grammatical correct in
        // the message.
        var structuralElementTokensStr = structuralElementTokens.join(", ");
        //return new ValidationResult(errorNodes.length == 0, errorNodes, '', '', [currentElementToken, structuralElementTokens]);
        if (errorNodes.length == 0) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1", [currentElementToken, structuralElementTokensStr]);
        }
    }
};


/***/ }),

/***/ 1348:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_summary_redundant = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var fragment_1 = __webpack_require__(482);
exports.table_summary_redundant = {
    id: "table_summary_redundant",
    context: "dom:table",
    refactor: {
        "WCAG20_Table_CapSummRedundant": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_summary_redundant.html",
            "Fail_1": "table_summary_redundant.html",
            "group": "table_summary_redundant.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The table summary duplicates the caption",
            "group": "The table summary must not duplicate the caption"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var pofId;
        var passed = true;
        var sumStr;
        if (ruleContext.hasAttribute("summary")) {
            pofId = 0;
            sumStr = ruleContext.getAttribute("summary").trim().toLowerCase();
        }
        else if (ruleContext.hasAttribute("aria-describedby")) {
            pofId = 1;
            var summaryNodeIds = ruleContext.getAttribute("aria-describedby").split(" ");
            var summaryNodeConcat = "";
            for (var i = 0; i < summaryNodeIds.length; i++) {
                var summaryNodeId = summaryNodeIds[i];
                if (summaryNodeId) {
                    var summaryNode = fragment_1.FragmentUtil.getById(ruleContext, summaryNodeId);
                    if (summaryNode) {
                        summaryNodeConcat += " " + legacy_1.RPTUtil.getInnerText(summaryNode).trim().toLowerCase();
                    }
                }
            }
            sumStr = summaryNodeConcat;
        }
        if (!sumStr) {
            return null;
        }
        else {
            var capElems = ruleContext.getElementsByTagName("caption");
            if (capElems.length === 0) {
                return null;
            }
            else if (sumStr.length > 0) {
                var capStr = legacy_1.RPTUtil.getInnerText(capElems[0]).trim().toLowerCase();
                if (!sumStr.includes(capStr)) {
                    return (0, IRule_1.RulePass)("Pass_0");
                }
                else {
                    return (0, IRule_1.RuleFail)("Fail_1");
                }
            }
        }
    }
};


/***/ }),

/***/ 5275:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text_block_heading = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var DOMWalker_1 = __webpack_require__(7440);
exports.text_block_heading = {
    id: "text_block_heading",
    context: "dom:p, dom:div, dom:br",
    refactor: {
        "RPT_Block_ShouldBeHeading": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "text_block_heading.html",
            "Potential_1": "text_block_heading.html",
            "group": "text_block_heading.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Check if this text should be marked up as a heading: {0}",
            "group": "Heading text must use a heading element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            numWords: {
                value: 10,
                type: "integer"
            }
        };
        var ruleContext = context["dom"].node;
        var numWords = validateParams.numWords.value;
        var wordsSeen = 0;
        var wordStr = [];
        var emphasizedText = false;
        var nw = new legacy_1.NodeWalker(ruleContext);
        var passed = false;
        while (!passed &&
            nw.nextNode() &&
            nw.node !== ruleContext &&
            nw.node !== DOMWalker_1.DOMWalker.parentNode(ruleContext) &&
            !["br", "div", "p"].includes(nw.node.nodeName.toLowerCase())) // Don't report twice
         {
            var nwName = nw.node.nodeName.toLowerCase();
            if ((nwName == "b" || nwName == "em" || nwName == "i" ||
                nwName == "strong" || nwName == "u" || nwName == "font") && !legacy_1.RPTUtil.shouldNodeBeSkippedHidden(nw.node)) {
                var nextStr = legacy_1.RPTUtil.getInnerText(nw.node);
                var wc = legacy_1.RPTUtil.wordCount(nextStr);
                if (wc > 0) {
                    wordStr.push(nextStr);
                    emphasizedText = true;
                    wordsSeen += wc;
                }
                passed = wordsSeen > numWords;
                // Skip this node because it's emphasized
                nw.bEndTag = true;
            }
            else {
                passed =
                    (nw.node.nodeType == 1 && legacy_1.RPTUtil.attributeNonEmpty(nw.node, "alt") &&
                        (nwName == "applet" || nwName == "embed" || nwName == "img" ||
                            (nwName === "input" && nw.elem().hasAttribute("type") && nw.elem().getAttribute("type") == "image")))
                        || (nwName === "#text" && nw.node.nodeValue.trim().length > 0)
                        // Give them the benefit of the doubt if there's a link
                        || (nwName === "a" && nw.elem().hasAttribute("href") && legacy_1.RPTUtil.attributeNonEmpty(nw.node, "href"));
            }
        }
        if (wordsSeen == 0)
            passed = true;
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RulePotential)("Potential_1", [wordStr.join(" ")]);
        }
    }
};


/***/ }),

/***/ 7900:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text_contrast_sufficient = void 0;
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
var ColorUtil_1 = __webpack_require__(9831);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
//import { setCache } from "../util/CacheUtil";
var CSSUtil_1 = __webpack_require__(1775);
exports.text_contrast_sufficient = {
    id: "text_contrast_sufficient",
    context: "dom:*",
    refactor: {
        "IBMA_Color_Contrast_WCAG2AA": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Potential_1": "Potential_same_color"
        },
        "IBMA_Color_Contrast_WCAG2AA_PV": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_graphic_background"
        }
    },
    help: {
        "en-US": {
            "group": "text_contrast_sufficient.html",
            "Pass_0": "text_contrast_sufficient.html",
            "Fail_1": "text_contrast_sufficient.html",
            "Potential_same_color": "text_contrast_sufficient.html",
            "Potential_graphic_background": "text_contrast_sufficient.html",
            "Potential_text_shadow": "text_contrast_sufficient.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The contrast ratio of text with its background must meet WCAG 2.1 AA requirements",
            "Pass_0": "Rule Passed",
            "Fail_1": "Text contrast of {0} with its background is less than the WCAG AA minimum requirements for text of size {1}px and weight of {2}",
            "Potential_same_color": "The foreground text and its background color are both detected as {3}. Verify the text meets the WCAG 2.1 AA requirements for minimum contrast",
            "Potential_graphic_background": "Verify the contrast ratio of the text against the lightest and the darkest colors of the background meets the WCAG 2.1 AA minimum requirements for text of size {1}px and weight of {2}",
            "Potential_text_shadow": "Verify the contrast ratio of the text with shadow meets the WCAG 2.1 AA minimum requirements for text of size {1}px and weight of {2}"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "WCAG_2_0", "WCAG_2_1"],
            num: "1.4.3",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: ['afw4f7'],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        // avoid diagnosing elements that are not visible
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) ||
            (VisUtil_1.VisUtil.hiddenByDefaultElements != null &&
                VisUtil_1.VisUtil.hiddenByDefaultElements != undefined &&
                VisUtil_1.VisUtil.hiddenByDefaultElements.indexOf(nodeName) > -1)) {
            return null;
        }
        //TODO ? should only consider native disabled, ignore aria-disabled
        //skip disabled element
        if (legacy_1.RPTUtil.isNodeDisabled(ruleContext))
            return null;
        //skip elements
        if (legacy_1.RPTUtil.getAncestor(ruleContext, ["svg", "script", "meta"]))
            return null;
        var doc = ruleContext.ownerDocument;
        if (!doc) {
            return null;
        }
        var win = doc.defaultView;
        if (!win) {
            return null;
        }
        // Ensure that this element has children with actual text.
        var childStr = legacy_1.RPTUtil.getNodeText(ruleContext);
        if (!legacy_1.RPTUtil.isShadowHostElement(ruleContext) || (legacy_1.RPTUtil.isShadowHostElement(ruleContext) && legacy_1.RPTUtil.getNodeText(ruleContext.shadowRoot) === '')) {
            if (childStr.trim().length == 0)
                return null;
            // ignore if the text does not convey anything in human language
            /**
             * (1) ignore non-alphanumeric or special characters in ASCI: ^(a-zA-Z\d\s)
             * (2) ignore non-printable unicode characters: \u0000-\u0008\u000B-\u001F\u007F-\u009F\u2000-\u200F\u2028-\u202F\u205F-\u206F\u3000\uFEFF
             *  see https://stackoverflow.com/questions/3770117/what-is-the-range-of-unicode-printable-characters
             * (3) for now not consider unicode special characters that are different in different languages
            */
            var regex = /[^(a-zA-Z\d\s)\u0000-\u0008\u000B-\u001F\u007F-\u009F\u2000-\u200F\u2028-\u202F\u205F-\u206F\u3000\uFEFF]+/g;
            var removed = childStr.trim().replace(regex, '');
            if (removed.trim().length === 0)
                return null;
        }
        var elem = ruleContext;
        // the child elements (rather than shadow root) of a shadow host is either re-assigned to the shadow slot if the slot exists 
        // or not displayed, so shouldn't be checked from the light DOM, rather it should be checked as reassginged slot element(s) in the shadow DOM.
        if (legacy_1.RPTUtil.isShadowHostElement(ruleContext)) {
            // if it's direct text of a shadow host
            if (ruleContext.shadowRoot) {
                for (var node = ruleContext.firstChild; node; node = node.nextSibling) {
                    if (node.nodeType == 3) {
                        //if multiple texts exist, only need to check one 
                        elem = node.assignedSlot;
                        break;
                    }
                }
            }
            if (elem === null)
                return;
        }
        var style = win.getComputedStyle(elem);
        // JCH clip INFO:
        //      The clip property lets you specify a rectangle to clip an absolutely positioned element. 
        //      The rectangle specified as four coordinates, all from the top-left corner of the element to be clipped.
        //      Property values:
        //          none        This is default. No clipping is done
        //          auto        No clipping will be done
        //          shape       The only valid value is: rect (top, right, bottom, left)
        //                      e.g., clip: rect(10px, 20px, 30px, 40px);
        //                      Note: the four values are in the same order as margin/padding
        //                      The rect values are positive pixel values, e.g., 10px, etc.
        //          margin-box  Uses the margin box as the reference box
        //          border-box  Uses the border box as the reference box
        //          padding-box Uses the padding box as the reference box
        //          content-box
        //          fill-box
        //          stroke-box
        //      NOTE: the CSS clip property is deprecated
        //      Also: clip only works if the element is absolutely positioned and can only do rectangles
        // check if element visible
        var visible = true;
        if (style.width !== "0" &&
            style.height !== "0" &&
            style.opacity !== "0" &&
            style.display !== 'none' &&
            style.visibility !== 'hidden' &&
            style.overflow !== 'hidden' &&
            // left and right work with all absolute units
            (style.left === "auto" || (style.position === 'absolute' && parseInt(style.left.replace(/[^0-9.+-]/, '')) > 0)) &&
            (style.left === "auto" || (style.position === 'absolute' && parseInt(style.top.replace(/[^0-9.+-]/, '')) > 0))) {
            visible = true;
            // console.log("element IS visible");
            // console.log("CHECK COLOR CONTRAST unless to small");
        }
        else {
            visible = false;
            // console.log("element NOT visible");
        }
        if (visible === false) {
            // console.log("DO NOT CHECK COLOR CONTRAST");
            return null;
        }
        var clipHeight = -1;
        if (style.clip !== "auto") {
            var clipString = style.clip.toString();
            if (clipString.includes("rect")) {
                var reBrackets = /\((.*)\)/g;
                var listOfText = [];
                var found = reBrackets.exec(clipString);
                var foundArr = found[1].split(', ');
                for (var i = 0; i < foundArr.length; i++) {
                    // console.log("foundArr[",i,"] = ",foundArr[i]);
                    listOfText.push(foundArr[i]);
                }
                ;
            }
            // console.log("listOfText = ",listOfText);
            clipHeight = parseInt(listOfText[0].replace(/px/g, '')) - parseInt(listOfText[2].replace(/px/g, ''));
            clipHeight = Math.abs(clipHeight);
        }
        // JCH clip-path INFO:
        //      Excellent article on clip-path: https://ishadeed.com/article/clip-path/
        //      clip-path is a totally different animal with many, many different variations
        //      The goal was for it to not be as limited as clip
        //      The syntax is more complicated (as it does more) and it is different from clip,
        //      e.g., the above clip rectangle would be clip-path: inset(10px 20px 30px 40px);
        //      Note: there are no commas
        //      Also, it can take single values to make all sides the same, or 2 values (vert/hori).
        //      or 3 values (top/hori/bottom)
        //      And percentages can works as well as px
        //      
        //      Although there are five different shapes: inset (term used for rectangle), circle,
        //          ellipse, polygon, path - we will only concern ourselves with inset
        //      There are 7 box values: margin-box, border-box, padding-box, content-box, fill-box, stroke-box, view-box
        //      Box and shape values may be combined: clip-path: padding-box circle(50px at 0 100px);
        //      NOTE: the box values are NOT intuitive, see: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes/From_box_values#margin-box
        //      
        //      So the key question is what amount of effort do we want to invest into clip-path
        // 
        // JCH don't do clip-path now 
        var clipPathHeight = -1;
        // if (style.clipPath !== "auto") {
        //     console.log("style.clipPath = ",style.clipPath);
        //     console.log("style.clipPath.toString = ",style.clipPath.toString());
        //     let clipString = style.clipPath.toString();
        //     if (clipString.includes("inset")) {
        //         var reBrackets = /\((.*)\)/g;
        //       var listOfText = [];
        //       var found = reBrackets.exec(clipString);
        //       var foundArr = found[1].split(' ');
        //       for (let i=0; i<foundArr.length; i++) {
        //         console.log("foundArr[",i,"] = ",foundArr[i]);
        //         listOfText.push(foundArr[i]);
        //       };
        //     }
        //     console.log("listOfText = ",listOfText);
        // clipPathHeight = parseInt(listOfText[0].replace(/px/g, '')) - parseInt(listOfText[2].replace(/px/g, ''));
        // clipPathHeight = Math.abs(clipHeight);
        // }
        // console.log("clipPathHeight = ", clipPathHeight);
        // if (style.position === "absolute" && style.clip === "rect(0px, 0px, 0px, 0px)" && style.overflow !== "visible") {
        // JCH arbitrarily use less that 7px for clipHeight
        if (style.position === "absolute" && clipHeight < 7 && clipHeight !== -1) {
            // console.log("DO NOT CHECK COLOR CONTRAST because too small");
            // Corner case where item is hidden (accessibility hiding technique)
            return null;
        }
        // First determine the color contrast ratio
        var colorCombo = ColorUtil_1.ColorUtil.ColorCombo(elem);
        if (colorCombo === null) {
            //some exception occurred, or not able to get color combo for some reason
            console.log("unable to get color combo for element: " + elem.nodeName);
            return;
        }
        var fg = colorCombo.fg;
        var bg = colorCombo.bg;
        var ratio = fg.contrastRatio(bg);
        var weight = (0, CSSUtil_1.getWeightNumber)(style.fontWeight);
        var size = (0, CSSUtil_1.getFontInPixels)(style.fontSize, elem);
        var isLargeScale = size >= 24 || size >= 18.6 && weight >= 700;
        var passed = ratio >= 4.5 || (ratio >= 3 && isLargeScale);
        var hasBackground = colorCombo.hasBGImage || colorCombo.hasGradient;
        var textShadow = colorCombo.textShadow;
        var isDisabled = legacy_1.RPTUtil.isNodeDisabled(elem);
        if (!isDisabled) {
            var control = legacy_1.RPTUtil.getControlOfLabel(elem);
            if (control) {
                isDisabled = legacy_1.RPTUtil.isNodeDisabled(control);
            }
        }
        if (!isDisabled && nodeName === 'label' && legacy_1.RPTUtil.isDisabledByFirstChildFormElement(elem)) {
            isDisabled = true;
        }
        if (!isDisabled && ruleContext.hasAttribute("id") && legacy_1.RPTUtil.isDisabledByReferringElement(elem)) {
            isDisabled = true;
        }
        /**setCache(ruleContext, "EXT_Color_Contrast_WCAG2AA", {
            "ratio": ratio,
            "isLargeScale": isLargeScale,
            "weight": weight,
            "size": size,
            "hasBackground": hasBackground,
            "isDisabled": isDisabled
        });*/
        // If element or parent is disabled, this rule does not apply (but may be 3:1 in future)
        if (!passed && isDisabled) {
            passed = true;
        }
        if (!passed) {
            if (hasBackground) {
                // fire potential since a text on an image or gradient may be still viewable, depending on the text location on the gradient or image
                return (0, IRule_1.RulePotential)("Potential_graphic_background", [ratio.toFixed(2), size, weight]);
                ;
            }
            else if (textShadow) {
                // fire potential since a text with shadow may be still viewable, depending on the shadow efffects
                return (0, IRule_1.RulePotential)("Potential_text_shadow", [ratio.toFixed(2), size, weight]);
                ;
            }
            else {
                if (fg.toHex() === bg.toHex()) {
                    return (0, IRule_1.RulePotential)("Potential_same_color", [ratio.toFixed(2), size, weight, fg.toHex(), bg.toHex(), colorCombo.hasBGImage, colorCombo.hasGradient]);
                }
                else {
                    return (0, IRule_1.RuleFail)("Fail_1", [ratio.toFixed(2), size, weight, fg.toHex(), bg.toHex(), colorCombo.hasBGImage, colorCombo.hasGradient]);
                }
            }
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0", [ratio.toFixed(2), size, weight, fg.toHex(), bg.toHex(), colorCombo.hasBGImage, colorCombo.hasGradient]);
        }
    }
};


/***/ }),

/***/ 5027:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text_quoted_correctly = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
exports.text_quoted_correctly = {
    id: "text_quoted_correctly",
    context: "dom:*",
    help: {
        "en-US": {
            "Pass_0": "text_quoted_correctly.html",
            "Potential_1": "text_quoted_correctly.html",
            "group": "text_quoted_correctly.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "If the following text is a quotation, mark it as a <q> or <blockquote> element: {0}",
            "group": "Quotations should be marked with <q> or <blockquote> elements"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // ignore the check if the node is hidden
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext))
            return null;
        // Don't trigger if the element is not in the body
        if (legacy_1.RPTUtil.getAncestor(ruleContext, ["body"]) === null)
            return null;
        var validateParams = {
            minWords: {
                value: 3,
                type: "integer"
            }
        };
        var minWords = validateParams.minWords.value;
        var passed = true;
        var walkNode = ruleContext.firstChild;
        var violatedtext = null;
        // ignore the check for the text of the following elements
        var ignored = ["blockquote", "q", "script", "style", "pre", "code", "ruby", "samp"];
        while (passed && walkNode) {
            // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
            // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
            // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
            // a node walk only on siblings so it would not get text nodes from other siblings at all.
            // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
            // if.
            if (walkNode.nodeName === "#text") {
                var txtVal = walkNode.nodeValue;
                // Do the regex tests first - should be fast
                // Remove apostrophe's
                txtVal = txtVal.replace(/(\S)'(\S)/g, "$1$2");
                var dblQuotes = txtVal.match(/("[^"]+")/g);
                var snglQuotes = txtVal.match(/('[^']+')/g);
                // Walk the parents - only continue testing if we found a quote, but
                // we're not already marked up
                // Also skip if we're in a script - there's lots of quotes used in scripts
                if ((dblQuotes !== null || snglQuotes !== null) &&
                    legacy_1.RPTUtil.getAncestor(walkNode, ignored) === null) {
                    if (dblQuotes != null) {
                        for (var i = 0; passed && i < dblQuotes.length; ++i)
                            passed = legacy_1.RPTUtil.wordCount(dblQuotes[i]) < minWords;
                    }
                    if (snglQuotes != null) {
                        for (var i = 0; passed && i < snglQuotes.length; ++i)
                            passed = legacy_1.RPTUtil.wordCount(snglQuotes[i]) < minWords;
                    }
                    // Remove any linefeed inside the quote
                    // violatedtext = txtVal.replace(new RegExp("\\r?\\n|\\r","g"),"");
                    if (dblQuotes === null) {
                        violatedtext = snglQuotes.join(", ").replace(new RegExp("\\r?\\n|\\r", "g"), "");
                    }
                    else if (snglQuotes === null) {
                        violatedtext = dblQuotes.join(", ").replace(new RegExp("\\r?\\n|\\r", "g"), "");
                    }
                    else {
                        violatedtext = dblQuotes.concat(snglQuotes).join(", ").replace(new RegExp("\\r?\\n|\\r", "g"), "");
                    }
                }
            }
            walkNode = walkNode.nextSibling;
        }
        //if the violatedtext is longer than 69 chars, only keep the first 32, the " ... ", and the last 32 chars 
        if (!passed && violatedtext.length && violatedtext.length > 69) {
            violatedtext = violatedtext.substring(0, 32) + " ... " + violatedtext.substring(violatedtext.length - 32);
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1", [violatedtext]);
    }
};


/***/ }),

/***/ 3496:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text_sensory_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8174);
exports.text_sensory_misuse = {
    id: "text_sensory_misuse",
    context: "dom:body, dom:body dom:*",
    refactor: {
        "RPT_Text_SensoryReference": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "text_sensory_misuse.html",
            "Potential_1": "text_sensory_misuse.html",
            "group": "text_sensory_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "If the word(s) '{0}' is part of instructions for using page content, check it is still understandable without this location or shape information",
            "group": "Instructions must be meaningful without shape or location words"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.3"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            sensoryText: {
                value: ["top-left", "top-right", "bottom-right", "bottom-left",
                    "round", "square", "shape", "rectangle", "triangle",
                    "right", "left", "above", "below", "top", "bottom",
                    "upper", "lower", "corner", "beside"],
                type: "[string]"
            }
        };
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.hiddenByDefaultElements.includes(ruleContext.nodeName.toLowerCase())) {
            return null;
        }
        // Extract the nodeName of the context node
        var nodeName = ruleContext.nodeName.toLowerCase();
        // In the case this is a style or link element, skip triggering rule as we do not want to scan
        // CSS for sensory words, as there can be CSS keys which contain theses sensory text that is matching.
        if (nodeName === "style" || nodeName === "link") {
            return (0, IRule_1.RulePass)(1);
        }
        var violatedtextArray = null;
        var violatedtext = null;
        var sensoryRegex = (0, CacheUtil_1.getCache)(ruleContext.ownerDocument, "text_sensory_misuse", null);
        if (sensoryRegex == null) {
            var sensoryText = validateParams.sensoryText.value;
            var regexStr = "(" + sensoryText[0];
            for (var j = 1; j < sensoryText.length; ++j)
                regexStr += "|" + sensoryText[j];
            regexStr += ")\\W";
            sensoryRegex = new RegExp(regexStr, "gi");
            (0, CacheUtil_1.setCache)(ruleContext.ownerDocument, "text_sensory_misuse", sensoryRegex);
        }
        var passed = true;
        var walkNode = ruleContext.firstChild;
        var _loop_1 = function () {
            // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
            // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
            // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
            // a node walk only on siblings so it would not get text nodes from other siblings at all.
            // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
            // if.
            if (walkNode.nodeName == "#text") {
                var txtVal = walkNode.nodeValue.trim();
                if (txtVal.length > 0) {
                    violatedtextArray = txtVal.match(sensoryRegex);
                    if (violatedtextArray != null) {
                        var hash_1 = {}, result_1 = [];
                        var exemptWords_1 = ["right-click", "left-click", "right-clicking", "right-clicks", "left-clicking", "left-clicks"];
                        // Note: split(/[\n\r ]+/) will spread the string into group of words using space,
                        // carriage return or linefeed as separators.
                        var counts = txtVal.split(/[\n\r ]+/).reduce(function (map, word) {
                            var sensoryTextArr = validateParams.sensoryText.value;
                            var wordWoTrailingPunc = word.replace(/[.?!:;()'",`\]]+$/, "");
                            var lcWordWoPunc = word.toLowerCase().replace(/[.?!:;()'",`\]]/g, "");
                            for (var counter = 0; counter < sensoryTextArr.length; counter++) {
                                var a = lcWordWoPunc.indexOf(sensoryTextArr[counter]);
                                var b = exemptWords_1.indexOf(lcWordWoPunc);
                                var sensoryWordLen = sensoryTextArr[counter].length;
                                var charFollowSensoryText = lcWordWoPunc.charAt(sensoryWordLen + a);
                                // If the word does not contains substring of sensoryTextArr[counter]
                                // proceed to the next loop iteration for next sensoryText.
                                if (a < 0) {
                                    continue;
                                }
                                var isPuncfollowing = ((charFollowSensoryText == '\-') ||
                                    (charFollowSensoryText == '\.') ||
                                    (charFollowSensoryText == '\?') || (charFollowSensoryText == '\!') ||
                                    (charFollowSensoryText == '\:') || (charFollowSensoryText == '\;') ||
                                    (charFollowSensoryText == '\(') || (charFollowSensoryText == '\)') ||
                                    (charFollowSensoryText == '\'') || (charFollowSensoryText == '\"') ||
                                    (charFollowSensoryText == '\,') || (charFollowSensoryText == '.\`') ||
                                    (charFollowSensoryText == '\\') || (charFollowSensoryText == '\]'));
                                var isPuncPreceding = false;
                                if (a > 0) {
                                    var charPrecedeSensoryText = lcWordWoPunc.charAt(a - 1);
                                    isPuncPreceding = ((charPrecedeSensoryText == '\-') ||
                                        (charPrecedeSensoryText == '\.') ||
                                        (charPrecedeSensoryText == '\?') || (charPrecedeSensoryText == '\!') ||
                                        (charPrecedeSensoryText == '\:') || (charPrecedeSensoryText == '\;') ||
                                        (charPrecedeSensoryText == '\(') || (charPrecedeSensoryText == '\)') ||
                                        (charPrecedeSensoryText == '\'') || (charPrecedeSensoryText == '\"') ||
                                        (charPrecedeSensoryText == '\,') || (charPrecedeSensoryText == '.\`') ||
                                        (charPrecedeSensoryText == '\\') || (charPrecedeSensoryText == '\]'));
                                }
                                if (((lcWordWoPunc.length == sensoryWordLen) || (isPuncfollowing == true) || (isPuncPreceding == true)) && (b < 0)) {
                                    passed = false;
                                    if (!hash_1.hasOwnProperty(wordWoTrailingPunc)) {
                                        hash_1[wordWoTrailingPunc] = true;
                                        result_1.push(wordWoTrailingPunc);
                                    }
                                    counter = sensoryTextArr.length;
                                }
                            }
                            map[wordWoTrailingPunc] = (map[wordWoTrailingPunc] || 0) + 1;
                            return map;
                        }, Object.create(null));
                        violatedtext = result_1.join(", ");
                    }
                }
            }
            walkNode = walkNode.nextSibling;
        };
        while (passed && walkNode) {
            _loop_1();
        }
        if (!passed) {
            // Don't trigger if we're not in the body or if we're in a script
            var checkAncestor = legacy_1.RPTUtil.getAncestor(ruleContext, ["body", "script"]);
            passed = (checkAncestor == null || checkAncestor.nodeName.toLowerCase() != "body");
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1", [violatedtext]);
    }
};


/***/ }),

/***/ 1131:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text_spacing_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var VisUtil_1 = __webpack_require__(8174);
var CSSUtil_1 = __webpack_require__(1775);
exports.text_spacing_valid = {
    id: "text_spacing_valid",
    context: "dom:*",
    help: {
        "en-US": {
            "pass": "text_spacing_valid.html",
            "group": "text_spacing_valid.html",
            "fail_letter_spacing_style": "text_spacing_valid.html",
            "fail_word_spacing_style": "text_spacing_valid.html",
            "fail_line_height_style": "text_spacing_valid.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "CSS !important is not used in inline style to control letter or word spacing or line height",
            "group": "CSS !important should not be used in inline style to control letter or word spacing or line height",
            "fail_letter_spacing_style": "CSS !important should not be used in inline ‘letter-spacing’ style",
            "fail_word_spacing_style": "CSS !important should not be used in inline ‘word-spacing’ style",
            "fail_line_height_style": "CSS !important should not be used in inline ‘line-height’ style"
        }
    },
    rulesets: [],
    // rulesets: [{
    //     "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
    //     "num": ["1.4.12"],
    //     "level": eRulePolicy.VIOLATION,
    //     "toolkitLevel": eToolkitLevel.LEVEL_THREE
    // }],
    act: ['9e45ec', '24afc2', '78fd32'],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || legacy_1.RPTUtil.isNodeDisabled(ruleContext))
            return null;
        //skip the check if the element is off screen
        var bounds = context["dom"].bounds;
        //in case the bounds not available
        if (!bounds)
            return null;
        if (bounds['top'] < 0 || bounds['left'] < 0)
            return null;
        //skip no-html element
        if (legacy_1.RPTUtil.getAncestor(ruleContext, "svg"))
            return null;
        // Ensure that this element has children with actual text.
        var childStr = "";
        var childNodes = ruleContext.childNodes;
        for (var i = 0; i < childNodes.length; ++i) {
            if (childNodes[i].nodeType == 3) {
                childStr += childNodes[i].nodeValue;
            }
        }
        if (childStr.trim().length == 0)
            return null;
        //font size always resolved to 'px'    
        var font_size_style = (0, CSSUtil_1.getComputedStyle)(ruleContext).getPropertyValue('font-size');
        var font_size = parseFloat(font_size_style);
        var styles = (0, CSSUtil_1.getDefinedStyles)(ruleContext);
        if (Object.keys(styles).length === 0)
            return null;
        //note that CSS unit is required for non-zero values, otherwise it's ignored
        var ret = [];
        // matched string: original style, the style value and unit
        var regex = /(-?[\d.]+)([a-z%]*)/;
        var word_style = styles['word-spacing'];
        if (word_style) {
            if (word_style.startsWith('inherit') || word_style.startsWith('unset')) {
                //get closet ancestor's word-spacing
                var ancestor = legacy_1.RPTUtil.getAncestorWithStyles(ruleContext.parentElement, { "word-spacing": ["*"] }, ['inherit', 'unset']);
                if (ancestor !== null) {
                    word_style = (0, CSSUtil_1.getDefinedStyles)(ancestor)['word-spacing'];
                }
                else if (word_style.startsWith('unset')) {
                    word_style = "initial";
                }
            }
            if (ruleContext.style.getPropertyPriority("word-spacing") === 'important') {
                word_style = word_style.substring(0, word_style.length - "!important".length - 1);
                // computed space is 0 for 'normal' or 'initial'.
                if (word_style === 'initial' || word_style === 'normal')
                    ret.push((0, IRule_1.RuleFail)("fail_word_spacing_style"));
                else {
                    var wordSpacing = parseFloat(word_style);
                    if (!isNaN(wordSpacing)) {
                        var parsed = word_style.trim().match(regex);
                        if (parsed[2] !== '' && parsed[1] !== 0) { //no zero value without unit which is considered as error, so implicable
                            var pixels = (0, CSSUtil_1.convertValue2Pixels)(parsed[2], parsed[1], ruleContext);
                            if (pixels != null && pixels / font_size < 0.16)
                                ret.push((0, IRule_1.RuleFail)("fail_word_spacing_style"));
                            else
                                ret.push((0, IRule_1.RulePass)("pass"));
                        }
                    }
                    else
                        ret.push((0, IRule_1.RulePass)("pass"));
                }
            }
            else
                ret.push((0, IRule_1.RulePass)("pass"));
        }
        var letter_style = styles['letter-spacing'];
        if (letter_style) {
            if (letter_style.startsWith('inherit') || letter_style.startsWith('unset')) {
                //get closet ancestor's word-spacing
                var ancestor = legacy_1.RPTUtil.getAncestorWithStyles(ruleContext.parentElement, { "letter-spacing": ["*"] }, ['inherit', 'unset']);
                if (ancestor !== null) {
                    letter_style = (0, CSSUtil_1.getDefinedStyles)(ancestor)['letter-spacing'];
                }
                else if (letter_style.startsWith('unset')) {
                    letter_style = "initial";
                }
            }
            if (ruleContext.style.getPropertyPriority("letter-spacing") === 'important') {
                letter_style = letter_style.substring(0, letter_style.length - "!important".length - 1);
                // computed space is 0 for 'normal' or 'initial'.
                if (letter_style === 'initial' || letter_style === 'normal')
                    ret.push((0, IRule_1.RuleFail)("fail_letter_spacing_style"));
                else {
                    var letterSpacing = parseFloat(letter_style);
                    if (!isNaN(letterSpacing)) {
                        var parsed = letter_style.trim().match(regex);
                        if (parsed[2] !== '' && parsed[1] !== 0) { //no zero value without unit which is considered as error, so implicable
                            var pixels = (0, CSSUtil_1.convertValue2Pixels)(parsed[2], parsed[1], ruleContext);
                            if (pixels != null && pixels / font_size < 0.12)
                                ret.push((0, IRule_1.RuleFail)("fail_letter_spacing_style"));
                            else
                                ret.push((0, IRule_1.RulePass)("pass"));
                        }
                    }
                    else
                        ret.push((0, IRule_1.RulePass)("pass"));
                }
            }
            else
                ret.push((0, IRule_1.RulePass)("pass"));
        }
        var line_style = styles['line-height'];
        var overflow = { "overflow": ['auto', 'scroll'], "overflow-x": ['auto', 'scroll'], "overflow-y": ['auto', 'scroll'] };
        if (line_style && legacy_1.RPTUtil.getAncestorWithStyles(ruleContext, overflow) === null) {
            if (line_style.startsWith('inherit') || line_style.startsWith('unset')) {
                //get closet ancestor's word-spacing
                var ancestor = legacy_1.RPTUtil.getAncestorWithStyles(ruleContext.parentElement, { "line-height": ["*"] }, ['inherit', 'unset']);
                if (ancestor !== null) {
                    line_style = (0, CSSUtil_1.getDefinedStyles)(ancestor)['line-height'];
                }
                else if (line_style.startsWith('unset')) {
                    line_style = "initial";
                }
            }
            if (ruleContext.style.getPropertyPriority("line-height") === 'important') {
                line_style = line_style.substring(0, line_style.length - "!important".length - 1);
                // computed space is 0 for 'normal' or 'initial'.
                if (line_style === 'initial' || line_style === 'normal')
                    ret.push((0, IRule_1.RuleFail)("fail_line_height_style"));
                else {
                    var lineHeight = parseFloat(line_style);
                    if (!isNaN(lineHeight)) {
                        var parsed = line_style.trim().match(regex);
                        if (parsed[2] === '') { //line-height are allowed unitless when the valie is multiple (or fraction) of the font size
                            if (parsed[1] < 1.5)
                                ret.push((0, IRule_1.RuleFail)("fail_line_height_style"));
                            else
                                ret.push((0, IRule_1.RulePass)("pass"));
                        }
                        else {
                            var pixels = (0, CSSUtil_1.convertValue2Pixels)(parsed[2], parsed[1], ruleContext);
                            if (pixels != null && pixels / font_size < 1.5)
                                ret.push((0, IRule_1.RuleFail)("fail_line_height_style"));
                            else
                                ret.push((0, IRule_1.RulePass)("pass"));
                        }
                    }
                    else
                        ret.push((0, IRule_1.RulePass)("pass"));
                }
            }
            else
                ret.push((0, IRule_1.RulePass)("pass"));
        }
        if (ret.length > 0)
            return ret;
        return null; //implicable or ignore
    }
};


/***/ }),

/***/ 8681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text_whitespace_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
exports.text_whitespace_valid = {
    id: "text_whitespace_valid",
    context: "dom:*",
    help: {
        "en-US": {
            "pass": "text_whitespace_valid.html",
            "potential_text": "text_whitespace_valid.html",
            "group": "text_whitespace_valid.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "potential_text": "Space characters should not be used to create space between the letters of a word",
            "group": "Space characters should not be used to control spacing within a word"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["1.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Don't trigger if we're not in the body or if we're in a script
        var checkAncestor = legacy_1.RPTUtil.getAncestor(ruleContext, ["body", "script", "code"]);
        if (checkAncestor == null || checkAncestor.nodeName.toLowerCase() != "body")
            return null;
        var passed = true;
        var walkNode = ruleContext.firstChild;
        while (passed && walkNode) {
            // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
            // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
            // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
            // a node walk only on siblings so it would not get text nodes from other siblings at all.
            // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
            // if.
            if (walkNode.nodeName == "#text") {
                var txtVal = walkNode.nodeValue;
                passed = !(/(^|\s)[a-zA-Z] [a-zA-Z] [a-zA-Z]($|\s)/.test(txtVal));
            }
            walkNode = walkNode.nextSibling;
        }
        if (passed)
            return (0, IRule_1.RulePass)("pass");
        return (0, IRule_1.RulePotential)("potential_text");
    }
};


/***/ }),

/***/ 4577:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.widget_tabbable_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var ARIAMapper_1 = __webpack_require__(4944);
var VisUtil_1 = __webpack_require__(8174);
exports.widget_tabbable_exists = {
    id: "widget_tabbable_exists",
    context: "aria:button,aria:link,aria:spinbutton,aria:tablist,aria:combobox,aria:listbox,aria:menu,aria:radiogroup,aria:tree,aria:checkbox,aria:slider,aria:spinbutton,aria:textbox,aria:scrollbar,aria:slider,aria:spinbutton",
    refactor: {
        "IBMA_Focus_Tabbable": {
            "pass": "pass",
            "fail_no_tabbable": "fail_no_tabbable"
        }
    },
    help: {
        "en-US": {
            "pass": "widget_tabbable_exists.html",
            "fail_no_tabbable": "widget_tabbable_exists.html",
            "group": "widget_tabbable_exists.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "fail_no_tabbable": "Component with \"{0}\" role does not have a tabbable element",
            "group": "Component must have at least one tabbable element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.3"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || legacy_1.RPTUtil.isNodeDisabled(ruleContext))
            return;
        //skip the check if the element should be a presentational child of an element
        if (legacy_1.RPTUtil.shouldBePresentationalChild(ruleContext))
            return;
        var nodeName = ruleContext.nodeName.toLowerCase();
        //ignore datalist element check since it will be part of a input element or hidden by default
        if (nodeName === 'datalist')
            return null;
        var role = ARIAMapper_1.ARIAMapper.nodeToRole(ruleContext);
        var count = 0;
        if (legacy_1.RPTUtil.isTabbable(ruleContext)) {
            ++count;
        }
        // If node has children, look for tab stops in the children
        // skip the count if the element requires presentational children only
        if (count < 1 && !legacy_1.RPTUtil.containsPresentationalChildrenOnly(ruleContext) && ruleContext.firstChild) {
            var nw = new legacy_1.NodeWalker(ruleContext);
            while (count < 1 && nw.nextNode() && nw.node != ruleContext) {
                if (nw.node.nodeType == 1 && !nw.bEndTag && legacy_1.RPTUtil.isTabbable(nw.node)) {
                    ++count;
                }
            }
        }
        var passed = count >= 1;
        return passed ? (0, IRule_1.RulePass)("pass") : (0, IRule_1.RulePotential)("fail_no_tabbable", [role]);
    }
};


/***/ }),

/***/ 8051:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.widget_tabbable_single = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var legacy_1 = __webpack_require__(8422);
var ARIAMapper_1 = __webpack_require__(4944);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8174);
exports.widget_tabbable_single = {
    id: "widget_tabbable_single",
    context: "aria:button,aria:link,aria:menuitem,aria:spinbutton,aria:tablist,aria:combobox,aria:listbox,aria:menu,aria:radiogroup,aria:tree,aria:checkbox,aria:option,aria:radio,aria:slider,aria:spinbutton,aria:textbox,aria:columnheader,aria:rowheader,aria:slider,aria:tab",
    refactor: {
        "IBMA_Focus_MultiTab": {
            "pass": "pass",
            "fail_multiple_tabbable": "fail_multiple_tabbable"
        }
    },
    help: {
        "en-US": {
            "pass": "widget_tabbable_single.html",
            "fail_multiple_tabbable": "widget_tabbable_single.html",
            "group": "widget_tabbable_single.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "fail_multiple_tabbable": "Component with \"{0}\" role has more than one tabbable element",
            "group": "Certain components must have no more than one tabbable element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0"],
            "num": ["2.4.3"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || legacy_1.RPTUtil.isNodeDisabled(ruleContext))
            return;
        //skip the check if the element should be a presentational child of an element
        if (legacy_1.RPTUtil.shouldBePresentationalChild(ruleContext))
            return;
        var role = ARIAMapper_1.ARIAMapper.nodeToRole(ruleContext);
        var count = 0;
        if (legacy_1.RPTUtil.isTabbable(ruleContext)) {
            ++count;
        }
        // If node has children, look for tab stops in the children
        //skip the count if the element requires presentational children only
        if (count < 2 && !legacy_1.RPTUtil.containsPresentationalChildrenOnly(ruleContext) && ruleContext.firstChild) {
            var nw = new legacy_1.NodeWalker(ruleContext);
            while (count < 2 && nw.nextNode() && nw.node != ruleContext) {
                if (nw.node.nodeType == 1 && !nw.bEndTag && legacy_1.RPTUtil.isTabbable(nw.node)) {
                    ++count;
                }
            }
        }
        var passed = count < 2;
        if (!passed)
            (0, CacheUtil_1.setCache)(ruleContext, "widget_tabbable_single", "fail_multiple_tabbable");
        return passed ? (0, IRule_1.RulePass)("pass") : (0, IRule_1.RulePotential)("fail_multiple_tabbable", [role]);
    }
};


/***/ }),

/***/ 1070:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.a11yRulesets = void 0;
var IEngine_1 = __webpack_require__(9077);
// This file comes from https://raw.githubusercontent.com/act-rules/act-tools/main/src/data/sc-urls.json
var SCURLs = __webpack_require__(4976);
var SCs = [];
for (var key in SCURLs) {
    SCs.push(SCURLs[key]);
}
var summaries = {
    "1.1.1": "All non-text content that is presented to the user has a text alternative that serves the equivalent purpose.",
    "1.2.1": "For prerecorded audio-only or video-only media, an alternative provides equivalent information.",
    "1.2.2": "Captions are provided for all prerecorded audio content in synchronized media.",
    "1.2.3": "An alternative for time-based media or audio description of the prerecorded video content is provided for synchronized media.",
    "1.2.4": "Captions are provided for all live audio content in synchronized media.",
    "1.2.5": "Audio description is provided for all prerecorded video content in synchronized media.",
    "1.3.1": "Information, structure, and relationships conveyed through presentation can be programmatically determined or are available in text.",
    "1.3.2": "When the sequence in which content is presented affects its meaning, a correct reading sequence can be programmatically determined.",
    "1.3.3": "Instructions provided for understanding and operating content do not rely solely on sensory characteristics of components such as shape, size, visual location, orientation, or sound.",
    "1.3.4": "Content does not restrict its view and operation to a single display orientation, such as portrait or landscape.",
    "1.3.5": "The purpose of each input field that collects information about the user can be programmatically determined when the field serves a common purpose.",
    "1.4.1": "Color is not used as the only visual means of conveying information, indicating an action, prompting a response, or distinguishing a visual element.",
    "1.4.2": "If any audio plays automatically for more than 3 seconds, either a mechanism is available to pause or stop the audio, or a mechanism is available to control audio volume independently from the overall system volume level.",
    "1.4.3": "The visual presentation of text and images of text has a contrast ratio of at least 4.5:1, with a 3:1 ratio for large-scale text.",
    "1.4.4": "Text can be resized without assistive technology up to 200 percent without loss of content or functionality.",
    "1.4.5": "If the technologies being used can achieve the visual presentation, text should not be used to convey information rather than images of text.",
    "1.4.10": "Content can reflow without loss of information or functionality, and without requiring scrolling in two dimensions.",
    "1.4.11": "The parts of graphical objects required to understand the content, and the visual information required to identify UI components and states, have a contrast ratio of at least 3:1 against adjacent colors.",
    "1.4.12": "No loss of content or functionality occurs when users change letter, word and paragraph spacing, as well as line height.",
    "1.4.13": "Where hover or focus actions cause additional content to become visible and hidden, the additional content is dismissable, hoverable and persistent.",
    "2.1.1": "All functionality of the content is operable through a keyboard interface without requiring specific timings for individual keystrokes.",
    "2.1.2": "If keyboard focus can be moved to a component using a keyboard interface, then focus can be moved away from that component using only a keyboard interface, and, if it requires more than unmodified arrow or tab keys or other standard exit methods, the user is advised of the method for moving focus away.",
    "2.1.4": "If a keyboard shortcut is implemented using only letter, punctuation, number or symbol characters, then the shortcut can be turned off, remapped or activated only on focus.",
    "2.2.1": "For each time limit that is set by the content, the user can turn off, adjust, or extend the limit.",
    "2.2.2": "For moving, blinking, scrolling, or auto-updating information, the user can pause, stop, hide or adjust the information.",
    "2.3.1": "Content does not contain anything that flashes more than three times in any one second period, or the flash is below the general flash and red flash thresholds.",
    "2.4.1": "A mechanism is available to bypass blocks of content that are repeated on multiple Web pages.",
    "2.4.2": "Web pages, non-web documents, and software have titles that describe topic or purpose.",
    "2.4.3": "If content can be navigated sequentially and the navigation sequences affect meaning or operation, focusable components receive focus in an order that preserves meaning and operability.",
    "2.4.4": "The purpose of each link can be determined from the link text alone or from the link text together with its programmatically determined link content.",
    "2.4.5": "More than one way is available to locate a Web page within a set of Web pages, except where the Web Page is the result of, or a step in, a process.",
    "2.4.6": "Headings and labels describe topic or purpose.",
    "2.4.7": "Any keyboard operable user interface has a mode of operation where the keyboard focus indicator is visible.",
    "2.5.1": "All functionality that uses multipoint or path-based gestures for operation can be operated with a single pointer without a path-based gesture.",
    "2.5.2": "For functionality that can be operated using a single pointer, completion of the function is on the up-event with an ability to abort, undo or reverse the outcome.",
    "2.5.3": "For user interface components with labels that include text or images of text, the accessible name contains the text that is presented visually.",
    "2.5.4": "Functionality that can be operated by motion can also be operated by user interface components, and the motion trigger can be disabled.",
    "3.1.1": "The default human language of Web pages, non-Web documents, or software can be programmatically determined.",
    "3.1.2": "The human language of each passage or phrase in the content can be programmatically determined.",
    "3.2.1": "When any component receives focus, it does not initiate a change of context.",
    "3.2.2": "Changing the setting of any user interface component does not automatically cause a change of context unless the user has been advised of the behavior before using the component.",
    "3.2.3": "Navigational mechanisms that are repeated on multiple Web pages within a set of Web pages occur in the same relative order each time they are repeated, unless a change is initiated by the user.",
    "3.2.4": "Components that have the same functionality within a set of Web pages are identified consistently.",
    "3.3.1": "If an input error is automatically detected, the item that is in error is identified and the error is described to the user in text.",
    "3.3.2": "Labels or instructions are provided when content requires user input.",
    "3.3.3": "If an input error is automatically detected and suggestions for correction are known, then the suggestions are provided to the user, unless it would jeopardize the security or purpose of the content.",
    "3.3.4": "For content that cause legal commitments or financial transactions for the user to occur, that modify or delete user-controllable data in data storage systems, or that submit user test responses, the user can reverse, correct, or confirm the action.",
    "4.1.1": "In content implemented using markup languages, elements have complete start and end tags, elements are nested according to their specifications, elements do not contain duplicate attributes, and any IDs are unique, except where the specifications allow these features.",
    "4.1.2": "For all user interface components (including, but not limited to: form elements, links and components generated by scripts), the name and role can be programmatically determined; states, properties, and values that can be set by the user can be programmatically set; and notification of changes to these items is available to user agents, including assistive technologies.",
    "4.1.3": "In content implemented using markup languages, status messages can be programmatically determined through role or properties such that they can be presented to the user by assistive technologies without receiving focus.",
};
exports.a11yRulesets = [
    // {
    //     id: "DEBUG",
    //     name: "DEBUG Rules",
    //     category: eRuleCategory.ACCESSIBILITY,
    //     description: "Rules for debugging",
    //     checkpoints: [{
    //         num: "1",
    //         name: "Debug CP 1",
    //         wcagLevel: "A",
    //         summary: "Rules for Debug"
    //     }]
    // },
    {
        id: "EXTENSIONS",
        name: "Extension Rules",
        category: IEngine_1.eRuleCategory.ACCESSIBILITY,
        description: "Rules for enabling the browser extensions",
        type: IEngine_1.eRulesetType.EXTENSION,
        checkpoints: [{
                num: "1",
                name: "Extension CP 1",
                wcagLevel: "A",
                summary: "Rules for Extension"
            }]
    },
    {
        id: "IBM_Accessibility",
        name: "IBM Accessibility",
        category: IEngine_1.eRuleCategory.ACCESSIBILITY,
        description: "Rules for WCAG 2.1 AA plus additional IBM checklist supplemental requirements.",
        // This ruleset has all 2.0 and 2.1 checkpoints that are A or AA
        checkpoints: SCs
            .filter(function (sc) { return (sc.level === "A" || sc.level === "AA") && (sc.wcagType === "2.0" || sc.wcagType === "2.1"); })
            .map(function (sc) { return ({
            num: sc.num,
            scId: sc.scId,
            name: sc.handle,
            wcagLevel: sc.level,
            summary: summaries[sc.num]
        }); })
    },
    {
        id: "WCAG_2_1",
        name: "WCAG 2.1 (A, AA)",
        category: IEngine_1.eRuleCategory.ACCESSIBILITY,
        description: "Rules for WCAG 2.1 AA. This is the current W3C recommendation. Content that conforms to WCAG 2.1 also conforms to WCAG 2.0.",
        // This ruleset has all 2.0 and 2.1 checkpoints that are A or AA
        checkpoints: SCs
            .filter(function (sc) { return (sc.level === "A" || sc.level === "AA") && (sc.wcagType === "2.0" || sc.wcagType === "2.1"); })
            .map(function (sc) { return ({
            num: sc.num,
            scId: sc.scId,
            name: sc.handle,
            wcagLevel: sc.level,
            summary: summaries[sc.num]
        }); })
    },
    {
        id: "WCAG_2_0",
        name: "WCAG 2.0 (A, AA)",
        category: IEngine_1.eRuleCategory.ACCESSIBILITY,
        description: "Rules for WCAG 2.0 AA. Referenced by US Section 508, but not the latest W3C recommendation.",
        // This ruleset has all 2.0 checkpoints that are A or AA
        checkpoints: SCs
            .filter(function (sc) { return (sc.level === "A" || sc.level === "AA") && (sc.wcagType === "2.0"); })
            .map(function (sc) { return ({
            num: sc.num,
            scId: sc.scId,
            name: sc.handle,
            wcagLevel: sc.level,
            summary: summaries[sc.num]
        }); })
    }
];


/***/ }),

/***/ 1775:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2022- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCSSStyle = exports.getFontInPixels = exports.getWeightNumber = exports.isMaterialIconFont = exports.convertValue2Pixels = exports.getPixelsFromStyle = exports.getRotationDegree = exports.getMediaOrientationTransform = exports.getDefinedStyles = exports.getComputedStyle = exports.selectorMatchesElem = void 0;
function selectorMatchesElem(element, selector) {
    try {
        if (selector.trim() === "")
            return false;
        if (typeof element.matches === 'function') {
            return element.matches(selector);
        }
        if (typeof element.matchesSelector === 'function') {
            return element.matchesSelector(selector);
        }
        // Native functions not there, fallback
        var matches = (element.document || element.ownerDocument).querySelectorAll(selector);
        var i = 0;
        while (i < matches.length && matches[i] !== element) {
            ++i;
        }
        return i < matches.length;
    }
    catch (err) {
        // Bad selector? Doesn't match then...
        return false;
    }
}
exports.selectorMatchesElem = selectorMatchesElem;
/**
 * Returns the style computed for this element
 * @param elem
 */
function getComputedStyle(elem, pseudoElt) {
    var doc = elem.ownerDocument;
    var win = doc.defaultView;
    return win.getComputedStyle(elem, pseudoElt);
}
exports.getComputedStyle = getComputedStyle;
/**
 * Returns the style defined for this element
 *
 * This differs from the computed style in that the computed style will return
 * styles defined by the user agent. This will only return styles defined by the
 * application
 * if rotation transform is used, the computed style returns the resolved matrix
 *  while the defined style return the transform function(s)
 * for example, for 'transform: rotate(2.5deg);', the computed style returns 'matrix(-0.0436194, 0.999048, -0.999048, -0.0436194, 0, 0)'
 *  and the defined style returns 'rotate(2.5deg)'
 *
 * @param {HTMLElement} elem
 * @param {string} [pseudoClass] If specified, will return values that are different
 * than when the pseudoClass does not match.
 */
function getDefinedStyles(elem, pseudoClass) {
    // console.log("Function: getDefinedStyles");
    var definedStyles = {};
    var definedStylePseudo = {};
    function fillStyle(maps, style) {
        for (var sIndex = 0; sIndex < style.length; ++sIndex) {
            if (style[sIndex] === "all" && style[style[sIndex]]) {
                for (var _i = 0, maps_1 = maps; _i < maps_1.length; _i++) {
                    var map = maps_1[_i];
                    for (var key in map) {
                        delete map[key];
                    }
                }
                break;
            }
            else {
                var key = style[sIndex];
                for (var _a = 0, maps_2 = maps; _a < maps_2.length; _a++) {
                    var map = maps_2[_a];
                    var priority = style.getPropertyPriority(key);
                    if (key in map && map[key].endsWith("!important")) {
                        if (priority === 'important' && !map[key].startsWith("inherit") && !map[key].startsWith("unset"))
                            //override !important only if it is also !important
                            map[key] = style[key] + " !important";
                        else
                            //don't override !important if it is not !important
                            continue;
                    }
                    else
                        //create/overide anyway
                        map[key] = style[key] + (priority === 'important' ? " !important" : "");
                }
            }
        }
    }
    // Iterate through all of the stylesheets and rules
    for (var ssIndex = 0; ssIndex < elem.ownerDocument.styleSheets.length; ++ssIndex) {
        var sheet = elem.ownerDocument.styleSheets[ssIndex];
        try {
            if (sheet && sheet.cssRules) {
                // console.log("Got sheet");
                for (var rIndex = 0; rIndex < sheet.cssRules.length; ++rIndex) {
                    // console.log("Got rule: ", sheet.cssRules[rIndex]);
                    var rule = sheet.cssRules[rIndex];
                    var fullRuleSelector = rule.selectorText;
                    if (fullRuleSelector) {
                        var pseudoMatch = fullRuleSelector.match(/^(.*)(:[a-zA-Z-]*)$/);
                        var hasPseudoClass = !!pseudoMatch;
                        var selMain = hasPseudoClass ? pseudoMatch[1] : fullRuleSelector;
                        var selPseudo = hasPseudoClass ? pseudoMatch[2] : "";
                        var samePseudoClass = selPseudo === pseudoClass;
                        if (pseudoClass && pseudoClass === ":focus") {
                            // If this element has focus, remove focus-within from parents
                            selMain = selMain.replace(/([ >][^+~ >]+):focus-within/g, "$1");
                        }
                        // Get styles of non-pseudo selectors
                        if (!hasPseudoClass && selectorMatchesElem(elem, selMain)) {
                            fillStyle([definedStyles, definedStylePseudo], rule.style);
                        }
                        if (samePseudoClass && selectorMatchesElem(elem, selMain)) {
                            fillStyle([definedStylePseudo], rule.style);
                        }
                    }
                }
            }
        }
        catch (err) {
            if (!err.toString().includes("Cannot access rules") && !err.toString().includes("SecurityError:")) {
                throw err;
            }
        }
    }
    // Handled the stylesheets, now handle the element defined styles
    fillStyle([definedStyles, definedStylePseudo], elem.style);
    /**
     * 'initial' sets the style back to default
    for (const key in definedStyles) {
        if (definedStyles[key] === "initial") {
            delete definedStyles[key];
        }
    }
    for (const key in definedStylePseudo) {
        if (definedStylePseudo[key] === "initial") {
            delete definedStylePseudo[key];
        }
    }
    */
    if (!pseudoClass) {
        // console.log("[DEBUG: CSSUtil::getDefinedStyles]", elem.nodeName, pseudoClass, JSON.stringify(definedStyles, null, 2));
        return definedStyles;
    }
    else {
        for (var key in definedStylePseudo) {
            if (definedStylePseudo[key] === definedStyles[key]) {
                delete definedStylePseudo[key];
            }
        }
        // console.log("[DEBUG: CSSUtil::getDefinedStyles]", elem.nodeName, pseudoClass, JSON.stringify(definedStylePseudo, null, 2));
        return definedStylePseudo;
    }
}
exports.getDefinedStyles = getDefinedStyles;
/**
 * Returns the media query defined for the document
 *
 *
 * @param {Document} doc
 */
function getMediaOrientationTransform(doc) {
    var orientationTransforms = {};
    // Iterate through all of the stylesheets and rules
    for (var ssIndex = 0; ssIndex < doc.styleSheets.length; ++ssIndex) {
        var sheet = doc.styleSheets[ssIndex];
        try {
            if (sheet && sheet.cssRules) {
                for (var rIndex = 0; rIndex < sheet.cssRules.length; ++rIndex) {
                    var sheetRule = sheet.cssRules[rIndex];
                    if (CSSRule.MEDIA_RULE === sheetRule.MEDIA_RULE) {
                        var rule = sheetRule;
                        if (rule && rule.media) {
                            var mediaList = rule.media;
                            for (var i = 0; i < mediaList.length; i++) {
                                var elem_transforms = orientationTransforms[mediaList.item(i).toLocaleLowerCase()];
                                if (!elem_transforms)
                                    elem_transforms = {};
                                var styleRules = rule.cssRules;
                                for (var i_1 = 0; i_1 < styleRules.length; ++i_1) {
                                    if (CSSRule.STYLE_RULE === styleRules[i_1].STYLE_RULE) {
                                        var styleRule = styleRules[i_1];
                                        var selector = styleRule.selectorText;
                                        if (selector) {
                                            var transforms = {};
                                            var styles = styleRule.style;
                                            for (var s = 0; s < styles.length; ++s) {
                                                var key = styles[s];
                                                if (key.toLocaleLowerCase() === "transform") {
                                                    if (key === "all" && styles[key]) {
                                                        delete transforms[key];
                                                        break;
                                                    }
                                                    else {
                                                        transforms[key] = styles[key];
                                                    }
                                                }
                                            }
                                            elem_transforms[selector] = transforms;
                                        }
                                    }
                                }
                                orientationTransforms[mediaList.item(i).toLocaleLowerCase()] = elem_transforms;
                            }
                        }
                    }
                }
            }
        }
        catch (err) {
            if (!err.toString().includes("Cannot access rules") && !err.toString().includes("SecurityError:")) {
                throw err;
            }
        }
    }
    return orientationTransforms;
}
exports.getMediaOrientationTransform = getMediaOrientationTransform;
/**
 * convert given rotation transform functions to the degree transformed.
 * If multiple functions are given, then the functions are applied linearly in the order.
 *   rotation_transform function example:  rotate(45deg), rotate(2turn), rotate(2rad), rotate3d(1, 1, 1, 45deg),
 *        rotate(2rad) rotate3d(1, 1, 1, 45deg)
 * @param rotation_transform
 */
function getRotationDegree(rotation_transform) {
    var degree = 0;
    try {
        if (!rotation_transform)
            return degree;
        // normalize the rotation_transform
        rotation_transform = rotation_transform.replaceAll(", ", ",");
        var transform_functions = rotation_transform.split(" ");
        for (var i = 0; i < transform_functions.length; i++) {
            var transform_function = transform_functions[i].trim();
            if (transform_function === '')
                continue;
            if (transform_function.startsWith("rotate3d")) {
                // example: rotate3d(1, 1, 1, 45deg);
                var left = transform_function.indexOf("(");
                var right = transform_function.indexOf(")");
                if (left !== -1 && right !== -1) {
                    var matrix = transform_function.substring(left + 1, right);
                    var values = void 0;
                    if (matrix)
                        values = matrix.split(",");
                    if (values && values.length === 4) {
                        var rotation = values[3];
                        if (!rotation)
                            continue;
                        rotation = rotation.trim();
                        if (rotation.endsWith("turn")) {
                            var num = rotation.substring(0, rotation.length - 4);
                            num = parseFloat(num);
                            if (!isNaN(num))
                                degree = num * 360;
                        }
                        else if (rotation.endsWith("rad")) {
                            var num = rotation.substring(0, rotation.length - 3);
                            num = parseFloat(num);
                            if (!isNaN(num))
                                degree = num * 180 / Math.PI;
                        }
                        else if (rotation.endsWith("deg")) {
                            var num = rotation.substring(0, rotation.length - 3);
                            num = parseFloat(num);
                            if (!isNaN(num))
                                degree += num;
                        }
                    }
                }
            }
            else if (transform_function.startsWith("rotate") || transform_function.startsWith("rotateZ")) {
                // example: rotate(45deg);
                var left = transform_function.indexOf("(");
                var right = transform_function.indexOf(")");
                if (left !== -1 && right !== -1) {
                    var rotation = transform_function.substring(left + 1, right);
                    if (!rotation)
                        continue;
                    rotation = rotation.trim();
                    if (rotation.endsWith("turn")) {
                        var num = rotation.substring(0, rotation.length - 4);
                        num = parseFloat(num);
                        if (!isNaN(num))
                            degree = num * 360;
                    }
                    else if (rotation.endsWith("rad")) {
                        var num = rotation.substring(0, rotation.length - 3);
                        num = parseFloat(num);
                        if (!isNaN(num))
                            degree = num * 180 / Math.PI;
                    }
                    else if (rotation.endsWith("deg")) {
                        var num = rotation.substring(0, rotation.length - 3);
                        num = parseFloat(num);
                        if (!isNaN(num))
                            degree += num;
                    }
                }
            }
            else if (transform_function.startsWith("matrix3d")) {
                // calculate the three Euler angles
                var left = transform_function.indexOf("(");
                var right = transform_function.indexOf(")");
                if (left !== -1 && right !== -1) {
                    var matrix = transform_function.substring(left + 1, right);
                    var values = null;
                    if (matrix)
                        values = matrix.split(",");
                    if (values !== null) {
                        var z_angle = Math.atan2(values[4], values[5]);
                        degree += Math.round(Math.round(z_angle * 180 / Math.PI));
                    }
                }
            }
            else if (transform_function.startsWith("matrix")) {
                // calculate the three Euler angles
                var left = transform_function.indexOf("(");
                var right = transform_function.indexOf(")");
                if (left !== -1 && right !== -1) {
                    var matrix = transform_function.substring(left + 1, right);
                    var values = null;
                    if (matrix)
                        values = matrix.split(",");
                    if (values !== null) {
                        var z_angle = Math.atan2(values[1], values[0]);
                        degree += Math.round(Math.round(z_angle * 180 / Math.PI));
                    }
                }
            }
        }
        while (degree >= 360)
            degree -= 360;
    }
    catch (err) {
        console.log("Cannot retrieve rotation degree: " + err);
        throw err;
    }
    return degree;
}
exports.getRotationDegree = getRotationDegree;
/**
 * Convert CSS style string values to pixels.
 *
 * @param value style value in string, such as 3rem, 230px etc.
 * @param target element.
 * @return value in pixels
 */
function getPixelsFromStyle(value, elem) {
    if (!value)
        return 0;
    var regex = /(-?[\d.]+)([a-z%]*)/;
    var parsed = value.trim().match(regex);
    if (parsed[2] === '' || parsed[1] === 0)
        //no zero value without unit which is considered as error, so implicable
        return 0;
    var pixels = convertValue2Pixels(parsed[2], parsed[1], elem);
    return pixels === null ? pixels : parseFloat(pixels);
}
exports.getPixelsFromStyle = getPixelsFromStyle;
/**
 * Convert absolute CSS numerical values to pixels.
 *
 * @param unitValue in string
 * @param target element.
 * @return value in pixels
 */
function convertValue2Pixels(unit, unitValue, elem) {
    if (unitValue == 0)
        return 0;
    var supportedUnits = {
        // absolute unit
        'px': function (value) { return value; },
        'cm': function (value) { return value * 37.8; },
        'mm': function (value) { return value * 3.78; },
        'q': function (value) { return value * 0.95; },
        'in': function (value) { return value * 96; },
        'pc': function (value) { return value * 16; },
        'pt': function (value) { return value * 1.33; },
        // relative unit
        'rem': function (value) { return value * parseFloat(getComputedStyle(elem.ownerDocument.documentElement).getPropertyValue('font-size')); },
        'em': function (value) { return value * parseFloat(getComputedStyle(elem).getPropertyValue('font-size')); },
        'vw': function (value) { return value / 100 * elem.ownerDocument.defaultView.innerWidth; },
        'vh': function (value) { return value / 100 * elem.ownerDocument.defaultView.innerHeight; },
        '%': function (value) { return value / 100 * parseFloat(getComputedStyle(elem).getPropertyValue('font-size')); }
    };
    if (unit in supportedUnits)
        return supportedUnits[unit](unitValue);
    return null;
}
exports.convertValue2Pixels = convertValue2Pixels;
/*
* Returns if the font for visible text of the element is defined by material icons
*
* @param {HTMLElement} elem
*/
function isMaterialIconFont(elem) {
    // TODO: check the existence material icons using fetch in node 18+
    // for now (node 16) just dertermine if the stylesheet for the 'Material Icons' exists statically. note that the loading of the font stylesheet occurs at run time.
    //list of known material icons and stylesheet link
    var known_icons = {
        'Material Icons': "https://fonts.googleapis.com/icon?family=Material+Icons"
    };
    var known_css_classes = {
        'material-icons': "https://fonts.googleapis.com/icon?family=Material+Icons"
    };
    // material icon font can be defined either by font-family: 'Material Icons' or by class="material-icons"
    var styles = getDefinedStyles(elem);
    var fontFamily = styles['font-family'];
    var found = false;
    // font-family specifies a prioritized list of one or more font family names 
    if (fontFamily && fontFamily.split(",")[0].replace(/['"]+/g, '').trim() in known_icons)
        found = true;
    if (!found) {
        var list = elem.classList;
        for (var css_class in known_css_classes) {
            if (list.contains(css_class)) {
                found = true;
                break;
            }
        }
    }
    if (!found)
        return false;
    var passed = false;
    // check if the stylesheet for the 'Material Icons' exists statically
    var sheets = elem.ownerDocument.styleSheets;
    for (var s = 0; s < sheets.length; s++) {
        if (sheets && sheets.length > 0 && Object.values(known_icons).indexOf(sheets[s].href) > -1) {
            passed = true;
            break;
        }
    }
    return passed;
}
exports.isMaterialIconFont = isMaterialIconFont;
function getWeightNumber(styleVal) {
    var map = {
        "light": 100,
        "bold": 700
    };
    var retVal = parseInt(styleVal);
    if (retVal)
        return retVal;
    if (styleVal in map)
        return map[styleVal];
    return 400;
}
exports.getWeightNumber = getWeightNumber;
function getFontInPixels(styleVal, elem) {
    var map = {
        "xx-small": 16,
        "x-small": 10,
        "small": 13,
        "medium": 16,
        "large": 18,
        "x-large": 24,
        "xx-large": 32
    };
    var value = parseFloat(styleVal);
    if (!value) {
        return map[styleVal];
    }
    var units = styleVal.substring(("" + value).length);
    /**
        if (units === "" || units === "px") return value;
        if (units === "em") return value * 16;
        if (units === "%") return value / 100 * 16;
        if (units === "pt") return value * 4 / 3;
        return Math.round(value);
    */
    return convertValue2Pixels(units, value, elem);
}
exports.getFontInPixels = getFontInPixels;
function getCSSStyle(element) {
    var styleText = "";
    if (element === null)
        return [];
    if (element.IBM_CSS_THB)
        return element.IBM_CSS_THB;
    var nodeName = element.nodeName.toLowerCase();
    if (nodeName === "style") {
        styleText = element.innerText;
        if (styleText === undefined || styleText.trim() === "")
            styleText = element.textContent;
    }
    else if (element.hasAttribute("style")) {
        styleText = element.getAttribute("style");
    }
    else
        return [];
    if (styleText === null || styleText.trim().length === 0)
        return [];
    //remove comment blocks
    var re = /(\/\*+(?:(?:(?:[^\*])+)|(?:[\*]+(?!\/)))[*]+\/)|\/\/.*/g;
    var subst = ' ';
    styleText = styleText.replace(re, subst);
    // Find all "key : val;" pairs with various whitespace inbetween
    var rKeyVals = /\s*([^:\s]+)\s*:\s*([^;$}]+)\s*(;|$)/g;
    // Find all "selector { csskeyvals } with various whitespace inbetween
    var rSelectors = /\s*([^{]*){([^}]*)}/g;
    if (styleText.indexOf("{") === -1) {
        var keyVals = {};
        var m = void 0;
        while ((m = rKeyVals.exec(styleText)) != null) {
            keyVals[m[1]] = m[2].trim().toLowerCase();
        }
        var retVal = [{
                selector: null,
                values: keyVals
            }];
        element.IBM_CSS_THB = retVal;
        return retVal;
    }
    else {
        var retVal = [];
        var m = void 0;
        var m2 = void 0;
        while ((m = rSelectors.exec(styleText)) != null) {
            var keyVals = {};
            var selKey = m[1];
            var selVal = m[2];
            while ((m2 = rKeyVals.exec(selVal)) != null) {
                keyVals[m2[1]] = m2[2].trim().toLowerCase();
            }
            retVal.push({
                selector: selKey,
                values: keyVals
            });
        }
        element.IBM_CSS_THB = retVal;
        return retVal;
    }
}
exports.getCSSStyle = getCSSStyle;


/***/ }),

/***/ 7788:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clearCaches = exports.setCache = exports.getCache = void 0;
var DOMWalker_1 = __webpack_require__(7440);
/* Return a pointer to the given global variable
     * with its initial value as given */
function getCache(cacheSpot, keyName, initValue) {
    var cacheObj = (cacheSpot.nodeType === 9 /* Node.DOCUMENT_NODE */ || cacheSpot.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? cacheSpot : cacheSpot;
    if (cacheObj.aceCache === undefined) {
        cacheObj.aceCache = {};
    }
    if (cacheObj.aceCache[keyName] === undefined) {
        cacheObj.aceCache[keyName] = initValue;
    }
    return cacheObj.aceCache[keyName];
}
exports.getCache = getCache;
function setCache(cacheSpot, globalName, value) {
    var cacheObj = (cacheSpot.nodeType === 9 /* Node.DOCUMENT_NODE */ || cacheSpot.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? cacheSpot : cacheSpot;
    if (cacheObj.aceCache === undefined) {
        cacheObj.aceCache = {};
    }
    cacheObj.aceCache[globalName] = value;
    return value;
}
exports.setCache = setCache;
function clearCaches(cacheRoot) {
    delete cacheRoot.ownerDocument.aceCache;
    var nw = new DOMWalker_1.DOMWalker(cacheRoot);
    do {
        delete nw.node.aceCache;
        nw.node.ownerDocument && delete nw.node.ownerDocument.aceCache;
    } while (nw.nextNode());
}
exports.clearCaches = clearCaches;


/***/ }),

/***/ 8137:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTableDescendant = exports.getConflictAriaAndHtmlAttributes = exports.getInvalidAriaAttributes = exports.getInvalidRoles = exports.areRolesDefined = void 0;
var legacy_1 = __webpack_require__(8422);
var ARIADefinitions_1 = __webpack_require__(8235);
/*
 * check if any explicit role specified for the element is a valid ARIA role
 * return: null if no explicit role is defined,
 *         true if the role(s) are defined in ARIA
 *         false if any role is not defined in ARIA
*/
function areRolesDefined(roles) {
    if (!roles || roles.length === 0)
        return null;
    var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
    for (var _i = 0, roles_1 = roles; _i < roles_1.length; _i++) {
        var role = roles_1[_i];
        if (!(role.toLowerCase() in designPatterns))
            return false;
    }
    return true;
}
exports.areRolesDefined = areRolesDefined;
/*
 * check if any explicit role specified for the element is a valid ARIA role
 * return: null if no explicit role is defined,
 *         true if the role(s) are defined in ARIA
 *         false if any role is not defined in ARIA
*/
function getInvalidRoles(ruleContext) {
    var domRoles = legacy_1.RPTUtil.getUserDefinedRoles(ruleContext);
    if (!domRoles || domRoles.length === 0)
        return null;
    // check the 'generic' role first
    if (domRoles && domRoles.includes('generic'))
        return ["generic"];
    // Failing roles
    var failRoleTokens = [];
    // Passing roles
    var passRoleTokens = [];
    var tagProperty = legacy_1.RPTUtil.getElementAriaProperty(ruleContext);
    var allowedRoles = legacy_1.RPTUtil.getAllowedAriaRoles(ruleContext, tagProperty);
    if (!allowedRoles && allowedRoles.length === 0)
        return domRoles;
    var invalidRoles = [];
    if (allowedRoles && allowedRoles.includes('any'))
        return [];
    for (var i = 0; i < domRoles.length; i++)
        if (!allowedRoles.includes(domRoles[i]) && !invalidRoles.includes(domRoles[i]))
            invalidRoles.push(domRoles[i]);
    return invalidRoles;
}
exports.getInvalidRoles = getInvalidRoles;
/*
 * this method first checks explicit roles, if no explicit role, it will check the implicit role
 * return: null if any explicit role is invalid,
 *         a list of invalid attributes
 *         empty list if all attributes are valid, or no aria attributes are specified
 */
function getInvalidAriaAttributes(ruleContext) {
    var roles = legacy_1.RPTUtil.getUserDefinedRoles(ruleContext);
    // the invalid role case: handled by Rpt_Aria_ValidRole. Ignore to avoid duplicated report
    // for mutiple roles, skip if any role is invalid
    var defined = areRolesDefined(roles);
    if (defined !== null && !defined)
        return null;
    var attrs = [];
    if (!roles || roles.length == 0)
        roles = legacy_1.RPTUtil.getImplicitRole(ruleContext);
    var aria_attrs = legacy_1.RPTUtil.getUserDefinedAriaAttributes(ruleContext);
    var tagProperty = legacy_1.RPTUtil.getElementAriaProperty(ruleContext);
    // Attributes allowed on this node
    var allowedAttributes = legacy_1.RPTUtil.getAllowedAriaAttributes(ruleContext, roles, tagProperty);
    if (aria_attrs) {
        for (var i = 0; i < aria_attrs.length; i++) {
            var attrName = aria_attrs[i].trim().toLowerCase();
            if (!allowedAttributes.includes(attrName) && !attrs.includes(attrName))
                attrs.push(attrName);
        }
    }
    return attrs;
}
exports.getInvalidAriaAttributes = getInvalidAriaAttributes;
/*
 * get conflict Aria and Html attributes
 * return: a list of Aria and Html attribute pairs that are conflict
*/
function getConflictAriaAndHtmlAttributes(elem) {
    var ariaAttrs = legacy_1.RPTUtil.getUserDefinedAriaAttributeNameValuePairs(elem);
    var htmlAttrs = legacy_1.RPTUtil.getUserDefinedHtmlAttributeNameValuePairs(elem);
    var ret = [];
    if (ariaAttrs && ariaAttrs.length > 0 && htmlAttrs && htmlAttrs.length > 0) {
        var _loop_1 = function (i) {
            var examinedHtmlAtrNames = legacy_1.RPTUtil.getConflictOrOverlappingHtmlAttribute(ariaAttrs[i], htmlAttrs, 'conflict');
            if (examinedHtmlAtrNames === null)
                return "continue";
            examinedHtmlAtrNames.forEach(function (item) {
                if (item['result'] === 'Failed') //failed
                    ret.push({ 'ariaAttr': ariaAttrs[i]['name'], 'htmlAttr': item['attr'] });
            });
        };
        for (var i = 0; i < ariaAttrs.length; i++) {
            _loop_1(i);
        }
    }
    return ret;
}
exports.getConflictAriaAndHtmlAttributes = getConflictAriaAndHtmlAttributes;
/*
 * get conflict Aria and Html attributes
 * return: a list of Aria and Html attribute pairs that are conflict
*/
function isTableDescendant(contextHierarchies) {
    if (!contextHierarchies)
        return null;
    return contextHierarchies["aria"].filter(function (hier) { return ["table", "grid", "treegrid"].includes(hier.role); });
}
exports.isTableDescendant = isTableDescendant;


/***/ }),

/***/ 4976:
/***/ ((module) => {

module.exports = JSON.parse('{"1.1.1":{"num":"1.1.1","url":"https://www.w3.org/TR/WCAG21/#non-text-content","scId":"WCAG2:non-text-content","scAltId":["text-equiv-all"],"test":"WCAG2:text-equiv-all","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#non-text-content","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/non-text-content.html","handle":"Non-text Content","level":"A","wcagType":"2.0"},"1.2.1":{"num":"1.2.1","url":"https://www.w3.org/TR/WCAG21/#audio-only-and-video-only-prerecorded","scId":"WCAG2:audio-only-and-video-only-prerecorded","scAltId":["media-equiv-av-only-alt"],"test":"WCAG2:media-equiv-av-only-alt","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#audio-only-and-video-only-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/audio-only-and-video-only-prerecorded.html","handle":"Audio-only and Video-only (Prerecorded)","level":"A","wcagType":"2.0"},"1.2.2":{"num":"1.2.2","url":"https://www.w3.org/TR/WCAG21/#captions-prerecorded","scId":"WCAG2:captions-prerecorded","scAltId":["media-equiv-captions"],"test":"WCAG2:media-equiv-captions","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#captions-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/captions-prerecorded.html","handle":"Captions (Prerecorded)","level":"A","wcagType":"2.0"},"1.2.3":{"num":"1.2.3","url":"https://www.w3.org/TR/WCAG21/#audio-description-or-media-alternative-prerecorded","scId":"WCAG2:audio-description-or-media-alternative-prerecorded","scAltId":["media-equiv-audio-desc"],"test":"WCAG2:media-equiv-audio-desc","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#audio-description-or-media-alternative-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/audio-description-or-media-alternative-prerecorded.html","handle":"Audio Description or Media Alternative (Prerecorded)","level":"A","wcagType":"2.0"},"1.2.4":{"num":"1.2.4","url":"https://www.w3.org/TR/WCAG21/#captions-live","scId":"WCAG2:captions-live","scAltId":["media-equiv-real-time-captions"],"test":"WCAG2:media-equiv-real-time-captions","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#captions-live","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/captions-live.html","handle":"Captions (Live)","level":"AA","wcagType":"2.0"},"1.2.5":{"num":"1.2.5","url":"https://www.w3.org/TR/WCAG21/#audio-description-prerecorded","scId":"WCAG2:audio-description-prerecorded","scAltId":["media-equiv-audio-desc-only"],"test":"WCAG2:media-equiv-audio-desc-only","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#audio-description-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/audio-description-prerecorded.html","handle":"Audio Description (Prerecorded)","level":"AA","wcagType":"2.0"},"1.2.6":{"num":"1.2.6","url":"https://www.w3.org/TR/WCAG21/#sign-language-prerecorded","scId":"WCAG2:sign-language-prerecorded","scAltId":["media-equiv-sign"],"test":"WCAG2:media-equiv-sign","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#sign-language-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/sign-language-prerecorded.html","handle":"Sign Language (Prerecorded)","level":"AAA","wcagType":"2.0"},"1.2.7":{"num":"1.2.7","url":"https://www.w3.org/TR/WCAG21/#extended-audio-description-prerecorded","scId":"WCAG2:extended-audio-description-prerecorded","scAltId":["media-equiv-extended-ad"],"test":"WCAG2:media-equiv-extended-ad","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#extended-audio-description-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/extended-audio-description-prerecorded.html","handle":"Extended Audio Description (Prerecorded)","level":"AAA","wcagType":"2.0"},"1.2.8":{"num":"1.2.8","url":"https://www.w3.org/TR/WCAG21/#media-alternative-prerecorded","scId":"WCAG2:media-alternative-prerecorded","scAltId":["media-equiv-text-doc"],"test":"WCAG2:media-equiv-text-doc","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#media-alternative-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/media-alternative-prerecorded.html","handle":"Media Alternative (Prerecorded)","level":"AAA","wcagType":"2.0"},"1.2.9":{"num":"1.2.9","url":"https://www.w3.org/TR/WCAG21/#audio-only-live","scId":"WCAG2:audio-only-live","scAltId":["media-equiv-live-audio-only"],"test":"WCAG2:media-equiv-live-audio-only","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#audio-only-live","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/audio-only-live.html","handle":"Audio-only (Live)","level":"AAA","wcagType":"2.0"},"1.3.1":{"num":"1.3.1","url":"https://www.w3.org/TR/WCAG21/#info-and-relationships","scId":"WCAG2:info-and-relationships","scAltId":["content-structure-separation-programmatic"],"test":"WCAG2:content-structure-separation-programmatic","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#info-and-relationships","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/info-and-relationships.html","handle":"Info and Relationships","level":"A","wcagType":"2.0"},"1.3.2":{"num":"1.3.2","url":"https://www.w3.org/TR/WCAG21/#meaningful-sequence","scId":"WCAG2:meaningful-sequence","scAltId":["content-structure-separation-sequence"],"test":"WCAG2:content-structure-separation-sequence","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#meaningful-sequence","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/meaningful-sequence.html","handle":"Meaningful Sequence","level":"A","wcagType":"2.0"},"1.3.3":{"num":"1.3.3","url":"https://www.w3.org/TR/WCAG21/#sensory-characteristics","scId":"WCAG2:sensory-characteristics","scAltId":["content-structure-separation-understanding"],"test":"WCAG2:content-structure-separation-understanding","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#sensory-characteristics","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/sensory-characteristics.html","handle":"Sensory Characteristics","level":"A","wcagType":"2.0"},"1.3.4":{"num":"1.3.4","url":"https://www.w3.org/TR/WCAG21/#orientation","scId":"WCAG2:orientation","scAltId":[],"test":"WCAG2:WCAG2:orientation","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#orientation","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/orientation.html","handle":"Orientation","level":"AA","wcagType":"2.1"},"1.3.5":{"num":"1.3.5","url":"https://www.w3.org/TR/WCAG21/#identify-input-purpose","scId":"WCAG2:identify-input-purpose","scAltId":[],"test":"WCAG2:WCAG2:identify-input-purpose","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#identify-input-purpose","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/identify-input-purpose.html","handle":"Identify Input Purpose","level":"AA","wcagType":"2.1"},"1.3.6":{"num":"1.3.6","url":"https://www.w3.org/TR/WCAG21/#identify-purpose","scId":"WCAG2:identify-purpose","scAltId":[],"test":"WCAG2:WCAG2:identify-purpose","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#identify-purpose","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/identify-purpose.html","handle":"Identify Purpose","level":"AAA","wcagType":"2.1"},"1.4.1":{"num":"1.4.1","url":"https://www.w3.org/TR/WCAG21/#use-of-color","scId":"WCAG2:use-of-color","scAltId":["visual-audio-contrast-without-color"],"test":"WCAG2:visual-audio-contrast-without-color","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#use-of-color","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/use-of-color.html","handle":"Use of Color","level":"A","wcagType":"2.0"},"1.4.2":{"num":"1.4.2","url":"https://www.w3.org/TR/WCAG21/#audio-control","scId":"WCAG2:audio-control","scAltId":["visual-audio-contrast-dis-audio"],"test":"WCAG2:visual-audio-contrast-dis-audio","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#audio-control","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/audio-control.html","handle":"Audio Control","level":"A","wcagType":"2.0"},"1.4.3":{"num":"1.4.3","url":"https://www.w3.org/TR/WCAG21/#contrast-minimum","scId":"WCAG2:contrast-minimum","scAltId":["visual-audio-contrast-contrast"],"test":"WCAG2:visual-audio-contrast-contrast","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#contrast-minimum","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html","handle":"Contrast (Minimum)","level":"AA","wcagType":"2.0"},"1.4.4":{"num":"1.4.4","url":"https://www.w3.org/TR/WCAG21/#resize-text","scId":"WCAG2:resize-text","scAltId":["visual-audio-contrast-scale"],"test":"WCAG2:visual-audio-contrast-scale","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#resize-text","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/resize-text.html","handle":"Resize text","level":"AA","wcagType":"2.0"},"1.4.5":{"num":"1.4.5","url":"https://www.w3.org/TR/WCAG21/#images-of-text","scId":"WCAG2:images-of-text","scAltId":["visual-audio-contrast-text-presentation"],"test":"WCAG2:visual-audio-contrast-text-presentation","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#images-of-text","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/images-of-text.html","handle":"Images of Text","level":"AA","wcagType":"2.0"},"1.4.6":{"num":"1.4.6","url":"https://www.w3.org/TR/WCAG21/#contrast-enhanced","scId":"WCAG2:contrast-enhanced","scAltId":["visual-audio-contrast7"],"test":"WCAG2:visual-audio-contrast7","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#contrast-enhanced","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/contrast-enhanced.html","handle":"Contrast (Enhanced)","level":"AAA","wcagType":"2.0"},"1.4.7":{"num":"1.4.7","url":"https://www.w3.org/TR/WCAG21/#low-or-no-background-audio","scId":"WCAG2:low-or-no-background-audio","scAltId":["visual-audio-contrast-noaudio"],"test":"WCAG2:visual-audio-contrast-noaudio","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#low-or-no-background-audio","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/low-or-no-background-audio.html","handle":"Low or No Background Audio","level":"AAA","wcagType":"2.0"},"1.4.8":{"num":"1.4.8","url":"https://www.w3.org/TR/WCAG21/#visual-presentation","scId":"WCAG2:visual-presentation","scAltId":["visual-audio-contrast-visual-presentation"],"test":"WCAG2:visual-audio-contrast-visual-presentation","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#visual-presentation","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/visual-presentation.html","handle":"Visual Presentation","level":"AAA","wcagType":"2.0"},"1.4.9":{"num":"1.4.9","url":"https://www.w3.org/TR/WCAG21/#images-of-text-no-exception","scId":"WCAG2:images-of-text-no-exception","scAltId":["visual-audio-contrast-text-images"],"test":"WCAG2:visual-audio-contrast-text-images","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#images-of-text-no-exception","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/images-of-text-no-exception.html","handle":"Images of Text (No Exception)","level":"AAA","wcagType":"2.0"},"1.4.10":{"num":"1.4.10","url":"https://www.w3.org/TR/WCAG21/#reflow","scId":"WCAG2:reflow","scAltId":[],"test":"WCAG2:WCAG2:reflow","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#reflow","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/reflow.html","handle":"Reflow","level":"AA","wcagType":"2.1"},"1.4.11":{"num":"1.4.11","url":"https://www.w3.org/TR/WCAG21/#non-text-contrast","scId":"WCAG2:non-text-contrast","scAltId":[],"test":"WCAG2:WCAG2:non-text-contrast","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#non-text-contrast","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/non-text-contrast.html","handle":"Non-text Contrast","level":"AA","wcagType":"2.1"},"1.4.12":{"num":"1.4.12","url":"https://www.w3.org/TR/WCAG21/#text-spacing","scId":"WCAG2:text-spacing","scAltId":[],"test":"WCAG2:WCAG2:text-spacing","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#text-spacing","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/text-spacing.html","handle":"Text Spacing","level":"AA","wcagType":"2.1"},"1.4.13":{"num":"1.4.13","url":"https://www.w3.org/TR/WCAG21/#content-on-hover-or-focus","scId":"WCAG2:content-on-hover-or-focus","scAltId":[],"test":"WCAG2:WCAG2:content-on-hover-or-focus","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#content-on-hover-or-focus","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/content-on-hover-or-focus.html","handle":"Content on Hover or Focus","level":"AA","wcagType":"2.1"},"2.1.1":{"num":"2.1.1","url":"https://www.w3.org/TR/WCAG21/#keyboard","scId":"WCAG2:keyboard","scAltId":["keyboard-operation-keyboard-operable"],"test":"WCAG2:keyboard-operation-keyboard-operable","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#keyboard","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/keyboard.html","handle":"Keyboard","level":"A","wcagType":"2.0"},"2.1.2":{"num":"2.1.2","url":"https://www.w3.org/TR/WCAG21/#no-keyboard-trap","scId":"WCAG2:no-keyboard-trap","scAltId":["keyboard-operation-trapping"],"test":"WCAG2:keyboard-operation-trapping","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#no-keyboard-trap","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/no-keyboard-trap.html","handle":"No Keyboard Trap","level":"A","wcagType":"2.0"},"2.1.3":{"num":"2.1.3","url":"https://www.w3.org/TR/WCAG21/#keyboard-no-exception","scId":"WCAG2:keyboard-no-exception","scAltId":["keyboard-operation-all-funcs"],"test":"WCAG2:keyboard-operation-all-funcs","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#keyboard-no-exception","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/keyboard-no-exception.html","handle":"Keyboard (No Exception)","level":"AAA","wcagType":"2.0"},"2.1.4":{"num":"2.1.4","url":"https://www.w3.org/TR/WCAG21/#character-key-shortcuts","scId":"WCAG2:character-key-shortcuts","scAltId":[],"test":"WCAG2:WCAG2:character-key-shortcuts","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#character-key-shortcuts","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/character-key-shortcuts.html","handle":"Character Key Shortcuts","level":"A","wcagType":"2.1"},"2.2.1":{"num":"2.2.1","url":"https://www.w3.org/TR/WCAG21/#timing-adjustable","scId":"WCAG2:timing-adjustable","scAltId":["time-limits-required-behaviors"],"test":"WCAG2:time-limits-required-behaviors","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#timing-adjustable","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/timing-adjustable.html","handle":"Timing Adjustable","level":"A","wcagType":"2.0"},"2.2.2":{"num":"2.2.2","url":"https://www.w3.org/TR/WCAG21/#pause-stop-hide","scId":"WCAG2:pause-stop-hide","scAltId":["time-limits-pause"],"test":"WCAG2:time-limits-pause","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#pause-stop-hide","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/pause-stop-hide.html","handle":"Pause, Stop, Hide","level":"A","wcagType":"2.0"},"2.2.3":{"num":"2.2.3","url":"https://www.w3.org/TR/WCAG21/#no-timing","scId":"WCAG2:no-timing","scAltId":["time-limits-no-exceptions"],"test":"WCAG2:time-limits-no-exceptions","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#no-timing","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/no-timing.html","handle":"No Timing","level":"AAA","wcagType":"2.0"},"2.2.4":{"num":"2.2.4","url":"https://www.w3.org/TR/WCAG21/#interruptions","scId":"WCAG2:interruptions","scAltId":["time-limits-postponed"],"test":"WCAG2:time-limits-postponed","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#interruptions","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/interruptions.html","handle":"Interruptions","level":"AAA","wcagType":"2.0"},"2.2.5":{"num":"2.2.5","url":"https://www.w3.org/TR/WCAG21/#re-authenticating","scId":"WCAG2:re-authenticating","scAltId":["time-limits-server-timeout"],"test":"WCAG2:time-limits-server-timeout","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#re-authenticating","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/re-authenticating.html","handle":"Re-authenticating","level":"AAA","wcagType":"2.0"},"2.2.6":{"num":"2.2.6","url":"https://www.w3.org/TR/WCAG21/#timeouts","scId":"WCAG2:timeouts","scAltId":[],"test":"WCAG2:WCAG2:timeouts","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#timeouts","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/timeouts.html","handle":"Timeouts","level":"AAA","wcagType":"2.1"},"2.3.1":{"num":"2.3.1","url":"https://www.w3.org/TR/WCAG21/#three-flashes-or-below-threshold","scId":"WCAG2:three-flashes-or-below-threshold","scAltId":["seizure-does-not-violate"],"test":"WCAG2:seizure-does-not-violate","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#three-flashes-or-below-threshold","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/three-flashes-or-below-threshold.html","handle":"Three Flashes or Below Threshold","level":"A","wcagType":"2.0"},"2.3.2":{"num":"2.3.2","url":"https://www.w3.org/TR/WCAG21/#three-flashes","scId":"WCAG2:three-flashes","scAltId":["seizure-three-times"],"test":"WCAG2:seizure-three-times","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#three-flashes","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/three-flashes.html","handle":"Three Flashes","level":"AAA","wcagType":"2.0"},"2.3.3":{"num":"2.3.3","url":"https://www.w3.org/TR/WCAG21/#animation-from-interactions","scId":"WCAG2:animation-from-interactions","scAltId":[],"test":"WCAG2:WCAG2:animation-from-interactions","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#animation-from-interactions","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/animation-from-interactions.html","handle":"Animation from Interactions","level":"AAA","wcagType":"2.1"},"2.4.1":{"num":"2.4.1","url":"https://www.w3.org/TR/WCAG21/#bypass-blocks","scId":"WCAG2:bypass-blocks","scAltId":["navigation-mechanisms-skip"],"test":"WCAG2:navigation-mechanisms-skip","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#bypass-blocks","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/bypass-blocks.html","handle":"Bypass Blocks","level":"A","wcagType":"2.0"},"2.4.2":{"num":"2.4.2","url":"https://www.w3.org/TR/WCAG21/#page-titled","scId":"WCAG2:page-titled","scAltId":["navigation-mechanisms-title"],"test":"WCAG2:navigation-mechanisms-title","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#page-titled","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/page-titled.html","handle":"Page Titled","level":"A","wcagType":"2.0"},"2.4.3":{"num":"2.4.3","url":"https://www.w3.org/TR/WCAG21/#focus-order","scId":"WCAG2:focus-order","scAltId":["navigation-mechanisms-focus-order"],"test":"WCAG2:navigation-mechanisms-focus-order","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#focus-order","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/focus-order.html","handle":"Focus Order","level":"A","wcagType":"2.0"},"2.4.4":{"num":"2.4.4","url":"https://www.w3.org/TR/WCAG21/#link-purpose-in-context","scId":"WCAG2:link-purpose-in-context","scAltId":["navigation-mechanisms-refs"],"test":"WCAG2:navigation-mechanisms-refs","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#link-purpose-in-context","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/link-purpose-in-context.html","handle":"Link Purpose (In Context)","level":"A","wcagType":"2.0"},"2.4.5":{"num":"2.4.5","url":"https://www.w3.org/TR/WCAG21/#multiple-ways","scId":"WCAG2:multiple-ways","scAltId":["navigation-mechanisms-mult-loc"],"test":"WCAG2:navigation-mechanisms-mult-loc","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#multiple-ways","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/multiple-ways.html","handle":"Multiple Ways","level":"AA","wcagType":"2.0"},"2.4.6":{"num":"2.4.6","url":"https://www.w3.org/TR/WCAG21/#headings-and-labels","scId":"WCAG2:headings-and-labels","scAltId":["navigation-mechanisms-descriptive"],"test":"WCAG2:navigation-mechanisms-descriptive","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#headings-and-labels","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/headings-and-labels.html","handle":"Headings and Labels","level":"AA","wcagType":"2.0"},"2.4.7":{"num":"2.4.7","url":"https://www.w3.org/TR/WCAG21/#focus-visible","scId":"WCAG2:focus-visible","scAltId":["navigation-mechanisms-focus-visible"],"test":"WCAG2:navigation-mechanisms-focus-visible","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#focus-visible","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/focus-visible.html","handle":"Focus Visible","level":"AA","wcagType":"2.0"},"2.4.8":{"num":"2.4.8","url":"https://www.w3.org/TR/WCAG21/#location","scId":"WCAG2:location","scAltId":["navigation-mechanisms-location"],"test":"WCAG2:navigation-mechanisms-location","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#location","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/location.html","handle":"Location","level":"AAA","wcagType":"2.0"},"2.4.9":{"num":"2.4.9","url":"https://www.w3.org/TR/WCAG21/#link-purpose-link-only","scId":"WCAG2:link-purpose-link-only","scAltId":["navigation-mechanisms-link"],"test":"WCAG2:navigation-mechanisms-link","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#link-purpose-link-only","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/link-purpose-link-only.html","handle":"Link Purpose (Link Only)","level":"AAA","wcagType":"2.0"},"2.4.10":{"num":"2.4.10","url":"https://www.w3.org/TR/WCAG21/#section-headings","scId":"WCAG2:section-headings","scAltId":["navigation-mechanisms-headings"],"test":"WCAG2:navigation-mechanisms-headings","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#section-headings","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/section-headings.html","handle":"Section Headings","level":"AAA","wcagType":"2.0"},"2.5.1":{"num":"2.5.1","url":"https://www.w3.org/TR/WCAG21/#pointer-gestures","scId":"WCAG2:pointer-gestures","scAltId":[],"test":"WCAG2:WCAG2:pointer-gestures","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#pointer-gestures","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/pointer-gestures.html","handle":"Pointer Gestures","level":"A","wcagType":"2.1"},"2.5.2":{"num":"2.5.2","url":"https://www.w3.org/TR/WCAG21/#pointer-cancellation","scId":"WCAG2:pointer-cancellation","scAltId":[],"test":"WCAG2:WCAG2:pointer-cancellation","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#pointer-cancellation","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/pointer-cancellation.html","handle":"Pointer Cancellation","level":"A","wcagType":"2.1"},"2.5.3":{"num":"2.5.3","url":"https://www.w3.org/TR/WCAG21/#label-in-name","scId":"WCAG2:label-in-name","scAltId":[],"test":"WCAG2:WCAG2:label-in-name","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#label-in-name","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/label-in-name.html","handle":"Label in Name","level":"A","wcagType":"2.1"},"2.5.4":{"num":"2.5.4","url":"https://www.w3.org/TR/WCAG21/#motion-actuation","scId":"WCAG2:motion-actuation","scAltId":[],"test":"WCAG2:WCAG2:motion-actuation","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#motion-actuation","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/motion-actuation.html","handle":"Motion Actuation","level":"A","wcagType":"2.1"},"2.5.5":{"num":"2.5.5","url":"https://www.w3.org/TR/WCAG21/#target-size","scId":"WCAG2:target-size","scAltId":[],"test":"WCAG2:WCAG2:target-size","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#target-size","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/target-size.html","handle":"Target Size","level":"AAA","wcagType":"2.1"},"2.5.6":{"num":"2.5.6","url":"https://www.w3.org/TR/WCAG21/#concurrent-input-mechanisms","scId":"WCAG2:concurrent-input-mechanisms","scAltId":[],"test":"WCAG2:WCAG2:concurrent-input-mechanisms","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#concurrent-input-mechanisms","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/concurrent-input-mechanisms.html","handle":"Concurrent Input Mechanisms","level":"AAA","wcagType":"2.1"},"3.1.1":{"num":"3.1.1","url":"https://www.w3.org/TR/WCAG21/#language-of-page","scId":"WCAG2:language-of-page","scAltId":["meaning-doc-lang-id"],"test":"WCAG2:meaning-doc-lang-id","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#language-of-page","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/language-of-page.html","handle":"Language of Page","level":"A","wcagType":"2.0"},"3.1.2":{"num":"3.1.2","url":"https://www.w3.org/TR/WCAG21/#language-of-parts","scId":"WCAG2:language-of-parts","scAltId":["meaning-other-lang-id"],"test":"WCAG2:meaning-other-lang-id","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#language-of-parts","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/language-of-parts.html","handle":"Language of Parts","level":"AA","wcagType":"2.0"},"3.1.3":{"num":"3.1.3","url":"https://www.w3.org/TR/WCAG21/#unusual-words","scId":"WCAG2:unusual-words","scAltId":["meaning-idioms"],"test":"WCAG2:meaning-idioms","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#unusual-words","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/unusual-words.html","handle":"Unusual Words","level":"AAA","wcagType":"2.0"},"3.1.4":{"num":"3.1.4","url":"https://www.w3.org/TR/WCAG21/#abbreviations","scId":"WCAG2:abbreviations","scAltId":["meaning-located"],"test":"WCAG2:meaning-located","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#abbreviations","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/abbreviations.html","handle":"Abbreviations","level":"AAA","wcagType":"2.0"},"3.1.5":{"num":"3.1.5","url":"https://www.w3.org/TR/WCAG21/#reading-level","scId":"WCAG2:reading-level","scAltId":["meaning-supplements"],"test":"WCAG2:meaning-supplements","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#reading-level","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/reading-level.html","handle":"Reading Level","level":"AAA","wcagType":"2.0"},"3.1.6":{"num":"3.1.6","url":"https://www.w3.org/TR/WCAG21/#pronunciation","scId":"WCAG2:pronunciation","scAltId":["meaning-pronunciation"],"test":"WCAG2:meaning-pronunciation","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#pronunciation","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/pronunciation.html","handle":"Pronunciation","level":"AAA","wcagType":"2.0"},"3.2.1":{"num":"3.2.1","url":"https://www.w3.org/TR/WCAG21/#on-focus","scId":"WCAG2:on-focus","scAltId":["consistent-behavior-receive-focus"],"test":"WCAG2:consistent-behavior-receive-focus","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#on-focus","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/on-focus.html","handle":"On Focus","level":"A","wcagType":"2.0"},"3.2.2":{"num":"3.2.2","url":"https://www.w3.org/TR/WCAG21/#on-input","scId":"WCAG2:on-input","scAltId":["consistent-behavior-unpredictable-change"],"test":"WCAG2:consistent-behavior-unpredictable-change","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#on-input","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/on-input.html","handle":"On Input","level":"A","wcagType":"2.0"},"3.2.3":{"num":"3.2.3","url":"https://www.w3.org/TR/WCAG21/#consistent-navigation","scId":"WCAG2:consistent-navigation","scAltId":["consistent-behavior-consistent-locations"],"test":"WCAG2:consistent-behavior-consistent-locations","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#consistent-navigation","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/consistent-navigation.html","handle":"Consistent Navigation","level":"AA","wcagType":"2.0"},"3.2.4":{"num":"3.2.4","url":"https://www.w3.org/TR/WCAG21/#consistent-identification","scId":"WCAG2:consistent-identification","scAltId":["consistent-behavior-consistent-functionality"],"test":"WCAG2:consistent-behavior-consistent-functionality","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#consistent-identification","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/consistent-identification.html","handle":"Consistent Identification","level":"AA","wcagType":"2.0"},"3.2.5":{"num":"3.2.5","url":"https://www.w3.org/TR/WCAG21/#change-on-request","scId":"WCAG2:change-on-request","scAltId":["consistent-behavior-no-extreme-changes-context"],"test":"WCAG2:consistent-behavior-no-extreme-changes-context","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#change-on-request","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/change-on-request.html","handle":"Change on Request","level":"AAA","wcagType":"2.0"},"3.3.1":{"num":"3.3.1","url":"https://www.w3.org/TR/WCAG21/#error-identification","scId":"WCAG2:error-identification","scAltId":["minimize-error-identified"],"test":"WCAG2:minimize-error-identified","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#error-identification","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/error-identification.html","handle":"Error Identification","level":"A","wcagType":"2.0"},"3.3.2":{"num":"3.3.2","url":"https://www.w3.org/TR/WCAG21/#labels-or-instructions","scId":"WCAG2:labels-or-instructions","scAltId":["minimize-error-cues"],"test":"WCAG2:minimize-error-cues","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#labels-or-instructions","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/labels-or-instructions.html","handle":"Labels or Instructions","level":"A","wcagType":"2.0"},"3.3.3":{"num":"3.3.3","url":"https://www.w3.org/TR/WCAG21/#error-suggestion","scId":"WCAG2:error-suggestion","scAltId":["minimize-error-suggestions"],"test":"WCAG2:minimize-error-suggestions","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#error-suggestion","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/error-suggestion.html","handle":"Error Suggestion","level":"AA","wcagType":"2.0"},"3.3.4":{"num":"3.3.4","url":"https://www.w3.org/TR/WCAG21/#error-prevention-legal-financial-data","scId":"WCAG2:error-prevention-legal-financial-data","scAltId":["minimize-error-reversible"],"test":"WCAG2:minimize-error-reversible","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#error-prevention-legal-financial-data","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/error-prevention-legal-financial-data.html","handle":"Error Prevention (Legal, Financial, Data)","level":"AA","wcagType":"2.0"},"3.3.5":{"num":"3.3.5","url":"https://www.w3.org/TR/WCAG21/#help","scId":"WCAG2:help","scAltId":["minimize-error-context-help"],"test":"WCAG2:minimize-error-context-help","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#help","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/help.html","handle":"Help","level":"AAA","wcagType":"2.0"},"3.3.6":{"num":"3.3.6","url":"https://www.w3.org/TR/WCAG21/#error-prevention-all","scId":"WCAG2:error-prevention-all","scAltId":["minimize-error-reversible-all"],"test":"WCAG2:minimize-error-reversible-all","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#error-prevention-all","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/error-prevention-all.html","handle":"Error Prevention (All)","level":"AAA","wcagType":"2.0"},"4.1.1":{"num":"4.1.1","url":"https://www.w3.org/TR/WCAG21/#parsing","scId":"WCAG2:parsing","scAltId":["ensure-compat-parses"],"test":"WCAG2:ensure-compat-parses","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#parsing","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/parsing.html","handle":"Parsing","level":"A","wcagType":"2.0"},"4.1.2":{"num":"4.1.2","url":"https://www.w3.org/TR/WCAG21/#name-role-value","scId":"WCAG2:name-role-value","scAltId":["ensure-compat-rsv"],"test":"WCAG2:ensure-compat-rsv","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#name-role-value","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/name-role-value.html","handle":"Name, Role, Value","level":"A","wcagType":"2.0"},"4.1.3":{"num":"4.1.3","url":"https://www.w3.org/TR/WCAG21/#status-messages","scId":"WCAG2:status-messages","scAltId":[],"test":"WCAG2:WCAG2:status-messages","howToMeetUrl":"https://www.w3.org/WAI/WCAG21/quickref/#status-messages","understandingUrl":"https://www.w3.org/WAI/WCAG21/Understanding/status-messages.html","handle":"Status Messages","level":"AA","wcagType":"2.1"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DOMWalker = exports.Config = exports.checkDemo = exports.ARIAMapper = exports.Context = exports.Checker = void 0;
var Context_1 = __webpack_require__(2306);
Object.defineProperty(exports, "Context", ({ enumerable: true, get: function () { return Context_1.Context; } }));
// import { Simulator } from "./v2/simulator"
var Checker_1 = __webpack_require__(7884);
Object.defineProperty(exports, "Checker", ({ enumerable: true, get: function () { return Checker_1.Checker; } }));
var ARIAMapper_1 = __webpack_require__(4944);
Object.defineProperty(exports, "ARIAMapper", ({ enumerable: true, get: function () { return ARIAMapper_1.ARIAMapper; } }));
var Config_1 = __webpack_require__(3962);
Object.defineProperty(exports, "Config", ({ enumerable: true, get: function () { return Config_1.Config; } }));
var DOMWalker_1 = __webpack_require__(7440);
Object.defineProperty(exports, "DOMWalker", ({ enumerable: true, get: function () { return DOMWalker_1.DOMWalker; } }));
String.prototype.startsWith = String.prototype.startsWith || function (str) {
    return this.indexOf(str) === 0;
};
String.prototype.includes = String.prototype.includes || function (str) {
    return this.indexOf(str) !== -1;
};
Array.prototype.includes = Array.prototype.includes || function (str) {
    return this.indexOf(str) !== -1;
};
/*
function simDemo(timeout?: number) {
    if (!timeout) timeout = 0;
    setTimeout(function() {
        let sim = new Simulator();
        let s = sim.renderItem(document.documentElement);
        console.group("--- Item View ---");
        console.log(s);
        console.groupEnd();
        console.group("--- Link View ---");
        s = sim.renderLink(document.documentElement);
        console.log(s);
        console.groupEnd();
    }, timeout);
}
*/
function checkDemo(timeout) {
    if (!timeout)
        timeout = 0;
    var checker = new Checker_1.Checker();
    setTimeout(function () {
        checker.check(document.documentElement, ["IBM_Accessibility", "IBM_Design"])
            .then(function (report) {
            console.log(report);
            var vals = {
                "FAIL": 0,
                "POTENTIAL": 1,
                "MANUAL": 2,
                "PASS": 3
            };
            for (var idx = 0; idx < report.results.length; ++idx) {
                if (report.results[idx].value[1] === "PASS") {
                    report.results.splice(idx--, 1);
                }
            }
            report.results.sort(function (a, b) {
                if (a.category != b.category) {
                    return a.category.localeCompare(b.category);
                }
                if (a.path["aria"] === b.path["aria"]) {
                    return vals[a.value[1]] - vals[b.value[1]];
                }
                return a.path["aria"].localeCompare(b.path["aria"]);
            });
            var lastPath = null;
            var category = null;
            for (var _i = 0, _a = report.results; _i < _a.length; _i++) {
                var result = _a[_i];
                if (category !== result.category) {
                    if (category !== null) {
                        console.groupEnd();
                        console.groupEnd();
                        lastPath = null;
                    }
                    category = result.category;
                    console.group(result.category);
                }
                if (result.path["aria"] != lastPath) {
                    if (lastPath !== null) {
                        console.groupEnd();
                    }
                    lastPath = result.path["aria"];
                    if (lastPath === "") {
                        console.group("page");
                    }
                    else {
                        console.group(lastPath);
                    }
                }
                console.log(result.value, result.message);
            }
            console.groupEnd();
            console.groupEnd();
        });
    }, timeout);
}
exports.checkDemo = checkDemo;

})();

module.exports = __webpack_exports__;
/******/ })()
;