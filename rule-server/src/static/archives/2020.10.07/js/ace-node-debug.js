/*!
 * Copyright:: 2016,2017,2019,2020- IBM, Inc
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleManual = exports.RulePotential = exports.RuleFail = exports.RuleRender = exports.RulePass = exports.eRuleCategory = exports.eRulePolicy = exports.eRuleConfidence = void 0;
var eRuleConfidence;
(function (eRuleConfidence) {
    eRuleConfidence["PASS"] = "PASS";
    eRuleConfidence["FAIL"] = "FAIL";
    eRuleConfidence["POTENTIAL"] = "POTENTIAL";
    eRuleConfidence["MANUAL"] = "MANUAL";
})(eRuleConfidence = exports.eRuleConfidence || (exports.eRuleConfidence = {}));
var eRulePolicy;
(function (eRulePolicy) {
    eRulePolicy["VIOLATION"] = "VIOLATION";
    eRulePolicy["RECOMMENDATION"] = "RECOMMENDATION";
    eRulePolicy["INFORMATION"] = "INFORMATION";
})(eRulePolicy = exports.eRulePolicy || (exports.eRulePolicy = {}));
var eRuleCategory;
(function (eRuleCategory) {
    eRuleCategory["ACCESSIBILITY"] = "Accessibility";
    eRuleCategory["DESIGN"] = "Design";
    eRuleCategory["OTHER"] = "Other";
})(eRuleCategory = exports.eRuleCategory || (exports.eRuleCategory = {}));
function RulePass(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.PASS],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RulePass = RulePass;
function RuleRender(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.PASS],
        reasonId: 0,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RuleRender = RuleRender;
function RuleFail(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.FAIL],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RuleFail = RuleFail;
function RulePotential(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.POTENTIAL],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RulePotential = RulePotential;
function RuleManual(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.MANUAL],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RuleManual = RuleManual;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeWalker = exports.ColorObj = exports.RPTUtilStyle = exports.RPTUtil = void 0;
var ARIADefinitions_1 = __webpack_require__(2);
var ARIAMapper_1 = __webpack_require__(6);
var RPTUtil = /** @class */ (function () {
    function RPTUtil() {
    }
    RPTUtil.isDefinedAriaAttributeAtIndex = function (ele, index) {
        var attrName = ele.attributes[index].name;
        return RPTUtil.isDefinedAriaAttribute(ele, attrName);
    };
    /**
     * This method handles implicit aria definitions, for example, an input with checked is equivalent to aria-checked="true"
     */
    RPTUtil.getAriaAttribute = function (ele, attributeName) {
        // If the attribute is defined, it takes precedence
        var retVal = ele.getAttribute(attributeName);
        if (ele.hasAttribute(attributeName) && retVal.trim() == "") { //"" is treated as false, so we need return it before the below check
            return retVal;
        }
        // Then determine implicit values from other attributes
        if (!retVal) {
            var tag = ele.nodeName.toLowerCase();
            if (attributeName in RPTUtil.ariaAttributeImplicitMappings) {
                if (tag in RPTUtil.ariaAttributeImplicitMappings[attributeName]) {
                    retVal = RPTUtil.ariaAttributeImplicitMappings[attributeName][tag];
                    if (typeof (retVal) === "function") {
                        retVal = retVal(ele);
                    }
                }
                else if ("*" in RPTUtil.ariaAttributeImplicitMappings[attributeName]) {
                    retVal = RPTUtil.ariaAttributeImplicitMappings[attributeName]["*"];
                    if (typeof (retVal) === "function") {
                        retVal = retVal(ele);
                    }
                }
            }
        }
        // Check role-based defaults
        if (!retVal) {
            var role = ARIAMapper_1.ARIAMapper.nodeToRole(ele);
            if (role in RPTUtil.ariaAttributeRoleDefaults && attributeName in RPTUtil.ariaAttributeRoleDefaults[role]) {
                retVal = RPTUtil.ariaAttributeRoleDefaults[role][attributeName];
                if (typeof (retVal) === "function") {
                    retVal = retVal(ele);
                }
            }
        }
        // Still not defined? Check global defaults
        if (!retVal && attributeName in RPTUtil.ariaAttributeGlobalDefaults) {
            retVal = RPTUtil.ariaAttributeGlobalDefaults[attributeName];
        }
        return retVal;
    };
    RPTUtil.wordCount = function (str) {
        str = str.trim();
        if (str.length == 0)
            return 0;
        return str.split(/\s+/g).length;
    };
    /**
     * Note that this only detects if the element itself is in the tab order.
     * However, this element may delegate focus to another element via aria-activedescendant
     * Also, focus varies by browser...  sticking to things that are focusable on chrome and firefox
     */
    RPTUtil.isTabbable = function (element) {
        // Using https://allyjs.io/data-tables/focusable.html
        // Handle the explicit cases first
        if (!RPTUtil.isNodeVisible(element))
            return false;
        if (element.hasAttribute("tabindex")) {
            return parseInt(element.getAttribute("tabindex")) >= 0;
        }
        // Explicit cases handled - now the implicit
        var nodeName = element.nodeName.toLowerCase();
        if (nodeName in RPTUtil.tabTagMap) {
            var retVal = RPTUtil.tabTagMap[nodeName];
            if (typeof (retVal) === "function") {
                retVal = retVal(element);
            }
            return retVal;
        }
        else {
            return false;
        }
    };
    RPTUtil.tabIndexLEZero = function (elem) {
        if (RPTUtil.hasAttribute(elem, "tabindex")) {
            if (elem.getAttribute("tabindex").match(/^-?\d+$/)) {
                var tabindexValue = parseInt(elem.getAttribute("tabindex"));
                return tabindexValue == 0 || tabindexValue == -1;
            }
        }
        return false;
    };
    //TODO: function does not handle equivalents for roles: row, link, header, button
    // But it may not have to.  Bug reports have been about radio buttons and checkboxes.
    RPTUtil.isHtmlEquiv = function (node, htmlEquiv) {
        var retVal = false;
        if (node) {
            var nodeName = node.nodeName.toLowerCase();
            if (nodeName == "input") {
                var type = node.getAttribute("type").toLowerCase();
                if (type) {
                    if (htmlEquiv.indexOf("checkbox") != -1) {
                        retVal = type == "checkbox";
                    }
                    else if (htmlEquiv.indexOf("radio") != -1) {
                        retVal = type == "radio";
                    }
                }
            }
        }
        return retVal;
    };
    RPTUtil.isDefinedAriaAttribute = function (ele, attrName) {
        var isDefinedAriaAttribute = false;
        if (attrName.substring(0, 5) == 'aria-') {
            isDefinedAriaAttribute = ele.hasAttribute && ele.hasAttribute(attrName);
        }
        return isDefinedAriaAttribute;
    };
    RPTUtil.normalizeSpacing = function (s) {
        return s.trim().replace(/\s+/g, ' ');
    };
    ;
    RPTUtil.nonExistantIDs = function (node, targetids) {
        var returnnotfoundids = '';
        if (RPTUtil.normalizeSpacing(targetids).length < 1)
            return returnnotfoundids;
        var targetArray = targetids.split(" ");
        var doc = node.ownerDocument;
        for (var i = 0; i < targetArray.length; i++) {
            var xp = "//*[@id='" + targetArray[i] + "']";
            var xpathResult = doc.evaluate(xp, node, doc.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
            var r = xpathResult.iterateNext();
            if (!r)
                returnnotfoundids += targetArray[i] + ', ';
        }
        if (RPTUtil.normalizeSpacing(returnnotfoundids).length >= 2)
            returnnotfoundids = returnnotfoundids.substring(0, returnnotfoundids.length - 2);
        else
            returnnotfoundids = '';
        return returnnotfoundids;
    };
    RPTUtil.getDocElementsByTag = function (elem, tagName) {
        var doc = elem.ownerDocument;
        tagName = tagName.toLowerCase();
        if (!doc.RPT_DOCELEMSBYTAG)
            doc.RPT_DOCELEMSBYTAG = {};
        if (!(tagName in doc.RPT_DOCELEMSBYTAG))
            doc.RPT_DOCELEMSBYTAG[tagName] = doc.getElementsByTagName(tagName);
        return doc.RPT_DOCELEMSBYTAG[tagName];
    };
    /**
     * This function is responsible for get a list of all the child elemnts which match the tag
     * name provided.
     *
     * Note: This is a wrapper function to: RPTUtil.getChildByTagHidden
     *
     * @parm {element} parentElem - The parent element
     * @parm {string} tagName - The tag to search for under the parent element
     * @parm {boolean} ignoreHidden - true if hidden elements with the tag should ignored from the list
     *                                false if the hidden elements should be added
     *
     * @return {List} retVal - list of all the elements which matched the tag under the parent that were provided.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getChildByTag = function (parentElem, tagName) {
        return RPTUtil.getChildByTagHidden(parentElem, tagName, false, false);
    };
    /**
     * This function is responsible for get a list of all the child elemnts which match the tag
     * name provided.
     *
     * @parm {element} parentElem - The parent element
     * @parm {string} tagName - The tag to search for under the parent element
     * @parm {boolean} ignoreHidden - true if hidden elements with the tag should ignored from the list
     *                                false if the hidden elements should be added
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     *
     * @return {List} retVal - list of all the elements which matched the tag under the parent that were provided.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getChildByTagHidden = function (parentElem, tagName, ignoreHidden, considerHiddenSetting) {
        // Variable Decleration
        var retVal = [];
        var child = parentElem.firstChild;
        // Loop over all the child elements of the parent to build a list of all the elements that
        // match the tagName provided
        while (child != null) {
            // Only include the children into the return array if they match with tagname.
            if (child.nodeName.toLowerCase() == tagName) {
                // In the case that ignorehidden was set to true, then perform a isNodeVisible check
                // and in the case the node is not visilble we more to theses then move to the next node.
                // Perform a couple of checks to determine if hidden elements should be ignored or not.
                //  1. When ignoreHidden is set to true upfront, then perform a isNodeVisible
                //  2. If considerHiddenSetting option is set to true then we perform the check to consider the
                //     Check Hidden Content that is provided.
                //  2.1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                //       be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                //       add it to the roleToElems hash at all or even do any checking for it at all.
                if ((ignoreHidden || (considerHiddenSetting && !RPTUtil.shouldCheckHiddenContent(child))) && !RPTUtil.isNodeVisible(child)) {
                    // Move on to the next element
                    child = child.nextSibling;
                    continue;
                }
                // Push the element
                retVal.push(child);
            }
            // Move to the next sibling element
            child = child.nextSibling;
        }
        return retVal;
    };
    /**
     * This function is responsible for finding a list of elements that match given roles(s).
     * This function by defauly will not consider Check Hidden Setting at all.
     * This function by defauly will not consider implicit roles.
     * Note: This is a wrapper function to: RPTUtil.getElementsByRoleHidden
     *
     * @parm {document} doc - The document node
     * @parm {list or string} roles - List or single role for which to return elements based on.
     *
     * @return {List} retVal - list of all the elements which matched the role(s) that were provided.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getElementsByRole = function (doc, roles) {
        return RPTUtil.getElementsByRoleHidden(doc, roles, false, false);
    };
    /**
     * This function is responsible for finding a list of elements that match given roles(s).
     * This function aslo finds elements with implicit roles.
     * This function will also consider elements that are hidden based on the if the Check
     * Hidden Content settings should be considered or not.
     *
     * @parm {document} doc - The document node
     * @parm {list or string} roles - List or single role for which to return elements based on.
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {List} retVal - list of all the elements which matched the role(s) that were provided.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getElementsByRoleHidden = function (doc, roles, considerHiddenSetting, considerImplicitRoles) {
        // In the case that the role to element assoication is already made, and available in the global hasAttribute
        // we can just use that one instead of building a new one.
        var roleToElems = null;
        if (considerImplicitRoles) {
            roleToElems = RPTUtil.getCache(doc, "RPTUtil_GETELEMENTSBY_ROLE_IMPLICIT", null);
        }
        else {
            roleToElems = RPTUtil.getCache(doc, "RPTUtil_GETELEMENTSBY_ROLE", null);
        }
        // Build the new role to element, this is where we loop through all the elements and extract all the
        // elements bsaed on roles.
        if (roleToElems == null) {
            // Re-initialize the roleToElems hash
            roleToElems = {};
            // Get the body of the doc
            var root = doc.body;
            // Keep looping until we are at the very parent node of the entire page, so that we can loop through
            // all the nodes.
            while (root.parentNode != null) {
                // Get the parentNode
                root = root.parentNode;
            }
            // Build a nodewalter based of the root node, this node walter will be use loop over all the nodes
            // and build the roles to Element coralation
            var nw = new NodeWalker(root);
            // Loop over the entire doc/list of nodes to build the role to element map
            // Note: This will build an roleToElems hash which is in the following format.
            // roleToElems = {
            //    document: [{div},{abbr},{var}],
            //    main: [{div}],
            //    navigation: [{div}]
            // }
            while (nw.nextNode()) {
                // Only check the elements which have the role attribute assiciated to them
                if (!nw.bEndTag) {
                    var wRoles = [];
                    //check if the node has role attributes
                    if (nw.node.hasAttribute && nw.node.hasAttribute("role")) {
                        // Extract all the roles that are assigned to this element, can have multiple roles on one
                        // element split by space, so we need to extract all of them into an array.
                        wRoles = nw.node.getAttribute("role").split(" ");
                    }
                    if (wRoles.length === 0 && considerImplicitRoles) {
                        var tagProperty = RPTUtil.getElementAriaProperty(nw.node);
                        //check if there are any implicit roles for this element.
                        if (tagProperty && tagProperty.implicitRole) {
                            wRoles = tagProperty.implicitRole;
                        }
                    }
                    if (wRoles.length == 0) {
                        continue;
                    }
                    // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                    // or not.
                    //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
                    //     Check Hidden Content that is provided.
                    //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                    //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                    //     add it to the roleToElems hash at all or even do any checking for it at all.
                    //
                    // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                    //       so on and so forth.
                    if (considerHiddenSetting && RPTUtil.shouldNodeBeSkippedHidden(nw.node)) {
                        continue;
                    }
                    // Loop through all the roles and assigned this node to all thes roles
                    for (var i = 0; i < wRoles.length; ++i) {
                        // In the case that the role key is not already in the roleToElems hash, construct the
                        // add the key and assign empty array.
                        if (!(wRoles[i] in roleToElems)) {
                            roleToElems[wRoles[i]] = [];
                        }
                        // Add the node to the array for the role
                        roleToElems[wRoles[i]].push(nw.node);
                    }
                }
            }
            // Set the roleToElems hash map as a global variable
            if (considerImplicitRoles) {
                RPTUtil.setCache(doc, "RPTUtil_GETELEMENTSBY_ROLE_IMPLICIT", roleToElems);
            }
            else {
                RPTUtil.setCache(doc, "RPTUtil_GETELEMENTSBY_ROLE", roleToElems);
            }
        }
        // Initilize the return value
        var retVal = [];
        // Handle the cases where the provided role is a string and not an array,
        // for this case we take the string and put it into an array
        if (typeof (roles) == "string") {
            var role = roles;
            roles = [];
            roles.push(role);
        }
        // Loop through the roles that were provided and find the list of elements for this roles
        // and add them to the return value.
        if (roles.length) {
            // loop over all the roles
            for (var i = 0; i < roles.length; ++i) {
                // Extract the role from the array
                var nextRole = roles[i];
                // Fetch the list of all the elements for this role
                var copyRoles = roleToElems[nextRole];
                // If there are elements to copy to another array, then perform the copy
                if (copyRoles) {
                    // Loop over all the elements which are to be copied
                    for (var j = 0; j < copyRoles.length; ++j) {
                        // Add this element to the return val
                        retVal.push(copyRoles[j]);
                    }
                }
            }
        }
        return retVal;
    };
    /**
     * This function is responsible for retrieving element's roles.
     * This function aslo finds implicit roles.
     * @parm {HTMLElement} ele - element for which to find role.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {List} roles - list of attribute roles and implicit roles.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getRoles = function (ele, considerImplicitRoles) {
        var roles = [];
        if (ele && ele.hasAttribute && ele.hasAttribute("role")) {
            var attrRoles = RPTUtil.normalizeSpacing(ele.getAttribute("role").trim()).split(" ");
            for (var i = 0; i < attrRoles.length; ++i) {
                roles.push(attrRoles[i]);
            }
        }
        //check if implicit roles exist.
        //Note: element can have multiple implicit roles
        if (considerImplicitRoles) {
            var implicitRole = RPTUtil.getImplicitRole(ele);
            if (implicitRole.length > 0) {
                //add implicit roles to the attributes roles.
                RPTUtil.concatUniqueArrayItemList(implicitRole, roles);
            }
        }
        return roles;
    };
    /**
     * Returns the implicit role of the elemement
     * @parm {HTMLElement} ele - element for which to find role.
     *
     * @return the implicit role or [] if doesn't exist
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getImplicitRole = function (ele) {
        var tagProperty = RPTUtil.getElementAriaProperty(ele);
        //check if there are any implicit roles for this element.
        if (tagProperty) {
            if (tagProperty.implicitRole) {
                return tagProperty.implicitRole;
            }
        }
        return [];
    };
    /**
     * Returns the required properties of the role
     * @parm {string} role - the role
     * @parm {HTMLElement} ele - element for which to find role.
     *
     * @return {List} properties - list of properties that are required by the role
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getRoleRequiredProperties = function (role, ele) {
        if (role == null) {
            return null;
        }
        if (ARIADefinitions_1.ARIADefinitions.designPatterns[role]) {
            // handle special case of separator
            if (role.toLowerCase() === "separator") {
                if (RPTUtil.isFocusable(ele)) {
                    return ARIADefinitions_1.ARIADefinitions.designPatterns[role].reqProps;
                }
                return null;
            }
            return ARIADefinitions_1.ARIADefinitions.designPatterns[role].reqProps;
        }
        else {
            return null;
        }
    };
    /**
     * Test if the ele node is focusable
     */
    RPTUtil.isFocusable = function (ele) {
        if (ele === "undefined" || ele == null) {
            return false;
        }
        return RPTUtil.isTabbable(ele);
    };
    /**
     * This function is responsible for finding if a element has given role.
     * This function aslo finds if element has give roles as implicit role.
     * @parm {HTMLElement} ele - element for which to find role.
     * @parm {list or string} roles - List or single role for which to find if element has these roles.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {List} retVal - true or false based on if th element has the specified role.
     *
     * @memberOf RPTUtil
     *
     * Consider to use hasRoleInSemantics() instead.
     */
    RPTUtil.hasRole = function (ele, role, considerImplicitRoles) {
        var retVal = false;
        if (ele && ele.hasAttribute && ele.hasAttribute("role")) {
            if (typeof (role) != typeof ("")) {
                var roles = ele.getAttribute("role").trim().split(" ");
                for (var i = 0; !retVal && i < roles.length; ++i) {
                    retVal = roles[i] in role;
                }
            }
            else {
                var roles = ele.getAttribute("role").trim().split(" ");
                for (var i = 0; !retVal && i < roles.length; ++i) {
                    retVal = roles[i] == role;
                }
            }
        }
        //if none of the the attribute roles matched with given role
        //check if implicit roles matches.
        //Note: element can have multiple implicit roles
        if (!retVal && considerImplicitRoles) {
            var tagProperty = RPTUtil.getElementAriaProperty(ele);
            var wRoles = [];
            //check if there are any implicit roles for this element.
            if (tagProperty && tagProperty.implicitRole !== null) {
                //add implicit roles to the attributes roles.
                RPTUtil.concatUniqueArrayItemList(tagProperty.implicitRole, wRoles);
                //if role is array loop thru and see if any  of the implicit role present in the array
                if (typeof (role) != typeof ("")) {
                    for (var i = 0; !retVal && i < wRoles.length; ++i) {
                        retVal = wRoles[i] in role;
                    }
                }
                else {
                    for (var i = 0; !retVal && i < wRoles.length; ++i) {
                        retVal = wRoles[i] == role;
                    }
                }
            }
        }
        return retVal;
    };
    /**
     * Checks if the element has the role, including the implied role if role is not explicitly specified.
     *
     * This function is replacing the hasRole function
     *
     * @parm {HTMLElement} ele - element for which to find role.
     * @parm {list or string} roles - List or single role for which to find if element has these roles.
     *
     * @return {List} retVal - true or false based on if the element has the specified role.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.hasRoleInSemantics = function (ele, role) {
        var retVal = false;
        var roleSpecified = false;
        if (ele && ele.hasAttribute && ele.hasAttribute("role")) {
            if (typeof (role) != typeof ("")) {
                var roles = ele.getAttribute("role").trim().toLowerCase().split(/\s+/);
                for (var i = 0; !retVal && i < roles.length; ++i) {
                    roleSpecified = true;
                    retVal = roles[i] in role;
                }
            }
            else {
                var roles = ele.getAttribute("role").trim().toLowerCase().split(/\s+/);
                for (var i = 0; !retVal && i < roles.length; ++i) {
                    roleSpecified = true;
                    retVal = roles[i] == role;
                }
            }
        }
        if (roleSpecified) {
            return retVal;
        }
        //check if implicit roles matches.
        //Note: element can have multiple implicit roles
        var tagProperty = RPTUtil.getElementAriaProperty(ele);
        //check if there are any implicit roles for this element.
        if (tagProperty && tagProperty.implicitRole !== null) {
            var impRoles = tagProperty.implicitRole;
            //if role is array loop thru and see if any  of the implicit role present in the array
            if (typeof (role) != typeof ("")) {
                for (var i = 0; !retVal && i < impRoles.length; ++i) {
                    retVal = impRoles[i] in role;
                }
            }
            else {
                for (var i = 0; !retVal && i < impRoles.length; ++i) {
                    retVal = impRoles[i] == role;
                }
            }
        }
        return retVal;
    };
    /**
     * This function is responsible for finding if a element has given role.
     * This function also checks if element has given roles as implicit roles.
     * @parm {HTMLElement} ele - element for which to find role.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {bool} retVal - true or false based on if the element has the specified role.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.hasAnyRole = function (ele, considerImplicitRoles) {
        var retVal = false;
        if (ele && ele.hasAttribute && ele.hasAttribute("role")) {
            retVal = true;
        }
        //check if implicit roles exist.
        //Note: element can have multiple implicit roles
        if (!retVal && considerImplicitRoles) {
            var tagProperty = RPTUtil.getElementAriaProperty(ele);
            //check if there are any implicit roles for this element.
            if (tagProperty && tagProperty.implicitRole !== null &&
                tagProperty.implicitRole.length > 0) {
                retVal = true;
            }
        }
        return retVal;
    };
    RPTUtil.isDataTable = function (tableNode) {
        return !(RPTUtil.hasRole(tableNode, "none") || RPTUtil.hasRole(tableNode, "presentation"));
    };
    /*
     * A complex data table is a data table with any of the following characteristics:
     *
     * a thead element that contains two or more tr elements
     * a table with more than one thead element
     * a table with two or more tr elements that contain only th elements
     * a th or td element with a rowspan or colspan attribute
     * a tr element that contains at least one td element and two or more th elements
     * a table with headers not located in the first row or first column
     * a td element with a headers attribute value that contains more than two IDREFs
     */
    RPTUtil.isComplexDataTable = function (table) {
        if ("RPTUtil_isComplexDataTable" in table) {
            return !!table.RPTUtil_isComplexDataTable;
        }
        var isComplexTable = false;
        if (table && RPTUtil.isDataTable(table)) {
            var thNodes = null, tdNodes = null;
            var trNodes = table.getElementsByTagName("tr");
            var trNodeCount = trNodes.length;
            var tdNodeCount = 0, thNodeCount = 0, trNodesHavingOnlyThNodes = 0;
            for (var i = 0; !isComplexTable && i < trNodeCount; ++i) {
                thNodes = trNodes[i].getElementsByTagName("th");
                tdNodes = trNodes[i].getElementsByTagName("td");
                thNodeCount = thNodes.length;
                tdNodeCount = tdNodes.length;
                if (tdNodeCount !== 0) {
                    // a tr element that contains at least one td element and two or more th elements;
                    isComplexTable = thNodeCount > 1;
                    // a th element with a rowspan or colspan attribute
                    for (var j = 0; !isComplexTable && j < thNodeCount; ++j) {
                        isComplexTable = ((thNodes[j].hasAttribute("rowspan") ||
                            thNodes[j].hasAttribute("colspan")) &&
                            RPTUtil.getAncestor(thNodes[j], "table") == table);
                    }
                    // a td element with a rowspan or colspan attribute
                    // a td element with a headers attribute value that contains more than two IDREFs
                    for (var k = 0; !isComplexTable && k < tdNodeCount; ++k) {
                        isComplexTable = ((tdNodes[k].hasAttribute("rowspan") ||
                            tdNodes[k].hasAttribute("colspan") ||
                            (tdNodes[k].hasAttribute("headers") && RPTUtil.normalizeSpacing(tdNodes[k].getAttribute("headers")).split(" ").length > 2)) &&
                            RPTUtil.getAncestor(tdNodes[k], "table") == table);
                    }
                }
                else {
                    // two or more tr elements that contain only th elements
                    if (thNodeCount > 0) {
                        ++trNodesHavingOnlyThNodes;
                    }
                    isComplexTable = trNodesHavingOnlyThNodes == 2;
                }
            }
            if (!isComplexTable) {
                var theadNodes = table.getElementsByTagName("thead");
                var theadNodesLength = theadNodes.length;
                if (theadNodesLength > 0) {
                    // table has more than one thead element
                    isComplexTable = theadNodesLength > 1;
                    // a thead element that contains two or more tr elements
                    if (!isComplexTable) {
                        isComplexTable = theadNodes[0].getElementsByTagName("tr").length > 1;
                    }
                }
            }
            if (!isComplexTable && trNodeCount !== 0) {
                // a table with headers not located in the first row or first column
                isComplexTable = thNodeCount > 0 && !RPTUtil.isTableHeaderInFirstRowOrColumn(table);
            }
        }
        table.RPTUtil_isComplexDataTable = isComplexTable;
        return isComplexTable;
    };
    // Return true if a table's header is in the first row or column
    RPTUtil.isTableHeaderInFirstRowOrColumn = function (ruleContext) {
        var passed = false;
        var rows = ruleContext.rows;
        // Check if the first row is all TH's
        if (rows != null && rows.length > 0) {
            var firstRow = rows[0];
            passed = firstRow.cells.length > 0 && RPTUtil.getChildByTagHidden(firstRow, "td", false, true).length == 0;
            // If the first row isn't a header row, try the first column
            if (!passed) {
                // Assume that the first column has all TH's unless we find a TD in the first column.
                passed = true;
                for (var i = 0; passed && i < rows.length; ++i) {
                    // If no cells in this row, that's okay too.
                    passed = !rows[i].cells ||
                        rows[i].cells.length == 0 ||
                        rows[i].cells[0].nodeName.toLowerCase() != "td";
                }
            }
            if (!passed) {
                // Special case - both first row and first column are headers, but they did not use
                // a th for the upper-left cell
                passed = true;
                for (var i = 1; passed && i < firstRow.cells.length; ++i) {
                    passed = firstRow.cells[i].nodeName.toLowerCase() != "td";
                }
                for (var i = 1; passed && i < rows.length; ++i) {
                    // If no cells in this row, that's okay too.
                    passed = !rows[i].cells ||
                        rows[i].cells.length == 0 ||
                        rows[i].cells[0].nodeName.toLowerCase() != "td";
                }
            }
        }
        return passed;
    };
    RPTUtil.isNodeInGrid = function (node) {
        return RPTUtil.getAncestorWithRole(node, "grid") != null;
    };
    RPTUtil.isLayoutTable = function (tableNode) {
        return RPTUtil.hasRole(tableNode, "presentation") || RPTUtil.hasRole(tableNode, "none");
    };
    RPTUtil.getFileExt = function (url) {
        var m = url.match(/\.(([^;?#\.]|^$)+)([;?#]|$)/);
        if (m != null && m.length >= 2) {
            return "." + m[1];
        }
        return "";
    };
    RPTUtil.getFileAnchor = function (url) {
        var m = url.match(/#(([^;?\.]|^$)+)([;?]|$)/);
        if (m != null && m.length >= 2) {
            return m[1];
        }
        return "";
    };
    RPTUtil.checkObjEmbed = function (node, extTest, mimeTest) {
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName != "object" && nodeName != "embed" &&
            nodeName != "a" && nodeName != "area")
            return false;
        var retVal = false;
        // Check mime type
        if (!retVal && node.hasAttribute("type")) {
            var mime = node.getAttribute("type").toLowerCase();
            retVal = mimeTest(mime);
        }
        if (!retVal && node.hasAttribute("codetype")) {
            var mime = node.getAttribute("codetype");
            retVal = mimeTest(mime);
        }
        // Check the filename
        if (!retVal) {
            var filename = "";
            if (nodeName == "embed") {
                filename = node.getAttribute("src");
            }
            else if (nodeName == "a" || nodeName == "area") {
                filename = node.getAttribute("href");
            }
            else if (node.hasAttribute("data")) {
                filename = node.getAttribute("data");
            }
            if (filename == null)
                filename = "";
            var ext = RPTUtil.getFileExt(filename);
            retVal = extTest(ext);
        }
        // Check for filenames in the params
        if (!retVal && nodeName == "object") {
            // In the case that Check Hidden Option is set then comply with that setting
            var params = RPTUtil.getChildByTagHidden(node, "param", false, true);
            for (var i = 0; !retVal && params != null && i < params.length; ++i) {
                retVal = params[i].hasAttribute("value") &&
                    extTest(RPTUtil.getFileExt(params[i].getAttribute("value")));
            }
        }
        return retVal;
    };
    RPTUtil.isAudioObjEmbedLink = function (node) {
        return RPTUtil.checkObjEmbed(node, RPTUtil.isAudioExt, function (mime) {
            return mime.startsWith("audio");
        });
    };
    RPTUtil.isAudioExt = function (ext) {
        var audio_extensions = [".aif", ".aifc", ".aiff", ".air", ".asf", ".au", ".cda",
            ".dsm", ".dss", ".dwd", ".iff", ".kar", ".m1a", ".med",
            ".mp2", ".mp3", ".mpa", ".pcm", ".ra", ".ram", ".rm",
            ".sam", ".sf", ".sf2", ".smp", ".snd", ".svx", ".ul",
            ".voc", ".wav", ".wma", ".wve"
        ];
        return RPTUtil.valInArray(ext.toLowerCase(), audio_extensions);
    };
    RPTUtil.isVideoObjEmbedLink = function (node) {
        return RPTUtil.checkObjEmbed(node, RPTUtil.isVideoExt, function (mime) {
            return mime.startsWith("video") ||
                mime.startsWith("application/x-shockwave-flash");
        });
    };
    RPTUtil.isVideoExt = function (ext) {
        var video_extensions = [".asf", ".avi", ".divx", ".dv", ".m1v", ".m2p", ".m2v", ".moov",
            ".mov", ".mp4", ".mpeg", ".mpg", ".mpv", ".ogm", ".omf", ".qt",
            ".rm", ".rv", ".smi", ".smil", ".swf", ".vob", ".wmv", ".rmvb",
            ".mvb"
        ];
        return RPTUtil.valInArray(ext.toLowerCase(), video_extensions);
    };
    RPTUtil.isImageObjEmbedLink = function (node) {
        return RPTUtil.checkObjEmbed(node, RPTUtil.isImgExt, function (mime) {
            return mime.startsWith("image");
        });
    };
    RPTUtil.isImgExt = function (ext) {
        var image_extensions = [".bmp", ".gif", ".jpg", ".jpeg", ".pcx", ".png"];
        return RPTUtil.valInArray(ext.toLowerCase(), image_extensions);
    };
    RPTUtil.isHtmlExt = function (ext) {
        var html_extensions = [".asp", ".aspx", ".cfm", ".cfml", ".cgi", ".htm", ".html", ".shtm",
            ".shtml", ".php", ".pl", ".py", ".shtm", ".shtml", ".xhtml"
        ];
        return RPTUtil.valInArray(ext.toLowerCase(), html_extensions);
    };
    RPTUtil.isPresentationalElement = function (node) {
        // Elements extracted from https://developer.mozilla.org/en/docs/Web/HTML/Element#Inline_text_semantics,
        // http://dev.w3.org/html5/html-author/#text-level-semantics and https://wiki.whatwg.org/wiki/Presentational_elements_and_attributes
        var presentationalElements = ["abbr", "b", "bdi", "bdo", "br", "cite", "code", "data", "dfn",
            "em", "i", "kbd", "mark", "q", "rp", "rt", "rtc", "ruby", "s",
            "samp", "small", "span", "strong", "sub", "sup", "time", "u",
            "var", "wbr", "a", "progress", "meter", "basefont", "big", "center",
            "strike", "tt", "font", "blink", "h1", "h2", "h3", "h4", "h5", "h6",
            "hr", "blockquote", "p"
        ];
        return RPTUtil.valInArray(node.nodeName.toLowerCase(), presentationalElements);
    };
    RPTUtil.hasTriggered = function (doc, id) {
        return RPTUtil.getCache(doc, id, false);
    };
    RPTUtil.triggerOnce = function (doc, id, passed) {
        if (passed)
            return true;
        var triggered = RPTUtil.getCache(doc, id, false);
        RPTUtil.setCache(doc, id, true);
        return triggered;
    };
    /* determine if the given value exists in the given array */
    RPTUtil.valInArray = function (value, arr) {
        for (var idx in arr) {
            if (arr[idx] == value)
                return true;
        }
        return false;
    };
    /**
     * return the ancestor of the given element
     * @param tagNames string, array, or dictionary containing the tags to search for
     */
    RPTUtil.getAncestor = function (element, tagNames) {
        var walkNode = element;
        while (walkNode != null) {
            var thisTag = walkNode.nodeName.toLowerCase();
            if (typeof (tagNames) == "string") {
                if (thisTag == tagNames.toLowerCase()) {
                    break;
                }
            }
            else if (tagNames.length) {
                for (var idx in tagNames) {
                    //                        Packages.java.lang.System.err.println(thisTag + ":" + tagNames[idx] + ":" + (tagNames[idx] == thisTag));
                    if (tagNames[idx] == thisTag)
                        return walkNode;
                }
            }
            else if (thisTag in tagNames) {
                break;
            }
            walkNode = walkNode.parentNode;
        }
        return walkNode;
    };
    // return true if element1 and element2 are siblings
    RPTUtil.isSibling = function (element1, element2) {
        if (element1 && element2) {
            var node = null;
            if (element1.parentNode && element1.parentNode.firstChild)
                node = element1.parentNode.firstChild;
            while (node) {
                if (node === element2)
                    return true;
                node = node.nextSibling;
            }
        }
        return false;
    };
    /**
     * return the ancestor of the given element and role.
     *
     * @parm {element} element - The element to start the node walk on to find parent node
     * @parm {string} role - The role to search for on an element under the provided element
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node} walkNode - A parent node of the element passed in, which has the provided role
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getAncestorWithRole = function (element, roleName, considerImplicitRoles) {
        var walkNode = element;
        while (walkNode != null) {
            if (considerImplicitRoles) {
                if (RPTUtil.hasRoleInSemantics(walkNode, roleName)) {
                    break;
                }
            }
            else {
                if (RPTUtil.hasRole(walkNode, roleName, false)) {
                    break;
                }
            }
            walkNode = walkNode.parentNode;
        }
        return walkNode;
    };
    /**
     * This function is responsible for finding a node which matches the role and is a sibling of the
     * provided element.
     *
     * This function by default will not consider Check Hidden Setting at all.
     *
     * Note: This is a wrapper function to: RPTUtil.getSiblingWithRoleHidden
     *
     * @parm {element} element - The element to start the node walk on to find sibling node
     * @parm {string} role - The role to search for on an element under the provided element
     *
     * @return {node} walkNode - A sibling node of the element passed in, which has the provided role
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getSiblingWithRole = function (element, role) {
        return RPTUtil.getSiblingWithRoleHidden(element, role, false);
    };
    /**
     * This function is responsible for finding a node which matches the role and is a sibling of the
     * provided element.
     *
     * This function also considers implicit roles for the elements.
     *
     * This function will also consider elements that are hidden based on the if the Check
     * Hidden Content settings should be considered or not.
     *
     * @parm {element} element - The element to start the node walk on to find sibling node
     * @parm {string} role - The role to search for on an element under the provided element
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicit - true or false based on if Implicit roles should be considered.
     *
     * @return {node} walkNode - A sibling node of the element passed in, which has the provided role
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getSiblingWithRoleHidden = function (element, role, considerHiddenSetting, considerImplicitRole) {
        // Variable Declaration
        var walkNode = null;
        var hasRole = false;
        // Only perform the check if element and role are both provided
        if (element && role) {
            // Fetch the next sibling element
            walkNode = element.nextSibling;
            // Keep looping over the next siblings to find element which matches
            // the provided role.
            while (walkNode != null && !hasRole) {
                // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                // or not.
                //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
                //     Check Hidden Content that is provided.
                //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                //     add it to the roleToElems hash at all or even do any checking for it at all.
                //
                // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                //       so on and so forth.
                if (considerHiddenSetting && RPTUtil.shouldNodeBeSkippedHidden(walkNode)) {
                    // Move on to the next node
                    walkNode = walkNode.nextSibling;
                    continue;
                }
                // Check if this node has the role that we need to check exists
                if (considerImplicitRole) {
                    hasRole = RPTUtil.hasRoleInSemantics(walkNode, role);
                }
                else {
                    hasRole = RPTUtil.hasRole(walkNode, role, false);
                }
                // Move on to the next node
                walkNode = walkNode.nextSibling;
            }
            // If we still have not found a node that matches the role, start a reverse look up
            if (!walkNode) {
                // Fetch the previous Sibling of this element
                walkNode = element.previousSibling;
                // Keep looping over all the previous siblings to search for an element which
                // matches the provided role.
                while (walkNode != null && !hasRole) {
                    // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                    // or not.
                    //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
                    //     Check Hidden Content that is provided.
                    //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                    //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                    //     add it to the roleToElems hash at all or even do any checking for it at all.
                    //
                    // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                    //       so on and so forth.
                    if (considerHiddenSetting && RPTUtil.shouldNodeBeSkippedHidden(walkNode)) {
                        // Move on to the next node
                        walkNode = walkNode.previousSibling;
                        continue;
                    }
                    // Check if this node has the role that we need to check exists
                    hasRole = RPTUtil.hasRole(walkNode, role, considerImplicitRole);
                    // Move on to the next node
                    walkNode = walkNode.previousSibling;
                }
            }
        }
        return walkNode;
    };
    RPTUtil.isDescendant = function (parent, child) {
        var node = child.parentNode;
        while (node != null) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    };
    /**
     * This function is responsible for getting a descendant element with the specified role, under
     * the element that was provided.
     *
     * Note by default this function will not consider the Check Hidden Content Setting.
     *
     * Note: This is a wrapper function to: RPTUtil.getDescendantWithRoleHidden
     *
     * @parm {element} element - parent element for which we will be checking descendants for
     * @parm {string} roleName - The role to look for on the descendants elements
     *
     * @return {node} - The descendant element that matches the role specified (only one)
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getDescendantWithRole = function (element, roleName) {
        return RPTUtil.getDescendantWithRoleHidden(element, roleName, false);
    };
    /**
     * This function is responsible for getting a descendant element with the specified role, under
     * the element that was provided. This function aslo finds elements with implicit roles.
     *
     * @parm {element} element - parent element for which we will be checking descendants for
     * @parm {string} roleName - The role to look for on the descendants elements
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node} - The descendant element that matches the role specified (only one)
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getDescendantWithRoleHidden = function (element, roleName, considerHiddenSetting, considerImplicitRoles) {
        // Variable Decleration
        var descendant = null;
        var nw = new NodeWalker(element);
        // Loop over all the childrens of the element provided and check if the rolename provided exists
        while (nw.nextNode() && nw.node != element && nw.node != element.nextSibling) {
            // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
            // or not.
            //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
            //     Check Hidden Content that is provided.
            //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
            //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
            //     add it to the roleToElems hash at all or even do any checking for it at all.
            //
            // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
            //       so on and so forth.
            if (considerHiddenSetting && RPTUtil.shouldNodeBeSkippedHidden(nw.node)) {
                continue;
            }
            // Check if this node has the role specified, if it does then set this as the descendant and stop checking the rest of the
            // nodes.
            // Check if this node has the implicit roles, if it does then set this as the descendant and stop checking the rest of the
            // nodes.
            if (considerImplicitRoles ? RPTUtil.hasRoleInSemantics(nw.node, roleName) : RPTUtil.hasRole(nw.node, roleName, false)) {
                descendant = nw.node;
                break;
            }
        }
        return descendant;
    };
    /**
     * This function is responsible for getting a All descendant elements with the specified role, under
     * the element that was provided. This function aslo finds elements with implicit roles.
     *
     * @parm {element} element - parent element for which we will be checking descendants for
     * @parm {string} roleName - The role to look for on the descendants elements
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node} - The descendant element that matches the role specified (only one)
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getAllDescendantsWithRoleHidden = function (element, roleName, considerHiddenSetting, considerImplicitRoles) {
        // Variable Decleration
        var descendants = [];
        var nw = new NodeWalker(element);
        // Loop over all the childrens of the element provided and check if the rolename provided exists
        while (nw.nextNode() && nw.node != element && nw.node != element.nextSibling) {
            if (nw.bEndTag) {
                continue;
            }
            // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
            // or not.
            //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
            //     Check Hidden Content that is provided.
            //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
            //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
            //     add it to the roleToElems hash at all or even do any checking for it at all.
            //
            // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
            //       so on and so forth.
            if (considerHiddenSetting && RPTUtil.shouldNodeBeSkippedHidden(nw.node)) {
                continue;
            }
            // Check if this node has the role specified, if it does then set this as the descendant and stop checking the rest of the
            // nodes.
            // Check if this node has the implicit roles, if it does then set this as the descendant and stop checking the rest of the
            // nodes.
            if (RPTUtil.hasRole(nw.node, roleName, considerImplicitRoles)) {
                descendants.push(nw.node);
            }
        }
        return descendants;
    };
    /**
     * This function is responsible for getting an element referenced by aria-owns and has the
     * role that was specified.
     *
     * Note by default this function will not consider the Check Hidden Content Setting.
     *
     * Note: This is a wrapper function to: RPTUtil.getAriaOwnsWithRoleHidden
     *
     * @parm {element} element - Element to check for aria-owns
     * @parm {string} roleName - The role to look for on the aria-owns element
     *
     * @return {node} - The element that is referenced by aria-owns and has role specified.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getAriaOwnsWithRole = function (element, roleName) {
        return RPTUtil.getAriaOwnsWithRoleHidden(element, roleName, false);
    };
    /**
     * This function is responsible for getting an element referenced by aria-owns and has the
     * role that was specified. This function aslo finds elements with implicit roles.
     *
     * @parm {element} element - Element to check for aria-owns
     * @parm {string} roleName - The role to look for on the aria-owns element
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node} - The element that is referenced by aria-owns and has role specified.
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getAriaOwnsWithRoleHidden = function (element, roleName, considerHiddenSetting, considerImplicitRoles) {
        // Variable Decleration
        var referencedElement = null;
        var referencedElemHasRole = false;
        // In the case aria-owns is not on the element just break out of this function with null
        if (RPTUtil.attributeNonEmpty(element, "aria-owns")) {
            // Get the reference ID
            var referenceID = element.getAttribute("aria-owns");
            // Get the element for the reference ID
            referencedElement = element.ownerDocument.getElementById(referenceID);
            // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
            // or not.
            //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
            //     Check Hidden Content that is provided.
            //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
            //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
            //     add it to the roleToElems hash at all or even do any checking for it at all.
            if (considerHiddenSetting && referencedElement != null && RPTUtil.shouldNodeBeSkippedHidden(referencedElement)) {
                referencedElemHasRole = null;
            }
            else {
                referencedElemHasRole = RPTUtil.hasRole(referencedElement, roleName, considerImplicitRoles);
            }
        }
        return referencedElemHasRole ? referencedElement : null;
    };
    /** get element containing label for the given element
     * @deprecated Deprecated because the function name is misleading. Use getLabelForElement(element) instead
     */
    RPTUtil.getInputLabel = function (element) {
        return RPTUtil.getLabelForElement(element);
    };
    /**
     * This function is responsible for getting the element containing the label for the given element.
     *
     * Note: This is a wrapper function to: RPTUtil.getLabelForElementHidden
     *
     * @parm {element} element - The element for which to get the label element for.
     *
     * @return {element} element - return the element for the label, otherwise null
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getLabelForElement = function (element) {
        return RPTUtil.getLabelForElementHidden(element, false);
    };
    /**
     * This function is responsible for getting the element containing the label for the given element.
     *
     * This function will return null if the containing lable element is hidden, when the ignoreHidden option
     * is set to true.
     *
     * @parm {element} element - The element for which to get the label element for.
     * @parm {boolean} ignoreHidden - true if hidden elements with label should be ignored from the list
     *                                false if the hidden elements should be added
     *
     * @return {element} element - return the element for the label, otherwise null
     *
     * @memberOf RPTUtil
     */
    RPTUtil.getLabelForElementHidden = function (element, ignoreHidden) {
        // Check if the global RPTUtil_LABELS hash is available, as this will contain the label nodes based on
        // for attribute.
        if (!RPTUtil.getCache(element.ownerDocument, "RPTUtil_LABELS", null)) {
            // Variable Decleration
            var idToLabel = {};
            // Get all the label elements in the entire doc
            var labelNodes = RPTUtil.getDocElementsByTag(element, "label");
            // Loop over all the label nodes, in the case the label node has a for attribute,
            // extract that attribute and add this node to the hash if it is visible.
            for (var i = 0; i < labelNodes.length; ++i) {
                if (labelNodes[i].hasAttribute("for")) {
                    // If ignore hidden is specified and the node is not visible we do not add it to the
                    // labelNodes hash.
                    if (ignoreHidden && !RPTUtil.isNodeVisible(labelNodes[i])) {
                        continue;
                    }
                    idToLabel[labelNodes[i].getAttribute("for")] = labelNodes[i];
                }
            }
            // Add the built hash to the ownerDocument (document), to be used later to fast retrival
            RPTUtil.setCache(element.ownerDocument, "RPTUtil_LABELS", idToLabel);
        }
        // If this element has an id attribute, get the corosponding label element
        if (element.hasAttribute("id")) {
            // Fetch the id attribute
            var ctrlId = element.getAttribute("id");
            // Return the corosponding label element.
            // Note: in the case that the the id is not found in the hash that means, it does not exists or is hidden
            if (ctrlId.trim().length > 0) {
                return RPTUtil.getCache(element.ownerDocument, "RPTUtil_LABELS", {})[ctrlId];
            }
        }
        return null;
    };
    /* Return specified element attribute if present else return null */
    RPTUtil.getElementAttribute = function (element, attr) {
        return (element && element.hasAttribute && element.hasAttribute(attr)) ? element.getAttribute(attr) : null;
    };
    // Return true if the element has an ARIA label
    RPTUtil.hasAriaLabel = function (element) {
        // Rpt_Aria_ValidIdRef determines if the aria-labelledby id points to a valid element
        return RPTUtil.attributeNonEmpty(element, "aria-label") || RPTUtil.attributeNonEmpty(element, "aria-labelledby");
    };
    // Return true if element has valid implicit label
    RPTUtil.hasImplicitLabel = function (element) {
        var parentNode = element.parentNode;
        // Test  a) if the parent is a label which is the implicit label
        //       b) if the form element is the first child of the label
        //       c) if the form element requires an implicit or explicit label : "input",  "textarea", "select", "keygen", "progress", "meter", "output"
        // form elements that do not require implicit or explicit label element are:
        // "optgroup", "option", "datalist"(added later). These were handled differently in the main rule, might need to refactor the code later
        if (parentNode.tagName.toLowerCase() === "label" && RPTUtil.isFirstFormElement(parentNode, element)) {
            var parentClone = parentNode.cloneNode(true);
            // exclude all form elements from the label since they might also have inner content
            parentClone = RPTUtil.removeAllFormElementsFromLabel(parentClone);
            return RPTUtil.hasInnerContentHidden(parentClone);
        }
        else
            return false;
    };
    RPTUtil.isFirstFormElement = function (parentNode, element) {
        var formElementsRequiringLabel = ["input", "textarea", "select", "keygen", "progress", "meter", "output"];
        var childNodes = parentNode.childNodes;
        for (var i = 0; i < childNodes.length; i++) {
            if (formElementsRequiringLabel.indexOf(childNodes[i].nodeName.toLowerCase()) === -1)
                continue;
            else if (childNodes[i] !== element)
                return false;
            else
                return true;
        }
        return false;
    };
    RPTUtil.removeAllFormElementsFromLabel = function (element) {
        var formElements = ["input", "textarea", "select", "button", "datalist", "optgroup", "option", "keygen", "output", "progress", "meter"];
        var childNodes = element.childNodes;
        for (var i = 0; i < childNodes.length; i++) {
            if (formElements.indexOf(childNodes[i].nodeName.toLowerCase()) > -1) {
                element.removeChild(childNodes[i]);
            }
        }
        return element;
    };
    // Given an array of elements, return true if the elements have unique ARIA labels
    RPTUtil.hasUniqueAriaLabelsLocally = function (elements, isGlobal) {
        if (elements.length === 0)
            return false;
        var doc = elements[0].ownerDocument;
        var hasDuplicateLabels = false;
        var uniqueAriaLabels = null;
        if (isGlobal) {
            uniqueAriaLabels = RPTUtil.getCache(doc, "RPTUtil_HAS_UNIQUE_ARIA_LABELS", null);
        }
        if (uniqueAriaLabels == null) {
            uniqueAriaLabels = {};
        }
        for (var i = 0; !hasDuplicateLabels && i < elements.length; ++i) {
            if (elements[i].hasAttribute) {
                if (elements[i].hasAttribute("aria-label")) {
                    var ariaLabel = RPTUtil.normalizeSpacing(elements[i].getAttribute("aria-label")).toLowerCase();
                    hasDuplicateLabels = ariaLabel in uniqueAriaLabels;
                    uniqueAriaLabels[ariaLabel] = true;
                }
                else if (elements[i].hasAttribute("aria-labelledby")) {
                    var labelID = elements[i].getAttribute("aria-labelledby");
                    var labelNode = elements[i].ownerDocument.getElementById(labelID);
                    var label = labelNode ? RPTUtil.getInnerText(labelNode) : "";
                    var normalizedLabel = RPTUtil.normalizeSpacing(label).toLowerCase();
                    hasDuplicateLabels = normalizedLabel in uniqueAriaLabels;
                    uniqueAriaLabels[normalizedLabel] = true;
                }
                else {
                    // Has no label at all
                    hasDuplicateLabels = true;
                }
            }
        }
        if (isGlobal) {
            RPTUtil.setCache(doc, "RPTUtil_HAS_UNIQUE_ARIA_LABELS", uniqueAriaLabels);
        }
        return !hasDuplicateLabels;
    };
    RPTUtil.getAriaLabel = function (ele) {
        if (ele.hasAttribute) {
            if (ele.hasAttribute("aria-labelledby")) {
                var labelIDs = ele.getAttribute("aria-labelledby").trim().split(" ");
                var normalizedLabel = "";
                for (var j = 0, length_1 = labelIDs.length; j < length_1; ++j) {
                    var labelID = labelIDs[j];
                    var labelNode = ele.ownerDocument.getElementById(labelID);
                    var label = labelNode ? RPTUtil.getInnerText(labelNode) : "";
                    normalizedLabel += RPTUtil.normalizeSpacing(label).toLowerCase();
                }
                return normalizedLabel.trim();
            }
            else if (ele.hasAttribute("aria-label")) {
                return RPTUtil.normalizeSpacing(ele.getAttribute("aria-label")).toLowerCase().trim();
            }
        }
        if (ele.nodeName.toLowerCase() === "input") {
            var label = RPTUtil.getLabelForElement(ele);
            if (!label)
                return "";
            return (RPTUtil.getAriaLabel(label) || label.innerText || "").trim();
        }
        return "";
    };
    RPTUtil.findAriaLabelDupes = function (elements) {
        var dupeMap = {};
        elements.forEach(function (ele) {
            dupeMap[RPTUtil.getAriaLabel(ele)] = (dupeMap[RPTUtil.getAriaLabel(ele)] || 0) + 1;
        });
        return dupeMap;
    };
    // Given an array of elements, return true if the elements have unique ARIA labels globally
    RPTUtil.hasUniqueAriaLabels = function (elements) {
        return RPTUtil.hasUniqueAriaLabelsLocally(elements, true);
    };
    // Given an array of elements, return true if the elements have unique ARIA labels
    RPTUtil.hasDuplicateAriaLabelsLocally = function (elements, isGlobal) {
        if (elements.length === 0)
            return false;
        var doc = elements[0].ownerDocument;
        var hasDuplicateLabels = false;
        var uniqueAriaLabels = null;
        var duplicateLabelNameArray = new Array();
        if (isGlobal) {
            uniqueAriaLabels = RPTUtil.getCache(doc, "RPTUtil_HAS_UNIQUE_ARIA_LABELS", null);
        }
        if (uniqueAriaLabels == null) {
            uniqueAriaLabels = {};
        }
        for (var i = 0; i < elements.length; ++i) {
            if (elements[i].hasAttribute) {
                if (elements[i].hasAttribute("aria-label")) {
                    var ariaLabel = RPTUtil.normalizeSpacing(elements[i].getAttribute("aria-label")).toLowerCase();
                    hasDuplicateLabels = ariaLabel in uniqueAriaLabels;
                    uniqueAriaLabels[ariaLabel] = true;
                    if (!(ariaLabel in duplicateLabelNameArray)) {
                        duplicateLabelNameArray[ariaLabel] = new Array();
                    }
                    duplicateLabelNameArray[ariaLabel].push(elements[i].nodeName.toLowerCase());
                }
                else if (elements[i].hasAttribute("aria-labelledby")) {
                    var labelIDs = elements[i].getAttribute("aria-labelledby").trim().split(" ");
                    var normalizedLabel = "";
                    for (var j = 0, length_2 = labelIDs.length; j < length_2; ++j) {
                        var labelID = labelIDs[j];
                        var labelNode = elements[i].ownerDocument.getElementById(labelID);
                        var label = labelNode ? RPTUtil.getInnerText(labelNode) : "";
                        normalizedLabel += RPTUtil.normalizeSpacing(label).toLowerCase();
                    }
                    hasDuplicateLabels = normalizedLabel in uniqueAriaLabels;
                    uniqueAriaLabels[normalizedLabel] = true;
                    if (!(normalizedLabel in duplicateLabelNameArray)) {
                        duplicateLabelNameArray[normalizedLabel] = new Array();
                    }
                    duplicateLabelNameArray[normalizedLabel].push(elements[i].nodeName.toLowerCase());
                }
            }
        }
        if (isGlobal) {
            RPTUtil.setCache(doc, "RPTUtil_HAS_UNIQUE_ARIA_LABELS", uniqueAriaLabels);
        }
        return duplicateLabelNameArray;
    };
    // Given an array of elements, return true if the elements have unique ARIA labels globally
    RPTUtil.hasDuplicateAriaLabels = function (elements) {
        return RPTUtil.hasDuplicateAriaLabelsLocally(elements, true);
    };
    // Given an array of elements, return true if the elements have unique aria-labelledby attributes
    RPTUtil.hasUniqueAriaLabelledby = function (elements) {
        var hasDuplicateLabels = false;
        var labelRefs = {};
        for (var i = 0; !hasDuplicateLabels && i < elements.length; ++i) {
            if (elements[i].hasAttribute && elements[i].hasAttribute("aria-labelledby")) {
                var labelRef = RPTUtil.normalizeSpacing(elements[i].getAttribute("aria-labelledby"));
                hasDuplicateLabels = labelRef in labelRefs;
                labelRefs[labelRef] = true;
            }
            else {
                hasDuplicateLabels = true;
            }
        }
        return !hasDuplicateLabels;
    };
    /* Determine the node depth of the given element */
    RPTUtil.nodeDepth = function (element) {
        var depth = 0;
        var walkNode = element;
        while (walkNode != null) {
            walkNode = walkNode.parentNode;
            depth = depth + 1;
        }
        return depth;
    };
    /* compare node order of the 2 given nodes */
    /* returns
     *   0 if the nodes are equal
     *   1 if node b is before node a
     *  -1 if node a is before node b
     *   2 if node a is nested in node b
     *  -2 if node b is nested in node a
     *   null if either node is null or their parent nodes are not equal
     */
    RPTUtil.compareNodeOrder = function (nodeA, nodeB) {
        if (nodeA == nodeB)
            return 0;
        var aDepth = RPTUtil.nodeDepth(nodeA);
        var bDepth = RPTUtil.nodeDepth(nodeB);
        if (bDepth > aDepth) {
            for (var i = 0; i < bDepth - aDepth; ++i)
                nodeB = nodeB.parentNode;
            if (nodeA == nodeB) // Node B nested in Node A
                return -2;
        }
        else if (aDepth > bDepth) {
            for (var i = 0; i < aDepth - bDepth; ++i)
                nodeA = nodeA.parentNode;
            if (nodeA == nodeB) // Node A nested in Node B
                return 2;
        }
        while (nodeA != null && nodeB != null && nodeA.parentNode != nodeB.parentNode) {
            nodeA = nodeA.parentNode;
            nodeB = nodeB.parentNode;
        }
        if (nodeA == null || nodeB == null || nodeA.parentNode != nodeB.parentNode)
            return null;
        while (nodeB != null && nodeB != nodeA)
            nodeB = nodeB.previousSibling;
        if (nodeB == null) // nodeB before nodeA
            return 1;
        else
            return -1;
    };
    /* Determine if given string is a valid language */
    RPTUtil.validLang = function (langStr) {
        return /^(([a-zA-Z]{2,3}(-[a-zA-Z](-[a-zA-Z]{3}){0,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-([0-9a-zA-Z]{5,8}|[0-9][a-zA-Z]{3}))*(-[0-9a-wy-zA-WY-Z](-[a-zA-Z0-9]{2,8})+)*(-x(-[a-zA-Z0-9]{1,8})+)?|x(-[a-zA-Z0-9]{1,8})+|(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE|art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))$/.test(langStr);
    };
    /**
     *  Determine if the given attribute of the given element is not empty
     *  @memberOf RPTUtil
     */
    RPTUtil.attributeNonEmpty = function (element, attrStr) {
        return element.hasAttribute(attrStr) && element.getAttribute(attrStr).trim().length > 0;
    };
    /* Return a pointer to the given global variable
     * with its initial value as given */
    RPTUtil.getCache = function (cacheSpot, keyName, initValue) {
        var cacheObj = (cacheSpot.nodeType === 9 /* Node.DOCUMENT_NODE */) ? cacheSpot : cacheSpot;
        if (cacheObj.aceCache == undefined) {
            cacheObj.aceCache = {};
        }
        if (cacheObj.aceCache[keyName] == undefined) {
            cacheObj.aceCache[keyName] = initValue;
        }
        return cacheObj.aceCache[keyName];
    };
    RPTUtil.setCache = function (cacheSpot, globalName, value) {
        var cacheObj = (cacheSpot.nodeType === 9 /* Node.DOCUMENT_NODE */) ? cacheSpot : cacheSpot;
        if (cacheObj.aceCache == undefined) {
            cacheObj.aceCache = {};
        }
        cacheObj.aceCache[globalName] = value;
        return value;
    };
    /* Return a pointer to the given frame, null if not found */
    RPTUtil.getFrameByName = function (ruleContext, frameName) {
        var window = ruleContext.ownerDocument.defaultView;
        var frameList = [window];
        var idx = 0;
        while (idx < frameList.length) {
            try {
                if (frameList[idx].name == frameName)
                    return frameList[idx];
                for (var i = 0; i < frameList[idx].frames.length; ++i) {
                    try {
                        // Ensure it's a real frame and avoid recursion
                        if (frameList[idx].frames[i] && !frameList.includes(frameList[idx].frames[i])) {
                            frameList.push(frameList[idx].frames[i]);
                        }
                    }
                    catch (e) { }
                }
            }
            catch (e) { }
            ++idx;
        }
        return null;
    };
    RPTUtil.defaultNSResolver = function (prefix) {
        var uri;
        switch (prefix) {
            case 'html':
                uri = 'http://www.w3.org/1999/xhtml';
            case 'x2':
                uri = 'http://www.w3.org/TR/xhtml2';
            case 'x':
                uri = 'http://www.w3.org/1999/xhtml';
            case 'xhtml':
                uri = 'http://www.w3.org/1999/xhtml';
            default:
                uri = null;
        }
        return uri;
    };
    //checking if only the inner text is empty or not
    RPTUtil.isInnerTextOnlyEmpty = function (element) {
        // Get the innerText of the element
        var text = element.innerText;
        if (text === undefined && element.textContent !== undefined) {
            // In headless mode,  innerText is sometimes 'undefined'
            // so we try textContent as a workaround
            text = element.textContent;
        }
        // Trim the inner text and verify that it is not empty.
        return !(text != null && text.trim().length > 0);
    };
    /* Return the inner text of the given element */
    RPTUtil.getInnerText = function (element) {
        var retVal = element.innerText;
        if (retVal == undefined || retVal.trim() == "")
            retVal = element.textContent;
        return retVal;
    };
    /**
     * This function is responsible for checking if elements inner text is empty or not.
     *
     * @parm {element} node The node which should be checked it has inner text or not.
     * @return {bool} true if element has empty inner text, false otherwise
     *
     * @memberOf RPTUtil
     */
    RPTUtil.isInnerTextEmpty = function (element) {
        // Get the innerText of the element
        var text = RPTUtil.getInnerText(element);
        // Trim the inner text and verify that it is not empty.
        return !(text != null && text.trim().length > 0);
    };
    RPTUtil.hasInnerContent = function (element) {
        var text = RPTUtil.getInnerText(element);
        var hasContent = (text != null && text.trim().length > 0);
        if (element.firstChild != null) {
            var nw = new NodeWalker(element);
            while (!hasContent && nw.nextNode()) {
                hasContent = (nw.node.nodeName.toLowerCase() == "img" &&
                    RPTUtil.attributeNonEmpty(nw.node, "alt"));
            }
        }
        return hasContent;
    };
    /**
     * This function is responsible for determine if an element has inner content.
     * This function also considers cases where inner text is hidden, which now will
     * be classified as does not have hidden content.
     *
     * @parm {element} node The node which should be checked it has inner text or not.
     * @return {bool} true if element has empty inner text, false otherwise
     *
     * @memberOf RPTUtil
     */
    RPTUtil.hasInnerContentHidden = function (element) {
        return RPTUtil.hasInnerContentHiddenHyperLink(element, false);
    };
    RPTUtil.hasInnerContentHiddenHyperLink = function (element, hyperlink_flag) {
        // Variable Decleration
        var childElement = element.firstElementChild;
        var hasContent = false;
        // In the case that the childElement is not null then we need to check each of the elements
        // to make sure that the elements are not all hidden.
        if (childElement != null) {
            // Get the nodewalter of the element node, so that we can loop over it and verify
            // that the elements under the element are not completly hidden.
            var nw = new NodeWalker(element);
            // Loop over all the nodes until there are no more nodes or we have determine that there is content under
            // this parent element.
            while (!hasContent && nw.nextNode() && nw.node != element) {
                // Get the next node
                var node = nw.node;
                // In the case an img element is present with alt then we can mark this as pass
                // otherwise keep checking all the other elements. Make sure that this image element is not hidden.
                hasContent = (node.nodeName.toLowerCase() == "img" && RPTUtil.attributeNonEmpty(node, "alt") && RPTUtil.isNodeVisible(node));
                // Now we check if this node is of type element, visible
                if (!hasContent && node.nodeType == 1 && RPTUtil.isNodeVisible(node)) {
                    // Check if the innerText of the element is empty or not
                    hasContent = !RPTUtil.isInnerTextOnlyEmpty(node);
                    if (!hasContent && hyperlink_flag == true) {
                        hasContent = RPTUtil.attributeNonEmpty(node, "aria-label") || RPTUtil.attributeNonEmpty(node, "aria-labelledby");
                        var doc = node.ownerDocument;
                        if (doc) {
                            var win = doc.defaultView;
                            if (win) {
                                var cStyle = win.getComputedStyle(node);
                                if (!hasContent && cStyle != null) {
                                    //                                       console.log(cStyle.backgroundImage);
                                    //                                       console.log(cStyle.content)
                                    hasContent = ((cStyle.backgroundImage && cStyle.backgroundImage.indexOf) || cStyle.content) && RPTUtil.attributeNonEmpty(node, "alt");
                                }
                            }
                        }
                    }
                }
                // Check for cases where there is text node after an element under the parent
                // In the case we detect nodetype as text node and the patent of the text node is
                // the same element we are checking has Inner content for then get the inner content of this
                // text node.
                if (node.nodeType == 3 && node.parentElement == element) {
                    // Check if the innerText of the element is empty or not
                    hasContent = !RPTUtil.isInnerTextEmpty(node);
                }
            }
        }
        // In the case there are no child elements then we can simply perform the check for only innertext
        // the img with alt case will be covered in the above if, as img is considers as an element.
        else {
            // Check if the innerText of the element is empty or not
            hasContent = !RPTUtil.isInnerTextEmpty(element);
        }
        return hasContent;
    };
    RPTUtil.hasInnerContentOrAlt = function (element) {
        var text = RPTUtil.getInnerText(element);
        var hasContent = (text != null && text.trim().length > 0) || RPTUtil.attributeNonEmpty(element, "alt");
        if (element.firstChild != null) {
            var nw = new NodeWalker(element);
            while (!hasContent && nw.nextNode() && nw.node != element) {
                hasContent = (nw.node.nodeName.toLowerCase() == "img" &&
                    RPTUtil.attributeNonEmpty(nw.node, "alt"));
            }
        }
        return hasContent;
    };
    RPTUtil.concatUniqueArrayItem = function (item, arr) {
        arr.indexOf(item) === -1 && item !== null ? arr.push(item) : false;
        return arr;
    };
    RPTUtil.concatUniqueArrayItemList = function (itemList, arr) {
        for (var i = 0; itemList !== null && i < itemList.length; i++) {
            arr = RPTUtil.concatUniqueArrayItem(itemList[i], arr);
        }
        return arr;
    };
    RPTUtil.getElementAriaProperty = function (ruleContext) {
        var tagName = null;
        if (ruleContext.tagName) {
            tagName = ruleContext.tagName.toLowerCase();
        }
        else if (ruleContext.nodeName) {
            tagName = ruleContext.nodeName.toLowerCase();
        }
        // check if the tagProperty exists in the documentConformanceRequirement hash.
        var tagProperty = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirement[tagName];
        // The tag needs to check some special attributes
        if (tagProperty === null || tagProperty === undefined) {
            var specialTagProperties = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags[tagName];
            switch (tagName) { // special cases
                case "a":
                    RPTUtil.attributeNonEmpty(ruleContext, "href") ? tagProperty = specialTagProperties["with-href"] : tagProperty = specialTagProperties["without-href"];
                    break;
                case "area":
                    RPTUtil.attributeNonEmpty(ruleContext, "href") ? tagProperty = specialTagProperties["with-href"] : tagProperty = specialTagProperties["without-href"];
                    break;
                case "button":
                    RPTUtil.attributeNonEmpty(ruleContext, "type") && ruleContext.getAttribute("type").trim().toLowerCase() === "menu" ? tagProperty = specialTagProperties["with-type-menu"] : tagProperty = specialTagProperties["without-type-menu"];
                    break;
                case "footer": {
                    var ancestor_1 = RPTUtil.getAncestor(ruleContext, "article");
                    if (ancestor_1 === null)
                        ancestor_1 = RPTUtil.getAncestor(ruleContext, "aside");
                    if (ancestor_1 === null)
                        ancestor_1 = RPTUtil.getAncestor(ruleContext, "main");
                    if (ancestor_1 === null)
                        ancestor_1 = RPTUtil.getAncestor(ruleContext, "nav");
                    if (ancestor_1 === null)
                        ancestor_1 = RPTUtil.getAncestor(ruleContext, "section");
                    ancestor_1 !== null ? tagProperty = specialTagProperties["des-section-article"] : tagProperty = specialTagProperties["not-des-section-article"];
                    break;
                }
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                    specialTagProperties = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags["h1-6"];
                    if (RPTUtil.attributeNonEmpty(ruleContext, "aria-level") && ruleContext.getAttribute("aria-level") > 0)
                        tagProperty = specialTagProperties["h1-6-with-aria-level-positive-integer"];
                    else
                        tagProperty = specialTagProperties["h1-6-without-aria-level-positive-integer"];
                    break;
                case "header":
                    var ancestor = RPTUtil.getAncestor(ruleContext, "article");
                    if (ancestor === null)
                        ancestor = RPTUtil.getAncestor(ruleContext, "aside");
                    if (ancestor === null)
                        ancestor = RPTUtil.getAncestor(ruleContext, "main");
                    if (ancestor === null)
                        ancestor = RPTUtil.getAncestor(ruleContext, "nav");
                    if (ancestor === null)
                        ancestor = RPTUtil.getAncestor(ruleContext, "section");
                    ancestor !== null ? tagProperty = specialTagProperties["des-section-article"] : tagProperty = specialTagProperties["not-des-section-article"];
                    break;
                case "hgroup":
                    if (RPTUtil.attributeNonEmpty(ruleContext, "aria-level"))
                        tagProperty = specialTagProperties["with-aria-level"];
                    else
                        tagProperty = specialTagProperties["without-aria-level"];
                    break;
                case "img":
                    ruleContext.hasAttribute("alt") && ruleContext.getAttribute("alt").trim() === "" ? tagProperty = specialTagProperties["img-with-empty-alt"] : tagProperty = specialTagProperties["img-without-empty-alt"];
                    break;
                case "input":
                    if (RPTUtil.attributeNonEmpty(ruleContext, "type")) {
                        var type = ruleContext.getAttribute("type").trim().toLowerCase();
                        tagProperty = specialTagProperties[type];
                        if (tagProperty === null || tagProperty === undefined) {
                            switch (type) {
                                case "search":
                                    RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["search-list"] : tagProperty = specialTagProperties["search-no-list"];
                                    break;
                                case "text":
                                    RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["text-with-list"] : tagProperty = specialTagProperties["text-no-list"];
                                    break;
                                case "tel":
                                    RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["tel-with-list"] : tagProperty = specialTagProperties["tel-no-list"];
                                    break;
                                case "url":
                                    RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["url-with-list"] : tagProperty = specialTagProperties["url-no-list"];
                                    break;
                                case "email":
                                    RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["email-with-list"] : tagProperty = specialTagProperties["email-no-list"];
                                    break;
                                case "checkbox":
                                    RPTUtil.attributeNonEmpty(ruleContext, "aria-pressed") ? tagProperty = specialTagProperties["checkbox-with-aria-pressed"] : tagProperty = specialTagProperties["checkbox-without-aria-pressed"];
                                    break;
                                default:
                                    // default type is the same as type=text
                                    RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["text-with-list"] : tagProperty = specialTagProperties["text-no-list"];
                                    break;
                            }
                        }
                    }
                    else {
                        // default type is the same as type=text
                        RPTUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["text-with-list"] : tagProperty = specialTagProperties["text-no-list"];
                    }
                    break;
                case "li": {
                    var parentNode_1 = ruleContext.parentNode;
                    parentNode_1 !== null && (parentNode_1.tagName.toLowerCase() === "ol" || parentNode_1.tagName.toLowerCase() === "ul") ? tagProperty = specialTagProperties["parent-ol-or-ul"] : tagProperty = specialTagProperties["parent-not-ol-or-ul"];
                    break;
                }
                case "link":
                    RPTUtil.attributeNonEmpty(ruleContext, "href") ? tagProperty = specialTagProperties["with-href"] : tagProperty = specialTagProperties["without-href"]; //https://www.w3.org/TR/html51/document-metadata.html#elementdef-link
                    break;
                case "menu":
                    RPTUtil.attributeNonEmpty(ruleContext, "type") && ruleContext.getAttribute("type").trim().toLowerCase() === "context" ? tagProperty = specialTagProperties["type-context"] : tagProperty = tagProperty;
                    break;
                case "menuitem":
                    if (RPTUtil.attributeNonEmpty(ruleContext, "type")) {
                        if (ruleContext.getAttribute("type").trim().toLowerCase() === "command")
                            tagProperty = specialTagProperties["type-command"];
                        else if (ruleContext.getAttribute("type").trim().toLowerCase() === "checkbox")
                            tagProperty = specialTagProperties["type-checkbox"];
                        else if (ruleContext.getAttribute("type").trim().toLowerCase() === "radio")
                            tagProperty = specialTagProperties["type-radio"];
                    }
                    if (tagProperty === null || tagProperty === undefined)
                        tagProperty = specialTagProperties["default"];
                    break;
                case "option":
                    var parentNode = ruleContext.parentNode;
                    // https://developer.mozilla.org/en/docs/Web/HTML/Element/option
                    /* refer to Github issue #436, we remove "select" and "optgroup" based on HTML 5.1 spec. A select can have a role of menu
                        * A menu role requires a menuitem, menuitemcheckbox, or menuitemradio. So, "option" element needs to take one of those roles.
                        * Hence, the conformance table is incorrect.*/
                    if ( /*parentNode.tagName.toLowerCase() === "select" || parentNode.tagName.toLowerCase() === "optgroup" || */parentNode.tagName.toLowerCase() === "datalist" || parentNode.tagName.toLowerCase() === "options")
                        tagProperty = specialTagProperties["list-suggestion-datalist"];
                    else
                        tagProperty = specialTagProperties["not-list-suggestion-datalist"];
                    break;
                case "select":
                    specialTagProperties = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags["select"];
                    if (ruleContext.hasAttribute("multiple") ||
                        RPTUtil.attributeNonEmpty(ruleContext, "size") && ruleContext.getAttribute("size") > 1)
                        tagProperty = specialTagProperties["multiple-attr-size-gt1"];
                    else
                        tagProperty = specialTagProperties["no-multiple-attr-size-gt1"];
                    break;
                default:
                    if (ARIADefinitions_1.ARIADefinitions.textLevelSemanticElements.indexOf(tagName) > -1) {
                        tagProperty = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags["text-level-semantic-elements"];
                    }
                    else {
                        tagProperty = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags["default"];
                    }
            } //switch
        }
        return tagProperty || null;
    };
    RPTUtil.getAllowedAriaRoles = function (ruleContext, properties) {
        var tagName = ruleContext.tagName.toLowerCase();
        var allowedRoles = [];
        var tagProperty = null;
        if (properties != null && properties !== undefined)
            tagProperty = properties;
        else
            tagProperty = RPTUtil.getElementAriaProperty(ruleContext);
        if (tagProperty !== null && tagProperty !== undefined) {
            if (tagProperty.implicitRole !== null) {
                RPTUtil.concatUniqueArrayItemList(tagProperty.implicitRole, allowedRoles);
            }
            if (tagProperty.validRoles !== null) {
                RPTUtil.concatUniqueArrayItemList(tagProperty.validRoles, allowedRoles);
            }
        }
        return allowedRoles;
    };
    RPTUtil.getAllowedAriaAttributes = function (ruleContext, permittedRoles, properties) {
        var tagName = ruleContext.tagName.toLowerCase();
        var allowedAttributes = [];
        /*These needs to be handled first since its applicable to all elements*/
        if (ruleContext.hasAttribute("disabled") && ARIADefinitions_1.ARIADefinitions.elementsAllowedDisabled.indexOf(tagName) === -1) {
            /*Element with a disabled attribute  https://www.w3.org/TR/html5/disabled-elements.html
                Use the disabled attribute on any element that is allowed the disabled attribute in HTML5. aria-disabled="true"
                Only use the aria-disabled attribute for elements that are not allowed to have a disabled attribute in HTML5 */
            allowedAttributes = RPTUtil.concatUniqueArrayItem("aria-disabled", allowedAttributes);
        }
        if (ruleContext.hasAttribute("required") && ARIADefinitions_1.ARIADefinitions.elementsAllowedRequired.indexOf(tagName) > -1) {
            /*Element with a required attribute  // http://www.the-art-of-web.com/html/html5-form-validation/
                * aria-required="true" Use the aria-required attribute on any element that is allowed the required attribute in HTML5.
                * MAY also be used for elements that have an attached ARIA role which allows the aria-required attribute.*/
            allowedAttributes = RPTUtil.concatUniqueArrayItem("aria-required", allowedAttributes);
        }
        if (ruleContext.hasAttribute("readonly") && ARIADefinitions_1.ARIADefinitions.elementsAllowedReadOnly.indexOf(tagName) === -1) {
            /*Element with a readonly attribute* aria-readonly="true" * Use the readonly attribute on any element that is allowed the readonly attribute in HTML5.
                Only use the aria-readonly attribute for elements that are not allowed to have a readonly attribute in HTML5 */
            allowedAttributes = RPTUtil.concatUniqueArrayItem("aria-readonly", allowedAttributes);
        }
        if (ruleContext.hasAttribute("hidden")) {
            /*Element with a hidden attribute Use the aria-hidden attribute on any HTML element.
                Note: If an element has a hidden attribute, an aria-hidden attribute is not required.*/
            allowedAttributes = RPTUtil.concatUniqueArrayItem("aria-hidden", allowedAttributes);
        }
        var tagProperty = null;
        if (properties != null && properties !== undefined)
            tagProperty = properties;
        else
            tagProperty = RPTUtil.getElementAriaProperty(ruleContext);
        var skipImplicitRoleCheck = false;
        if (tagName === "form" || tagName === "section") {
            // special case: form has an implicit role only if it has an accessible name
            skipImplicitRoleCheck = !ruleContext.hasAttribute("aria-label") &&
                !ruleContext.hasAttribute("aria-labelledby") &&
                !ruleContext.hasAttribute("title");
        }
        if (tagProperty !== null && tagProperty !== undefined) {
            // add the implicit role allowed attributes to the allowed role list if there is no specified role
            if (tagProperty.implicitRole !== null &&
                (permittedRoles === null || permittedRoles === undefined || permittedRoles.length == 0) &&
                !skipImplicitRoleCheck) {
                for (var i = 0; i < tagProperty.implicitRole.length; i++) {
                    var roleProperty = ARIADefinitions_1.ARIADefinitions.designPatterns[tagProperty.implicitRole[i]];
                    if (roleProperty !== null && roleProperty !== undefined) {
                        var properties_1 = roleProperty.props;
                        RPTUtil.concatUniqueArrayItemList(properties_1, allowedAttributes);
                        properties_1 = RPTUtil.getRoleRequiredProperties(tagProperty.implicitRole[i], ruleContext);
                        RPTUtil.concatUniqueArrayItemList(properties_1, allowedAttributes);
                        // special case of separator
                        if (tagProperty.implicitRole[i] === "separator" && RPTUtil.isFocusable(ruleContext)) {
                            RPTUtil.concatUniqueArrayItemList(["aria-valuetext"], allowedAttributes);
                        }
                    }
                }
            }
            // Adding the global properties to the valid attribute list
            if (tagProperty.globalAriaAttributesValid) {
                var properties_2 = ARIADefinitions_1.ARIADefinitions.globalProperties; // global properties
                RPTUtil.concatUniqueArrayItemList(properties_2, allowedAttributes);
            }
            else {
                // special case: <img> with alt="" allows only aria-hidden
                if (tagName === "img" &&
                    ruleContext.hasAttribute("alt") &&
                    ruleContext.getAttribute("alt").trim() === "") {
                    RPTUtil.concatUniqueArrayItemList(["aria-hidden"], allowedAttributes);
                }
            }
        }
        // adding the specified role properties to the allowed attribute list
        for (var i = 0; permittedRoles !== null && i < permittedRoles.length; i++) {
            var roleProperties = ARIADefinitions_1.ARIADefinitions.designPatterns[permittedRoles[i]];
            if (roleProperties !== null && roleProperties !== undefined) {
                var properties_3 = roleProperties.props; // allowed properties
                RPTUtil.concatUniqueArrayItemList(properties_3, allowedAttributes);
                properties_3 = RPTUtil.getRoleRequiredProperties(permittedRoles[i], ruleContext); // required properties
                RPTUtil.concatUniqueArrayItemList(properties_3, allowedAttributes);
                // special case for separator
                if (permittedRoles[i] === "separator" && RPTUtil.isFocusable(ruleContext)) {
                    RPTUtil.concatUniqueArrayItemList(["aria-valuetext"], allowedAttributes);
                }
            }
        }
        return allowedAttributes;
    };
    RPTUtil.CSS = function (element) {
        var styleText = "";
        if (element == null)
            return [];
        if (element.IBM_CSS_THB)
            return element.IBM_CSS_THB;
        var nodeName = element.nodeName.toLowerCase();
        if (nodeName == "style") {
            styleText = RPTUtil.getInnerText(element);
        }
        else if (element.hasAttribute("style")) {
            styleText = element.getAttribute("style");
        }
        else
            return [];
        if (styleText == null || styleText.trim().length == 0)
            return [];
        //remove comment blocks
        var re = /(\/\*+(?:(?:(?:[^\*])+)|(?:[\*]+(?!\/)))[*]+\/)|\/\/.*/g;
        var subst = ' ';
        styleText = styleText.replace(re, subst);
        // Find all "key : val;" pairs with various whitespace inbetween
        var rKeyVals = /\s*([^:\s]+)\s*:\s*([^;$}]+)\s*(;|$)/g;
        // Find all "selector { csskeyvals } with various whitespace inbetween
        var rSelectors = /\s*([^{]*){([^}]*)}/g;
        if (styleText.indexOf("{") == -1) {
            var keyVals = {};
            var m = void 0;
            while ((m = rKeyVals.exec(styleText)) != null) {
                keyVals[m[1]] = m[2].trim().toLowerCase();
            }
            var retVal = [{
                    selector: null,
                    values: keyVals
                }];
            element.IBM_CSS_THB = retVal;
            return retVal;
        }
        else {
            var retVal = [];
            var m = void 0;
            var m2 = void 0;
            while ((m = rSelectors.exec(styleText)) != null) {
                var keyVals = {};
                var selKey = m[1];
                var selVal = m[2];
                while ((m2 = rKeyVals.exec(selVal)) != null) {
                    keyVals[m2[1]] = m2[2].trim().toLowerCase();
                }
                retVal.push({
                    selector: selKey,
                    values: keyVals
                });
            }
            element.IBM_CSS_THB = retVal;
            return retVal;
        }
    };
    /**
     * This function is responsible for checking if the node that is provied is
     * visible or not. Following is how the check is performed:
     *    1. Check if the current node is hidden with the following options:
     *       CSS --> dislay: none
     *       CSS --> visibility: hidden
     *       attribute --> hidden
     *    2. Check if the any of the current nodes parents are hidden with the same
     *       options listed in 1.
     *
     *    Note: If either current node or any of the parent nodes are hidden then this
     *          function will return false (node is not visible).
     *
     * @parm {element} node The node which should be checked if it is visible or not.
     * @return {bool} false if the node is NOT visible, true otherwise
     *
     * @memberOf RPTUtil
     */
    RPTUtil.isNodeVisible = function (node) {
        // Set PT_NODE_HIDDEN to false for all the nodes, before the check and this will be changed to
        // true when we detect that the node is hidden. We have to set it to false so that we know
        // the rules has already been checked.
        RPTUtil.setCache(node, "PT_NODE_HIDDEN", RPTUtil.getCache(node, "PT_NODE_HIDDEN", false));
        // Check the nodeType if this node, if this node is a text node then
        // we get the parentnode and set that as the node as a text nodes,
        // visibility is directly related to the parent node.
        if (node.nodeType == 3) {
            node = node.parentNode;
        }
        // We should only allow nodeType element, and TextNode all other nodesTypes
        // we can return the visibility as visible.
        // Following nodes will be returned as visable by default, since we can not
        // actually change their visibility.
        //  Node.PROCESSING_INSTRUCTION_NODE --> 7
        //  Node.COMMENT_NODE                --> 8
        //  9 /* Node.DOCUMENT_NODE */               --> 9
        //  Node.DOCUMENT_TYPE_NODE          --> 10
        //  Node.DOCUMENT_FRAGMENT_NODE      --> 11
        else if (node.nodeType != 1) {
            return true;
        }
        // Make sure that the ownerDocument is present before moving forward
        // in detecting if the node is visible or not. In the case that ownerDocument
        // does not exist then we simply return node is visible by default.
        if (!node.ownerDocument) {
            return true;
        }
        // Variable Declaration
        var compStyle;
        var nodeName = node.nodeName.toLowerCase();
        // In the case this node is a script, link or style node, right away return node is visible
        // because scripts, links and style nodes can not be hidden by HTML attribute or CSS or are hidden by default. But we want to scan
        // the elements everytime as they render content still which is still visible to users.
        //  script --> script elements have display: none by default
        //  link --> link elements have display: none by default, but the actually CSS script is still executed so we have to
        //            mark this element as visible at all times.
        //  style --> style elements have display: none by default, but the actually CSS script is still executed so we have to
        //            mark this element as visible at all times.
        if (RPTUtil.hiddenByDefaultElements != null && RPTUtil.hiddenByDefaultElements != undefined && RPTUtil.hiddenByDefaultElements.indexOf(nodeName) > -1) {
            return true;
        }
        // Check if this node is visible, we check couple of CSS properties and hidden attribute.
        // area, param and audio elements we do not check if they are hidden as it does not apply to them.
        // Check the unhideableElements array which is part of the rules, to check if this element is allowed to be hidden or not
        // in the case that the element is part of the unhideableElements array then we do not run the hidden check on this element,
        // and go stright to the parent node.
        // Array check elements like:
        //  area --> area element is part of a map element and it can not be hidden because it is used to
        //           make an certian parts of an map interactive.
        //  param --> element can only be part of object elment and it cannot be hidden directly, it
        //            can only be hidden if the parent is hidden.
        //  audio --> If this element is hidden it will still play the music, so we should still trigger
        //            violations for this element.
        // In the case that unhideableElements array is not defined then we just scan all elements and do no filtering at all.
        if (RPTUtil.unhideableElements == null || RPTUtil.unhideableElements == undefined || RPTUtil.unhideableElements.indexOf(nodeName) == -1) {
            // Check if defaultView exists for this node, if it does then use this to run the getComputedStyle
            // function to get the CSS style for the node.
            if (node.ownerDocument.defaultView) {
                // Run the getComputedStyle on this node to fetch the CSS compuation of the node
                compStyle = node.ownerDocument.defaultView.getComputedStyle(node, null);
            }
            // In the case that defaultView does not exists return true to identify that this
            // node is visible, because were not able to detect if it was not.
            else {
                return true;
            }
            // Get the hidden element property and hidden attribute
            var hiddenAttribute = node.getAttribute("hidden");
            var hiddenPropertyCustom = RPTUtil.getCache(node, "PT_NODE_HIDDEN", undefined);
            ;
            // To get the hidden property we need to perform a special check as in some cases the hidden property will not be
            // a boolean, for theses cases we set it to false as we are not able to determine the true hidden condition.
            // The reason for this is because form elements are able to perform an override, so when we have id="hidden" for an element
            // which is under the form element then, node.hidden gives the element/list of elements which have id="hidden". Refer to
            // mozilla bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1267356
            var hiddenProperty = typeof node.hidden == "boolean" ? node.hidden : false;
            // If compStyle object is empty, node does't have hidden property, node does't have hidden attribute and does't have custom PT
            // hidden property then we can just return true (node visible) at this point.
            if (!compStyle &&
                !hiddenProperty && // this covers false, null, or undefined
                (hiddenAttribute == null || hiddenAttribute == undefined) &&
                !hiddenPropertyCustom // This covers false, null or undefined
            ) {
                return true;
            }
            // In the case that the compStyle is defined we check the following:
            //  CSS style display set to none
            //  CSS style visibility set to hidden
            //    Note: For this property since it is inherited, need to skip the check on parents as
            //          the parent can have hidden but the child can be visible. So we only check this property
            //          on child elements/elements that are passed to this function the first time.
            //  node hidden property set (node.hidden)
            //  node attribute hidden set (to any value)
            //  node custom hidden property ser (node.PT_NODE_HIDDEN)
            // If any of the above conditions are true then we return false as this element is not visible
            if ((compStyle !== null && (compStyle.getPropertyValue('display') == 'none' ||
                (!node.Visibility_Check_Parent && compStyle.getPropertyValue('visibility') == 'hidden'))) ||
                hiddenProperty ||
                hiddenAttribute != null ||
                hiddenPropertyCustom) {
                // Set a custom expandos property on the the node to identify that it is hidden, so that we can uses
                // use this in the rules to determine if the node is hidden or not, if we need to.
                // Use expandos property instead of a hash map which stores the elements, adding/checking expandos
                // properties is a lot faster performance whise. For Hash map we need to store based on xpath, and to calculate
                // xpath it is more performance impact.
                RPTUtil.setCache(node, "PT_NODE_HIDDEN", true);
                return false;
            }
        }
        // Get the parentNode for this node, becuase we have to check all parents to make sure they do not have
        // the hidden CSS, property or attribute. Only keep checking until we are all the way back to the parentNode
        // element.
        var parentElement = node.parentNode;
        // If the parent node exists and the nodetype is element (1), then run recursive call to perform the check
        // all the way up to the very parent node. Use recursive call here instead of a while loop so that we do not
        // have to duplicate the logic for checking if the node is visible or not for all the parents starting with
        // child node.
        if (parentElement != null && parentElement.nodeType == 1) {
            // When we have a parent element going through the isNodeVisible function we have to mark it as such
            // so that in the function we can skip checking visibility: hidden for parent elements since visibility: hidden
            // is inherited, which allows a child to have a different setting then the child. This property only needs to be checked
            // once for the first element that is passed down and that is all. Ignore it for all the parents that we iterate over.
            parentElement.Visibility_Check_Parent = true;
            // Check upwards recursively, and save the results in an variable
            var nodeVisible = RPTUtil.isNodeVisible(parentElement);
            // If the node is found to not be visible then add the custom PT_NODE_HIDDEN to true.
            // so that we can use this in the rules.
            if (!nodeVisible) {
                RPTUtil.setCache(node, "PT_NODE_HIDDEN", true);
            }
            // Check upwards recursively
            return nodeVisible;
        }
        // Return true (node is visible)
        return true;
    };
    RPTUtil.getControlOfLabel = function (node) {
        // Handle the easy case of label -> for
        var labelAncestor = RPTUtil.getAncestor(node, "label");
        if (labelAncestor) {
            if (labelAncestor.hasAttribute("for")) {
                return node.ownerDocument.getElementById(labelAncestor.getAttribute("for"));
            }
        }
        // Create a dictionary containing ids of parent nodes
        var idDict = {};
        var parentWalk = node;
        while (parentWalk) {
            if (parentWalk.nodeType === 1 /* Node.ELEMENT_NODE */) {
                var ancestor = parentWalk;
                if (ancestor.hasAttribute("id")) {
                    idDict[ancestor.getAttribute("id")] = true;
                }
            }
            parentWalk = parentWalk.parentNode;
        }
        // Iterate through controls that use aria-labelledby and see if any of them reference one of my ancestor ids
        var inputsUsingLabelledBy = node.ownerDocument.querySelectorAll("*[aria-labelledby]");
        for (var idx = 0; idx < inputsUsingLabelledBy.length; ++idx) {
            var inputUsingLabelledBy = inputsUsingLabelledBy[idx];
            var ariaLabelledBy = inputUsingLabelledBy.getAttribute("aria-labelledby");
            var sp = ariaLabelledBy.split(" ");
            for (var _i = 0, sp_1 = sp; _i < sp_1.length; _i++) {
                var id = sp_1[_i];
                if (id in idDict) {
                    return inputUsingLabelledBy;
                }
            }
        }
        // Find the cases where we're within an aria labelledby
        return null;
    };
    /**
     * This function is responsible for checking if the node that is provied is
     * disabled or not. Following is how the check is performed:
     *    1. Check if the current node is disabled with the following options:
     *       attribute --> disabled
     *         Also needs to be "button", "input", "select", "textarea", "optgroup", "option",
     *         "menuitem", "fieldset" nodes (in array elementsAllowedDisabled)
     *       attribute --> aria-disabled="true"
     *    2. Check if any of the current nodes parents are disabled with the same
     *       options listed in 1.
     *
     *    Note: If either current node or any of the parent nodes are disabled then this
     *          function will return true (node is disabled).
     *
     * @parm {HTMLElement} node - The node which should be checked if it is disabled or not.
     * @return {bool} true if the node is disabled, false otherwise
     *
     * @memberOf RPTUtil
     */
    RPTUtil.isNodeDisabled = function (node) {
        // Set PT_NODE_DISABLED to false for all the nodes, before the check and this will be changed to
        // true when we detect that the node is disabled. We have to set it to false so that we know
        // the node has already been checked. Only set it to false if the setting is undefined or null
        // as if it is defined we do not wnat to reset it. As if it is true then we should make use of it
        // to speed up the check.
        var PT_NODE_DISABLED = RPTUtil.getCache(node, "PT_NODE_DISABLED", false);
        // Check the nodeType of this node, if this node is a text node then
        // we get the parentnode and set that as the node as a text nodes,
        // disabled is directly related to the parent node.
        if (node.nodeType == 3) {
            node = node.parentNode;
        }
        // Variable Declaration
        var nodeName = node.nodeName.toLowerCase();
        // Get the disabled element property, disabled and aria-disabled attribute and check that it is true
        var disabledAttribute = node.hasAttribute("disabled");
        var disabledPropertyCustom = PT_NODE_DISABLED;
        var ariaDisabledAttribute = node.hasAttribute('aria-disabled') && node.getAttribute("aria-disabled") === 'true';
        // If this node has disabled attribute and the node allows disabled attribute, then return true.
        // Disabled attribute is only allowed on "button", "input", "select", "textarea", "optgroup", "option", "menuitem", "fieldset"
        // In the case aria-disabled is set to true, then also return true
        if (disabledPropertyCustom || (disabledAttribute && ARIADefinitions_1.ARIADefinitions.elementsAllowedDisabled.indexOf(nodeName) > -1) || ariaDisabledAttribute) {
            PT_NODE_DISABLED = true;
            RPTUtil.setCache(node, "PT_NODE_DISABLED", PT_NODE_DISABLED);
            return true;
        }
        // Get the parentNode for this node, becuase we have to check all parents to make sure they do not have
        // disabled attribute. Only keep checking until we are all the way back to the parentNode
        // element.
        var parentElement = node.parentNode;
        // If the parent node exists and the nodetype is element (1), then run recursive call to perform the check
        // all the way up to the very parent node. Use recursive call here instead of a while loop so that we do not
        // have to duplicate the logic for checking if the node is disabled or not for all the parents starting with
        // child node.
        if (parentElement != null && parentElement.nodeType == 1) {
            // Check upwards recursively, and save the results in an variable
            var nodeDisabled = RPTUtil.isNodeDisabled(parentElement);
            // If the node is found to be disabled then add the custom PT_NODE_DISABLED to true.
            // so that we can use this next time, to quickly determine if node is disabled or not.
            // This is extra percaution, the isNodeDisabled function already sets this.
            if (nodeDisabled) {
                PT_NODE_DISABLED = true;
            }
            // Check upwards recursively
            RPTUtil.setCache(node, "PT_NODE_DISABLED", PT_NODE_DISABLED);
            return nodeDisabled;
        }
        // Return false (node is not disabled)
        return false;
    };
    /**
     * This function is responsible for determine if hidden content should be checked
     * in rules.
     *
     * @parm {element} node - A node so that the document can be accessed to check for the
     *                        option. Can be document element or a simple node element.
     * @return {bool} true if hidden content should be checked, false otherwise
     *
     * @memberOf RPTUtil
     */
    RPTUtil.shouldCheckHiddenContent = function (node) {
        return false;
    };
    /**
     * This function is responsible for determining if node should be skipped from checking or not, based
     * on the Check Hidden Content settings and if the node is visible or not.
     *
     * @parm {element} node - Node to check if it is visible or not based on the Check Hidden Content
     *                        setting.
     *
     * @return {bool} true if node should be skipped, false otherwise
     *
     * @memberOf RPTUtil
     */
    RPTUtil.shouldNodeBeSkippedHidden = function (node) {
        // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
        // or not.
        //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
        //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we
        //     return true to identify that the node should not be scanned/added to any hash/array.
        //
        // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
        //       so on and so forth.
        if (!RPTUtil.shouldCheckHiddenContent(node) && !RPTUtil.isNodeVisible(node)) {
            return true;
        }
        return false;
    };
    RPTUtil.isfocusableByDefault = function (node) {
        var focusableElements = ['input', 'select', 'button', 'textarea', 'option', 'area'];
        if (node.nodeName.toLowerCase() == "a" && RPTUtil.hasAttribute(node, 'href'))
            return true;
        if (node.nodeName.toLowerCase() == "area" && RPTUtil.hasAttribute(node, 'href'))
            return true;
        if (focusableElements.indexOf(node.nodeName.toLowerCase()) != -1)
            return true;
        return false;
    };
    /**
     * This function check if a non-tabable node has valid tabable content.
     * If it is tabable (the tabindex is not speicified or is not -1), returns false;
     * If it is non-tabable, but a child is tabable and does not have element content, returns false;
     * Otherwise, returns true.
     */
    RPTUtil.nonTabableChildCheck = function (element) {
        if (!element.hasAttribute("tabindex") ||
            (parseInt(element.getAttribute("tabindex")) != -1)) {
            return false;
        }
        var nw = new NodeWalker(element);
        while (nw.nextNode()) {
            var child = nw.node;
            if (child.nodeType !== 1 /* Node.ELEMENT_NODE */) { // Text node. usually is a cartridge return.
                continue;
            }
            if (child.hasAttribute("tabindex") &&
                (parseInt(child.getAttribute("tabindex")) != -1) &&
                !RPTUtil.hasInnerContent(child)) {
                return false;
            }
        }
        return true;
    };
    // Rewrite the color object to account for alpha
    RPTUtil.Color = function (cssStyleColor) {
        cssStyleColor = cssStyleColor.toLowerCase();
        if (cssStyleColor == "transparent")
            return new ColorObj(255, 255, 255, 0);
        if (cssStyleColor in RPTUtil.CSSColorLookup)
            cssStyleColor = RPTUtil.CSSColorLookup[cssStyleColor];
        if (cssStyleColor.startsWith("rgb(")) {
            var rgbRegex = /\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/;
            var m = cssStyleColor.match(rgbRegex);
            if (m == null)
                return null;
            else {
                return new ColorObj(m[1], m[2], m[3]);
            }
        }
        else if (cssStyleColor.startsWith("rgba(")) {
            var rgbRegex = /\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(.+)\s*\)/;
            var m = cssStyleColor.match(rgbRegex);
            if (m == null)
                return null;
            else {
                return new ColorObj(m[1], m[2], m[3], m[4]);
            }
        }
        else if (cssStyleColor.charAt(0) != "#") {
            return null;
        }
        else {
            if (cssStyleColor.length == 4) {
                // The three-digit RGB (#rgb) is converted to six-digit form (#rrggbb) by replicating digits
                // (https://www.w3.org/TR/css-color-3/#rgb-color)
                cssStyleColor = "#" + cssStyleColor.charAt(1).repeat(2) +
                    cssStyleColor.charAt(2).repeat(2) +
                    cssStyleColor.charAt(3).repeat(2);
            }
            var thisRed = parseInt(cssStyleColor.substring(1, 3), 16);
            var thisGreen = parseInt(cssStyleColor.substring(3, 5), 16);
            var thisBlue = parseInt(cssStyleColor.substring(5, 7), 16);
            return new ColorObj(thisRed, thisGreen, thisBlue);
        }
        //    return null; // Unreachable
    };
    ;
    RPTUtil.ColorCombo = function (ruleContext) {
        var doc = ruleContext.ownerDocument;
        if (!doc) {
            return null;
        }
        var win = doc.defaultView;
        if (!win) {
            return null;
        }
        var ancestors = [];
        var walkNode = ruleContext;
        while (walkNode) {
            if (walkNode.nodeType == 1)
                ancestors.push(walkNode);
            walkNode = walkNode.parentElement;
        }
        var retVal = {
            "hasGradient": false,
            "hasBGImage": false,
            "fg": null,
            "bg": null
        };
        var compStyleColor = win.getComputedStyle(ruleContext).color;
        if (!compStyleColor)
            compStyleColor = "black";
        var fg = RPTUtil.Color(compStyleColor);
        var reColor = /transparent|rgba?\([^)]+\)/gi;
        var guessGradColor = function (gradList, bgColor, fgColor) {
            try {
                // If there's only one color, return that
                if (typeof gradList.length == "undefined")
                    return gradList;
                var overallWorst = null;
                var overallWorstRatio = null;
                for (var iGrad = 1; iGrad < gradList.length; ++iGrad) {
                    var worstColor = gradList[iGrad - 1];
                    var worstRatio = fgColor.contrastRatio(gradList[iGrad - 1]);
                    var step = .1;
                    var idx = 0;
                    while (step > .0001) {
                        while (idx + step <= 1 && worstRatio > fgColor.contrastRatio(gradList[iGrad].mix(gradList[iGrad - 1], idx + step).getOverlayColor(bgColor))) {
                            worstColor = gradList[iGrad].mix(gradList[iGrad - 1], idx + step).getOverlayColor(bgColor);
                            worstRatio = fgColor.contrastRatio(worstColor);
                            idx = idx + step;
                        }
                        while (idx - step >= 0 && worstRatio > fgColor.contrastRatio(gradList[iGrad].mix(gradList[iGrad - 1], idx - step).getOverlayColor(bgColor))) {
                            worstColor = gradList[iGrad].mix(gradList[iGrad - 1], idx - step).getOverlayColor(bgColor);
                            worstRatio = fgColor.contrastRatio(worstColor);
                            idx = idx - step;
                        }
                        step = step / 10;
                    }
                    if (overallWorstRatio == null || overallWorstRatio > worstRatio) {
                        overallWorstRatio = worstRatio;
                        overallWorst = worstColor;
                    }
                }
                return overallWorst;
            }
            catch (e) {
                console.log(e);
            }
            return bgColor;
        };
        var priorStackBG = RPTUtil.Color("white");
        var thisStackOpacity = null;
        var thisStackAlpha = null;
        var thisStackBG = null;
        // Ancestors processed from the topmost parent toward the child
        while (ancestors.length > 0) {
            var procNext = ancestors.pop();
            // cStyle is the computed style of this layer
            var cStyle = win.getComputedStyle(procNext);
            if (cStyle == null)
                continue;
            // thisBgColor is the color of this layer or null if the layer is transparent
            var thisBgColor = null;
            if (cStyle.backgroundColor && cStyle.backgroundColor != "transparent" && cStyle.backgroundColor != "rgba(0, 0, 0, 0)") {
                thisBgColor = RPTUtil.Color(cStyle.backgroundColor);
            }
            // If there is a gradient involved, set thisBgColor to the worst color combination available against the foreground
            if (cStyle.backgroundImage && cStyle.backgroundImage.indexOf && cStyle.backgroundImage.indexOf("gradient") != -1) {
                var gradColors = cStyle.backgroundImage.match(reColor);
                if (gradColors) {
                    var gradColorComp = [];
                    for (var i = 0; i < gradColors.length; ++i) {
                        if (!gradColors[i].length) {
                            gradColors.splice(i--, 1);
                        }
                        else {
                            gradColorComp.push(RPTUtil.Color(gradColors[i]));
                        }
                    }
                    thisBgColor = guessGradColor(gradColorComp, thisStackBG || priorStackBG, fg);
                }
            }
            // Handle non-solid opacity
            if (thisStackOpacity == null || (cStyle.opacity && cStyle.opacity.length > 0 && parseFloat(cStyle.opacity) < 1)) {
                // New stack, reset
                if (thisStackBG != null) {
                    // Overlay
                    thisStackBG.alpha = thisStackOpacity * thisStackAlpha;
                    priorStackBG = thisStackBG.getOverlayColor(priorStackBG);
                }
                thisStackOpacity = 1.0;
                thisStackAlpha = null;
                thisStackBG = null;
                if (cStyle.opacity && cStyle.opacity.length > 0) {
                    thisStackOpacity = parseFloat(cStyle.opacity);
                }
                if (thisBgColor != null) {
                    thisStackBG = thisBgColor;
                    thisStackAlpha = thisStackBG.alpha || 1.0;
                    delete thisStackBG.alpha;
                    if (thisStackOpacity == 1.0 && thisStackAlpha == 1.0) {
                        retVal.hasBGImage = false;
                        retVal.hasGradient = false;
                    }
                }
            }
            // Handle solid color backgrounds and gradient color backgrounds
            else if (thisBgColor != null) {
                // If this stack already has a background color, blend it
                if (thisStackBG == null) {
                    thisStackBG = thisBgColor;
                    thisStackAlpha = thisStackBG.alpha || 1.0;
                    delete thisStackBG.alpha;
                }
                else {
                    thisStackBG = thisBgColor.getOverlayColor(thisStackBG);
                }
                // #526: If thisBgColor had an alpha value, it may not expose through thisStackBG in the above code
                // We can't wipe out the gradient info if this layer was transparent
                if (thisStackOpacity == 1.0 && thisStackAlpha == 1.0 && (thisStackBG.alpha || 1.0) == 1.0 && (thisBgColor.alpha || 1.0) == 0) {
                    retVal.hasBGImage = false;
                    retVal.hasGradient = false;
                }
            }
            if (cStyle.backgroundImage && cStyle.backgroundImage != "none") {
                if (cStyle.backgroundImage.indexOf && cStyle.backgroundImage.indexOf("gradient") != -1) {
                    retVal.hasGradient = true;
                }
                else {
                    retVal.hasBGImage = true;
                }
            }
        }
        if (thisStackBG != null) {
            fg = fg.getOverlayColor(thisStackBG);
            delete fg.alpha;
        }
        fg.alpha = (fg.alpha || 1) * thisStackOpacity;
        fg = fg.getOverlayColor(priorStackBG);
        if (thisStackBG != null) {
            thisStackBG.alpha = thisStackOpacity * thisStackAlpha;
            priorStackBG = thisStackBG.getOverlayColor(priorStackBG);
        }
        retVal.fg = fg;
        retVal.bg = priorStackBG;
        return retVal;
    };
    ;
    RPTUtil.hasAttribute = function (element, attributeName) {
        var hasAttribute = false;
        if (element.hasAttribute) {
            hasAttribute = element.hasAttribute(attributeName);
        }
        else if (element.attributes && element.attributes.getNamedItem) {
            var attr = element.attributes.getNamedItem(attributeName);
            hasAttribute = attr && attr.specified;
        }
        return hasAttribute;
    };
    // This list contains a list of element tags which can not be hidden, when hidden is
    // added to theses elements it does not do anything at all.
    //  area --> area element is part of a map element and it can not be hidden because it is used to
    //           make an certian parts of an map interactive.
    //  param --> element can only be part of object elment and it cannot be hidden directly, it
    //            can only be hidden if the parent is hidden.
    //  audio --> If this element is hidden it will still play the music, so we should still trigger
    //            violations for this element.
    // Note: All element tags that are added here should be added as lowercase, as we are using indexOf to do the check.
    RPTUtil.unhideableElements = ['area', 'param', 'audio'];
    // This list contains a list of elements tags which have display: none by default, since we have rules triggering
    // on theses elements we need to make then visible by default so that the rules can trigger regardless of the
    // Check Hidden Content option in the tools.
    //  script --> script elements have display: none by default
    //  link --> link elements have display: none by default, but the actually CSS script is still executed so we have to
    //            mark this element as visible at all times.
    //  style --> style elements have display: none by default, but the actually CSS script is still executed so we have to
    //            mark this element as visible at all times.
    //  head --> head elements have display: none by default, but it will still behave correct
    //  title --> title elements have display: none by default, but it will still display the title
    //  meta --> meta elements have display: none by default, but it will still perform the action that meta is suppose to
    //  base --> base elements have display: none by default, but it will still perform the action that meta is suppose to
    //  noscript --> noscript elements have display: none by default, but it will still perform the action that meta is suppose to
    //  template --> template elements have display: none by default, because they are just a mechanism for holding client-side content
    //               that is not to be rendered when a page is loaded. https://developer.mozilla.org/en/docs/Web/HTML/Element/template
    //  datalist --> datalist elements have display: none by default,
    RPTUtil.hiddenByDefaultElements = ['script', 'link', 'style', 'head', 'title', 'meta', 'base', 'noscript', 'template', 'datalist'];
    // This list contains a list of elements tags which have display: none by default, since we have rules triggering
    RPTUtil.navLinkKeywords = ['start', 'next', 'prev', 'previous', 'contents', 'index'];
    // This list contains a list of rule ids for the rules that have to check for hidden content regardless of the Check Hidden
    // Content Setting. This means that when the engine is actually determine which elements to mass to the rules, it will always
    // pass theses rules no matter what the Check Hidden Content Setting is.
    RPTUtil.rulesThatHaveToCheckHidden = ['RPT_Elem_UniqueId'];
    // https://www.w3.org/TR/wai-aria-1.1/#introstates
    RPTUtil.ariaAttributeRoleDefaults = {
        "alert": {
            "aria-live": "assertive",
            "aria-atomic": "true"
        },
        "checkbox": {
            "aria-checked": "false"
        },
        "combobox": {
            "aria-expanded": "false",
            "aria-haspopup": "listbox"
        },
        "heading": {
            "aria-level": "2"
        },
        "listbox": {
            "aria-orientation": "vertical"
        },
        "log": {
            "aria-live": "polite"
        },
        "menu": {
            "aria-orientation": "vertical"
        },
        "menubar": {
            "aria-orientation": "horizontal"
        },
        "menuitemcheckbox": {
            "aria-checked": "false"
        },
        "menuitemradio": {
            "aria-checked": "false"
        },
        "option": {
            "aria-selected": "false"
        },
        "radio": {
            "aria-checked": "false"
        },
        "scrollbar": {
            "aria-orientation": "vertical",
            "aria-valuemin": "0",
            "aria-valuemax": "100",
            "aria-valuenow": function (element) {
                var max = RPTUtil.getAriaAttribute(element, "aria-valuemax");
                var min = RPTUtil.getAriaAttribute(element, "aria-valuemin");
                return "" + (((max - min) / 2) + min);
            }
        },
        "separator": {
            "aria-orientation": "horizontal",
            "aria-valuemin": "0",
            "aria-valuemax": "100",
            "aria-valuenow": "50"
        },
        "slider": {
            "aria-orientation": "horizontal",
            "aria-valuemin": "0",
            "aria-valuemax": "100",
            "aria-valuenow": function (element) {
                var max = RPTUtil.getAriaAttribute(element, "aria-valuemax");
                var min = RPTUtil.getAriaAttribute(element, "aria-valuemin");
                return "" + (((max - min) / 2) + min);
            }
        },
        "spinbutton": {
            // Not sure how to encode min/max
            "aria-valuenow": "0"
        },
        "status": {
            "aria-live": "polite",
            "aria-atomic": "true"
        },
        "switch": {
            "aria-checked": "false"
        },
        "tab": {
            "aria-selected": "false"
        },
        "tablist": {
            "aria-orientation": "horizontal"
        },
        "toolbar": {
            "aria-orientation": "horizontal"
        },
        "tree": {
            "aria-orientation": "vertical"
        }
    };
    // https://www.w3.org/TR/wai-aria-1.1/#aria-atomic
    RPTUtil.ariaAttributeGlobalDefaults = {
        "aria-atomic": "false",
        "aria-autocomplete": "none",
        "aria-busy": "false",
        "aria-checked": undefined,
        "aria-current": "false",
        "aria-disabled": "false",
        "aria-dropeffect": "none",
        "aria-expanded": undefined,
        "aria-grabbed": undefined,
        "aria-haspopup": "false",
        "aria-hidden": undefined,
        "aria-invalid": "false",
        "aria-live": "off",
        "aria-modal": "false",
        "aria-multiline": "false",
        "aria-multiselectable": "false",
        "aria-orientation": undefined,
        "aria-pressed": undefined,
        "aria-readonly": "false",
        "aria-required": "false",
        "aria-selected": undefined,
        "aria-sort": "none"
    };
    // https://www.w3.org/TR/html-aam-1.0/#html-attribute-state-and-property-mappings
    RPTUtil.ariaAttributeImplicitMappings = {
        "aria-autocomplete": {
            "form": function (e) {
                return "off" === e.getAttribute("autocomplete") ? "none" : "both";
            },
            "input": function (e) {
                return "off" === e.getAttribute("autocomplete") ? "none" : "both";
            },
            "select": function (e) {
                return "off" === e.getAttribute("autocomplete") ? "none" : "both";
            },
            "textarea": function (e) {
                return "off" === e.getAttribute("autocomplete") ? "none" : "both";
            }
        },
        "aria-checked": {
            "input": function (e) {
                if (e.hasAttribute("indeterminate"))
                    return "mixed";
                return "" + e.hasAttribute("checked");
            },
            "menuitem": function (e) {
                if (e.hasAttribute("indeterminate"))
                    return "mixed";
                return "" + e.hasAttribute("checked");
            },
            "*": function (e) {
                if (e.hasAttribute("indeterminate"))
                    return "mixed";
            },
        },
        "aria-haspopup": {
            "*": function (e) {
                if (e.hasAttribute("contextmenu"))
                    return "true";
                return;
            }
        },
        "aria-multiselectable": {
            "input": function (e) {
                if (e.hasAttribute("multiple"))
                    return "true";
                return;
            }
        },
        "aria-expanded": {
            "details": function (e) {
                return e.getAttribute("open");
            },
            "dialog": function (e) {
                return e.getAttribute("open");
            }
        },
        "aria-placeholder": {
            "input": function (e) {
                return e.getAttribute("placeholder");
            },
            "textarea": function (e) {
                return e.getAttribute("placeholder");
            }
        },
        "aria-required": {
            "input": function (e) {
                return e.getAttribute("required");
            },
            "select": function (e) {
                return e.getAttribute("required");
            },
            "textarea": function (e) {
                return e.getAttribute("required");
            }
        },
        "aria-disabled": {
            "button": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "fieldset": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "input": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "keygen": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "optgroup": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "option": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "select": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "textarea": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            }
        }
    };
    RPTUtil.tabTagMap = {
        "button": true,
        "input": function (element) {
            return element.getAttribute("type") != "hidden";
        },
        "select": true,
        "textarea": true,
        "div": function (element) {
            return element.hasAttribute("contenteditable");
        },
        "a": function (element) {
            // xlink:href?? see svg
            return element.hasAttribute("href");
        },
        "area": function (element) {
            return element.hasAttribute("href");
        },
        "audio": function (element) {
            return element.hasAttribute("controls");
        },
        "video": function (element) {
            return element.hasAttribute("controls");
        }
    };
    RPTUtil.CSSColorLookup = {
        "aliceblue": "#f0f8ff",
        "antiquewhite": "#faebd7",
        "aqua": "#00ffff",
        "aquamarine": "#7fffd4",
        "azure": "#f0ffff",
        "beige": "#f5f5dc",
        "bisque": "#ffe4c4",
        "black": "#000000",
        "blanchedalmond": "#ffebcd",
        "blue": "#0000ff",
        "blueviolet": "#8a2be2",
        "brown": "#a52a2a",
        "burlywood": "#deb887",
        "cadetblue": "#5f9ea0",
        "chartreuse": "#7fff00",
        "chocolate": "#d2691e",
        "coral": "#ff7f50",
        "cornflowerblue": "#6495ed",
        "cornsilk": "#fff8dc",
        "crimson": "#dc143c",
        "cyan": "#00ffff",
        "darkblue": "#00008b",
        "darkcyan": "#008b8b",
        "darkgoldenrod": "#b8860b",
        "darkgray": "#a9a9a9",
        "darkgreen": "#006400",
        "darkkhaki": "#bdb76b",
        "darkmagenta": "#8b008b",
        "darkolivegreen": "#556b2f",
        "darkorange": "#ff8c00",
        "darkorchid": "#9932cc",
        "darkred": "#8b0000",
        "darksalmon": "#e9967a",
        "darkseagreen": "#8fbc8f",
        "darkslateblue": "#483d8b",
        "darkslategray": "#2f4f4f",
        "darkturquoise": "#00ced1",
        "darkviolet": "#9400d3",
        "deeppink": "#ff1493",
        "deepskyblue": "#00bfff",
        "dimgray": "#696969",
        "dodgerblue": "#1e90ff",
        "firebrick": "#b22222",
        "floralwhite": "#fffaf0",
        "forestgreen": "#228b22",
        "fuchsia": "#ff00ff",
        "gainsboro": "#dcdcdc",
        "ghostwhite": "#f8f8ff",
        "gold": "#ffd700",
        "goldenrod": "#daa520",
        "gray": "#808080",
        "green": "#008000",
        "greenyellow": "#adff2f",
        "honeydew": "#f0fff0",
        "hotpink": "#ff69b4",
        "indianred": "#cd5c5c",
        "indigo": "#4b0082",
        "ivory": "#fffff0",
        "khaki": "#f0e68c",
        "lavender": "#e6e6fa",
        "lavenderblush": "#fff0f5",
        "lawngreen": "#7cfc00",
        "lemonchiffon": "#fffacd",
        "lightblue": "#add8e6",
        "lightcoral": "#f08080",
        "lightcyan": "#e0ffff",
        "lightgoldenrodyellow": "#fafad2",
        "lightgrey": "#d3d3d3",
        "lightgreen": "#90ee90",
        "lightpink": "#ffb6c1",
        "lightsalmon": "#ffa07a",
        "lightseagreen": "#20b2aa",
        "lightskyblue": "#87cefa",
        "lightslategray": "#778899",
        "lightsteelblue": "#b0c4de",
        "lightyellow": "#ffffe0",
        "lime": "#00ff00",
        "limegreen": "#32cd32",
        "linen": "#faf0e6",
        "magenta": "#ff00ff",
        "maroon": "#800000",
        "mediumaquamarine": "#66cdaa",
        "mediumblue": "#0000cd",
        "mediumorchid": "#ba55d3",
        "mediumpurple": "#9370d8",
        "mediumseagreen": "#3cb371",
        "mediumslateblue": "#7b68ee",
        "mediumspringgreen": "#00fa9a",
        "mediumturquoise": "#48d1cc",
        "mediumvioletred": "#c71585",
        "midnightblue": "#191970",
        "mintcream": "#f5fffa",
        "mistyrose": "#ffe4e1",
        "moccasin": "#ffe4b5",
        "navajowhite": "#ffdead",
        "navy": "#000080",
        "oldlace": "#fdf5e6",
        "olive": "#808000",
        "olivedrab": "#6b8e23",
        "orange": "#ffa500",
        "orangered": "#ff4500",
        "orchid": "#da70d6",
        "palegoldenrod": "#eee8aa",
        "palegreen": "#98fb98",
        "paleturquoise": "#afeeee",
        "palevioletred": "#d87093",
        "papayawhip": "#ffefd5",
        "peachpuff": "#ffdab9",
        "peru": "#cd853f",
        "pink": "#ffc0cb",
        "plum": "#dda0dd",
        "powderblue": "#b0e0e6",
        "purple": "#800080",
        "red": "#ff0000",
        "rosybrown": "#bc8f8f",
        "royalblue": "#4169e1",
        "saddlebrown": "#8b4513",
        "salmon": "#fa8072",
        "sandybrown": "#f4a460",
        "seagreen": "#2e8b57",
        "seashell": "#fff5ee",
        "sienna": "#a0522d",
        "silver": "#c0c0c0",
        "skyblue": "#87ceeb",
        "slateblue": "#6a5acd",
        "slategray": "#708090",
        "snow": "#fffafa",
        "springgreen": "#00ff7f",
        "steelblue": "#4682b4",
        "tan": "#d2b48c",
        "teal": "#008080",
        "thistle": "#d8bfd8",
        "tomato": "#ff6347",
        "turquoise": "#40e0d0",
        "violet": "#ee82ee",
        "wheat": "#f5deb3",
        "white": "#ffffff",
        "whitesmoke": "#f5f5f5",
        "yellow": "#ffff00",
        "yellowgreen": "#9acd32",
        "buttontext": "rgba(0, 0, 0, 0.847)",
        "buttonface": "#ffffff",
        "graytext": "rgba(0, 0, 0, 0.247)"
    };
    return RPTUtil;
}());
exports.RPTUtil = RPTUtil;
var RPTUtilStyle = /** @class */ (function () {
    function RPTUtilStyle() {
    }
    RPTUtilStyle.getWeightNumber = function (styleVal) {
        var map = {
            "light": 100,
            "bold": 700
        };
        var retVal = parseInt(styleVal);
        if (retVal)
            return retVal;
        if (styleVal in map)
            return map[styleVal];
        return 400;
    };
    RPTUtilStyle.getFontInPixels = function (styleVal) {
        var map = {
            "xx-small": 16,
            "x-small": 10,
            "small": 13,
            "medium": 16,
            "large": 18,
            "x-large": 24,
            "xx-large": 32
        };
        var value = parseFloat(styleVal);
        if (!value) {
            return map[styleVal];
        }
        var units = styleVal.substring(("" + value).length);
        if (units == "" || units == "px")
            return value;
        if (units == "em")
            return value * 16;
        if (units == "%")
            return value / 100 * 16;
        if (units == "pt")
            return value * 4 / 3;
        return Math.round(value);
    };
    return RPTUtilStyle;
}());
exports.RPTUtilStyle = RPTUtilStyle;
var ColorObj = /** @class */ (function () {
    function ColorObj(red, green, blue, alpha) {
        function fixComponent(comp) {
            if (typeof (comp) != typeof (""))
                return comp;
            var compStr = comp;
            compStr = compStr.trim();
            if (compStr[compStr.length - 1] != "%")
                return parseInt(compStr);
            return Math.round(parseFloat(compStr.substring(0, compStr.length - 1)) * 2.55);
        }
        this.red = fixComponent(red);
        this.green = fixComponent(green);
        this.blue = fixComponent(blue);
        if (typeof (alpha) != "undefined") {
            this.alpha = (typeof (alpha) == typeof ("")) ? parseFloat(alpha) : alpha;
        }
    }
    ColorObj.prototype.toHexHelp = function (value) {
        var retVal = Math.round(value).toString(16);
        if (retVal.length == 1)
            return "0" + retVal;
        return retVal;
    };
    ;
    ColorObj.prototype.toHex = function () {
        return "#" + this.toHexHelp(this.red) + this.toHexHelp(this.green) + this.toHexHelp(this.blue);
    };
    ;
    ColorObj.prototype.contrastRatio = function (bgColor) {
        var fgColor = this;
        if (typeof (this.alpha) != "undefined")
            fgColor = this.getOverlayColor(bgColor);
        var lum1 = fgColor.relativeLuminance();
        if (!bgColor.relativeLuminance) {
            var s = "";
            for (var key in bgColor) {
                s += key + "\n";
            }
            alert(bgColor);
            alert(s);
        }
        var lum2 = bgColor.relativeLuminance();
        var ratio = (lum1 > lum2) ? (lum1 + .05) / (lum2 + .05) : (lum2 + .05) / (lum1 + .05);
        return ratio;
    };
    ;
    ColorObj.prototype.relativeLuminance = function () {
        var R = this.red / 255.0;
        var G = this.green / 255.0;
        var B = this.blue / 255.0;
        R = R <= .03928 ? R / 12.92 : Math.pow((R + .055) / 1.055, 2.4);
        G = G <= .03928 ? G / 12.92 : Math.pow((G + .055) / 1.055, 2.4);
        B = B <= .03928 ? B / 12.92 : Math.pow((B + .055) / 1.055, 2.4);
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    };
    ;
    ColorObj.prototype.mix = function (color2, percThis) {
        if (typeof (this.alpha) == "undefined" && typeof (color2.alpha) == "undefined") {
            return new ColorObj(percThis * this.red + (1 - percThis) * color2.red, percThis * this.green + (1 - percThis) * color2.green, percThis * this.blue + (1 - percThis) * color2.blue);
        }
        else {
            var alphaThis = this.alpha ? this.alpha : 1;
            var alphaOther = color2.alpha ? color2.alpha : 1;
            return new ColorObj(percThis * this.red + (1 - percThis) * color2.red, percThis * this.green + (1 - percThis) * color2.green, percThis * this.blue + (1 - percThis) * color2.blue, percThis * alphaThis + (1 - percThis) * alphaOther);
        }
    };
    ;
    ColorObj.prototype.getOverlayColor = function (bgColor) {
        if (typeof (this.alpha) == "undefined" || this.alpha >= 1) {
            // No mixing required - it's opaque
            return this;
        }
        if (this.alpha < 0) {
            //		Haac.Error.logError("Invalid alpha value");
            return null;
        }
        if (typeof (bgColor.alpha) != "undefined" && bgColor.alpha < 1) {
            //		Haac.Error.logError("Cannot mix with a background alpha");
            return null;
        }
        var retVal = this.mix(bgColor, this.alpha);
        delete retVal.alpha;
        return retVal;
    };
    ColorObj.fromCSSColor = function (cssStyleColor) {
        var thisRed = -1;
        var thisGreen = -1;
        var thisBlue = -1;
        cssStyleColor = cssStyleColor.toLowerCase();
        if (cssStyleColor.startsWith("rgb(")) {
            var rgbRegex = /\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/;
            var m = cssStyleColor.match(rgbRegex);
            if (m == null)
                return null;
            else {
                thisRed = m[1];
                thisGreen = m[2];
                thisBlue = m[3];
            }
        }
        else if (cssStyleColor.startsWith("rgba(")) {
            var rgbRegex = /\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(.+)\s*\)/;
            var m = cssStyleColor.match(rgbRegex);
            if (m == null)
                return null;
            else {
                thisRed = m[1];
                thisGreen = m[2];
                thisBlue = m[3];
            }
        }
        else {
            if (cssStyleColor.charAt(0) != "#") {
                if (cssStyleColor in RPTUtil.CSSColorLookup)
                    cssStyleColor = RPTUtil.CSSColorLookup[cssStyleColor];
                else
                    return null;
            }
            var fromHex = function (val) {
                var lookup = {
                    "a": 10,
                    "b": 11,
                    "c": 12,
                    "d": 13,
                    "e": 14,
                    "f": 15
                };
                var retVal = 0;
                for (var i = 0; i < val.length; ++i) {
                    retVal = retVal * 16 +
                        parseInt(val.charAt(i) in lookup ? lookup[val.charAt(i)] : val.charAt(i));
                }
                return retVal;
            };
            if (cssStyleColor.length == 4) {
                // The three-digit RGB (#rgb) is converted to six-digit form (#rrggbb) by replicating digits
                // (https://www.w3.org/TR/css-color-3/#rgb-color)
                cssStyleColor = "#" + cssStyleColor.charAt(1).repeat(2) +
                    cssStyleColor.charAt(2).repeat(2) +
                    cssStyleColor.charAt(3).repeat(2);
            }
            thisRed = fromHex(cssStyleColor.substring(1, 3));
            thisGreen = fromHex(cssStyleColor.substring(3, 5));
            thisBlue = fromHex(cssStyleColor.substring(5, 7));
        }
        return new ColorObj(thisRed, thisGreen, thisBlue);
    };
    return ColorObj;
}());
exports.ColorObj = ColorObj;
/* Return a node walker for the given element.
 * bEnd is optional and defaults to false
 * but if true, indicates the node is the end node*/
var NodeWalker = /** @class */ (function () {
    function NodeWalker(element, bEnd) {
        this.node = element;
        this.bEndTag = (bEnd == undefined ? false : bEnd == true);
    }
    NodeWalker.prototype.nextNode = function () {
        if (!this.bEndTag && this.node.firstChild) {
            this.node = this.node.firstChild;
        }
        else if (this.node.nextSibling) {
            this.node = this.node.nextSibling;
            this.bEndTag = false;
        }
        else if (this.node.parentNode) {
            this.node = this.node.parentNode;
            this.bEndTag = true;
        }
        else {
            return false;
        }
        return true;
    };
    NodeWalker.prototype.prevNode = function () {
        if (this.bEndTag && this.node.lastChild) {
            this.node = this.node.lastChild;
            this.bEndTag = true;
        }
        else if (this.node.previousSibling) {
            this.node = this.node.previousSibling;
            this.bEndTag = true;
        }
        else if (this.node.parentNode) {
            this.node = this.node.parentNode;
            this.bEndTag = false;
        }
        else {
            return false;
        }
        if (this.bEndTag && (this.node.firstChild == null || typeof (this.node.firstChild) == 'undefined'))
            this.bEndTag = false;
        return true;
    };
    return NodeWalker;
}());
exports.NodeWalker = NodeWalker;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.ARIADefinitions = void 0;
/*global OpenAjax*/
// all references to WAI-ARIA specification is the WAI-ARIA 1.1
// https://www.w3.org/TR/wai-aria-1.1/
var ARIADefinitions = /** @class */ (function () {
    function ARIADefinitions() {
    }
    ARIADefinitions.nameFromContent = function (role) {
        return (role in ARIADefinitions.designPatterns)
            && ARIADefinitions.designPatterns[role].nameFrom
            && ARIADefinitions.designPatterns[role].nameFrom.includes("contents");
    };
    /*
     * array of WAI-ARIA global states and properties
     * @see https://www.w3.org/TR/wai-aria-1.1/#global_states
     */
    ARIADefinitions.globalProperties = ["aria-atomic", "aria-busy", "aria-controls", "aria-current", "aria-describedby",
        "aria-details", "aria-disabled", "aria-dropeffect", "aria-errormessage", "aria-flowto", "aria-grabbed",
        "aria-haspopup", "aria-hidden", "aria-invalid", "aria-keyshortcuts", "aria-label", "aria-labelledby",
        "aria-live", "aria-owns", "aria-relevant", "aria-roledescription"];
    /*
     * XSD data types for all WAI-ARIA properties
     * along with valid values when the data type is NMTOKEN
     * WAI-ARIA properties data types explaned:
     *  type: Used to identify the type of values allowed for the WAI-ARIA property
     *  values: Used to identify specific values of an WAI-ARIA property when type is nmtoken
     *  hiddenIDRefSupported: Used to identify if the WAI-ARIA property supports referencing hidden ID
     *                          true: refers to WAI-ARIA property supports hidden ID references
     *                          false: refers to WAI-ARIA property does not support hidden ID references
     *                        Default value will be set to false, if not specified.
     */
    ARIADefinitions.propertyDataTypes = {
        "aria-activedescendant": {
            type: "http://www.w3.org/2001/XMLSchema#idref",
            hiddenIDRefSupported: true
        },
        "aria-atomic": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-autocomplete": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["inline", "list", "both", "none", "undefined"] //add undefined to handle value empty
        },
        "aria-busy": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-checked": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "mixed", "undefined"]
        },
        "aria-colcount": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-colindex": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-colspan": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-controls": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-current": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["page", "step", "location", "date", "time", "true", "false", "undefined"] //add underfined for empty value
        },
        "aria-describedby": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-details": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs"
        },
        "aria-disabled": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-dropeffect": {
            type: "http://www.w3.org/2001/XMLSchema#nmtokens",
            values: ["copy", "move", "link", "execute", "popup", "none"]
        },
        "aria-errormessage": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-expanded": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "undefined"]
        },
        "aria-flowto": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: false
        },
        "aria-grabbed": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "undefined"]
        },
        "aria-haspopup": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "menu", "listbox", "tree", "grid", "dialog"]
        },
        "aria-hidden": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-invalid": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "spelling", "grammar", "undefined"] //add underfined for empty value
        },
        "aria-keyshortcuts": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        },
        "aria-label": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        },
        "aria-labelledby": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-level": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-live": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["off", "polite", "assertive"]
        },
        "aria-modal": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-multiline": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-multiselectable": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-orientation": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["horizontal", "vertical", "undefined"]
        },
        "aria-owns": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-placeholder": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        },
        "aria-posinset": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-pressed": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "mixed", "undefined"]
        },
        "aria-readonly": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-relevant": {
            type: "http://www.w3.org/2001/XMLSchema#nmtokens",
            values: ["additions", "removals", "text", "all"]
        },
        "aria-required": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-roledescription": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        },
        "aria-rowcount": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-rowindex": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-rowspan": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-selected": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "undefined"]
        },
        "aria-setsize": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-sort": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["ascending", "descending", "other", "none"]
        },
        "aria-valuemax": {
            type: "http://www.w3.org/2001/XMLSchema#decimal"
        },
        "aria-valuemin": {
            type: "http://www.w3.org/2001/XMLSchema#decimal"
        },
        "aria-valuenow": {
            type: "http://www.w3.org/2001/XMLSchema#decimal"
        },
        "aria-valuetext": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        }
    };
    /*
     * design patterns for concrete WAI-ARIA roles
     * legitimate keys for each role include:
     *
     * - container: appropriate container(s) for that role
     * - props: states and properties that may be associated with this role (in addition to the global states and properties listed above)
     * - reqProps: required states or properties for this role
     * - reqChildren: required children for this role
     * - htmlEquiv: HTML equivalent for this role
     * - roleType: one of widget, landmark, etc.
     * - nameRequired: determines whether an accessible name is required for a widget (see ARIA spec.)
     * - nameFrom: determines how an accessible name is supplied (author or content - see ARIA spec.)
     */
    ARIADefinitions.designPatterns = {
        "alert": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "alertdialog": {
            container: null,
            props: ["aria-expanded", "aria-modal"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "application": {
            container: null,
            props: ["aria-activedescendant"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameRequired: true,
            nameFrom: ["author"]
        },
        "article": {
            container: null,
            props: ["aria-expanded", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null
        },
        "banner": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"]
        },
        "button": {
            container: null,
            props: ["aria-expanded", "aria-pressed"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "input[@type='button']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true
        },
        "cell": {
            container: ["row"],
            props: ["aria-colindex", "aria-colspan", "aria-rowindex", "aria-rowspan", "aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameFrom: ["author", "contents"]
        },
        "checkbox": {
            container: null,
            props: ["aria-checked", "aria-readonly"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "input[@type='checkbox']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "columnheader": {
            container: ["row"],
            props: ["aria-colindex", "aria-colspan", "aria-expanded", "aria-readonly", "aria-required", "aria-rowindex", "aria-rowspan", "aria-selected", "aria-sort"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "combobox": {
            container: null,
            props: ["aria-expanded", "aria-activedescendant", "aria-autocomplete", "aria-orientation", "aria-readonly", "aria-required"],
            reqProps: ["aria-controls"],
            reqChildren: ["listbox", "textbox", "tree", "grid", "dialog"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "complementary": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"]
        },
        "contentinfo": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"]
        },
        "definition": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameFrom: ["author"]
        },
        "dialog": {
            container: null,
            props: ["aria-expanded", "aria-modal"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "directory": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameFrom: ["author"]
        },
        "document": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameRequired: false,
            nameFrom: ["author"]
        },
        "feed": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: ["article"],
            htmlEquiv: null
        },
        "figure": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null
        },
        "form": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark"
        },
        "grid": {
            container: null,
            props: ["aria-level", "aria-multiselectable", "aria-readonly", "aria-activedescendant", "aria-expanded", "aria-colcount", "aria-rowcount"],
            reqProps: null,
            reqChildren: ["row"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "gridcell": {
            container: ["row"],
            props: ["aria-readonly", "aria-selected", "aria-expanded", "aria-required", "aria-colindex", "aria-colspan", "aria-rowindex", "aria-rowspan"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "group": {
            container: null,
            props: ["aria-activedescendant", "aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null
        },
        "heading": {
            container: null,
            props: ["aria-level", "aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "h1 | h2 | h3 | h4 | h5 |h6",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "img": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "img",
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true
        },
        "link": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "a | link",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "list": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: ["listitem"],
            htmlEquiv: null
        },
        "listbox": {
            container: null,
            props: ["aria-expanded", "aria-activedescendant", "aria-multiselectable", "aria-readonly", "aria-required", "aria-orientation"],
            reqProps: null,
            reqChildren: ["option"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "listitem": {
            container: ["list", "group"],
            props: ["aria-expanded", "aria-level", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null
        },
        "log": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "main": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark"
        },
        "marquee": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "math": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameFrom: ["author"],
            presentationalChildren: true
        },
        "menu": {
            container: null,
            props: ["aria-expanded", "aria-activedescendant", "aria-orientation"],
            reqProps: null,
            reqChildren: ["menuitem", "menuitemcheckbox", "menuitemradio"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "menubar": {
            container: null,
            props: ["aria-activedescendant", "aria-expanded", "aria-orientation"],
            reqProps: null,
            reqChildren: ["menuitem", "menuitemcheckbox", "menuitemradio"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "menuitem": {
            container: ["group", "menu", "menubar"],
            props: ["aria-posinset", "aria-setsize", "aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "menuitemcheckbox": {
            container: ["menu", "menubar"],
            props: ["aria-posinset", "aria-readonly", "aria-setsize", "aria-checked"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "menuitemradio": {
            container: ["group", "menu", "menubar"],
            props: ["aria-setsize", "aria-posinset", "aria-readonly", "aria-checked"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "navigation": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark"
        },
        "none": {
            container: null,
            props: [],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null
        },
        "note": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null
        },
        "option": {
            container: ["listbox"],
            props: ["aria-checked", "aria-selected", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "presentation": {
            container: null,
            props: [],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null
        },
        "progressbar": {
            container: null,
            props: ["aria-expanded", "aria-valuetext", "aria-valuemax", "aria-valuemin", "aria-valuenow"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true
        },
        "radio": {
            container: null,
            props: ["aria-posinset", "aria-setsize", "aria-checked"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "input[@type='radio']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "radiogroup": {
            container: null,
            props: ["aria-activedescendant", "aria-expanded", "aria-required", "aria-readonly", "aria-orientation"],
            reqProps: null,
            reqChildren: ["radio"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "region": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "row": {
            container: ["grid", "treegrid", "table", "rowgroup"],
            props: ["aria-level", "aria-setsize", "aria-posinset", "aria-selected", "aria-activedescendant", "aria-expanded", "aria-colindex", "aria-rowindex"],
            reqProps: null,
            reqChildren: ["columnheader", "rowheader", "gridcell", "cell"],
            htmlEquiv: "tr"
        },
        "rowgroup": {
            container: ["grid", "table", "treegrid"],
            props: [],
            reqProps: null,
            reqChildren: ["row"],
            htmlEquiv: null
        },
        "rowheader": {
            container: ["row"],
            props: ["aria-expanded", "aria-sort", "aria-colindex", "aria-colspan", "aria-level", "aria-readonly", "aria-rowindex", "aria-rowspan", "aria-selected", "aria-required"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameRequired: true,
            nameFrom: ["contents", "author"]
        },
        "scrollbar": {
            container: null,
            props: ["aria-valuetext", "aria-orientation", "aria-valuenow", "aria-valuemax", "aria-valuemin"],
            reqProps: ["aria-controls"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"],
            presentationalChildren: true
        },
        "search": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark"
        },
        "searchbox": {
            container: null,
            props: ["aria-activedescendant", "aria-autocomplete", "aria-multiline", "aria-placeholder", "aria-readonly", "aria-required"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameRequired: true,
            nameFrom: ["author"],
            roleType: "widget"
        },
        "separator": {
            container: null,
            props: ["aria-orientation", "aria-valuemax", "aria-valuemin", "aria-valuenow"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            presentationalChildren: true
        },
        "slider": {
            container: null,
            props: ["aria-orientation", "aria-valuetext", "aria-readonly", "aria-valuemax", "aria-valuenow", "aria-valuemin"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true
        },
        "spinbutton": {
            container: null,
            props: ["aria-activedescendant", "aria-valuetext", "aria-required", "aria-readonly", "aria-valuemax", "aria-valuenow", "aria-valuemin"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "status": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameFrom: ["author"]
        },
        "switch": {
            container: null,
            props: ["aria-readonly", "aria-checked"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "tab": {
            container: ["tablist"],
            props: ["aria-selected", "aria-expanded", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author", "contents"]
        },
        "table": {
            container: null,
            props: ["aria-colcount", "aria-rowcount", "aria-expanded"],
            reqProps: null,
            reqChildren: ["row"],
            htmlEquiv: null,
            roleType: null,
            nameFrom: ["author"],
            nameRequired: true
        },
        "tablist": {
            container: null,
            props: ["aria-activedescendant", "aria-multiselectable", "aria-level", "aria-orientation"],
            reqProps: null,
            reqChildren: ["tab"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "tabpanel": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "term": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "dt",
            roleType: null
        },
        "textbox": {
            container: null,
            props: ["aria-activedescendant", "aria-autocomplete", "aria-multiline", "aria-placeholder", "aria-readonly", "aria-required"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "input[@type='text']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "timer": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "toolbar": {
            container: null,
            props: ["aria-activedescendant", "aria-expanded", "aria-orientation"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            // Although, not a widget according to the ARIA spec, Matt wants toolbars to be labeled
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "tooltip": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "tree": {
            container: null,
            props: ["aria-multiselectable", "aria-activedescendant", "aria-expanded", "aria-required", "aria-orientation"],
            reqProps: null,
            reqChildren: ["treeitem"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "treegrid": {
            container: null,
            props: ["aria-activedescendant", "aria-expanded", "aria-level", "aria-multiselectable", "aria-readonly", "aria-required", "aria-colcount", "aria-rowcount", "aria-orientation"],
            reqProps: null,
            reqChildren: ["row"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "treeitem": {
            container: ["tree", "group"],
            props: ["aria-checked", "aria-selected", "aria-expanded", "aria-level", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        }
    }; // end designPatterns
    // copied from https://www.w3.org/TR/html5/disabled-elements.html
    // https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms
    ARIADefinitions.elementsAllowedDisabled = ["button", "input", "select", "textarea", "optgroup", "option", "menuitem", "fieldset"];
    ARIADefinitions.elementsAllowedRequired = ["input", "select", "textarea"];
    ARIADefinitions.elementsAllowedReadOnly = ["input", "textarea"];
    /* https://www.w3.org/TR/html-aria/#docconformance
        * documentConformanceRequirement contains properties of the tags related to role without any additional attribute value
        * documentConformanceRequirementSpecialTags contains those tags that require special considerations
        */
    ARIADefinitions.documentConformanceRequirement = {
        "abbr": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "address": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "article": {
            implicitRole: ["article"],
            validRoles: ["presentation", "none", "document", "application", "feed", "main", "region"],
            globalAriaAttributesValid: true
        },
        "aside": {
            implicitRole: ["complementary"],
            validRoles: ["feed", "note", "presentation", "none", "region", "search"],
            globalAriaAttributesValid: true
        },
        "audio": {
            implicitRole: null,
            validRoles: ["application"],
            globalAriaAttributesValid: true
        },
        "base": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "body": {
            implicitRole: ["document"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "caption": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "canvas": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "col": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "colgroup": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "datalist": {
            implicitRole: ["listbox"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "dd": {
            implicitRole: ["definition"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "details": {
            implicitRole: ["group"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "dialog": {
            implicitRole: ["dialog"],
            validRoles: ["alertdialog"],
            globalAriaAttributesValid: true
        },
        "div": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "dl": {
            implicitRole: null,
            validRoles: ["group", "list", "presentation", "none"],
            globalAriaAttributesValid: true
        },
        "dt": {
            implicitRole: ["term"],
            validRoles: ["listitem"],
            globalAriaAttributesValid: true
        },
        "embed": {
            implicitRole: null,
            validRoles: ["application", "document", "presentation", "none", "img"],
            globalAriaAttributesValid: true
        },
        "figcaption": {
            implicitRole: null,
            validRoles: ["group", "presentation", "none"],
            globalAriaAttributesValid: true
        },
        "fieldset": {
            implicitRole: ["group"],
            validRoles: ["presentation", "none"],
            globalAriaAttributesValid: true
        },
        "figure": {
            implicitRole: ["figure"],
            validRoles: ["group", "presentation", "none"],
            globalAriaAttributesValid: true
        },
        "form": {
            implicitRole: ["form"],
            validRoles: ["search", "presentation", "none"],
            globalAriaAttributesValid: true
        },
        "head": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "hr": {
            implicitRole: ["separator"],
            validRoles: ["presentation", "none"],
            globalAriaAttributesValid: true
        },
        "html": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        /*
            For <iframe> role="presentation" is not allowed according the https://www.w3.org/TR/html-aria/#docconformance table.
            We have added the role=presentation in the allowed role list for backward compatibility of a DAP feature.
            DAP "Check iframes with role="presentation" should consider role="none" also. (role="none" is not added) since this feature might be deprecated later.
        */
        "iframe": {
            implicitRole: null,
            validRoles: ["application", "document", "none", "img", "presentation"],
            globalAriaAttributesValid: true
        },
        "ins": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "del": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "keygen": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "label": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "legend": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "main": {
            implicitRole: ["main"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "map": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "math": {
            implicitRole: ["math"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "meta": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "meter": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "nav": {
            implicitRole: ["navigation"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "noscript": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "object": {
            implicitRole: null,
            validRoles: ["application", "document", "img"],
            globalAriaAttributesValid: true
        },
        "ol": {
            implicitRole: ["list"],
            validRoles: ["directory", "group", "listbox", "menu", "menubar", "presentation", "none", "radiogroup", "tablist", "toolbar", "tree"],
            globalAriaAttributesValid: true
        },
        "optgroup": {
            implicitRole: ["group"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "output": {
            implicitRole: ["status"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "param": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "picture": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "progress": {
            implicitRole: ["progressbar"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "script": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "section": {
            implicitRole: ["region"],
            validRoles: ["alert", "alertdialog", "application", "banner", "complementary", "contentinfo", "dialog", "document", "feed", "log", "main", "marquee", "navigation", "none", "presentation", "search", "status", "tabpanel"],
            globalAriaAttributesValid: true
        },
        "source": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "span": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "style": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "summary": {
            implicitRole: ["button"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "svg": {
            implicitRole: null,
            validRoles: ["application", "document", "img"],
            globalAriaAttributesValid: true
        },
        "table": {
            implicitRole: ["table"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "tbody": {
            implicitRole: ["rowgroup"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "thead": {
            implicitRole: ["rowgroup"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "tfoot": {
            implicitRole: ["rowgroup"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "td": {
            implicitRole: ["cell"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "template": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "textarea": {
            implicitRole: ["textbox"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "th": {
            implicitRole: ["columnheader", "rowheader"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "title": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "tr": {
            implicitRole: ["row"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "track": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "ul": {
            implicitRole: ["list"],
            validRoles: ["directory", "group", "listbox", "menu", "menubar", "radiogroup", "tablist", "toolbar", "tree", "presentation", "none"],
            globalAriaAttributesValid: true
        },
        "video": {
            implicitRole: null,
            validRoles: ["application"],
            globalAriaAttributesValid: true
        },
        /* p, pre, blockquote grouping content elements not listed elsewhere: */
        "p": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "pre": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "blockquote": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        }
    }; // end documentConformanceRequirement
    ARIADefinitions.documentConformanceRequirementSpecialTags = {
        "a": {
            "with-href": {
                implicitRole: ["link"],
                //roleCondition: " when non-empty href attribute is present",
                validRoles: ["button", "checkbox", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "tab", "switch", "treeitem"],
                globalAriaAttributesValid: true
            },
            "without-href": {
                implicitRole: null,
                //roleCondition: " when href attribute is not present",
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "area": {
            "with-href": {
                implicitRole: ["link"],
                //roleCondition: " when non-empty href attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "without-href": {
                implicitRole: ["link"],
                //roleCondition: " when href attribute is not present",
                validRoles: null,
                globalAriaAttributesValid: true
            }
        },
        "button": {
            "with-type-menu": {
                implicitRole: ["button"],
                //roleCondition: " with type=menu",
                validRoles: ["menuitem"],
                globalAriaAttributesValid: true
            },
            "without-type-menu": {
                implicitRole: ["button"],
                //roleCondition: " without type=menu",
                validRoles: ["checkbox", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "switch", "tab"],
                globalAriaAttributesValid: true
            }
        },
        "footer": {
            "des-section-article": {
                implicitRole: null,
                validRoles: ["group", "presentation", "none"],
                globalAriaAttributesValid: true
            },
            "not-des-section-article": {
                implicitRole: ["contentinfo"],
                validRoles: ["group", "presentation", "none"],
                globalAriaAttributesValid: true
            }
        },
        "h1-6": {
            "h1-6-with-aria-level-positive-integer": {
                implicitRole: ["heading"],
                //roleCondition: " and implicit role is heading with aria-level=positive integer",
                validRoles: ["tab", "presentation", "none"],
                globalAriaAttributesValid: true
            },
            "h1-6-without-aria-level-positive-integer": {
                implicitRole: null,
                //roleCondition: " and implicit role is heading with aria-level=positive integer",
                validRoles: ["tab", "presentation", "none"],
                globalAriaAttributesValid: true
            }
        },
        "header": {
            "des-section-article": {
                implicitRole: null,
                //roleCondition: " and no implicit role when descendant of an article or section element",
                validRoles: ["group", "presentation", "none"],
                globalAriaAttributesValid: true
            },
            "not-des-section-article": {
                implicitRole: ["banner"],
                //roleCondition: " and implicit role is banner when not a descendant of an article or section element",
                validRoles: ["group", "presentation", "none"],
                globalAriaAttributesValid: true
            }
        },
        "hgroup": {
            "with-aria-level": {
                implicitRole: ["heading"],
                //roleCondition: " and implicit role is heading when aria-level attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "without-aria-level": {
                implicitRole: ["heading"],
                //roleCondition: " when aria-level attribute is not present",
                validRoles: null,
                globalAriaAttributesValid: true
            }
        },
        "img": {
            "img-with-empty-alt": {
                implicitRole: null,
                //roleCondition: " and no implicit role when empty alt attribute is present",
                validRoles: ["presentation", "none"],
                globalAriaAttributesValid: false
            },
            "img-without-empty-alt": {
                implicitRole: ["img"],
                //roleCondition: " and implicit role is img when empty alt attribute is not present",
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "input": {
            "number": {
                implicitRole: ["spinbutton"],
                //roleCondition: " with type=number",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "radio": {
                implicitRole: ["radio"],
                //roleCondition: " with type=radio",
                validRoles: ["menuitemradio"],
                globalAriaAttributesValid: true
            },
            "range": {
                implicitRole: ["slider"],
                //roleCondition: " with type=radio",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "hidden": {
                implicitRole: null,
                //roleCondition: " with type=hidden",
                validRoles: null,
                globalAriaAttributesValid: false
            },
            "submit": {
                implicitRole: ["button"],
                //roleCondition: " with type=submit",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "checkbox-with-aria-pressed": {
                implicitRole: ["checkbox"],
                //roleCondition: " with type=checkbox and aria-pressed attribute is present",
                validRoles: ["button", "option", "menuitemcheckbox", "switch"],
                globalAriaAttributesValid: true
            },
            "checkbox-without-aria-pressed": {
                implicitRole: ["checkbox"],
                //roleCondition: " with type=checkbox and aria-pressed attribute is not present",
                validRoles: ["option", "menuitemcheckbox", "switch"],
                globalAriaAttributesValid: true
            },
            "reset": {
                implicitRole: ["button"],
                //roleCondition: " with type=reset",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "time": {
                implicitRole: null,
                //roleCondition: " with type=time",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "password": {
                implicitRole: null,
                //roleCondition: " with type=password",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "button": {
                implicitRole: ["button"],
                validRoles: ["link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "switch", "tab"],
                globalAriaAttributesValid: true
            },
            "image": {
                implicitRole: ["button"],
                //roleCondition: " with type=image",
                validRoles: ["link", "menuitem", "menuitemcheckbox", "menuitemradio", "radio", "switch"],
                globalAriaAttributesValid: true
            },
            "color": {
                implicitRole: null,
                //roleCondition: " with type=color",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "date": {
                implicitRole: null,
                //roleCondition: " with type=date",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "datetime": {
                implicitRole: null,
                //roleCondition: " with type=datetime",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "file": {
                implicitRole: null,
                //roleCondition: " with type=file",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "month": {
                implicitRole: null,
                //roleCondition: " with type=month",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "week": {
                implicitRole: null,
                //roleCondition: " with type=week",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "search-no-list": {
                implicitRole: ["searchbox"],
                //roleCondition: " with type=search and no list attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "search-list": {
                implicitRole: ["combobox"],
                //roleCondition: " with type=search and a list attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "email-no-list": {
                implicitRole: ["textbox"],
                //roleCondition: " with type=email and no list attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "email-with-list": {
                implicitRole: ["combobox"],
                //roleCondition: " with type=email and a list attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "text-no-list": {
                implicitRole: ["textbox"],
                //roleCondition: " with type=text and no list attribute is present",
                validRoles: ["combobox", "searchbox", "spinbutton"],
                globalAriaAttributesValid: true
            },
            "tel-no-list": {
                implicitRole: ["textbox"],
                //roleCondition: " with type=tel and no list attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "url-no-list": {
                implicitRole: ["textbox"],
                //roleCondition: " with type=url and no list attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "text-with-list": {
                implicitRole: ["combobox"],
                //roleCondition: " with type=text and a list attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "tel-with-list": {
                implicitRole: ["combobox"],
                //roleCondition: " with type=tel and a list attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "url-with-list": {
                implicitRole: ["combobox"],
                //roleCondition: " with type=url and a list attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "default": {
                implicitRole: null,
                //roleCondition: "",
                validRoles: null,
                globalAriaAttributesValid: true
            }
        },
        "li": {
            "parent-ol-or-ul": {
                implicitRole: ["listitem"],
                //roleCondition: " when the li element's parent is an ol or ul element",
                validRoles: ["menuitem", "menuitemcheckbox", "menuitemradio", "option", "presentation", "none", "radio", "separator", "tab", "treeitem"],
                globalAriaAttributesValid: true
            },
            "parent-not-ol-or-ul": {
                implicitRole: ["listitem"],
                //roleCondition: " when the li element's parent is not an ol or ul element", 
                validRoles: ["listitem", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "tab", "treeitem", "presentation"],
                globalAriaAttributesValid: true
            }
        },
        "link": {
            "with-href": {
                implicitRole: ["link"],
                //roleCondition: " when non-empty href attribute is present",
                validRoles: null,
                globalAriaAttributesValid: false //Task #978: we are following the html 5.3 requirements
            },
            "without-href": {
                implicitRole: null,
                //roleCondition: " when non-empty href attribute is not present",
                validRoles: null,
                globalAriaAttributesValid: false
            }
        },
        "menu": {
            "type-context": {
                implicitRole: ["menu"],
                validRoles: null,
                globalAriaAttributesValid: true
            }
        },
        "menuitem": {
            "type-command": {
                implicitRole: ["menuitem"],
                //roleCondition: " with type=command",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "type-checkbox": {
                implicitRole: ["menuitemcheckbox"],
                //roleCondition: " with type=checkbox",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "type-radio": {
                implicitRole: ["menuitemradio"],
                //roleCondition: " with type=radio",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "default": {
                implicitRole: ["menuitem"],
                //roleCondition: " without type=command, type=checkbox or type=radio",
                validRoles: null,
                globalAriaAttributesValid: true
            }
        },
        "option": {
            "list-suggestion-datalist": {
                implicitRole: ["option"],
                //roleCondition: " when option element is in a list of options or represents a suggestion in a datalist",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "not-list-suggestion-datalist": {
                implicitRole: ["option"],
                //roleCondition: " when option element  is not in a list of options or does not represent a suggestion in a datalist",
                validRoles: ["menuitem", "menuitemradio", "separator"],
                globalAriaAttributesValid: true
            }
        },
        "select": {
            "no-multiple-attr-size-gt1": {
                // with a multiple attribute or a size attribute having value greater than 1
                implicitRole: ["combobox"],
                validRoles: ["menu"],
                globalAriaAttributesValid: true
            },
            "multiple-attr-size-gt1": {
                // with no multiple attribute and no size attribute having value greater than 1
                implicitRole: ["listbox"],
                validRoles: null,
                globalAriaAttributesValid: true
            }
        },
        "text-level-semantic-elements": {
            implicitRole: null,
            //roleCondition: "",
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "default": {
            implicitRole: null,
            //roleCondition: "",
            validRoles: ["any"],
            globalAriaAttributesValid: true
        }
    }; // end of documentConformanceRequirementSpecialTags
    /*Text level semantic elements not listed elsewhere:em, strong, small, s, cite, q, dfn, abbr, time, code, var, samp, kbd, sub and sup, i, b, u, mark , ruby, rt, rp, bdi, bdo, br, wbr */
    ARIADefinitions.textLevelSemanticElements = ["em", "strong", "small", "s", "cite", "q", "dfn",
        "abbr", "time", "code", "var", "samp", "kbd", "sub", "sup", "i", "b", "u", "mark",
        "ruby", "rt", "rp", "bdi", "bdo", "br", "wbr"
    ];
    ARIADefinitions.containers = [];
    return ARIADefinitions;
}());
exports.ARIADefinitions = ARIADefinitions;
;
var containerArray = [];
for (var roleDesign in ARIADefinitions.designPatterns) {
    var containers = ARIADefinitions.designPatterns[roleDesign].container;
    if (containers !== null) {
        for (var _i = 0, containers_1 = containers; _i < containers_1.length; _i++) {
            var container = containers_1[_i];
            if (containerArray.indexOf(container) == -1) {
                containerArray.push(container);
            }
        }
    }
}
ARIADefinitions.containers = containerArray;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DOMUtil = void 0;
var DOMUtil = /** @class */ (function () {
    function DOMUtil() {
    }
    DOMUtil.hasParent = function (node, names) {
        var p = node.parentElement;
        while (p && !names.includes(p.nodeName)) {
            p = p.parentElement;
        }
        return !!p;
    };
    DOMUtil.getAncestor = function (node, names) {
        var p = node.parentElement;
        while (p && !names.includes(p.nodeName.toLowerCase())) {
            p = p.parentElement;
        }
        return p;
    };
    DOMUtil.isNodeVisible = function (node) {
        var vis = null;
        while (node && node.nodeType !== 1 /* Node.ELEMENT_NODE */) {
            node = node.parentElement;
        }
        var elem = node;
        var w = elem.ownerDocument.defaultView;
        do {
            var cs = w.getComputedStyle(elem);
            if (cs.display === "none")
                return false;
            if (vis === null && cs.visibility) {
                vis = cs.visibility;
                if (vis === "hidden")
                    return false;
            }
            elem = elem.parentElement;
        } while (elem);
        return true;
    };
    DOMUtil.sameNode = function (a, b) {
        if (a === b) {
            return true;
        }
        else if (a.isSameNode) {
            return a.isSameNode(b);
        }
        else if (a.compareDocumentPosition) {
            return a.compareDocumentPosition(b) === 0;
        }
        else {
            // Not supported in this environment - try our best
            return true;
        }
    };
    DOMUtil.cleanWhitespace = function (s) {
        var retVal = s.replace(/[ \t\r\n]/g, " ").replace(/ +/g, " ");
        return retVal;
    };
    DOMUtil.cleanSpace = function (s) {
        var retVal = s.replace(/ +/g, " ");
        return retVal;
    };
    return DOMUtil;
}());
exports.DOMUtil = DOMUtil;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = void 0;
var Config = /** @class */ (function () {
    function Config() {
    }
    Config.DEBUG = false;
    Config.helpRoot = "https://able.ibm.com/rules/tools/help";
    return Config;
}());
exports.Config = Config;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommonMapper = void 0;
var CommonMapper = /** @class */ (function () {
    function CommonMapper() {
        this.hierarchyRole = null;
        this.hierarchyChildrenHaveRole = null;
        this.hierarchyPath = null;
        this.hierarchyResults = null;
    }
    CommonMapper.prototype.getBounds = function (node) {
        return null;
    };
    CommonMapper.prototype.reset = function (node) {
        this.hierarchyRole = [];
        this.hierarchyResults = [];
        this.hierarchyChildrenHaveRole = [];
        this.hierarchyPath = [{
                rolePath: "",
                roleCount: {}
            }];
        var ancestors = [];
        var parent = node.parentNode;
        while (parent && parent.nodeType != 9 /* Node.DOCUMENT_NODE */) {
            ancestors.push(parent);
            parent = parent.parentNode;
        }
        ancestors = ancestors.reverse();
        for (var _i = 0, ancestors_1 = ancestors; _i < ancestors_1.length; _i++) {
            var ancestor = ancestors_1[_i];
            var siblings = [];
            var sibling = ancestor.previousSibling;
            while (sibling) {
                siblings.push(sibling);
                sibling = sibling.previousSibling;
            }
            siblings = siblings.reverse();
            for (var _a = 0, siblings_1 = siblings; _a < siblings_1.length; _a++) {
                var sibling_1 = siblings_1[_a];
                this.pushHierarchy(sibling_1);
                this.popHierarchy();
            }
            this.pushHierarchy(ancestor);
        }
    };
    CommonMapper.prototype.pushHierarchy = function (node) {
        var role;
        var presentationalContainer = this.hierarchyChildrenHaveRole.length > 0 && !this.hierarchyChildrenHaveRole[this.hierarchyChildrenHaveRole.length - 1];
        if (presentationalContainer) {
            role = "none";
            this.hierarchyChildrenHaveRole.push(false);
        }
        else {
            role = this.getRole(node) || "none";
            this.hierarchyChildrenHaveRole.push(this.childrenHaveRole(node, role));
        }
        this.hierarchyRole.push(role);
        if (role !== "none") {
            var parentPathInfo = this.hierarchyPath[this.hierarchyPath.length - 1];
            parentPathInfo.roleCount[role] = (parentPathInfo.roleCount[role] || 0) + 1;
            this.hierarchyPath.push({
                "rolePath": parentPathInfo.rolePath + "/" + role + "[" + parentPathInfo.roleCount[role] + "]",
                "roleCount": {}
            });
        }
        this.hierarchyResults.push({
            node: node,
            namespace: this.getNamespace(),
            role: role,
            attributes: this.getAttributes(node),
            rolePath: this.hierarchyPath[this.hierarchyPath.length - 1].rolePath,
            bounds: this.getBounds(node)
        });
    };
    CommonMapper.prototype.popHierarchy = function () {
        var role = this.hierarchyRole.pop();
        this.hierarchyChildrenHaveRole.pop();
        if (role !== "none") {
            this.hierarchyPath.pop();
        }
        this.hierarchyResults.pop();
    };
    CommonMapper.prototype.openScope = function (node) {
        if (this.hierarchyRole === null) {
            this.reset(node);
        }
        this.pushHierarchy(node);
        return this.hierarchyResults;
    };
    CommonMapper.prototype.closeScope = function (node) {
        var retVal = [];
        for (var _i = 0, _a = this.hierarchyResults; _i < _a.length; _i++) {
            var res = _a[_i];
            // const temp = res.node;
            // res.node = null;
            // let cloned = JSON.parse(JSON.stringify(res));
            // cloned.node = res.node = temp; 
            // retVal.push(cloned);
            retVal.push(res);
        }
        retVal[retVal.length - 1].role = "/" + retVal[retVal.length - 1].role;
        this.popHierarchy();
        return retVal;
    };
    return CommonMapper;
}());
exports.CommonMapper = CommonMapper;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ARIAMapper = void 0;
var ARIADefinitions_1 = __webpack_require__(2);
var CommonMapper_1 = __webpack_require__(5);
var DOMUtil_1 = __webpack_require__(3);
var DOMWalker_1 = __webpack_require__(10);
var legacy_1 = __webpack_require__(1);
var ARIAMapper = /** @class */ (function (_super) {
    __extends(ARIAMapper, _super);
    function ARIAMapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ARIAMapper.prototype.childrenHaveRole = function (node, role) {
        // if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
        //     const elem = node as Element;
        //     if (elem.getAttribute("aria-hidden") === "true") {
        //         return false;
        //     }
        // }
        return !(role in ARIADefinitions_1.ARIADefinitions.designPatterns && ARIADefinitions_1.ARIADefinitions.designPatterns[role].presentationalChildren);
    };
    ARIAMapper.prototype.getRole = function (node) {
        var role = ARIAMapper.nodeToRole(node);
        return role;
    };
    ARIAMapper.prototype.getNamespace = function () {
        return "aria";
    };
    ARIAMapper.prototype.getAttributes = function (node) {
        var retVal = {};
        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
            var elem_1 = node;
            for (var idx = 0; idx < elem_1.attributes.length; ++idx) {
                var attrInfo = elem_1.attributes[idx];
                var name_1 = attrInfo.name.toLowerCase();
                if (name_1.startsWith("aria-")) {
                    retVal[name_1.substring(5)] = attrInfo.nodeValue;
                }
            }
            var applyAttrRole = function (nodeName) {
                if (!(nodeName in ARIAMapper.elemAttrValueCalculators))
                    return;
                for (var attr in ARIAMapper.elemAttrValueCalculators[nodeName]) {
                    if (!(attr in retVal)) {
                        var value = ARIAMapper.elemAttrValueCalculators[nodeName][attr];
                        if (typeof value != "undefined" && value !== null) {
                            if (typeof value !== typeof "") {
                                value = value(elem_1);
                            }
                            retVal[attr] = value;
                        }
                    }
                }
            };
            applyAttrRole("global");
            applyAttrRole(node.nodeName.toLowerCase());
        }
        else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
            for (var attr in ARIAMapper.textAttrValueCalculators) {
                var val = ARIAMapper.textAttrValueCalculators[attr](node);
                if (typeof val != "undefined" && val !== null) {
                    retVal[attr] = val;
                }
            }
        }
        return retVal;
    };
    ARIAMapper.prototype.reset = function (node) {
        ARIAMapper.nameComputationId = 0;
        _super.prototype.reset.call(this, node);
    };
    ARIAMapper.computeName = function (cur) {
        ++ARIAMapper.nameComputationId;
        return ARIAMapper.computeNameHelp(ARIAMapper.nameComputationId, cur, false, false);
    };
    ARIAMapper.computeNameHelp = function (walkId, cur, labelledbyTraverse, walkTraverse) {
        // 2g. None of the other content applies to text nodes, so just do this first
        if (cur.nodeType === 3 /* Node.TEXT_NODE */)
            return cur.nodeValue;
        if (cur.nodeType !== 1 /* Node.ELEMENT_NODE */)
            throw new Error("Can only compute name on Element and Text");
        var elem = cur;
        // We've been here before - prevent recursion
        if (legacy_1.RPTUtil.getCache(elem, "data-namewalk", null) === "" + walkId)
            return "";
        legacy_1.RPTUtil.setCache(elem, "data-namewalk", "" + walkId);
        // See https://www.w3.org/TR/html-aam-1.0/#input-type-text-input-type-password-input-type-search-input-type-tel-input-type-url-and-textarea-element
        // 2a. Only show hidden content if it's referenced by a labelledby
        if (!!labelledbyTraverse && !DOMUtil_1.DOMUtil.isNodeVisible(cur)) {
            return "";
        }
        // 2b. collect valid id references
        if (!labelledbyTraverse && elem.hasAttribute("aria-labelledby")) {
            var labelledby = elem.getAttribute("aria-labelledby").split(" ");
            var validElems = [];
            for (var _i = 0, labelledby_1 = labelledby; _i < labelledby_1.length; _i++) {
                var ref = labelledby_1[_i];
                var refElem = cur.ownerDocument.getElementById(ref);
                if (refElem) {
                    validElems.push(refElem);
                }
            }
            if (validElems.length > 0) {
                var accumulated = "";
                for (var _a = 0, validElems_1 = validElems; _a < validElems_1.length; _a++) {
                    var elem_2 = validElems_1[_a];
                    accumulated += " " + this.computeNameHelp(walkId, elem_2, true, false);
                }
                return accumulated.trim();
            }
        }
        // 2c. If label or walk, and this is a control, skip to the value, otherwise provide the label
        var role = ARIAMapper.nodeToRole(cur);
        var isEmbeddedControl = [
            "textbox", "button", "combobox", "listbox",
            "progressbar", "scrollbar", "slider", "spinbutton"
        ].includes(role);
        if (elem.hasAttribute("aria-label") && elem.getAttribute("aria-label").trim().length > 0) {
            // If I'm not an embedded control or I'm not recursing, return the aria-label
            if (!labelledbyTraverse && !walkTraverse || !isEmbeddedControl) {
                return elem.getAttribute("aria-label").trim();
            }
        }
        // 2d. 
        if (role !== "presentation" && role !== "none") {
            if (cur.nodeName.toLowerCase() === "img" && elem.hasAttribute("alt")) {
                return DOMUtil_1.DOMUtil.cleanWhitespace(elem.getAttribute("alt")).trim();
            }
            if (cur.nodeName.toLowerCase() === "input" && elem.hasAttribute("id") && elem.getAttribute("id").length > 0) {
                var label = elem.ownerDocument.querySelector("label[for='" + elem.getAttribute("id") + "']");
                if (label) {
                    return this.computeNameHelp(walkId, label, false, false);
                }
            }
        }
        // 2e.
        if ((walkTraverse || labelledbyTraverse) && isEmbeddedControl) {
            // If the embedded control has role textbox, return its value.
            if (role === "textbox") {
                if (elem.nodeName.toLowerCase() === "input") {
                    if (elem.hasAttribute("value"))
                        return elem.getAttribute("value");
                }
                else {
                    walkTraverse = false;
                }
            }
            // If the embedded control has role button, return the text alternative of the button.
            if (role === "button") {
                if (elem.nodeName.toLowerCase() === "input") {
                    var type = elem.getAttribute("type").toLowerCase();
                    if (["button", "submit", "reset"].includes(type)) {
                        if (elem.hasAttribute("value"))
                            return elem.getAttribute("value");
                        if (type === "submit")
                            return "Submit";
                        if (type === "reset")
                            return "Reset";
                    }
                }
                else {
                    walkTraverse = false;
                }
            }
            // TODO: If the embedded control has role combobox or listbox, return the text alternative of the chosen option.
            if (role === "combobox") {
                if (elem.hasAttribute("aria-activedescendant")) {
                    var selected = elem.ownerDocument.getElementById("aria-activedescendant");
                    if (selected) {
                        return ARIAMapper.computeNameHelp(walkId, selected, false, false);
                    }
                }
            }
            // If the embedded control has role range (e.g., a spinbutton or slider):
            if (["progressbar", "scrollbar", "slider", "spinbutton"].includes(role)) {
                // If the aria-valuetext property is present, return its value,
                if (elem.hasAttribute("aria-valuetext"))
                    return elem.getAttribute("aria-valuetext");
                // Otherwise, if the aria-valuenow property is present, return its value,
                if (elem.hasAttribute("aria-valuenow"))
                    return elem.getAttribute("aria-valuenow");
                // TODO: Otherwise, use the value as specified by a host language attribute.
            }
        }
        // 2f. 2h.
        if (!walkTraverse && (ARIADefinitions_1.ARIADefinitions.nameFromContent(role) || labelledbyTraverse)) {
            // 2fi. Set the accumulated text to the empty string.
            var accumulated = "";
            // 2fii. Check for CSS generated textual content associated with the current node and 
            // include it in the accumulated text. The CSS :before and :after pseudo elements [CSS2] 
            // can provide textual content for elements that have a content model.
            //   For :before pseudo elements, User agents MUST prepend CSS textual content, without 
            //     a space, to the textual content of the current node.
            //   For :after pseudo elements, User agents MUST append CSS textual content, without a 
            //     space, to the textual content of the current node.
            var before = null;
            before = elem.ownerDocument.defaultView.getComputedStyle(elem, "before").content;
            if (before && before !== "none") {
                before = before.replace(/^"/, "").replace(/"$/, "");
                accumulated += before;
            }
            // 2fiii. For each child node of the current node:
            //   Set the current node to the child node.
            //   Compute the text alternative of the current node beginning with step 2. Set the result 
            //     to that text alternative.
            //   Append the result to the accumulated text.
            var walkChild = new DOMWalker_1.DOMWalker(elem, false, elem);
            while (walkChild.nextNode() && !walkChild.atRoot()) {
                if (!walkChild.bEndTag) {
                    accumulated += " " + ARIAMapper.computeNameHelp(walkId, walkChild.node, labelledbyTraverse, true);
                }
            }
            var after = null;
            try {
                after = elem.ownerDocument.defaultView.getComputedStyle(elem, "after").content;
            }
            catch (e) { }
            if (after && after !== "none") {
                after = after.replace(/^"/, "").replace(/"$/, "");
                accumulated += after;
            }
            // 2fiv. Return the accumulated text.
            accumulated = accumulated.replace(/\s+/g, " ").trim();
            return accumulated;
        }
        // 2i. Otherwise, if the current node has a Tooltip attribute, return its value.
        if (elem.hasAttribute("title")) {
            return elem.getAttribute("title");
        }
        return "";
    };
    /*        if (role in ARIADefinitions.designPatterns
                && ARIADefinitions.designPatterns[role].nameFrom
                && ARIADefinitions.designPatterns[role].nameFrom.includes("contents"))
            {
                name = elem.textContent;
            }
            if (elem.nodeName.toLowerCase() === "input" && elem.hasAttribute("id") && elem.getAttribute("id").trim().length > 0) {
                name = elem.ownerDocument.querySelector("label[for='"+elem.getAttribute("id").trim()+"']").textContent;
            }
            if (elem.hasAttribute("aria-label")) {
                name = elem.getAttribute("aria-label");
            }
            if (elem.hasAttribute("aria-labelledby")) {
                name = "";
                const ids = elem.getAttribute("aria-labelledby").split(" ");
                for (const id of ids) {
                    name += elem.ownerDocument.getElementById(id).textContent + " ";
                }
                name = name.trim();
            }
            return name;
        }*/
    ARIAMapper.nodeToRole = function (node) {
        if (node.nodeType === 3 /* Node.TEXT_NODE */) {
            return "text";
        }
        else if (node.nodeType !== 1 /* Node.ELEMENT_NODE */) {
            return null;
        }
        var elem = node;
        if (!elem || elem.nodeType !== 1 /* Node.ELEMENT_NODE */) {
            return null;
        }
        if (elem.hasAttribute("role") && elem.getAttribute("role").trim().length > 0) {
            return elem.getAttribute("role").trim();
        }
        var nodeName = elem.nodeName.toLowerCase();
        if (!(nodeName in ARIAMapper.elemToRoleMap)) {
            return null;
        }
        var role = ARIAMapper.elemToRoleMap[nodeName];
        if (typeof role === "string") {
            return role;
        }
        else if (typeof role === "function") {
            return role(elem);
        }
        else {
            return null;
        }
    };
    ARIAMapper.hasParentRole = function (element, role) {
        var parent = element.parentNode;
        // If link is in a menu, it's a menuitem
        while (parent) {
            if (ARIAMapper.nodeToRole(parent) === role)
                return true;
            parent = parent.parentNode;
        }
        return false;
    };
    ARIAMapper.inputToRole = function (element) {
        if (!element) {
            return null;
        }
        var eType = "text";
        if (element.hasAttribute("type") && element.getAttribute("type").toLowerCase().trim().length > 0) {
            eType = element.getAttribute("type").toLowerCase().trim();
        }
        if (!(eType in ARIAMapper.inputToRoleMap)) {
            return null;
        }
        var role = ARIAMapper.inputToRoleMap[eType];
        if (typeof role === "string") {
            return role;
        }
        else if (typeof role === "function") {
            return role(element);
        }
        else {
            return null;
        }
    };
    ////////////////////////////////////////////////////////////////////////////
    // Helper functions
    ////
    // https://www.w3.org/TR/html-aam-1.0/#mapping-html-to-accessibility-apis
    ARIAMapper.elemAttrValueCalculators = {
        "global": {
            "name": ARIAMapper.computeName
        },
        "datalist": {
            // set to "true" if the datalist's selection model allows multiple option elements to be
            // selected at a time, and "false" otherwise
            "multiselectable": function (elem) {
                var id = elem.getAttribute("id");
                if (id && id.length > 0) {
                    var input = elem.ownerDocument.querySelector("input[list='" + id + "']");
                    return "" + (elem.getAttribute("multiple")
                        && (elem.getAttribute("multiple") == "true" || elem.getAttribute("multiple") == ""));
                }
                return null;
            }
        },
        "h1": {
            "level": "1"
        },
        "h2": {
            "level": "2"
        },
        "h3": {
            "level": "3"
        },
        "h4": {
            "level": "4"
        },
        "h5": {
            "level": "5"
        },
        "h6": {
            "level": "6"
        },
        "input": {
            // - type="checkbox" state set to "mixed" if the element's indeterminate IDL attribute 
            // is true, or "true" if the element's checkedness is true, or "false" otherwise
            // - type="radio" state set to "true" if the element's checkedness is true, or "false" 
            // otherwise. 
            "checked": function (elem) {
                if (elem.getAttribute("type") === "checkbox" || elem.getAttribute("type") === "radio") {
                    return "" + elem.checked;
                }
                return null;
            }
            // - type="radio" and not in menu reflecting number of type=radio input elements 
            // within the radio button group
            ,
            "setsize": function (elem) { return null; throw new Error("NOT IMPLEMENTED"); }
            // - type="radio" and not in menu value reflecting the elements position 
            // within the radio button group."
            ,
            "posinset": function (elem) { return null; throw new Error("NOT IMPLEMENTED"); }
            // input (type attribute in the Text, Search, Telephone, URL, or E-mail states with a 
            // suggestions source element) combobox role, with the aria-owns property set to the same
            // value as the list attribute
            ,
            "owns": function (elem) { return null; throw new Error("NOT IMPLEMENTED"); }
        },
        "keygen": {
            "multiselectable": "false"
        },
        "li": {
            // Number of li elements within the ol, ul, menu
            "setsize": function (elem) {
                var parent = DOMUtil_1.DOMUtil.getAncestor(elem, ["ol", "ul", "menu"]);
                if (!parent)
                    return null;
                var lis = parent.querySelectorAll("li");
                var otherlis = parent.querySelectorAll("ol li, ul li, menu li");
                return "" + (lis.length - otherlis.length);
            }
            // Position of li element within the ol, ul, menu
            ,
            "posinset": function (elem) {
                var parent = DOMUtil_1.DOMUtil.getAncestor(elem, ["ol", "ul", "menu"]);
                if (!parent)
                    return null;
                var lis = parent.querySelectorAll("li");
                var num = 0;
                for (var idx = 0; idx < lis.length; ++idx) {
                    var li = lis[idx];
                    if (DOMUtil_1.DOMUtil.sameNode(parent, DOMUtil_1.DOMUtil.getAncestor(li, ["ol", "ul", "menu"]))) {
                        return "" + num;
                    }
                    ++num;
                }
                return null;
            }
        },
        "menuitem": {
            // type = checkbox or radio, set to "true" if the checked attribute 
            // is present, and "false" otherwise
            "checked": function (elem) { return "" + !!(elem.getAttribute("checked")
                && (elem.getAttribute("checked") == "true" || elem.getAttribute("checked") == "")); }
        },
        "option": {
            // set to "true" if the element's selectedness is true, or "false" otherwise.
            "selected": function (elem) { return "" + !!(elem.getAttribute("selected")
                && (elem.getAttribute("selected") == "true" || elem.getAttribute("selected") == "")); }
        },
        "progress": {
            "valuemax": function (elem) { return elem.getAttribute("max") || "1"; },
            "valuemin": function (elem) { return "0"; },
            "valuenow": function (elem) { return elem.getAttribute("value"); }
        }
    };
    ARIAMapper.textAttrValueCalculators = {
        "name": function (node) { return node.nodeValue; }
    };
    ARIAMapper.nameComputationId = 0;
    ARIAMapper.inputToRoleMap = (function () {
        var menuButtonCheck = function (element) {
            return ARIAMapper.hasParentRole(element, "menu") ? "menuitem" : "button";
        };
        var textSuggestions = function (element) {
            if (element.hasAttribute("list")) {
                var id = element.getAttribute("list");
                var idRef = element.ownerDocument.getElementById(id);
                if (idRef && idRef.nodeName.toLowerCase() === "datalist") {
                    return "combobox";
                }
            }
            return "textbox";
        };
        return {
            "button": menuButtonCheck,
            "image": menuButtonCheck,
            "checkbox": function (element) {
                return ARIAMapper.hasParentRole(element, "menu") ? "menuitemcheckbox" : "checkbox";
            },
            "radio": function (element) {
                return ARIAMapper.hasParentRole(element, "menu") ? "menuitemradio" : "radio";
            },
            "email": textSuggestions,
            "search": textSuggestions,
            "tel": textSuggestions,
            "text": textSuggestions,
            "url": textSuggestions,
            "password": "textbox",
            "number": "spinbutton",
            "range": "slider",
            "reset": "button",
            "submit": "button"
        };
    })();
    ARIAMapper.elemToRoleMap = (function () {
        var sectioningRoots = {
            "blockquote": true,
            "body": true,
            "details": true,
            "dialog": true,
            "fieldset": true,
            "figure": true,
            "td": true
        };
        var sectioningContent = {
            "article": true,
            "aside": true,
            "nav": true,
            "section": true
        };
        var inputToRole = function (element) {
            return ARIAMapper.inputToRole(element);
        };
        return {
            "a": function (element) {
                // If it doesn't represent a hyperlink, no corresponding role
                if (!element.hasAttribute("href"))
                    return null;
                // If link is in a menu, it's a menuitem, otherwise it's a link
                return ARIAMapper.hasParentRole(element, "menu") ? "menuitem" : "link";
            },
            "area": function (element) {
                // If it doesn't represent a hyperlink, no corresponding role
                if (!element.hasAttribute("href"))
                    return null;
                return "link";
            },
            "article": "article",
            "aside": "complementary",
            "body": "document",
            "button": "button",
            "datalist": "listbox",
            "dd": "definition",
            "details": "group",
            "dialog": "dialog",
            "footer": function (element) {
                var parent = element.parentNode;
                var nodeName = parent.nodeName.toLowerCase();
                // If nearest sectioningRoot or sectioningContent is body
                while (parent) {
                    if (sectioningRoots[nodeName] || sectioningContent[nodeName]) {
                        return (nodeName === "body") ? "contentinfo" : null;
                    }
                    parent = parent.parentNode;
                    nodeName = parent.nodeName.toLowerCase();
                }
                return null;
            },
            "form": "form",
            "h1": "heading",
            "h2": "heading",
            "h3": "heading",
            "h4": "heading",
            "h5": "heading",
            "h6": "heading",
            "header": function (element) {
                var parent = element.parentNode;
                var nodeName = parent.nodeName.toLowerCase();
                // If nearest sectioningRoot or sectioningContent is body
                while (parent) {
                    if (sectioningRoots[nodeName] || sectioningContent[nodeName]) {
                        return (nodeName === "body") ? "banner" : null;
                    }
                    parent = parent.parentNode;
                    nodeName = parent.nodeName.toLowerCase();
                }
                return null;
            },
            "hr": "separator",
            "img": function (element) {
                if (element.hasAttribute("alt") && element.getAttribute("alt").length === 0) {
                    return "presentation";
                }
                else {
                    return "img";
                }
            },
            "input": inputToRole,
            "keygen": "listbox",
            "li": "listitem",
            "main": "main",
            "math": "math",
            "menu": function (element) {
                if (!element.hasAttribute("type"))
                    return null;
                var eType = element.getAttribute("type").toLowerCase();
                if (eType === "context")
                    return "menu";
                if (eType === "toolbar")
                    return "toolbar";
                return null;
            },
            "menuitem": function (element) {
                // Default type is command
                if (!element.hasAttribute("type"))
                    return "menuitem";
                var eType = element.getAttribute("type").toLowerCase();
                if (eType.trim().length == 0)
                    return "menuitem";
                if (eType === "command")
                    return "menuitem";
                if (eType === "checkbox")
                    return "menuitemcheckbox";
                if (eType === "radio")
                    return "menuitemradio";
                return null;
            },
            "meter": "progressbar",
            "nav": "navigation",
            "ol": "list",
            "optgroup": "group",
            "option": "option",
            "output": "status",
            "progress": "progressbar",
            "section": "region",
            "select": function (element) {
                if (element.hasAttribute("multiple") || (element.hasAttribute("size") && parseInt(element.getAttribute("size")) > 1)) {
                    return "listbox";
                }
                else {
                    return "combobox";
                }
            },
            "table": "table",
            "textarea": "textbox",
            "tbody": "rowgroup",
            "td": function (element) {
                var parent = element.parentNode;
                while (parent) {
                    var role = ARIAMapper.nodeToRole(parent);
                    if (role === "table")
                        return "cell";
                    if (role === "grid")
                        return "gridcell";
                    parent = parent.parentNode;
                }
                return null;
            },
            "th": function (element) {
                /** https://www.w3.org/TR/html5/tabular-data.html#header-and-data-cell-semantics
                 * A header cell anchored at the slot with coordinate (x, y) with width width and height height is
                 * said to be a column header if any of the following conditions are true:
                 * * The cell's scope attribute is in the column state, or
                 * * The cell's scope attribute is in the auto state, and there are no data cells in any of
                 *   the cells covering slots with y-coordinates y .. y+height-1.
                 * A header cell anchored at the slot with coordinate (x, y) with width width and height height is
                 * said to be a row header if any of the following conditions are true:
                 * * The cell's scope attribute is in the row state, or
                 * * The cell's scope attribute is in the auto state, the cell is not a column header, and there are
                 *   no data cells in any of the cells covering slots with x-coordinates x .. x+width-1.
                 */
                // Note: auto is default scope
                // Easiest answer is if scope is specified
                if (element.hasAttribute("scope")) {
                    var scope = element.getAttribute("scope").toLowerCase();
                    if (scope === "row")
                        return "rowheader";
                    if (scope === "col")
                        return "columnheader";
                }
                // We don't have a scope..  figure out if we might be a column or data header
                if (!element.hasAttribute("scope") || element.getAttribute("scope").toLowerCase() === "auto") {
                    // TODO: We need to generate the full table. We should do this once on the table as part of the engine
                    // and re-use it in the rules. We are already doing this in the table rules, but should formalize it better
                    // and move it into the engine.
                }
                // We're a cell - determine if we're a table cell or a grid cell
                var parent = element.parentNode;
                while (parent) {
                    var role = ARIAMapper.nodeToRole(parent);
                    if (role === "table")
                        return "cell";
                    if (role === "grid")
                        return "gridcell";
                    parent = parent.parentNode;
                }
                return null;
            },
            "tfoot": "rowgroup",
            "thead": "rowgroup",
            "tr": "row",
            "ul": "list"
        };
    })();
    return ARIAMapper;
}(CommonMapper_1.CommonMapper));
exports.ARIAMapper = ARIAMapper;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.AncestorUtil = void 0;
var AncestorUtil = /** @class */ (function () {
    function AncestorUtil() {
    }
    AncestorUtil.isPresentationFrame = function (contextHierarchy) {
        if (contextHierarchy && contextHierarchy.dom) {
            // Skip current node because we want ancestry
            for (var idx = contextHierarchy.dom.length - 2; idx >= 0; --idx) {
                var elem = contextHierarchy.dom[idx].node;
                if (elem.nodeType === 1 && elem.getAttribute("role") === "presentation" || elem.getAttribute("aria-hidden") === "true") {
                    return true;
                }
            }
        }
        return false;
    };
    return AncestorUtil;
}());
exports.AncestorUtil = AncestorUtil;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = exports.checkDemo = exports.ARIAMapper = exports.Context = exports.Checker = void 0;
var Context_1 = __webpack_require__(9);
Object.defineProperty(exports, "Context", { enumerable: true, get: function () { return Context_1.Context; } });
// import { Simulator } from "./v2/simulator"
var checker_1 = __webpack_require__(11);
Object.defineProperty(exports, "Checker", { enumerable: true, get: function () { return checker_1.Checker; } });
var ARIAMapper_1 = __webpack_require__(6);
Object.defineProperty(exports, "ARIAMapper", { enumerable: true, get: function () { return ARIAMapper_1.ARIAMapper; } });
var Config_1 = __webpack_require__(4);
Object.defineProperty(exports, "Config", { enumerable: true, get: function () { return Config_1.Config; } });
String.prototype.startsWith = String.prototype.startsWith || function (str) {
    return this.indexOf(str) === 0;
};
String.prototype.includes = String.prototype.includes || function (str) {
    return this.indexOf(str) !== -1;
};
Array.prototype.includes = Array.prototype.includes || function (str) {
    return this.indexOf(str) !== -1;
};
/*
function simDemo(timeout?: number) {
    if (!timeout) timeout = 0;
    setTimeout(function() {
        let sim = new Simulator();
        let s = sim.renderItem(document.documentElement);
        console.group("--- Item View ---");
        console.log(s);
        console.groupEnd();
        console.group("--- Link View ---");
        s = sim.renderLink(document.documentElement);
        console.log(s);
        console.groupEnd();
    }, timeout);
}
*/
function checkDemo(timeout) {
    if (!timeout)
        timeout = 0;
    var checker = new checker_1.Checker();
    setTimeout(function () {
        checker.check(document.documentElement, ["IBM_Accessibility", "IBM_Design"])
            .then(function (report) {
            console.log(report);
            var vals = {
                "FAIL": 0,
                "POTENTIAL": 1,
                "MANUAL": 2,
                "PASS": 3
            };
            for (var idx = 0; idx < report.results.length; ++idx) {
                if (report.results[idx].value[1] === "PASS") {
                    report.results.splice(idx--, 1);
                }
            }
            report.results.sort(function (a, b) {
                if (a.category != b.category) {
                    return a.category.localeCompare(b.category);
                }
                if (a.path["aria"] === b.path["aria"]) {
                    return vals[a.value[1]] - vals[b.value[1]];
                }
                return a.path["aria"].localeCompare(b.path["aria"]);
            });
            var lastPath = null;
            var category = null;
            for (var _i = 0, _a = report.results; _i < _a.length; _i++) {
                var result = _a[_i];
                if (category !== result.category) {
                    if (category !== null) {
                        console.groupEnd();
                        console.groupEnd();
                        lastPath = null;
                    }
                    category = result.category;
                    console.group(result.category);
                }
                if (result.path["aria"] != lastPath) {
                    if (lastPath !== null) {
                        console.groupEnd();
                    }
                    lastPath = result.path["aria"];
                    if (lastPath === "") {
                        console.group("page");
                    }
                    else {
                        console.group(lastPath);
                    }
                }
                console.log(result.value, result.message);
            }
            console.groupEnd();
            console.groupEnd();
        });
    }, timeout);
}
exports.checkDemo = checkDemo;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = exports.PartInfo = exports.AttrInfo = void 0;
// Context that will cause this rule to execute. 
// Context syntax:
//   Triggers:
//     role - Triggers on element with ARIA role role
//     role[attribute] - Triggers on elements with the equivalent logical 
//       aria- attribute (e.g., button[disabled] will trigger on 
//       <button disabled> or <div role="button" aria-disabled="true">)
//     role[attribute=value] - Similar to above, with case-sensitive match
//       to value
//     role[attribute~value] - Similar to above, with case-insensitive match
//     Note: Wrapping role in <>'s will trigger on HTML elements or attributes
//       (avoid when possible)
//   Combining triggers:
//     trigger1 trigger2 - Triggers on elements with trigger2 within an 
//       element with trigger1
//     !trigger1 trigger2 - Triggers on elements with trigger2 not within
//       element with trigger1
//     trigger1>trigger2 - Triggers on elements with trigger2 with an
//       an immediate parent with trigger1
//     trigger1+trigger2 - Triggers on elements with trigger2 with an
//       immediate previous sibling with trigger1
//     trigger1~trigger2 - Triggers on elements with trigger2 with an
//       some earlier sibling with trigger1
//     context,context - Triggers on elements with either context
var AttrInfo = /** @class */ (function () {
    function AttrInfo(inclusive, attr, eq, value) {
        this.inclusive = inclusive;
        this.attr = attr;
        this.eq = eq;
        this.value = value;
        if (!inclusive
            && ((typeof eq) !== "undefined" && eq.length > 0)) {
            throw new Error("Cannot have !attr" + eq + " context");
        }
        if (inclusive && (typeof eq) !== "undefined" && eq.length > 0 && ((typeof value) === "undefined" || value.length === 0)) {
            throw new Error("Cannot have equivalence check without a value");
        }
    }
    AttrInfo.prototype.matches = function (context) {
        var ruleAttrPart = this;
        var elemAttrs = context.attributes;
        if (!(ruleAttrPart.attr in elemAttrs)) {
            return !ruleAttrPart.inclusive;
        }
        else if (!ruleAttrPart.inclusive) {
            return false;
        }
        else if (!ruleAttrPart.eq) {
            // inclusive match and I have that attribute and no equivalence defined
            return true;
        }
        else {
            // inclusive match and I have that attribute and equivalence defined
            var attrValue = elemAttrs[ruleAttrPart.attr];
            if (ruleAttrPart.eq === "=") {
                return ruleAttrPart.value === attrValue;
            }
            else if (ruleAttrPart.eq === "!=") {
                return ruleAttrPart.value !== attrValue;
            }
            else if (ruleAttrPart.eq === "~") {
                return ruleAttrPart.value === attrValue;
            }
            else if (ruleAttrPart.eq === "!~") {
                return ruleAttrPart.value !== attrValue;
            }
            else {
                throw new Error("Context equivalence operator not supported");
            }
        }
    };
    return AttrInfo;
}());
exports.AttrInfo = AttrInfo;
var PartInfo = /** @class */ (function () {
    function PartInfo(inclusive, namespace, role, attrs, connector) {
        this.inclusive = inclusive;
        this.namespace = namespace;
        this.role = role;
        this.attrs = attrs;
        this.connector = connector;
        if (role === "*" && !inclusive) {
            throw new Error("!* context not supported");
        }
    }
    PartInfo.prototype.matches = function (contextHier, hierLevel) {
        var rulePart = this;
        var ruleRoleMatch = (rulePart.namespace in contextHier)
            && (contextHier[rulePart.namespace][hierLevel].role === rulePart.role
                || contextHier[rulePart.namespace][hierLevel].role !== "none" && rulePart.role === "*");
        if (ruleRoleMatch
            && rulePart.role === "*"
            && rulePart.namespace === "dom"
            && (contextHier[rulePart.namespace][hierLevel].role === "#text"
                || contextHier[rulePart.namespace][hierLevel].role === "/#text")) {
            ruleRoleMatch = false;
        }
        if (rulePart.inclusive && !ruleRoleMatch)
            return false;
        if (!rulePart.inclusive && !ruleRoleMatch)
            return true;
        // Match the attributes
        var ruleAttrs = rulePart.attrs;
        var elemContext = contextHier[rulePart.namespace][hierLevel];
        var match = true;
        for (var _i = 0, ruleAttrs_1 = ruleAttrs; _i < ruleAttrs_1.length; _i++) {
            var ruleAttrPart = ruleAttrs_1[_i];
            match = match && ruleAttrPart.matches(elemContext);
        }
        if (!rulePart.inclusive)
            match = !match;
        return match;
    };
    return PartInfo;
}());
exports.PartInfo = PartInfo;
var Context = /** @class */ (function () {
    function Context(context) {
        this.contextInfo = [];
        var contextHierMatches = context.match(/!?[/a-zA-Z:0-9*\-_]+(\[[^\]]+\])*[ >+~]?/g);
        var results = [];
        for (var _i = 0, contextHierMatches_1 = contextHierMatches; _i < contextHierMatches_1.length; _i++) {
            var part = contextHierMatches_1[_i];
            var parts = part.match(/(!?)([/a-zA-Z:0-9*\-_]+)((\[[^\]]+\])*)([ >+~]?)/);
            var attrInfo = [];
            for (var _a = 0, _b = parts[3].match(/\[([^\]]+)\]/g) || []; _a < _b.length; _a++) {
                var attrPart = _b[_a];
                var attrParts = attrPart.match(/\[(!?)([a-z:A-Z*\-_]+)(!?[=~])?([^\]]+)?\]/);
                attrInfo.push(new AttrInfo(attrParts[1] !== "!", attrParts[2].toLowerCase(), attrParts[3], attrParts[4]));
            }
            parts[2] = parts[2].toLowerCase();
            var nsParts = parts[2].split(":");
            var incl = parts[1] !== "!";
            var ns = nsParts.shift();
            var role = nsParts.join(":");
            var partInfo = new PartInfo(incl, ns, role, attrInfo, parts[parts.length - 1]);
            results.push(partInfo);
        }
        this.contextInfo = results;
    }
    Context.cleanContext = function (context) {
        context = context.toLowerCase().trim();
        context = context.replace(/ +!/g, " !");
        context = context.replace(/ +([>+~,])/g, "$1");
        context = context.replace(/([>+~,]) +/g, "$1");
        context = context.replace(/ +/g, " ");
        return context.trim();
    };
    Context.parse = function (context) {
        var contexts = Context.splitMultiple(Context.cleanContext(context));
        var retVal = [];
        for (var i = 0; i < contexts.length; ++i) {
            var ctx = new Context(contexts[i]);
            retVal.push(ctx);
        }
        return retVal;
    };
    /**
     * Handles initial processing of splitting on comma - context,context
     * @param context
     */
    Context.splitMultiple = function (context) {
        var contexts = [];
        if (context) {
            if (context.indexOf(",") === -1) {
                contexts.push(context);
            }
            else {
                for (var _i = 0, _a = context.split(","); _i < _a.length; _i++) {
                    var c = _a[_i];
                    contexts.push(c);
                }
            }
        }
        return contexts;
    };
    return Context;
}());
exports.Context = Context;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DOMWalker = void 0;
var DOMUtil_1 = __webpack_require__(3);
var DOMWalker = /** @class */ (function () {
    function DOMWalker(element, bEnd, root) {
        this.root = root || element;
        this.node = element;
        this.bEndTag = (bEnd == undefined ? false : bEnd == true);
    }
    DOMWalker.prototype.atRoot = function () {
        if (this.ownerElement)
            return false;
        if (this.root === this.node) {
            return true;
        }
        else if (this.root.isSameNode) {
            return this.root.isSameNode(this.node);
        }
        else if (this.root.compareDocumentPosition) {
            return this.root.compareDocumentPosition(this.node) === 0;
        }
        else {
            // Not supported in this environment - try our best
            return this.node.parentNode === null;
        }
    };
    DOMWalker.prototype.nextNode = function () {
        do {
            if (!this.bEndTag) {
                var iframeNode = this.node;
                if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && this.node.nodeName.toUpperCase() === "IFRAME"
                    && DOMUtil_1.DOMUtil.isNodeVisible(iframeNode)
                    && iframeNode.contentDocument
                    && iframeNode.contentDocument.documentElement) {
                    var ownerElement = this.node;
                    this.node = iframeNode.contentDocument.documentElement;
                    this.node.ownerElement = ownerElement;
                }
                else if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */ && this.node.firstChild) {
                    this.node = this.node.firstChild;
                }
                else {
                    this.bEndTag = true;
                }
            }
            else {
                if (this.atRoot()) {
                    return false;
                }
                else if (this.node.nextSibling) {
                    this.node = this.node.nextSibling;
                    this.bEndTag = false;
                }
                else if (this.node.ownerElement) {
                    this.node = this.node.ownerElement;
                    this.bEndTag = true;
                }
                else if (this.node.parentNode) {
                    this.node = this.node.parentNode;
                    this.bEndTag = true;
                }
                else {
                    return false;
                }
            }
        } while ((this.node.nodeType !== 1 /* Node.ELEMENT_NODE */ || this.node.getAttribute("aChecker") === "ACE") && this.node.nodeType !== 3 /* Node.TEXT_NODE */);
        return true;
    };
    DOMWalker.prototype.prevNode = function () {
        do {
            if (this.bEndTag) {
                var iframeNode = this.node;
                if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && this.node.nodeName.toUpperCase() === "IFRAME"
                    && DOMUtil_1.DOMUtil.isNodeVisible(iframeNode)
                    && iframeNode.contentDocument
                    && iframeNode.contentDocument.documentElement) {
                    var ownerElement = this.node;
                    this.node = iframeNode.contentDocument.documentElement;
                    this.node.ownerElement = ownerElement;
                }
                else if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */ && this.node.lastChild) {
                    this.node = this.node.lastChild;
                }
                else {
                    this.bEndTag = false;
                }
            }
            else {
                if (this.atRoot()) {
                    return false;
                }
                else if (this.node.previousSibling) {
                    this.node = this.node.previousSibling;
                    this.bEndTag = true;
                }
                else if (this.node.ownerElement) {
                    this.node = this.node.ownerElement;
                    this.bEndTag = false;
                }
                else if (this.node.parentNode) {
                    this.node = this.node.parentNode;
                    this.bEndTag = false;
                }
                else {
                    return false;
                }
            }
        } while ((this.node.nodeType !== 1 /* Node.ELEMENT_NODE */ || this.node.getAttribute("aChecker") === "ACE") && this.node.nodeType !== 3 /* Node.TEXT_NODE */);
        return true;
    };
    return DOMWalker;
}());
exports.DOMWalker = DOMWalker;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Checker = void 0;
var Checker_1 = __webpack_require__(12);
Object.defineProperty(exports, "Checker", { enumerable: true, get: function () { return Checker_1.Checker; } });


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Checker = void 0;
var IEngine_1 = __webpack_require__(0);
var Engine_1 = __webpack_require__(13);
var ARIAMapper_1 = __webpack_require__(6);
var StyleMapper_1 = __webpack_require__(15);
var rules_1 = __webpack_require__(16);
var nls_1 = __webpack_require__(61);
var help_1 = __webpack_require__(64);
var rulesets_1 = __webpack_require__(66);
var Checker = /** @class */ (function () {
    function Checker() {
        this.rulesets = [];
        this.rulesetIds = [];
        this.rulesetRules = {};
        this.ruleLevels = {};
        this.ruleCategory = {};
        var engine = this.engine = new Engine_1.Engine();
        engine.addMapper(new ARIAMapper_1.ARIAMapper());
        engine.addMapper(new StyleMapper_1.StyleMapper());
        engine.addRules(rules_1.checkRules);
        engine.addNlsMap(nls_1.checkNls);
        engine.addHelpMap(help_1.checkHelp);
        for (var _i = 0, checkRulesets_1 = rulesets_1.checkRulesets; _i < checkRulesets_1.length; _i++) {
            var rs = checkRulesets_1[_i];
            this.addRuleset(rs);
        }
    }
    Checker.prototype.addRuleset = function (rs) {
        this.rulesets.push(rs);
        this.rulesetIds.push(rs.id);
        var ruleIds = [];
        for (var _i = 0, _a = rs.checkpoints; _i < _a.length; _i++) {
            var cp = _a[_i];
            for (var _b = 0, _c = cp.rules; _b < _c.length; _b++) {
                var rule = _c[_b];
                ruleIds.push(rule.id);
                this.ruleLevels[rule.id] = this.ruleLevels[rule.id] || {};
                this.ruleLevels[rule.id][rs.id] = rule.level;
                this.ruleCategory[rule.id] = this.ruleCategory[rule.id] || {};
                this.ruleCategory[rule.id][rs.id] = rs.category;
            }
        }
        this.rulesetRules[rs.id] = ruleIds;
    };
    Checker.prototype.check = function (node, rsIds) {
        // Determine which rules to run
        var ruleIds = [];
        // Fix the input
        if (!rsIds) {
            ruleIds = this.engine.getRulesIds();
        }
        else {
            if (typeof rsIds === "string") {
                rsIds = [rsIds];
            }
            for (var _i = 0, rsIds_1 = rsIds; _i < rsIds_1.length; _i++) {
                var rsId = rsIds_1[_i];
                if (rsId in this.rulesetRules) {
                    ruleIds = ruleIds.concat(this.rulesetRules[rsId]);
                }
            }
        }
        this.engine.enableRules(ruleIds);
        // Add the report levels
        var myThis = this;
        return this.engine.run(node)
            .then(function (report) {
            report.nls = {};
            for (var _i = 0, _a = report.results; _i < _a.length; _i++) {
                var result = _a[_i];
                if (result.ruleId in nls_1.checkNls) {
                    report.nls[result.ruleId] = report.nls[result.ruleId] || {
                        0: nls_1.checkNls[result.ruleId][0]
                    };
                    if (result.reasonId in nls_1.checkNls[result.ruleId]) {
                        report.nls[result.ruleId][result.reasonId] = nls_1.checkNls[result.ruleId][result.reasonId];
                    }
                }
                result.value[0] = myThis.getLevel(rsIds, result.ruleId);
                result.category = myThis.getCategory(rsIds, result.ruleId);
                delete result.path.css;
            }
            return report;
        });
    };
    Checker.prototype.getLevel = function (rsIds, ruleId) {
        if (!rsIds)
            return IEngine_1.eRulePolicy.INFORMATION;
        var rsInfo = this.ruleLevels[ruleId];
        var retVal = null;
        if (rsIds) {
            if (!(ruleId in this.ruleLevels)) {
                throw new Error("Rule triggered for which we have no rule level information: " + ruleId);
            }
            for (var _i = 0, rsIds_2 = rsIds; _i < rsIds_2.length; _i++) {
                var rsId = rsIds_2[_i];
                if (rsId in rsInfo) {
                    if (rsInfo[rsId] === IEngine_1.eRulePolicy.VIOLATION) {
                        retVal = IEngine_1.eRulePolicy.VIOLATION;
                    }
                    else if (rsInfo[rsId] === IEngine_1.eRulePolicy.RECOMMENDATION && retVal === null) {
                        retVal = IEngine_1.eRulePolicy.RECOMMENDATION;
                    }
                    else if (retVal === null) {
                        retVal = IEngine_1.eRulePolicy.INFORMATION;
                    }
                }
            }
        }
        if (retVal === null) {
            throw new Error("Rule triggered for which we have no rule level information: " + ruleId);
        }
        return retVal;
    };
    Checker.prototype.getCategory = function (rsIds, ruleId) {
        var rsInfo = this.ruleCategory[ruleId];
        var retVal = "";
        if (!(ruleId in this.ruleCategory)) {
            return IEngine_1.eRuleCategory.OTHER;
        }
        if (!rsIds) {
            rsIds = this.rulesetIds;
        }
        for (var _i = 0, rsIds_3 = rsIds; _i < rsIds_3.length; _i++) {
            var rsId = rsIds_3[_i];
            if (rsId in rsInfo) {
                return rsInfo[rsId];
            }
        }
        return IEngine_1.eRuleCategory.OTHER;
    };
    return Checker;
}());
exports.Checker = Checker;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Engine = void 0;
var IEngine_1 = __webpack_require__(0);
var DOMWalker_1 = __webpack_require__(10);
var Context_1 = __webpack_require__(9);
var Config_1 = __webpack_require__(4);
var DOMMapper_1 = __webpack_require__(14);
var DOMUtil_1 = __webpack_require__(3);
var WrappedRule = /** @class */ (function () {
    function WrappedRule(rule, parsedInfo) {
        this.rule = rule;
        this.parsedInfo = parsedInfo;
        this.ns = this.parsedInfo.contextInfo[this.parsedInfo.contextInfo.length - 1].namespace;
        Config_1.Config.DEBUG && console.log("Added Rule:", rule.id, this.parsedInfo);
    }
    /**
     * This function is responsible converting the node into a snippet which can be added to report.
     *
     * Note: This function will take the node and extract the node name and the attributes and build the snippet based on this.
     *
     * TODO: Future, maybe we can extract more then just single line, add more info or even add closing tags etc...
     *
     * @param {HTMLElement} node - The html element to convert into element snippet with node name and attributes only.
     *
     * @return {String} nodeSnippet - return the element snippet of the element that was provided which only contains,
     *                                nodename and attributes. i.e. <table id=\"layout_table1\" role=\"presentation\">
     *
     * @memberOf this
     */
    WrappedRule.convertNodeToSnippet = function (node) {
        // Variable Decleration
        var nodeSnippet = '';
        // Extract the node name and add it to the node snippet
        nodeSnippet += '<' + node.nodeName.toLowerCase();
        // Extract all the node attributes as an array
        var nodeAttributes = node.attributes;
        // In the case there are attributes on this node
        if (nodeAttributes !== null && typeof nodeAttributes !== 'undefined') {
            // Loop over all theses attributes and add the name and value to the nodeSnippet which will be returned
            for (var i = nodeAttributes.length - 1; i >= 0; i--) {
                if (nodeAttributes[i].name === "data-namewalk")
                    continue;
                // Add the attribute name and value.
                nodeSnippet += ' ' + nodeAttributes[i].name + '="' + nodeAttributes[i].value + '"';
            }
        }
        // Close the node
        nodeSnippet += '>';
        // Return the node snippet
        return nodeSnippet;
    };
    WrappedRule.prototype.run = function (engine, context, options, contextHierarchies) {
        var startTime = new Date().getTime();
        var results;
        try {
            results = this.rule.run(context, options, contextHierarchies);
        }
        catch (e) {
            var err = e;
            console.error("RULE EXCEPTION:", this.rule.id, context.dom.rolePath, err.stack);
            throw e;
        }
        var endTime = new Date().getTime();
        if (!results)
            results = [];
        if (!(results instanceof Array)) {
            results = [results];
        }
        var retVal = [];
        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
            var result = results_1[_i];
            var message = engine.getMessage(this.rule.id, result.reasonId, result.messageArgs);
            var path = {};
            for (var ns in context) {
                path[ns] = context[ns].rolePath;
            }
            var ruleId = this.rule.id.replace(/^(.*)\$\$\d+$/, "$1");
            retVal.push({
                ruleId: ruleId,
                value: result.value,
                node: context["dom"].node,
                path: path,
                ruleTime: endTime - startTime,
                reasonId: result.reasonId,
                message: message,
                messageArgs: result.messageArgs,
                apiArgs: result.apiArgs,
                bounds: context["dom"].bounds,
                snippet: WrappedRule.convertNodeToSnippet(context["dom"].node)
            });
        }
        return retVal;
    };
    return WrappedRule;
}());
var Engine = /** @class */ (function () {
    function Engine() {
        this.mappers = {};
        this.ruleMap = {};
        this.wrappedRuleMap = {};
        this.nlsMap = {};
        this.helpMap = {};
        this.inclRules = {};
        this.exclRules = {};
        // Need a DOM Mapper as a minimum
        this.addMapper(new DOMMapper_1.DOMMapper());
    }
    Engine.clearCaches = function (cacheRoot) {
        delete cacheRoot.ownerDocument.aceCache;
        var nw = new DOMWalker_1.DOMWalker(cacheRoot);
        do {
            delete nw.node.aceCache;
        } while (nw.nextNode());
    };
    Engine.prototype.run = function (root, options) {
        if (root === null) {
            return Promise.reject("null document");
        }
        if (root.nodeType === 9 /* Node.DOCUMENT_NODE */) {
            root = root.documentElement;
        }
        root.ownerDocument && (root.ownerDocument.PT_CHECK_HIDDEN_CONTENT = false);
        Engine.clearCaches(root);
        var walker = new DOMWalker_1.DOMWalker(root);
        var retVal = {
            results: [],
            numExecuted: 0,
            ruleTime: 0,
            totalTime: 0
        };
        var start = new Date().getTime();
        // Reset the role mappers
        for (var namespace in this.mappers) {
            this.mappers[namespace].reset(root);
        }
        // Initialize the context detector
        do {
            // Get the context information from the rule mappers
            var contextHierarchies = {};
            for (var namespace in this.mappers) {
                if (!walker.bEndTag) {
                    contextHierarchies[namespace] = this.mappers[namespace].openScope(walker.node);
                    if (namespace === "dom" && walker.node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                        var elem = walker.node;
                        var id = void 0;
                        if (elem.hasAttribute("id") && (id = elem.getAttribute("id").trim()).length > 0) {
                            if (root.ownerDocument.getElementById(id) === elem) {
                                // contextHierarchies["dom"][contextHierarchies["dom"].length-1].rolePath = "//*[@id='"+id+"']";
                            }
                        }
                    }
                }
                else {
                    contextHierarchies[namespace] = this.mappers[namespace].closeScope(walker.node);
                }
            }
            if (DOMUtil_1.DOMUtil.isNodeVisible(walker.node)
                || walker.node.nodeName.toLowerCase() === "style"
                || walker.node.nodeName.toLowerCase() === "datalist"
                || walker.node.nodeName.toLowerCase() === "param"
                || !DOMUtil_1.DOMUtil.getAncestor(walker.node, ["body"])) {
                var context = {};
                for (var ns in contextHierarchies) {
                    var nsHier = contextHierarchies[ns];
                    var lastHier = nsHier[nsHier.length - 1];
                    context[ns] = lastHier;
                }
                var matchingRules = this.getMatchingRules(contextHierarchies);
                var depMatch = {};
                for (var _i = 0, matchingRules_1 = matchingRules; _i < matchingRules_1.length; _i++) {
                    var matchingRule = matchingRules_1[_i];
                    var fulfillsDependencies = true;
                    for (var _a = 0, _b = matchingRule.rule.dependencies || []; _a < _b.length; _a++) {
                        var dep = _b[_a];
                        if (!depMatch[dep])
                            fulfillsDependencies = false;
                    }
                    if (fulfillsDependencies) {
                        var results = [];
                        try {
                            results = matchingRule.run(this, context, options, contextHierarchies);
                        }
                        catch (err) {
                            // Wrapper shows error in console. Skip this rule as N/A
                            // We don't want to kill the engine
                        }
                        // If out of scope, it fulfills the dependency
                        if (results.length === 0) {
                            depMatch[matchingRule.rule.id] = true;
                        }
                        for (var _c = 0, results_2 = results; _c < results_2.length; _c++) {
                            var result = results_2[_c];
                            retVal.results.push(result);
                            retVal.ruleTime += result.ruleTime;
                            retVal.numExecuted++;
                            if (result.value[1] === IEngine_1.eRuleConfidence.PASS) {
                                depMatch[result.ruleId] = true;
                            }
                        }
                    }
                }
            }
        } while (walker.nextNode());
        retVal.totalTime = new Date().getTime() - start;
        return Promise.resolve(retVal);
    };
    Engine.prototype.enableRules = function (ruleIds) {
        for (var ruleId in this.ruleMap) {
            this.ruleMap[ruleId].enabled = false;
        }
        for (var _i = 0, _a = ruleIds || []; _i < _a.length; _i++) {
            var ruleId = _a[_i];
            if (!(ruleId in this.ruleMap)) {
                console.warn("WARNING: Rule Id", ruleId, "could not be enabled.");
            }
            else {
                this.ruleMap[ruleId].enabled = true;
            }
        }
    };
    Engine.prototype.getRule = function (ruleId) {
        return this.ruleMap[ruleId];
    };
    Engine.prototype.getRulesIds = function () {
        var retVal = [];
        for (var ruleId in this.ruleMap) {
            retVal.push(ruleId);
        }
        return retVal;
    };
    Engine.prototype.addRules = function (rules) {
        for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {
            var rule = rules_1[_i];
            this.addRule(rule);
        }
    };
    Engine.prototype.addRule = function (rule) {
        var ctxs = Context_1.Context.parse(rule.context);
        var idx = 0;
        var ruleId = rule.id;
        if (ruleId in this.ruleMap) {
            console.log("WARNING: Rule", ruleId, "already added to engine. Ignoring...");
            return;
        }
        this.ruleMap[ruleId] = rule;
        for (var _i = 0, ctxs_1 = ctxs; _i < ctxs_1.length; _i++) {
            var ctx = ctxs_1[_i];
            var wrapId = ruleId;
            if (idx >= 1) {
                wrapId = ruleId + "$$" + idx;
            }
            ++idx;
            var wrappedRule = new WrappedRule(rule, ctx);
            this.wrappedRuleMap[wrapId] = wrappedRule;
            var parts = wrappedRule.parsedInfo.contextInfo;
            var lastPart = parts[parts.length - 1];
            var triggerRole = lastPart.namespace + ":" + lastPart.role;
            if (lastPart.inclusive) {
                this.inclRules[triggerRole] = this.inclRules[triggerRole] || [];
                this.inclRules[triggerRole].push(wrappedRule);
            }
            else {
                this.exclRules[triggerRole] = this.exclRules[triggerRole] || [];
                this.exclRules[triggerRole].push(wrappedRule);
            }
        }
    };
    Engine.prototype.addNlsMap = function (map) {
        for (var key in map) {
            this.nlsMap[key] = map[key];
        }
    };
    Engine.prototype.addHelpMap = function (map) {
        for (var key in map) {
            this.helpMap[key] = map[key];
        }
    };
    Engine.prototype.getMessage = function (ruleId, ruleIdx, msgArgs) {
        var splitter = ruleId.indexOf("$$");
        if (splitter >= 0) {
            ruleId = ruleId.substring(0, splitter);
        }
        if (!(ruleId in this.nlsMap))
            return ruleId;
        var messageTemplate = this.nlsMap[ruleId][ruleIdx || 0];
        if (!messageTemplate)
            return ruleId + "_" + ruleIdx;
        return messageTemplate.replace(/\{(\d+)\}/g, function (matchedStr, matchedNum, matchedIndex) { return msgArgs[matchedNum]; });
    };
    Engine.prototype.getHelp = function (ruleId, ruleIdx) {
        var splitter = ruleId.indexOf("$$");
        if (splitter >= 0) {
            ruleId = ruleId.substring(0, splitter);
        }
        if (!(ruleId in this.helpMap))
            return ruleId;
        ruleIdx = ruleIdx || 0;
        var helpStr = null;
        if (ruleIdx in this.helpMap[ruleId]) {
            helpStr = this.helpMap[ruleId][ruleIdx || 0];
        }
        else {
            helpStr = this.helpMap[ruleId][0];
        }
        if (!helpStr)
            return ruleId + "_" + ruleIdx;
        return helpStr;
    };
    Engine.prototype.addMapper = function (mapper) {
        this.mappers[mapper.getNamespace()] = mapper;
    };
    Engine.match = function (ruleParts, contextHier) {
        var partIdx = ruleParts.length - 1;
        var hierIdx = contextHier["dom"].length - 1;
        // First check the end of the hierarchy
        if (!ruleParts[partIdx].matches(contextHier, hierIdx)) {
            return false;
        }
        else {
            --partIdx;
            --hierIdx;
        }
        while (hierIdx >= 0 && partIdx >= 0) {
            var part = ruleParts[partIdx];
            var matchesPart = ruleParts[partIdx].matches(contextHier, hierIdx);
            if (part.connector === ">") {
                if (!matchesPart) {
                    // Direct parent check and doesn't match
                    return false;
                }
                else {
                    // Direct parent check and does match
                    --partIdx;
                    --hierIdx;
                }
            }
            else if (part.connector === " ") {
                if (part.inclusive) {
                    // inclusive ancestor match
                    if (matchesPart) {
                        --partIdx;
                    }
                    // If doesn't match, just move up the role hierarchy
                    --hierIdx;
                }
                else if (!matchesPart) {
                    // exclusive ancestor match and current matches
                    return false;
                }
                else {
                    // exclusive ancestor match and current doesn't match - check for other ancestors
                    var parentMatch = false;
                    for (var searchIdx = hierIdx - 1; !parentMatch && searchIdx >= 0; --searchIdx) {
                        parentMatch = !ruleParts[partIdx].matches(contextHier, searchIdx);
                    }
                    if (parentMatch)
                        return false;
                    else
                        --partIdx;
                }
            }
            else {
                throw new Error("Context connector " + part.connector + " is not supported");
            }
        }
        return partIdx === -1;
    };
    Engine.prototype.getMatchingRules = function (ctxHier) {
        var dupeCheck = {};
        var matches = [];
        function addMatches(rules) {
            for (var _i = 0, rules_2 = rules; _i < rules_2.length; _i++) {
                var rule = rules_2[_i];
                if (rule.rule.enabled && Engine.match(rule.parsedInfo.contextInfo, ctxHier)) {
                    if (!(rule.rule.id in dupeCheck)) {
                        matches.push(rule);
                        dupeCheck[rule.rule.id] = true;
                    }
                }
            }
        }
        for (var ns in ctxHier) {
            var role = ns + ":" + ctxHier[ns][ctxHier[ns].length - 1].role;
            if (role in this.inclRules) {
                addMatches(this.inclRules[role]);
            }
            for (var xRole in this.exclRules) {
                if (xRole !== role) {
                    addMatches(this.exclRules[xRole]);
                }
            }
            if (role !== ns + ":none") {
                if (role.startsWith(ns + ":/")) {
                    if (ns + ":/*" in this.inclRules) {
                        addMatches(this.inclRules[ns + ":/*"]);
                    }
                }
                else {
                    if (ns + ":*" in this.inclRules) {
                        addMatches(this.inclRules[ns + ":*"]);
                    }
                }
            }
        }
        // Sort for dependencies
        for (var idx = 0; idx < matches.length; ++idx) {
            matches[idx].idx = idx;
        }
        matches.sort(function (a, b) {
            // a before b: -1
            // a after b: 1
            // equiv: 0
            var ruleA = a.rule;
            var ruleB = b.rule;
            if (ruleA.dependencies && !ruleB.dependencies) {
                return 1;
            }
            else if (!ruleA.dependencies && ruleB.dependencies) {
                return -1;
            }
            else if (ruleA.dependencies && ruleB.dependencies) {
                if (ruleA.dependencies.includes(ruleB.id)) {
                    return 1;
                }
                else if (ruleB.dependencies.includes(ruleA.id)) {
                    return -1;
                }
            }
            return a.idx - b.idx;
        });
        return matches;
    };
    return Engine;
}());
exports.Engine = Engine;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DOMMapper = void 0;
var CommonMapper_1 = __webpack_require__(5);
var DOMMapper = /** @class */ (function (_super) {
    __extends(DOMMapper, _super);
    function DOMMapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DOMMapper.prototype.childrenHaveRole = function (node, role) {
        return true;
    };
    DOMMapper.prototype.getRole = function (node) {
        return node.nodeName.toLowerCase();
    };
    DOMMapper.prototype.getNamespace = function () {
        return "dom";
    };
    DOMMapper.prototype.getAttributes = function (node) {
        var retVal = {};
        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
            var elem = node;
            for (var idx = 0; idx < elem.attributes.length; ++idx) {
                var attrInfo = elem.attributes[idx];
                retVal[attrInfo.name.toLowerCase()] = attrInfo.nodeValue;
            }
        }
        return retVal;
    };
    DOMMapper.prototype.getBounds = function (node) {
        if (node.nodeType === 1 /*Node.ELEMENT_NODE*/) {
            var adjustment = 1;
            if (node.ownerDocument && node.ownerDocument.defaultView && node.ownerDocument.defaultView.devicePixelRatio) {
                adjustment = node.ownerDocument.defaultView.devicePixelRatio;
            }
            var bounds = node.getBoundingClientRect();
            // Do a check whether bounds has value as we use different tool (htmlUnit, browser) to call this function
            if (bounds) {
                return {
                    "left": Math.ceil(bounds.left * adjustment),
                    "top": Math.ceil(bounds.top * adjustment),
                    "height": Math.ceil(bounds.height * adjustment),
                    "width": Math.ceil(bounds.width * adjustment)
                };
            }
        }
        return null;
    };
    return DOMMapper;
}(CommonMapper_1.CommonMapper));
exports.DOMMapper = DOMMapper;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.StyleMapper = void 0;
var CommonMapper_1 = __webpack_require__(5);
var StyleMapper = /** @class */ (function (_super) {
    __extends(StyleMapper, _super);
    function StyleMapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StyleMapper.prototype.childrenHaveRole = function (node, role) {
        return true;
    };
    StyleMapper.prototype.getRole = function (node) {
        return "computed";
    };
    StyleMapper.prototype.getNamespace = function () {
        return "css";
    };
    StyleMapper.prototype.getAttributes = function (node) {
        var retVal = {};
        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
            var elem = node;
            var style = elem.ownerDocument.defaultView.getComputedStyle(elem);
            for (var idx = 0; idx < style.length; ++idx) {
                var name_1 = style[idx].toLowerCase();
                retVal[name_1] = style[name_1];
            }
        }
        return retVal;
    };
    return StyleMapper;
}(CommonMapper_1.CommonMapper));
exports.StyleMapper = StyleMapper;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkRules = void 0;
var rules_1 = __webpack_require__(17);
var rules_2 = __webpack_require__(57);
var checkRules = [];
exports.checkRules = checkRules;
exports.checkRules = checkRules = checkRules.concat(rules_1.a11yRules);
exports.checkRules = checkRules = checkRules.concat(rules_2.designRules);


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRules = void 0;
var rpt_anchor_rules_1 = __webpack_require__(18);
var rpt_canvas_rules_1 = __webpack_require__(19);
var rpt_frame_rules_1 = __webpack_require__(20);
var rpt_meta_rules_1 = __webpack_require__(21);
var rpt_color_rules_1 = __webpack_require__(22);
var rpt_heading_rules_1 = __webpack_require__(23);
var rpt_mobile_iOS_rules_1 = __webpack_require__(24);
var rpt_applet_rules_1 = __webpack_require__(25);
var rpt_combobox_rules_1 = __webpack_require__(26);
var rpt_hierarchy_rules_1 = __webpack_require__(27);
var rpt_object_rules_1 = __webpack_require__(28);
var rpt_application_rules_1 = __webpack_require__(29);
var rpt_elem_rules_1 = __webpack_require__(30);
var rpt_html_rules_1 = __webpack_require__(31);
var rpt_script_rules_1 = __webpack_require__(32);
var rpt_area_rules_1 = __webpack_require__(33);
var rpt_embed_rules_1 = __webpack_require__(34);
var rpt_img_rules_1 = __webpack_require__(35);
var rpt_select_rules_1 = __webpack_require__(36);
var rpt_aria_rules_1 = __webpack_require__(37);
var rpt_fieldset_rules_1 = __webpack_require__(38);
var rpt_input_rules_1 = __webpack_require__(39);
var rpt_style_rules_1 = __webpack_require__(40);
var rpt_ariaLabeling_rules_1 = __webpack_require__(41);
var rpt_figure_rules_1 = __webpack_require__(42);
var rpt_label_rules_1 = __webpack_require__(43);
var rpt_table_rules_1 = __webpack_require__(44);
var rpt_blink_rules_1 = __webpack_require__(45);
var rpt_focus_rules_1 = __webpack_require__(46);
var rpt_list_rules_1 = __webpack_require__(47);
var rpt_text_rules_1 = __webpack_require__(48);
var rpt_blockquote_rules_1 = __webpack_require__(49);
var rpt_font_rules_1 = __webpack_require__(50);
var rpt_marquee_rules_1 = __webpack_require__(51);
var rpt_title_rules_1 = __webpack_require__(52);
var rpt_body_rules_1 = __webpack_require__(53);
var rpt_form_rules_1 = __webpack_require__(54);
var rpt_media_rules_1 = __webpack_require__(55);
var rpt_video_rules_1 = __webpack_require__(56);
var a11yRules = [].concat(rpt_anchor_rules_1.a11yRulesAnchor, rpt_canvas_rules_1.a11yRulesCanvas, rpt_frame_rules_1.a11yRulesFrame, rpt_meta_rules_1.a11yRulesMeta, rpt_color_rules_1.a11yRulesColor, rpt_heading_rules_1.a11yRulesHeading, rpt_mobile_iOS_rules_1.a11yRulesMobile, rpt_applet_rules_1.a11yRulesApplet, rpt_combobox_rules_1.a11yRulesCombobox, rpt_hierarchy_rules_1.a11yRulesHier, rpt_object_rules_1.a11yRulesObject, rpt_application_rules_1.a11yRulesApp, rpt_elem_rules_1.a11yRulesElem, rpt_html_rules_1.a11yRulesHtml, rpt_script_rules_1.a11yRulesScript, rpt_area_rules_1.a11yRulesArea, rpt_embed_rules_1.a11yRulesEmbed, rpt_img_rules_1.a11yRulesImg, rpt_select_rules_1.a11yRulesSelect, rpt_aria_rules_1.a11yRulesAria, rpt_fieldset_rules_1.a11yRulesFieldset, rpt_input_rules_1.a11yRulesInput, rpt_style_rules_1.a11yRulesStyle, rpt_ariaLabeling_rules_1.a11yRulesLabeling, rpt_figure_rules_1.a11yRulesFig, rpt_label_rules_1.a11yRulesLabel, rpt_table_rules_1.a11yRulesTable, rpt_blink_rules_1.a11yRulesBlink, rpt_focus_rules_1.a11yRulesFocus, rpt_list_rules_1.a11yRulesList, rpt_text_rules_1.a11yRulesText, rpt_blockquote_rules_1.a11yRulesBlockquote, rpt_font_rules_1.a11yRulesFont, rpt_marquee_rules_1.a11yRulesMarquee, rpt_title_rules_1.a11yRulesTitle, rpt_body_rules_1.a11yRulesBody, rpt_form_rules_1.a11yRulesForm, rpt_media_rules_1.a11yRulesMedia, rpt_video_rules_1.a11yRulesVideo);
exports.a11yRules = a11yRules;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesAnchor = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesAnchor = [{
        id: "WCAG20_A_HasText",
        context: "dom:a",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Rule only passes if an element has inner content, 
            // in the case that there is only hidden content under the the element it is a violation
            var domAttrs = context["dom"].attributes;
            // If this is an anchor element, it's not in scope of this rule - we're only assessing hyperlinks
            if (!ruleContext.hasAttribute("href") && (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "id")
                || legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "name"))) {
                return null;
            }
            var passed = legacy_1.RPTUtil.hasInnerContentHiddenHyperLink(ruleContext, true)
                || legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "aria-label")
                || legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "aria-labelledby")
                || legacy_1.RPTUtil.nonTabableChildCheck(ruleContext);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if there is a target, and text does not specify a new window.
         * Origin: WCAG 2.0 Technique H83, RPT 112, RPT G491
         */
        id: "WCAG20_A_TargetAndText",
        context: "dom:a[target],dom:area[target],dom:base[target]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var params = {
                paramWinText: {
                    value: ["new window", "new tab"],
                    type: "array"
                }
            };
            var tStr = ruleContext.getAttribute("target");
            var passed = tStr == "_parent" || tStr == "_self" || tStr == "_top" || legacy_1.RPTUtil.getFrameByName(ruleContext, tStr) != null;
            if (!passed) {
                // Name is not part of this frameset – must have potential to create new window?
                // See if a new window is mentioned
                var textStr = legacy_1.RPTUtil.getInnerText(ruleContext);
                if (ruleContext.hasAttribute("title"))
                    textStr += " " + ruleContext.getAttribute("title");
                for (var i = 0; !passed && i < params.paramWinText.value.length; ++i)
                    if (textStr.indexOf(params.paramWinText.value[i]) != -1)
                        passed = true;
            }
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1");
        }
    }];
exports.a11yRulesAnchor = a11yRulesAnchor;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesCanvas = void 0;
var IEngine_1 = __webpack_require__(0);
var a11yRulesCanvas = [
    {
        /**
         * Description: Triggers if the inner html of a canvas element is empty
         * Origin:  HTML 5 - per Richard Schwerdtfeger's requirements. g1143
         */
        id: "HAAC_Canvas",
        context: "dom:canvas",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = ruleContext.innerHTML.trim().length > 0;
            if (passed)
                return IEngine_1.RulePass(1);
            if (!passed)
                return IEngine_1.RuleManual("Manual_1");
        }
    }
];
exports.a11yRulesCanvas = a11yRulesCanvas;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesFrame = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesFrame = [
    {
        /**
         * Description: Trigger if the frame element is missing a title
         * Origin: WCAG 2.0 Technique H64
         */
        id: "WCAG20_Frame_HasTitle",
        context: "dom:frame, dom:iframe",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // JCH - NO OUT OF SCOPE hidden in context
            /*removed only the check for role=none. Although role=presentation is not allowed in the
             https://www.w3.org/TR/html-aria/#docconformance  table, the check has been kept due to the
             decisions taken in DAP "Check iframes with role="presentation" should consider role="none" also (96395)*/
            if (legacy_1.RPTUtil.hasRole(ruleContext, "presentation")) {
                return null;
            }
            else if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title")) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail("Fail_1");
            }
        }
    },
    {
        /**
         * Description: Trigger if the frame element points at something that isn't html
         * Origin: Valerie
         */
        id: "Valerie_Frame_SrcHtml",
        context: "dom:frame, dom:iframe",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "src") &&
                legacy_1.RPTUtil.isHtmlExt(legacy_1.RPTUtil.getFileExt(ruleContext.getAttribute("src")));
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesFrame = a11yRulesFrame;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesMeta = void 0;
var IEngine_1 = __webpack_require__(0);
var a11yRulesMeta = [
    {
        /**
         * Description: Trigger if meta redirect is non-zero
         * Origin: H76, F41, RPT 5.6 G254
         */
        id: "WCAG20_Meta_RedirectZero",
        context: "dom:meta[http-equiv][content]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // JCH - NO OUT OF SCOPE hidden in context
            var passed = true;
            if (ruleContext.getAttribute("http-equiv").toLowerCase() == 'refresh') {
                var content = ruleContext.getAttribute("content").toLowerCase();
                var fail = content.indexOf("url") != -1 && !content.startsWith("0;");
                if (fail) {
                    return IEngine_1.RuleFail("Fail_1");
                }
                else {
                    return IEngine_1.RulePass("Pass_0");
                }
            }
            else {
                return null;
            }
        }
    },
    {
        /**
         * Description: Trigger if meta refresh
         * Origin: RPT 5.6 G33
         */
        id: "RPT_Meta_Refresh",
        context: "dom:meta[http-equiv][content]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            if (ruleContext.getAttribute("http-equiv").toLowerCase() != 'refresh')
                return IEngine_1.RulePass("Pass_0");
            var content = ruleContext.getAttribute("content").toLowerCase();
            var fail = content.indexOf("url=") == -1;
            return !fail ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesMeta = a11yRulesMeta;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesColor = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesColor = [
    {
        "id": "IBMA_Color_Contrast_WCAG2AA",
        "context": "dom:*",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var nodeName = ruleContext.nodeName.toLowerCase();
            // avoid diagnosing elements that are not visible
            if (!legacy_1.RPTUtil.isNodeVisible(ruleContext) ||
                (legacy_1.RPTUtil.hiddenByDefaultElements != null &&
                    legacy_1.RPTUtil.hiddenByDefaultElements != undefined &&
                    legacy_1.RPTUtil.hiddenByDefaultElements.indexOf(nodeName) > -1)) {
                return null;
            }
            // Ensure that this element has children with actual text.
            var childStr = "";
            var childNodes = ruleContext.childNodes;
            for (var i = 0; i < childNodes.length; ++i) {
                if (childNodes[i].nodeType == 3) {
                    childStr += childNodes[i].nodeValue;
                }
            }
            if (childStr.trim().length == 0)
                return null;
            var doc = ruleContext.ownerDocument;
            if (!doc) {
                return null;
            }
            var win = doc.defaultView;
            if (!win) {
                return null;
            }
            var style = win.getComputedStyle(ruleContext);
            // First determine the color contrast ratio
            var colorCombo = legacy_1.RPTUtil.ColorCombo(ruleContext);
            var fg = colorCombo.fg;
            var bg = colorCombo.bg;
            var ratio = fg.contrastRatio(bg);
            var weight = legacy_1.RPTUtilStyle.getWeightNumber(style.fontWeight);
            var size = legacy_1.RPTUtilStyle.getFontInPixels(style.fontSize);
            var isLargeScale = size >= 24 || size >= 18.6 && weight >= 700;
            var passed = ratio >= 4.5 || (ratio >= 3 && isLargeScale);
            var hasBackground = colorCombo.hasBGImage || colorCombo.hasGradient;
            var isDisabled = legacy_1.RPTUtil.isNodeDisabled(ruleContext);
            if (!isDisabled) {
                var control = legacy_1.RPTUtil.getControlOfLabel(ruleContext);
                if (control) {
                    isDisabled = legacy_1.RPTUtil.isNodeDisabled(control);
                }
            }
            legacy_1.RPTUtil.setCache(ruleContext, "EXT_Color_Contrast_WCAG2AA", {
                "ratio": ratio,
                "isLargeScale": isLargeScale,
                "weight": weight,
                "size": size,
                "hasBackground": hasBackground,
                "isDisabled": isDisabled
            });
            if (hasBackground) {
                // Allow other color rule to fire if we have a background
                return null;
            }
            // If element or parent is disabled, this rule does not apply (but may be 3:1 in future)
            if (!passed && isDisabled) {
                passed = true;
            }
            //return new ValidationResult(passed, [ruleContext], '', '', [ratio.toFixed(2), size, weight, fg.toHex(), bg.toHex(), colorCombo.hasBGImage, colorCombo.hasGradient]);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [ratio.toFixed(2), size, weight, fg.toHex(), bg.toHex(), colorCombo.hasBGImage, colorCombo.hasGradient]);
            }
            else {
                return IEngine_1.RulePass("Pass_0", [ratio.toFixed(2), size, weight, fg.toHex(), bg.toHex(), colorCombo.hasBGImage, colorCombo.hasGradient]);
            }
        }
    },
    {
        "id": "IBMA_Color_Contrast_WCAG2AA_PV",
        "context": "dom:*",
        "dependencies": ["IBMA_Color_Contrast_WCAG2AA"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var nodeName = ruleContext.nodeName.toLowerCase();
            // avoid diagnosing disabled nodes or those that are not visible.
            if (legacy_1.RPTUtil.isNodeDisabled(ruleContext) ||
                !legacy_1.RPTUtil.isNodeVisible(ruleContext) ||
                (legacy_1.RPTUtil.hiddenByDefaultElements != null &&
                    legacy_1.RPTUtil.hiddenByDefaultElements != undefined &&
                    legacy_1.RPTUtil.hiddenByDefaultElements.indexOf(nodeName) > -1)) {
                return null;
            }
            var precalc = legacy_1.RPTUtil.getCache(ruleContext, "EXT_Color_Contrast_WCAG2AA", null);
            if (!precalc)
                return IEngine_1.RulePass("Pass_0");
            var passed = precalc.ratio >= 4.5 || (precalc.ratio >= 3 && precalc.isLargeScale);
            // If element or parent is disabled, this rule does not apply (but may be 3:1 in future)
            if (!passed && precalc.isDisabled) {
                passed = true;
            }
            if (!passed) {
                return IEngine_1.RulePotential("Potential_1", [precalc.ratio.toFixed(2), precalc.size, precalc.weight]);
            }
            else {
                return IEngine_1.RulePass("Pass_0", [precalc.ratio.toFixed(2), precalc.size, precalc.weight]);
            }
        }
    },
    {
        "id": "IBMA_Link_Contrast_WCAG2AA",
        "context": "a[href] | *[onclick]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var thisColorCombo = legacy_1.RPTUtil.ColorCombo(ruleContext);
            var cache = legacy_1.RPTUtil.getCache(ruleContext, "EXT_Link_Contrast_WCAG2AA", null);
            if (cache === null) {
                cache = {};
                // Ensure that this link has children with actual text.
                var childStr = "";
                var childNodes = ruleContext.childNodes;
                for (var i = 0; i < childNodes.length; ++i) {
                    if (childNodes[i].nodeType == 3) {
                        childStr += childNodes[i].nodeValue;
                    }
                }
                if (childStr.trim().length == 0)
                    return IEngine_1.RulePass(1);
                // Define helpers
                var doc = ruleContext.ownerDocument;
                if (!doc) {
                    return IEngine_1.RulePass(1);
                }
                var win_1 = doc.defaultView;
                if (!win_1) {
                    return IEngine_1.RulePass(1);
                }
                var isLink = function (node) {
                    return node.nodeType == 1 &&
                        ((node.nodeName.toUpperCase() == "A" && node.hasAttribute("href")) ||
                            node.hasAttribute("onclick"));
                };
                var isItem = function (node) {
                    if (node.nodeType != 1)
                        return false;
                    if (node.nodeName.toUpperCase() == "BR")
                        return true;
                    var compStyle = node.ownerDocument.defaultView.getComputedStyle(node, null);
                    if (!compStyle)
                        return false;
                    return compStyle.display != "inline";
                };
                var thisStyle_1 = win_1.getComputedStyle(ruleContext);
                var thisWeight_1 = legacy_1.RPTUtilStyle.getWeightNumber(thisStyle_1.fontWeight);
                var thisSize_1 = legacy_1.RPTUtilStyle.getFontInPixels(thisStyle_1.fontSize);
                cache.isLargeScale = thisSize_1 >= 24 || thisSize_1 >= 18.6 && thisWeight_1 >= 700;
                var testInfo = function (node) {
                    var style = win_1.getComputedStyle(node);
                    var weight = legacy_1.RPTUtilStyle.getWeightNumber(style.fontWeight);
                    var size = legacy_1.RPTUtilStyle.getFontInPixels(style.fontSize);
                    var colorComboOther = legacy_1.RPTUtil.ColorCombo(node);
                    var fgRatio = thisColorCombo.fg.contrastRatio(colorComboOther.fg);
                    var bgRatio = thisColorCombo.bg.contrastRatio(colorComboOther.bg);
                    var scaleChange = Math.abs(weight - thisWeight_1) >= 300
                        || Math.abs(size - thisSize_1) > 5
                        || style.textDecoration != thisStyle_1.textDecoration;
                    return {
                        "ratio": Math.max(fgRatio, bgRatio),
                        "fgRatio": fgRatio,
                        "bgRatio": bgRatio,
                        "scaleChange": scaleChange,
                        "colorCombo": colorComboOther
                    };
                };
                // Look for previous text
                var walkPrev = new legacy_1.NodeWalker(ruleContext);
                while (walkPrev.prevNode()) {
                    // If the previous is a link, or a newline, do nothing
                    if (isLink(walkPrev.node) || isItem(walkPrev.node))
                        break;
                    if (walkPrev.node.nodeType == 3 && walkPrev.node.nodeValue.trim().length > 0) {
                        walkPrev.node = walkPrev.node.parentNode;
                        cache.prev = testInfo(walkPrev.node);
                        break;
                    }
                }
                var walkNext = new legacy_1.NodeWalker(ruleContext, true);
                while (walkNext.nextNode()) {
                    // Find next text
                    // If the next is a link, or a newline, do nothing
                    if (isLink(walkNext.node) || isItem(walkNext.node))
                        break;
                    if (walkNext.node.nodeType == 3 && walkNext.node.textContent.trim().length > 0) {
                        walkNext.node = walkNext.node.parentNode;
                        cache.next = testInfo(walkNext.node);
                        break;
                    }
                }
            }
            legacy_1.RPTUtil.setCache(ruleContext, "EXT_Link_Contrast_WCAG2AA", cache);
            var isLargeScale = cache.isLargeScale;
            var passed = true;
            var ratio = 0;
            var otherColor = null;
            var goodRatio = isLargeScale ? 3 : 4.5;
            if (cache.prev) {
                passed = cache.prev.ratio >= goodRatio ||
                    cache.prev.scaleChange;
                if (!passed) {
                    ratio = cache.prev.fgRatio;
                    otherColor = cache.prev.colorCombo;
                }
            }
            else if (cache.next) {
                passed = passed && cache.next.ratio >= goodRatio ||
                    cache.next.scaleChange;
                if (!passed) {
                    ratio = cache.next.fgRatio;
                    otherColor = cache.next.colorCombo;
                }
            }
            if (!passed) {
                return IEngine_1.RulePotential("Potential_1", [ratio.toFixed(2), thisColorCombo.fg.toHex(), otherColor.fg.toHex()]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    }
];
exports.a11yRulesColor = a11yRulesColor;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesHeading = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesHeading = [
    {
        /**
         * Description: Trigger headers that are empty
         * Origin: RPT 5.6 G489
         */
        id: "RPT_Header_HasContent",
        context: "dom:h1, dom:h2, dom:h3, dom:h4, dom:h5, dom:h6",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = legacy_1.RPTUtil.hasInnerContentHidden(ruleContext);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Trigger for all heading elements
         * Origin: RPT 5.6 489
         */
        id: "RPT_Header_Trigger",
        context: "dom:h1, dom:h2, dom:h3, dom:h4, dom:h5, dom:h6",
        dependencies: ["RPT_Header_HasContent"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = legacy_1.RPTUtil.triggerOnce(ruleContext.ownerDocument, "RPT_Header_Trigger", false);
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger on headers (<h1>, <h2>, <h3>, <h4>,<h5>, <h6>) that have more than N words.
         * Origin: RPT 5.6
         */
        id: "RPT_Headers_FewWords",
        context: "dom:h1, dom:h2, dom:h3, dom:h4, dom:h5, dom:h6",
        dependencies: ["RPT_Header_HasContent"],
        run: function (context, options) {
            var validateParams = {
                headingLengthThresh: {
                    value: 20,
                    type: "integer"
                }
            };
            var ruleContext = context["dom"].node;
            var headingLengthThresh = validateParams.headingLengthThresh.value;
            var passed = legacy_1.RPTUtil.wordCount(legacy_1.RPTUtil.getInnerText(ruleContext)) <= headingLengthThresh;
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger on <p>, <div>, or between <br>'s whose text content is less than N words
         * and is all emphasized.
         * Emphasized text is contained in a <b>, <em>, <i>, <strong>, <u> or a <font> with size > "4"
         * or a relative increased size.
         * Origin: RPT 5.6 G322
         */
        id: "RPT_Block_ShouldBeHeading",
        context: "dom:p, dom:div, dom:br",
        run: function (context, options) {
            var validateParams = {
                numWords: {
                    value: 10,
                    type: "integer"
                }
            };
            var ruleContext = context["dom"].node;
            var numWords = validateParams.numWords.value;
            var wordsSeen = 0;
            var emphasizedText = false;
            var nw = new legacy_1.NodeWalker(ruleContext);
            var passed = false;
            while (!passed &&
                nw.nextNode() &&
                nw.node != ruleContext &&
                nw.node != ruleContext.parentNode &&
                !["br", "div", "p"].includes(nw.node.nodeName.toLowerCase())) // Don't report twice
             {
                var nwName = nw.node.nodeName.toLowerCase();
                if ((nwName == "b" || nwName == "em" || nwName == "i" ||
                    nwName == "strong" || nwName == "u" || nwName == "font") && !legacy_1.RPTUtil.shouldNodeBeSkippedHidden(nw.node)) {
                    var wc = legacy_1.RPTUtil.wordCount(legacy_1.RPTUtil.getInnerText(nw.node));
                    emphasizedText = wc > 0;
                    wordsSeen += wc;
                    passed = wordsSeen > numWords;
                    // Skip this node because it's emphasized
                    nw.bEndTag = true;
                }
                else {
                    passed =
                        (nw.node.nodeType == 1 && legacy_1.RPTUtil.attributeNonEmpty(nw.node, "alt") &&
                            (nwName == "applet" || nwName == "embed" || nwName == "img" ||
                                (nwName == "input" && nw.node.hasAttribute("type") && nw.node.getAttribute("type") == "image")))
                            || (nwName == "#text" && nw.node.nodeValue.trim().length > 0)
                            // Give them the benefit of the doubt if there's a link
                            || (nwName == "a" && nw.node.hasAttribute("href") && legacy_1.RPTUtil.attributeNonEmpty(nw.node, "href"));
                }
            }
            if (wordsSeen == 0)
                passed = true;
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesHeading = a11yRulesHeading;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesMobile = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesMobile = [
    {
        /**
         * Description: Triggers if a image role does not have a meaningful alternate text.
         * Origin:  HAAC, G1128
         */
        id: "HAAC_Aria_ImgAlt",
        context: "dom:*[role]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            /* removed the role check role= presentation since if an element has role=img, then there needs to be a check for alt attribute regardless of the presecne of role=presentation
            if (RPTUtil.hasRole(ruleContext, "presentation") || RPTUtil.hasRole(ruleContext, "none")){
                    return RulePass(1);
            }*/
            /* JCH - Points of failure
             *    0. Missing alt attr with value
             *    1. Missing aria-label or aria-labelledby
             *    2. Missing title attr with value
             */
            // Skip an image with a structural role - img must be in the role list at least
            if (!ruleContext.getAttribute("role").includes("img") || !legacy_1.RPTUtil.hasRole(ruleContext, "img"))
                return null;
            if (ruleContext.getAttribute("aria-hidden") === "true")
                return null;
            // If role === img, you must use an aria label
            //check attributes aria-label and aria-labelledby for other tags (e.g. <div>, <span>, etc)
            var passed = legacy_1.RPTUtil.getAriaLabel(ruleContext).length > 0;
            if (!passed) {
                //check title attribute
                passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title");
                // We should guide people to use alt or label - this is just a secondary approach to silence the rule.
                // So, we should keep the POF from above.
                // if (!passed) POF = "Fail_3";
            }
            //return new ValidationResult(passed, [ruleContext], 'role', '', []);
            if (passed) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail("Fail_2");
            }
        }
    }
];
exports.a11yRulesMobile = a11yRulesMobile;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesApplet = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesApplet = [
    {
        /**
         * Description: Trigger if the applet alt text is poor
         * Origin: WCAG 2.0 Technique H35
         */
        id: "WCAG20_Applet_HasAlt",
        context: "dom:applet",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // JCH - NO OUT OF SCOPE hidden in context
            if (!legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "alt")) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                var alt = ruleContext.getAttribute("alt").trim();
                if (ruleContext.hasAttribute("code") && alt == ruleContext.getAttribute("code").trim()) {
                    return IEngine_1.RuleFail("Fail_2");
                }
                else if (!legacy_1.RPTUtil.hasInnerContentHidden(ruleContext)) {
                    return IEngine_1.RuleFail("Fail_3");
                }
                else {
                    return IEngine_1.RulePass("Pass_0");
                }
            }
        }
    }
];
exports.a11yRulesApplet = a11yRulesApplet;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesCombobox = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesCombobox = [
    {
        /**
         * Description: Element with role='combobox' must contain single-line text input
         * Origin:  WAI-ARIA 1.1
         * 			https://www.w3.org/TR/wai-aria-1.1/#combobox
         */
        id: "HAAC_Combobox_Must_Have_Text_Input",
        context: "aria:combobox",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            if (!legacy_1.RPTUtil.isNodeVisible(ruleContext) || legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
                return null;
            }
            var tagName = ruleContext.tagName.toLowerCase();
            var pattern = ruleContext.nodeName.toLowerCase() === "input" ? "1.0" : "1.1";
            var expanded = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-expanded").trim().toLowerCase() === "true";
            var passed = true;
            var textEle = null;
            if (pattern === "1.0") {
                passed = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-multiline").trim().toLowerCase() === "false";
                textEle = ruleContext;
            }
            else {
                passed = false;
                // examine the children
                var nw = new legacy_1.NodeWalker(ruleContext);
                while (!passed && nw.nextNode() && nw.node != ruleContext && nw.node != ruleContext.nextSibling) {
                    if (nw.node.nodeType === 1 && legacy_1.RPTUtil.isNodeVisible(nw.node) && !legacy_1.RPTUtil.isNodeDisabled(nw.node)) {
                        passed = (legacy_1.RPTUtil.hasRoleInSemantics(nw.node, "textbox") ||
                            legacy_1.RPTUtil.hasRoleInSemantics(nw.node, "searchbox")) &&
                            legacy_1.RPTUtil.getAriaAttribute(nw.node, "aria-multiline").trim().toLowerCase() === "false";
                        textEle = nw.node;
                    }
                }
                // look for the "owns"
                if (!passed) {
                    var aria_owns = legacy_1.RPTUtil.getElementAttribute(ruleContext, "aria-owns");
                    if (aria_owns) {
                        var owns = legacy_1.RPTUtil.normalizeSpacing(aria_owns.trim()).split(" ");
                        for (var i = 0; !passed && i < owns.length; i++) {
                            var owned = ruleContext.ownerDocument.getElementById(owns[i]);
                            if (owned && legacy_1.RPTUtil.isNodeVisible(owned) && !legacy_1.RPTUtil.isNodeDisabled(owned)) {
                                passed = (legacy_1.RPTUtil.hasRoleInSemantics(owned, "textbox") ||
                                    legacy_1.RPTUtil.hasRoleInSemantics(owned, "searchbox")) &&
                                    legacy_1.RPTUtil.getAriaAttribute(owned, "aria-multiline").trim().toLowerCase() === "false";
                                textEle = owned;
                            }
                        }
                    }
                }
            }
            if (passed) {
                var key = context["dom"].rolePath;
                if (key) {
                    var cache = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "HAAC_Combobox_Must_Have_Text_Input", {});
                    cache[key] = {
                        "inputText": textEle,
                        "pattern": pattern,
                        "expanded": expanded
                    };
                    legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "HAAC_Combobox_Must_Have_Text_Input", cache);
                }
            }
            // check 'explicit' role combobox and that it is not <select>. 
            // Run this check after the cache was saved since other rules may need it(g1196,1197)
            if (!legacy_1.RPTUtil.hasRole(ruleContext, "combobox", false) || tagName === "select") {
                return null;
            }
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: For a 'combobox', only the textbox should receive DOM focus.
         * Focus of the listbox should be managed via aria-activedescendant on the textbox.
         * If any element other than the textbox within the combobox or aria-owned element has a tabindex >= 0 or aria-activedescendant, FAIL
         * Origin:  WAI-ARIA 1.1
         * 			https://www.w3.org/TR/wai-aria-1.1/#combobox
         */
        id: "HAAC_Combobox_DOM_Focus",
        context: "aria:combobox",
        dependencies: ["HAAC_Combobox_Must_Have_Text_Input"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var tagName = ruleContext.tagName.toLowerCase();
            // check 'explicit' role combobox and that it is not <select>
            if (!legacy_1.RPTUtil.hasRole(ruleContext, "combobox", false) || tagName === "select") {
                return null;
            }
            var cache = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "HAAC_Combobox_Must_Have_Text_Input", {});
            var cachedElem = cache[context["dom"].rolePath];
            if (!cachedElem)
                return null;
            var textInput = cachedElem.inputText;
            var pattern = cachedElem.pattern;
            var passed = true;
            if (pattern === "1.1") {
                //examine the container
                passed = !(legacy_1.RPTUtil.isTabbable(ruleContext) || legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-activedescendant"));
            }
            // examine the children
            if (ruleContext.firstChild) {
                var nw = new legacy_1.NodeWalker(ruleContext);
                while (passed && nw.nextNode() && nw.node != ruleContext && nw.node != ruleContext.nextSibling) {
                    if (nw.node.nodeType === 1 && legacy_1.RPTUtil.isNodeVisible(nw.node)) {
                        if (nw.node !== textInput) {
                            passed = !legacy_1.RPTUtil.isTabbable(nw.node) &&
                                !legacy_1.RPTUtil.getAriaAttribute(nw.node, "aria-activedescendant");
                        }
                    }
                }
            }
            if (passed) {
                // examine the owned elements
                var ariaOwnsAttr = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-owns");
                if (ariaOwnsAttr) {
                    var ownedIds = legacy_1.RPTUtil.normalizeSpacing(ariaOwnsAttr.trim()).split(" ");
                    for (var j = 0; passed && j < ownedIds.length; j++) {
                        var child_list = ruleContext.ownerDocument.getElementById(ownedIds[j]);
                        if (child_list && legacy_1.RPTUtil.isNodeVisible(child_list) && child_list !== textInput) {
                            passed = !legacy_1.RPTUtil.isTabbable(child_list) &&
                                !legacy_1.RPTUtil.getAriaAttribute(child_list, "aria-activedescendant");
                        }
                        if (passed && child_list && child_list.firstChild) {
                            var nwl = new legacy_1.NodeWalker(child_list);
                            while (passed && nwl.nextNode() && nwl.node != child_list.nextSibling) {
                                if (nwl.node.nodeType === 1 && legacy_1.RPTUtil.isNodeVisible(nwl.node)) {
                                    if (nwl.node !== textInput) {
                                        passed = !legacy_1.RPTUtil.isTabbable(nwl.node) &&
                                            !legacy_1.RPTUtil.getAriaAttribute(nwl.node, "aria-activedescendant");
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: In a 'combobox', the 'aria-autocomplete' property should only be set on the text input.
         * Look a the listbox and other elements (other than the textbox) and FAIL if autocomplete found.
         * Origin:  WAI-ARIA 1.1
         * 			https://www.w3.org/TR/wai-aria-1.1/#combobox
         */
        id: "HAAC_Combobox_Autocomplete",
        context: "aria:combobox",
        dependencies: ["HAAC_Combobox_Must_Have_Text_Input"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var tagName = ruleContext.tagName.toLowerCase();
            // check 'explicit' role combobox and that it is not <select>
            if (!legacy_1.RPTUtil.hasRole(ruleContext, "combobox", false) || tagName === "select") {
                return null;
            }
            var cache = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "HAAC_Combobox_Must_Have_Text_Input", {});
            var cachedElem = cache[context["dom"].rolePath];
            if (!cachedElem)
                return null;
            var textInput = cachedElem.inputText;
            var pattern = cachedElem.pattern;
            var passed = true;
            if (pattern === "1.1") {
                //examine the container
                passed = !ruleContext.hasAttribute("aria-autocomplete");
            }
            // examine the children
            if (ruleContext.firstChild) {
                var nw = new legacy_1.NodeWalker(ruleContext);
                while (passed && nw.nextNode() && nw.node != ruleContext && nw.node != ruleContext.nextSibling) {
                    if (nw.node.nodeType === 1 && legacy_1.RPTUtil.isNodeVisible(nw.node)) {
                        if (nw.node !== textInput) {
                            passed = !nw.node.hasAttribute("aria-autocomplete");
                        }
                    }
                }
            }
            if (passed) {
                //examine the owned elements
                var ariaOwnsAttr = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-owns");
                if (ariaOwnsAttr) {
                    var ownedIds = legacy_1.RPTUtil.normalizeSpacing(ariaOwnsAttr.trim()).split(" ");
                    for (var j = 0; passed && j < ownedIds.length; j++) {
                        var child_list = ruleContext.ownerDocument.getElementById(ownedIds[j]);
                        if (child_list && legacy_1.RPTUtil.isNodeVisible(child_list) && child_list !== textInput) {
                            passed = !child_list.hasAttribute("aria-autocomplete");
                        }
                        if (passed && child_list && child_list.firstChild) {
                            var nwl = new legacy_1.NodeWalker(child_list);
                            while (passed && nwl.nextNode() && nwl.node != child_list.nextSibling) {
                                if (nwl.node.nodeType === 1 && legacy_1.RPTUtil.isNodeVisible(nwl.node)) {
                                    if (nwl.node !== textInput) {
                                        passed = !nwl.node.hasAttribute("aria-autocomplete");
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: "aria-autocomplete value 'inline' is not supported on combobox"
         * If aria-autocomplete is used, it should be an attribute of the text input and should not be 'inline'"
         * Origin:  WAI-ARIA 1.1
         * 			https://www.w3.org/TR/wai-aria-1.1/#combobox
         */
        id: "HAAC_Combobox_Autocomplete_Invalid",
        context: "aria:combobox",
        dependencies: ["HAAC_Combobox_Must_Have_Text_Input"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var tagName = ruleContext.tagName.toLowerCase();
            // check 'explicit' role combobox and that it is not <select>
            if (tagName === "select") {
                return null;
            }
            var cache = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "HAAC_Combobox_Must_Have_Text_Input", {});
            var cachedElem = cache[context["dom"].rolePath];
            if (!cachedElem)
                return null;
            var textInput = cachedElem.inputText;
            var autocompleteAttr = legacy_1.RPTUtil.getAriaAttribute(textInput, "aria-autocomplete");
            var passed = true;
            if (autocompleteAttr && autocompleteAttr.trim().toLowerCase() === "inline") {
                passed = false;
            }
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: when the combobox popup is visible, check that aria-owns/controls in the input text refers to a popup element.
         *  When the combobox popup is visible then:
         *      if old combobox pattern then the textbox element has 'aria-owns' set to a value that refers to a 'listbox'.
         *      if new combobox pattern then the textbox element has 'aria-controls' set to a value that refers to a combobox popup element.
         * Origin:  WAI-ARIA 1.1
         * 			https://www.w3.org/TR/wai-aria-1.1/#combobox
         */
        id: "HAAC_Combobox_Expanded",
        context: "aria:combobox",
        dependencies: ["HAAC_Combobox_Must_Have_Text_Input"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var tagName = ruleContext.tagName.toLowerCase();
            // check 'explicit' role combobox and that it is not <select>
            if (!legacy_1.RPTUtil.hasRole(ruleContext, "combobox", false) || tagName === "select") {
                return null;
            }
            var cache = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "HAAC_Combobox_Must_Have_Text_Input", {});
            var cachedElem = cache[context["dom"].rolePath];
            if (!cachedElem)
                return null;
            var textInput = cachedElem.inputText;
            var pattern = cachedElem.pattern;
            var isExpanded = cachedElem.expanded;
            if (isExpanded) {
                var passed = false;
                if (pattern === "1.0") {
                    // old 1.0 combobox pattern
                    var aria_owns_1 = legacy_1.RPTUtil.getElementAttribute(textInput, "aria-owns");
                    if (aria_owns_1) {
                        var owns_1 = legacy_1.RPTUtil.normalizeSpacing(aria_owns_1.trim()).split(" ");
                        for (var i = 0; !passed && i < owns_1.length; i++) {
                            var owned_1 = ruleContext.ownerDocument.getElementById(owns_1[i]);
                            if (owned_1) {
                                passed = legacy_1.RPTUtil.hasRoleInSemantics(owned_1, "listbox") && legacy_1.RPTUtil.isNodeVisible(owned_1);
                                if (passed) {
                                    cachedElem["popupRole"] = "listbox";
                                }
                            }
                        }
                    }
                }
                else {
                    // new 1.1 combobox pattern
                    var aria_controls = legacy_1.RPTUtil.getElementAttribute(textInput, "aria-controls");
                    if (aria_controls) {
                        var controls = legacy_1.RPTUtil.normalizeSpacing(aria_controls.trim()).split(" ");
                        for (var i = 0; !passed && i < controls.length; i++) {
                            var controlled = ruleContext.ownerDocument.getElementById(controls[i]);
                            if (controlled) {
                                var roles = ["listbox", "tree", "grid", "dialog"];
                                for (var j = 0; !passed && j < roles.length; j++) {
                                    if (legacy_1.RPTUtil.hasRoleInSemantics(controlled, roles[j]) && legacy_1.RPTUtil.isNodeVisible(controlled)) {
                                        // check that the list is a descendant of the combobox or is owned by the combobox
                                        if (legacy_1.RPTUtil.isDescendant(ruleContext, controlled)) {
                                            passed = true;
                                        }
                                        else {
                                            // check that the list is owned by the combobox
                                            var aria_owns = legacy_1.RPTUtil.getElementAttribute(ruleContext, "aria-owns");
                                            if (aria_owns) {
                                                var owns = legacy_1.RPTUtil.normalizeSpacing(aria_owns.trim()).split(" ");
                                                for (var k = 0; !passed && k < owns.length; k++) {
                                                    var owned = ruleContext.ownerDocument.getElementById(owns[k]);
                                                    if (owned === controlled) {
                                                        passed = true;
                                                    }
                                                }
                                            }
                                        }
                                        if (passed) {
                                            cachedElem["popupRole"] = roles[j];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (!passed) {
                    return IEngine_1.RuleFail("Fail_1");
                }
                else {
                    return IEngine_1.RulePass("Pass_0");
                }
            }
            else {
                return null;
            }
        }
    },
    {
        /**
         * Description: For a 'combobox', 'aria-haspopup' must match the role of the combobox pop-up.
         * Origin:  WAI-ARIA 1.1
         * 			https://www.w3.org/TR/wai-aria-1.1/#combobox
         */
        id: "HAAC_Combobox_Popup",
        context: "aria:combobox",
        dependencies: ["HAAC_Combobox_Expanded"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var tagName = ruleContext.tagName.toLowerCase();
            // check 'explicit' role combobox and that it is not <select>
            if (!legacy_1.RPTUtil.hasRole(ruleContext, "combobox", false) || tagName === "select") {
                return null;
            }
            var cache = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "HAAC_Combobox_Must_Have_Text_Input", {});
            var cachedElem = cache[context["dom"].rolePath];
            if (!cachedElem)
                return null;
            // let textInput = cachedElem.inputText;
            var pattern = cachedElem.pattern;
            var isExpanded = cachedElem.expanded;
            var popupRole = cachedElem.popupRole;
            var haspopupAttr = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-haspopup").trim().toLowerCase();
            if (isExpanded) {
                var passed = false;
                if (pattern === "1.0") {
                    // old 1.0 combobox pattern
                    passed = (haspopupAttr === "true" || haspopupAttr === popupRole);
                }
                else {
                    // new 1.1 combobox pattern
                    passed = haspopupAttr === popupRole;
                }
                if (!passed) {
                    return IEngine_1.RuleFail("Fail_1");
                }
                else {
                    return IEngine_1.RulePass("Pass_0");
                }
            }
            else {
                return null;
            }
        }
    },
    {
        /**
         * Description: Triggers if the element is a combobox
         * Origin:  WAI-ARIA 1.1
         * 			https://www.w3.org/TR/wai-aria-1.1/#combobox
         */
        id: "HAAC_Combobox_ARIA_11_Guideline",
        context: "dom:*[role], dom:input",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            if (legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "combobox") && legacy_1.RPTUtil.isNodeVisible(ruleContext)) {
                passed = false;
            }
            if (!passed) {
                return IEngine_1.RuleManual("Manual_1");
            }
            else {
                return null;
            }
        }
    }
    // end of rules
];
exports.a11yRulesCombobox = a11yRulesCombobox;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesHier = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesHier = [{
        /**
         * Description: Triggers if list widget using group role and has children that are not listitem role
         * Origin:  WAI-ARIA 1.1
         */
        id: "HAAC_List_Group_ListItem",
        context: "aria:group",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var parent = ruleContext.parentElement;
            if (!legacy_1.RPTUtil.hasRoleInSemantics(parent, "list")) {
                return null;
            }
            var passed = true;
            var children = ruleContext.children;
            for (var i = 0; passed && i < children.length; i++) {
                passed = legacy_1.RPTUtil.hasRoleInSemantics(children[i], "listitem");
            }
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if the aria-activedescendant is not a descendant by nature, by aria-owns or aria-controls.
         * Origin:  WAI-ARIA 1.1
         *          https://www.w3.org/TR/wai-aria-1.1/#aria-activedescendant
         */
        id: "HAAC_ActiveDescendantCheck",
        context: "dom:*[aria-activedescendant]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var descendant_id = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-activedescendant");
            // POF1: The attribute is empty
            if (!descendant_id || descendant_id.trim() === "") {
                return IEngine_1.RuleFail("Fail_1");
            }
            var descendant = ruleContext.ownerDocument.getElementById(descendant_id.trim());
            if (!descendant) {
                // The referenced element doesn't exist. We let 1077 to trigger the error
                return null;
            }
            if (!legacy_1.RPTUtil.isNodeVisible(descendant)) {
                // POF2: aria-activedescendant references a hidden node
                return IEngine_1.RuleFail("Fail_2");
            }
            // 1. The value of aria-activedescendant refers to an element that is either a descendant of 
            // the element with DOM focus
            if (ruleContext.contains(descendant)) {
                return IEngine_1.RulePass("Pass_0");
            }
            var pofId = 2;
            // or is a logical descendant as indicated by the aria-owns attribute.
            if (ruleContext.hasAttribute("aria-owns")) {
                var owned_ids = legacy_1.RPTUtil.normalizeSpacing(ruleContext.getAttribute("aria-owns").trim()).split(" ");
                for (var i = 0; i < owned_ids.length; i++) {
                    var owned_ele = ruleContext.ownerDocument.getElementById(owned_ids[i]);
                    if (owned_ele.contains(descendant)) {
                        return IEngine_1.RulePass("Pass_0");
                    }
                }
            }
            // 2. The element with DOM focus is a textbox with aria-controls referring to an element that 
            //  supports aria-activedescendant, and the value of aria-activedescendant specified for the 
            //  textbox refers to either a descendant of the element controlled by the textbox or is a logical 
            //  descendant of that controlled element as indicated by the aria-owns attribute.
            //
            if (legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "textbox") && ruleContext.hasAttribute("aria-controls")) {
                pofId = 3;
                var controlled_ids = legacy_1.RPTUtil.normalizeSpacing(ruleContext.getAttribute("aria-controls").trim()).split(" ");
                for (var i = 0; i < controlled_ids.length; i++) {
                    var controlled_ele = ruleContext.ownerDocument.getElementById(controlled_ids[i]);
                    if (controlled_ele.contains(descendant)) {
                        return IEngine_1.RulePass("Pass_0");
                    }
                    if (controlled_ele.hasAttribute("aria-owns")) {
                        var owns_ids = legacy_1.RPTUtil.normalizeSpacing(controlled_ele.getAttribute("aria-owns").trim()).split(" ");
                        for (var j = 0; j < owns_ids.length; j++) {
                            var owned_ele = ruleContext.ownerDocument.getElementById(owns_ids[j]);
                            if (owned_ele.contains(descendant)) {
                                return IEngine_1.RulePass("Pass_0");
                            }
                        }
                    }
                }
            }
            // POF3: I'm not a combobox, and the referenced active-descendant is not a descendant and not owned by the element 
            // that referenced it.
            if (pofId == 3) {
                return IEngine_1.RuleFail("Fail_3");
            }
            // POF4: I'm a combobox, and the referenced active-descendant is not controlled by this widget
            return IEngine_1.RuleFail("Fail_4");
        }
    }
];
exports.a11yRulesHier = a11yRulesHier;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesObject = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesObject = [
    {
        /**
         * Description: Trigger if an object element does not have inner text
         * Origin: WCAG 2.0 Technique H27, H53
         */
        id: "WCAG20_Object_HasText",
        context: "dom:object",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // JCH - NO OUT OF SCOPE hidden in context
            // Detect if this object is of type text, by checking the object type in the case it is text then do not trigger this rule
            if (ruleContext.hasAttribute("type") && (ruleContext.getAttribute("type")).indexOf("text") !== -1) {
                return null;
            }
            var passed = legacy_1.RPTUtil.hasInnerContentHidden(ruleContext);
            if (passed) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail("Fail_1");
            }
        }
    }
];
exports.a11yRulesObject = a11yRulesObject;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesApp = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesApp = [
    {
        /**
         * Description: Triggers if any child of application role is not an article or a document
         * Origin:  WAI-ARIA 1.1
         * 			https://www.w3.org/TR/wai-aria-1.1/#application
         */
        id: "HAAC_Application_Role_Text",
        context: "dom:*[role]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            if (legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "application")) {
                var children = ruleContext.children;
                for (var i = 0; passed && i < children.length; i++) {
                    if (legacy_1.RPTUtil.isNodeVisible(children[i])) {
                        passed = legacy_1.RPTUtil.hasRoleInSemantics(children[i], "document") || legacy_1.RPTUtil.hasRoleInSemantics(children[i], "article");
                    }
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesApp = a11yRulesApp;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesElem = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesElem = [
    {
        /**
         * Description: Trigger if element language attributes are valid
         * Origin: WCAG 2.0 Technique H58
         */
        id: "WCAG20_Elem_Lang_Valid",
        context: "dom:*[lang], dom:*[xml:lang]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            if (ruleContext.hasAttribute("lang")) {
                passed = legacy_1.RPTUtil.validLang(ruleContext.getAttribute("lang"));
                // Lang is bad and I'm not on the html element
                if (!passed && ruleContext.nodeName.toLowerCase() !== "html") {
                    // It's okay to have a lang=""
                    passed = !legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "lang");
                }
            }
            if (passed && ruleContext.hasAttribute("xml:lang")) {
                passed = legacy_1.RPTUtil.validLang(ruleContext.getAttribute("xml:lang"));
                // Lang is bad and I'm not in the html element
                if (!passed && ruleContext.nodeName.toLowerCase() !== "html") {
                    // It's okay to have a lang=""
                    passed = !legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "xml:lang");
                }
            }
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Trigger if elements or attrributes are deprecated
         * Origin: RPT 5.6
         */
        id: "RPT_Elem_Deprecated",
        context: "dom:applet, dom:basefont, dom:center, dom:dir, dom:font, dom:isindex, dom:listing, dom:menu" +
            ", dom:plaintext, dom:spacer, dom:s, dom:strike, dom:u, dom:xmp, dom:*[align], dom:*[link], dom:*[archive]" +
            ", dom:*[background], dom:*[bgcolor], dom:*[clear], dom:*[code], dom:*[color]" +
            ", dom:*[compact], dom:*[face], dom:*[hspace], dom:*[language], dom:*[link]" +
            ", dom:*[noshade], dom:*[nowrap], dom:*[object], dom:*[prompt], dom:*[start]" +
            ", dom:*[text], dom:*[version], dom:*[vlink], dom:*[vspace], dom:img[border]" +
            ", dom:object[border], dom:td[height], dom:th[height], dom:li[type], dom:ol[type]" +
            ", dom:ul[type], dom:li[value], dom:pre[width], dom:hr[width], dom:td[width], dom:th[width]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = false;
            // HTMLUnit auto adds a tbody[align=left] to tables if tbody is missing!
            if (ruleContext.nodeName.toLowerCase() == "tbody" && ruleContext.hasAttribute("align"))
                passed = true;
            //        if (!passed)
            //            Packages.java.lang.System.err.println(""+ruleContext.nodeName);
            //        Packages.java.lang.System.err.println(""+ruleContext.getAttribute("align"));
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger if this elem's id isn't obtained by getElementById
         * Origin: RPT 5.6
         */
        id: "RPT_Elem_UniqueId",
        context: "dom:*[id]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // JCH - NO OUT OF SCOPE hidden in context
            var doc = ruleContext.ownerDocument;
            var id = ruleContext.getAttribute("id");
            // In the case that id is empty we should trigger a violation right away with out checking 
            // for uniqueness.
            if (id == "") {
                //return new ValidationResult(false, [ruleContext], '', '', [ruleContext.nodeName.toLowerCase(), id]);
                return IEngine_1.RuleFail("Fail_1", [ruleContext.nodeName.toLowerCase(), id]);
            }
            var element = doc.getElementById(id);
            var passed = element == ruleContext;
            //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [ruleContext.nodeName.toLowerCase(), id]);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_2", [ruleContext.nodeName.toLowerCase(), id]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Trigger if this elem's accesskey isn't unique
         * Origin: WCAG 2.0 Technique F17
         */
        id: "WCAG20_Elem_UniqueAccessKey",
        context: "dom:*[accesskey]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var map = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "WCAG20_Elem_UniqueAccessKey", {});
            var key = ruleContext.getAttribute("accesskey");
            var passed = !(key in map);
            map[key] = true;
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Trigger if an assesskey doesn't have a label
         * Origin:  HTML 5 - per Richard Schwerdtfeger's requirements. g1140
         */
        id: "HAAC_Accesskey_NeedLabel",
        context: "dom:*[accesskey]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = false;
            if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title")) {
                passed = true;
            }
            else if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "aria-label")) {
                passed = true;
            }
            else if (legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true)) { // ignore hidden
                passed = true;
            }
            else if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "aria-labelledby")) {
                // assume the validity of the id (of aria-labelledby) is checked by a different rule
                passed = true;
            }
            else if (ruleContext.nodeName.toLowerCase() === "input"
                && ruleContext.parentNode.nodeName.toLowerCase() === "label") {
                // assume the validity of the label, e.g. empty label, is checked by a different rule
                passed = true;
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger if a mouse event is used and a matching keyboard event is not
         * Origin: RPT 5.6 g269
         */
        id: "RPT_Elem_EventMouseAndKey",
        context: "dom:*[ondblclick], dom:*[onmousemove], dom:*[onmousedown], " +
            "dom:*[onmouseup], dom:*[onmouseover], dom:*[onmouseout], dom:*[onclick]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var nodeName = ruleContext.nodeName.toLowerCase();
            var passed = ruleContext.hasAttribute("href") ||
                (!ruleContext.hasAttribute("ondblclick") &&
                    !ruleContext.hasAttribute("onmousemove") &&
                    (!ruleContext.hasAttribute("onmousedown") || ruleContext.hasAttribute("onkeydown")) &&
                    (!ruleContext.hasAttribute("onmouseup") || ruleContext.hasAttribute("onkeyup")) &&
                    (!ruleContext.hasAttribute("onmouseover") || ruleContext.hasAttribute("onfocus")) &&
                    (!ruleContext.hasAttribute("onmouseout") || ruleContext.hasAttribute("onblur")) &&
                    (!ruleContext.hasAttribute("onclick") || ruleContext.hasAttribute("onkeypress") ||
                        nodeName == "a" || nodeName == "button"));
            var failedMouseEvents = new Array();
            if (!passed) {
                //store and display event name and node name in the tokens
                if (ruleContext.hasAttribute("ondblclick")) {
                    failedMouseEvents.push("ondblclick");
                }
                if (ruleContext.hasAttribute("onmousemove")) {
                    failedMouseEvents.push("onmousemove");
                }
                if (ruleContext.hasAttribute("onmousedown") && !ruleContext.hasAttribute("onkeydown")) {
                    failedMouseEvents.push("onmousedown");
                }
                if (ruleContext.hasAttribute("onmouseup") && !ruleContext.hasAttribute("onkeyup")) {
                    failedMouseEvents.push("onmouseup");
                }
                if (ruleContext.hasAttribute("onmouseover") && !ruleContext.hasAttribute("onfocus")) {
                    failedMouseEvents.push("onmouseover");
                }
                if (ruleContext.hasAttribute("onmouseout") && !ruleContext.hasAttribute("onblur")) {
                    failedMouseEvents.push("onmouseout");
                }
                if (ruleContext.hasAttribute("onclick") && !ruleContext.hasAttribute("onkeypress")) {
                    if (!(nodeName == "a" || nodeName == "button"))
                        failedMouseEvents.push("onclick");
                }
            }
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RuleManual("Manual_1", [nodeName, failedMouseEvents.join(", ")]);
        }
    },
    {
        /**
         * Description: Trigger if an invalid value is used for the dir attribute
         * Origin: Valerie
         */
        id: "Valerie_Elem_DirValid",
        context: "dom:*[dir]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var dirStr = ruleContext.getAttribute("dir").toLowerCase();
            var passed = dirStr == "ltr" || dirStr == "rtl" || dirStr == "auto";
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    }
];
exports.a11yRulesElem = a11yRulesElem;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesHtml = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var ancestor_1 = __webpack_require__(7);
var a11yRulesHtml = [
    {
        /**
         * Description: Trigger if the document language is invalid
         * Origin: WCAG 2.0 Technique H57
         */
        id: "WCAG20_Html_HasLang",
        context: "dom:html",
        run: function (context, options, contextHierarchies) {
            // This rule does not apply inside a presentational frame
            if (ancestor_1.AncestorUtil.isPresentationFrame(contextHierarchies)) {
                return null;
            }
            var ruleContext = context["dom"].node;
            var doctypeString = ruleContext.ownerDocument.doctype ? ruleContext.ownerDocument.doctype.publicId : "";
            if (!doctypeString)
                doctypeString = "";
            var lang = ruleContext.getAttribute("lang");
            var langXML = ruleContext.getAttribute("xml:lang");
            // Handle XHTML 1.0
            if (doctypeString.includes('XHTML') && doctypeString.includes("1.0")) {
                // If neither is provided, it's a failure
                if (!lang && !langXML) {
                    // XHTML and no lang
                    return IEngine_1.RuleFail("Fail_1");
                }
                else if (lang && langXML) {
                    if (lang != langXML) {
                        // XHTML and lang and xml:lang, but they don't match
                        return IEngine_1.RuleFail("Fail_4", [lang, langXML], []);
                    }
                    else {
                        // XHTML and lang and xml:lang match
                        return IEngine_1.RulePass("Pass_0", [lang]);
                    }
                }
                else if (lang) {
                    // XHTML and only lang (okay if only delivered via text/html)
                    return IEngine_1.RulePotential("Potential_5");
                }
                else {
                    // XHTML and only xml:lang (okay if only delivered via xml mime type)
                    return IEngine_1.RulePotential("Potential_6");
                }
            }
            else if (doctypeString.includes('XHTML')) {
                if (!langXML) {
                    // XHTML != 1.0 (must have xml:lang
                    return IEngine_1.RuleFail("Fail_2");
                }
                else {
                    return IEngine_1.RulePass("Pass_0", [langXML]);
                }
            }
            else {
                if (!lang) {
                    return IEngine_1.RuleFail("Fail_3");
                }
                else {
                    return IEngine_1.RulePass("Pass_0", [lang]);
                }
            }
        }
    },
    {
        /**
         * Description: Trigger if skip navigation is missing (headers, frames, or skip links count)
         * Origin: RPT 5.6 G481
         */
        id: "RPT_Html_SkipNav",
        context: "dom:html",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = false;
            var frames = legacy_1.RPTUtil.getDocElementsByTag(ruleContext, "frame");
            var headers = legacy_1.RPTUtil.getDocElementsByTag(ruleContext, "h1");
            if ((frames != null && frames.length > 0) || (headers != null && headers.length > 0)) {
                // If frames or headings are used, pass
                passed = true;
            }
            else {
                // Look for skip anchors
                var anchors = legacy_1.RPTUtil.getDocElementsByTag(ruleContext, "a");
                var targets = {};
                for (var idx = 0; !passed && idx < anchors.length; ++idx) {
                    if (anchors[idx].hasAttribute("href")) {
                        var href = anchors[idx].href;
                        if (typeof href !== typeof "") {
                            if (href.baseVal) {
                                href = href.baseVal;
                            }
                            else {
                                href = "";
                            }
                        }
                        var tmpLocation = void 0;
                        if (typeof (ruleContext.ownerDocument.locationFromDAP) != "undefined" && ruleContext.ownerDocument.locationFromDAP != null) { // DAP sets it
                            tmpLocation = ruleContext.ownerDocument.locationFromDAP;
                        }
                        else { // server scan has the location object
                            tmpLocation = ruleContext.ownerDocument.location;
                        }
                        var docHref = "";
                        if (tmpLocation) {
                            docHref = tmpLocation.href;
                        }
                        // Fix weird bugs with how various parsers report on file: url's:
                        if (href.startsWith("file:///"))
                            href = "file:/" + href.substring("file:///".length);
                        if (docHref.startsWith("file:///"))
                            docHref = "file:/" + docHref.substring("file:///".length);
                        if (href.charAt(0) == "#" || href.startsWith(docHref + "#")) {
                            var target = legacy_1.RPTUtil.getFileAnchor(href);
                            if (ruleContext.ownerDocument.getElementById(target) != null)
                                passed = true;
                            else
                                targets[target] = true;
                        }
                    }
                    else if (anchors[idx].hasAttribute("name")) {
                        // Assume forward jumping targets
                        var name_1 = anchors[idx].getAttribute("name");
                        if (name_1.indexOf("#") != -1)
                            name_1 = legacy_1.RPTUtil.getFileAnchor(name_1);
                        passed = name_1 in targets;
                    }
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesHtml = a11yRulesHtml;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesScript = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesScript = [
    {
        /**
         * Description: Trigger when onclick events are used on elements other than links, and reference
         * an HTML page.
         * Origin: RPT 5.6 G470 Error
         */
        id: "RPT_Script_OnclickHTML1",
        context: "dom:*[onclick]",
        run: function (context, options) {
            var validateParams = {
                failSubstring: {
                    value: [".asp", ".aspx", ".cfm", ".cfml", ".cgi", ".htm", ".html", ".shtm",
                        ".shtml", ".php", ".pl", ".py", ".shtm", ".shtml", ".xhtml",
                        "location.href"],
                    type: "[string]"
                }
            };
            var ruleContext = context["dom"].node;
            // If there's an aria-role specified, don't trigger this.
            var passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "role");
            // If this is an a or area, don't trigger if there's an href.
            var nodeName = ruleContext.nodeName.toLowerCase();
            passed = passed || ((nodeName == "a" || nodeName == "area") && legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "href"));
            // If the guards failed, check to see if they're looking at links
            if (!passed) {
                var failSubstring = validateParams.failSubstring.value;
                ;
                var onclick_1 = ruleContext.getAttribute("onclick").toLowerCase();
                passed = true;
                for (var i = 0; passed && i < failSubstring.length; ++i) {
                    passed = onclick_1.indexOf(failSubstring[i]) == -1;
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger when onclick events are used.
         * Origin: RPT 5.6 G470 Warning
         */
        id: "RPT_Script_OnclickHTML2",
        context: "dom:*[onclick]",
        dependencies: ["RPT_Script_OnclickHTML1"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Don't trigger this for SVG element for now until a determination is made (by Rich)
            // to support SVG at a point when the SVG a11y spec is ready.
            if (legacy_1.RPTUtil.getAncestor(ruleContext, "svg")) {
                return IEngine_1.RulePass("Pass_0");
            }
            // If there's an aria-role specified, don't trigger this.
            if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "role"))
                return IEngine_1.RulePass("Pass_0");
            var nodeName = ruleContext.nodeName.toLowerCase();
            var passed = nodeName == "a" || nodeName == "area" || nodeName == "input";
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Triggers if the script blurs on focus
         * Origin: WCAG 2.0 F55
         */
        id: "WCAG20_Script_FocusBlurs",
        context: "dom:*[onfocus]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = ruleContext.getAttribute("onfocus").indexOf(".blur(") == -1;
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesScript = a11yRulesScript;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesArea = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesArea = [
    {
        /**
         * Description: Triggers if the area element does not have alt text
         * Origin: WCAG 2.0 Technique H24
         */
        id: "WCAG20_Area_HasAlt",
        context: "dom:area",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // JCH - NO OUT OF SCOPE hidden in context
            if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "alt")) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail("Fail_1");
            }
        }
    }
];
exports.a11yRulesArea = a11yRulesArea;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesEmbed = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesEmbed = [
    {
        /**
         * Description: Trigger if embed is missing embed, or is not immediately after
         * Origin: WCAG 2.0 Technique H46
         */
        id: "WCAG20_Embed_HasNoEmbed",
        context: "dom:embed",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = ruleContext.getElementsByTagName("noembed").length > 0;
            if (!passed) {
                var walkNode = ruleContext.nextSibling;
                while (!passed && walkNode != null) {
                    if (walkNode.nodeName.toLowerCase() == "noembed")
                        passed = true;
                    else if (walkNode.nodeName.toLowerCase() == "#text" && walkNode.nodeValue.trim().length > 0)
                        break;
                    else if (walkNode.nodeType == 1)
                        break;
                    walkNode = walkNode.nextSibling;
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger if Noembed has no content
         * Origin: Valerie
         */
        id: "Valerie_Noembed_HasContent",
        context: "dom:noembed",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = legacy_1.RPTUtil.hasInnerContentHidden(ruleContext);
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Provide alternative content for embeded elements.
         * Origin: RPT 5.6 G320 piece not contained in WCAG20_Embed_HaSNoEmbed
         */
        id: "RPT_Embed_HasAlt",
        context: "dom:embed",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "alt");
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger if media automatically starts
         * Origin: RPT 5.6 G503
         */
        id: "RPT_Embed_AutoStart",
        context: "dom:param[name=autoplay], dom:param[name=autostart], " +
            "dom:embed[flashvars], dom:embed[src], " +
            "dom:*[autostart=true], dom:*[autostart=1], dom:bgsound",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var nodeName = ruleContext.nodeName.toLowerCase();
            var passed;
            if (nodeName == "bgsound") {
                passed = false;
            }
            else if (nodeName == "param") {
                var content = "";
                if (ruleContext.hasAttribute("value"))
                    content = ruleContext.getAttribute("value").toLowerCase();
                passed = content.indexOf("0;") == 0 ||
                    !(content.indexOf("true") != -1 || content.indexOf("1") != -1);
            }
            else if (nodeName == "embed") {
                passed = true;
                if (ruleContext.hasAttribute("flashvars")) {
                    var str = ruleContext.getAttribute("flashvars");
                    passed = str.indexOf("autostart=true") == -1 &&
                        str.indexOf("autostart=1") == -1;
                }
                if (passed && ruleContext.hasAttribute("src")) {
                    var str = ruleContext.getAttribute("src");
                    passed = str.indexOf("autostart=true") == -1 &&
                        str.indexOf("autostart=1") == -1;
                }
            }
            if (passed && ruleContext.hasAttribute("autostart")) {
                var val = ruleContext.getAttribute("autostart").toLowerCase();
                passed = val != 'true' && val != '1';
            }
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesEmbed = a11yRulesEmbed;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesImg = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesImg = [
    {
        /**
         * Description: Triggers if an image has no alt attribute
         * Origin: WCAG 2.0 Technique H37
         */
        id: "WCAG20_Img_HasAlt",
        context: "dom:img",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // JCH - NO OUT OF SCOPE hidden in context
            var passed = ruleContext.hasAttribute("alt");
            if (passed) {
                var alt = ruleContext.getAttribute("alt");
                if (alt.trim().length == 0 && alt.length != 0) {
                    // Alt, but it's whitespace (alt=" ")
                    return IEngine_1.RuleFail("Fail_1");
                }
            }
            if (!passed) {
                // No Alt
                return IEngine_1.RuleFail("Fail_2");
            }
            else {
                // Alt content or alt == ""
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers when a non-null alt attribute is applied to an image and role="presentation" or role="none"  is set on the image.
         * Origin: CI162 Checkpoint 1.1a
         */
        id: "WCAG20_Img_PresentationImgHasNonNullAlt",
        context: "dom:img[alt]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            if (legacy_1.RPTUtil.hasRole(ruleContext, "presentation") || legacy_1.RPTUtil.hasRole(ruleContext, "none")) {
                passed = ruleContext.getAttribute("alt").length == 0;
            }
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if there are redundancies between link text and image alt text.
         * Origin: WCAG 2.0 Technique WCAG_H2
         */
        id: "WCAG20_Img_LinkTextNotRedundant",
        context: "dom:img[alt]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var aNode = legacy_1.RPTUtil.getAncestor(ruleContext, "a");
            //If not in an anchor, Out of Scope
            if (aNode == null)
                return null;
            var altText = ruleContext.getAttribute("alt").trim().toLowerCase();
            if (altText.length == 0) {
                // If alt text is empty, there's no text to be redundant - let WCAG20_A_HasText
                // trigger in that case. 
                // So Out of Scope for this rule
                return null;
            }
            var innerText = aNode.innerText;
            var linkText = "";
            if (innerText != null) {
                linkText = innerText.trim().toLowerCase();
            }
            if (linkText.length > 0) {
                if (altText == linkText) {
                    // Text in link
                    return IEngine_1.RuleFail("Fail_1");
                }
            }
            else {
                var passed = true;
                //alt is non-zero, but no link text - ensure adjacent link text isn't redundant 
                var walk = new legacy_1.NodeWalker(aNode);
                while (passed && walk.prevNode()) {
                    // Get the node and nodeName
                    var node = walk.node;
                    var nodeName = node.nodeName.toLowerCase();
                    if ((nodeName == "#text" && node.nodeValue.length > 0) ||
                        (nodeName == "img" && legacy_1.RPTUtil.attributeNonEmpty(node, "alt"))) {
                        break;
                    }
                    // Comply with the Check Hidden Content Setting if the a element should be checked or not
                    else if (nodeName == "a" && !legacy_1.RPTUtil.shouldNodeBeSkippedHidden(node)) {
                        // Text before image link
                        passed = (node.innerText || node.textContent || "").trim().toLowerCase() != altText;
                    }
                }
                if (!passed) {
                    return IEngine_1.RuleFail("Fail_2");
                }
                walk = new legacy_1.NodeWalker(aNode, true);
                while (passed && walk.nextNode()) {
                    // Get the node and nodeName
                    var node = walk.node;
                    var nodeName = node.nodeName.toLowerCase();
                    if ((nodeName == "#text" && node.nodeValue.length > 0) ||
                        (nodeName == "img" && legacy_1.RPTUtil.attributeNonEmpty(node, "alt"))) {
                        break;
                    }
                    // Comply with the Check Hidden Content Setting if the a element should be checked or not
                    else if (nodeName == "a" && !legacy_1.RPTUtil.shouldNodeBeSkippedHidden(node)) {
                        passed = node.innerText.trim().toLowerCase() != altText;
                    }
                }
                if (!passed) {
                    // Text after image link
                    return IEngine_1.RuleFail("Fail_3");
                }
                else {
                    return IEngine_1.RulePass("Pass_0");
                }
            }
        }
    },
    {
        /**
         * Description: Trigger if an image has alt text
         * Origin: WCAG 2.0 Technique H37, RPT 5.6 G473
         */
        id: "WCAG20_Img_AltTriggerNonDecorative",
        context: "dom:img[alt]",
        run: function (context, options) {
            var validateParams = {
                bulletMax: {
                    value: 30,
                    type: "integer"
                },
                horizMinWidth: {
                    value: 400,
                    type: "integer"
                },
                horizMaxHeight: {
                    value: 30,
                    type: "integer"
                }
            };
            var ruleContext = context["dom"].node;
            if (legacy_1.RPTUtil.hasRole(ruleContext, "presentation") || legacy_1.RPTUtil.hasRole(ruleContext, "none") || ruleContext.getAttribute("alt").length == 0) {
                return IEngine_1.RulePass(1);
            }
            var params = validateParams;
            var myHeight = -1;
            var myWidth = -1;
            if (ruleContext.hasAttribute("height")) {
                myHeight = parseInt(ruleContext.getAttribute("height"));
            }
            if (ruleContext.hasAttribute("width")) {
                myWidth = parseInt(ruleContext.getAttribute("width"));
            }
            var passed = myHeight != -1 && myWidth != -1 &&
                ((myWidth <= params.bulletMax.value && myHeight <= params.bulletMax.value) ||
                    (myWidth >= params.horizMinWidth.value && myHeight <= params.horizMaxHeight.value));
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger if title is non-empty when alt is null
         * Origin: WCAG 2.0 Technique H67
         */
        id: "WCAG20_Img_TitleEmptyWhenAltNull",
        context: "dom:img[alt]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            if (ruleContext.getAttribute("alt").trim().length > 0) {
                return null;
            }
            // We have a title, but alt is empty
            if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title")) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Ensure that image with server side maps also have a
         * functioning user side map.
         * Origin: RPT 5.6 G11
         */
        id: "RPT_Img_UsemapValid",
        context: "dom:img[ismap]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = false;
            if (ruleContext.hasAttribute("usemap")) {
                var usemap = ruleContext.getAttribute("usemap");
                usemap = usemap.trim().toLowerCase();
                var idx = usemap.indexOf("#");
                if (idx != -1)
                    usemap = usemap.substr(idx + 1);
                if (usemap.length > 0) {
                    var maps = legacy_1.RPTUtil.getDocElementsByTag(ruleContext, "map");
                    for (var i = 0; !passed && i < maps.length; ++i) {
                        passed = maps[i].hasAttribute("name") &&
                            maps[i].getAttribute("name").toLowerCase() == usemap;
                    }
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: If the image has a non-empty usemap, ensure that it also has alt text.
         * Origin: CI162
         */
        id: "HAAC_Img_UsemapAlt",
        context: "dom:img[usemap], dom:img[ismap]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "alt") ||
                (!ruleContext.hasAttribute("ismap") && !legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "usemap"));
            if (!passed) {
                return IEngine_1.RuleFail("Pass_0");
            }
            else {
                return IEngine_1.RulePass("Fail_1");
            }
        }
    },
    {
        /**
         * Description: Triggers if an image's alt text uses common misuses
         * Origin: RPT 5.6 G453
         */
        id: "RPT_Img_AltCommonMisuse",
        context: "dom:img, dom:area, dom:input",
        run: function (context, options) {
            var validateParams = {
                badText: {
                    value: ["short description"],
                    type: "[string]"
                }
            };
            var ruleContext = context["dom"].node;
            var nodeName = ruleContext.nodeName.toLowerCase();
            var passed = true;
            // Alt text check are elsewhere (See 41, 240, 455)
            if (ruleContext.hasAttribute("alt")) {
                var altText = ruleContext.getAttribute("alt").trim();
                if (altText.length > 0) {
                    var badText = validateParams.badText.value;
                    for (var i = 0; passed && i < badText.length; ++i) {
                        passed = altText.indexOf(badText[i]) == -1;
                    }
                    if (passed) {
                        var src = ruleContext.getAttribute((nodeName == "area") ? "href" : "src");
                        // Allow it to pass if there's no src - can't determine these.
                        if (src != null) {
                            // Fail if the alt matches the src exactly
                            // Also fail if the alt has a . in it and either the src is in the alt or the alt is in the src
                            passed = src.trim() != altText &&
                                (altText.indexOf(".") == -1 || (altText.indexOf(src) == -1 && src.indexOf(altText) == -1));
                        }
                    }
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Triggers if an image does not have a long description
         * Origin: RPT 5.6 G454 Errors
         * Todo: isBad URL Check
         */
        id: "RPT_Img_LongDescription2",
        context: "dom:img[longdesc]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var longdesc = ruleContext.getAttribute("longdesc");
            // if (longdesc is bad URL) passed = false;
            var ext = legacy_1.RPTUtil.getFileExt(longdesc);
            var passed = ext.length != 0 && legacy_1.RPTUtil.isHtmlExt(ext)
                || longdesc.startsWith("#")
                || longdesc.startsWith("http://")
                || longdesc.startsWith("https://")
                || longdesc.startsWith("data:");
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger if an element has a background image and has text or has title
         * Origin: WCAG 2.0 Technique 1.1.1 F3. G1132
         */
        id: "HAAC_BackgroundImg_HasTextOrTitle",
        context: "dom:*",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var doc = ruleContext.ownerDocument;
            var style = doc.defaultView.getComputedStyle(ruleContext);
            if (style == null) {
                return IEngine_1.RulePass("Pass_0");
            }
            var backgroundImgs = style.backgroundImage;
            var passed = true;
            if (backgroundImgs != null && backgroundImgs != "" && backgroundImgs != 'none' && backgroundImgs != 'inherit') {
                if (ruleContext.innerHTML != null && ruleContext.innerHTML.trim().length != 0) {
                    passed = false;
                }
                else {
                    var title = ruleContext.getAttribute('title');
                    if (title != null && title.length != 0)
                        passed = false;
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RuleManual("Manual_1");
        }
    }
];
exports.a11yRulesImg = a11yRulesImg;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesSelect = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesSelect = [
    {
        /**
         * Description: Triggers if select has javascript for onchange or onfocus
         * Origin: WCAG 2.0 Technique H84
         */
        id: "WCAG20_Select_NoChangeAction",
        context: "dom:select",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = !ruleContext.hasAttribute("onchange") && !ruleContext.hasAttribute("onfocus");
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Triggers if select has more than X options and no optgroups
         * Origin: WCAG 2.0 Technique H85
         */
        id: "WCAG20_Select_HasOptGroup",
        context: "dom:select",
        run: function (context, options) {
            var validateParams = {
                paramNumOptions: {
                    value: 10,
                    type: "integer"
                }
            };
            var ruleContext = context["dom"].node;
            // Handle the cases where optgroup is hidden, which should trigger a violations
            // but in the case that Check hidden option is set then should not trigger a violation.
            var passed = legacy_1.RPTUtil.getChildByTagHidden(ruleContext, "optgroup", false, true).length > 0 ||
                legacy_1.RPTUtil.getChildByTagHidden(ruleContext, "option", false, true).length <=
                    validateParams.paramNumOptions.value;
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesSelect = a11yRulesSelect;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesAria = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var ARIADefinitions_1 = __webpack_require__(2);
var a11yRulesAria = [{
        /**
         * Description: Triggers if a role is not a valid WAI-ARIA role
         * Origin:  WCAG 2.0 guideline 4.1.2 Name, Role, Value
         * 			CI162 Web checklist checkpoint 4.1b
         *			Open Ajax Alliance Accessibility Working Group ruleset
         */
        id: "Rpt_Aria_ValidRole",
        context: "dom:*[role]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
            var roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
            // now we have all role attributes
            var invalidRoles = [];
            for (var _i = 0, roles_1 = roles; _i < roles_1.length; _i++) {
                var role = roles_1[_i];
                if (!(role.toLowerCase() in designPatterns)) {
                    invalidRoles.push(role);
                }
            }
            //return new ValidationResult(passed, [ruleContext], 'role', '', [roles[i]]);
            if (invalidRoles.length > 0) {
                return IEngine_1.RuleFail("Fail_1", [invalidRoles.join(",")]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if an invalid WAI-ARIA property is found anywhere
         * 				(on an element with a role or on an element with no role).
         * Origin:  WCAG 2.0 guideline 4.1.2 Name, Role, Value
         * 			CI162 Web checklist checkpoint 4.1b
         *			Open Ajax Alliance Accessibility Working Group ruleset
         *
         */
        id: "Rpt_Aria_ValidProperty",
        context: "dom:*",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var contextAttributes = ruleContext.attributes;
            // This gets all elements with attributes so we still have some
            // Out of Scope since not all attributes are aria 
            if (contextAttributes) {
                var propertyDataTypes = ARIADefinitions_1.ARIADefinitions.propertyDataTypes;
                var failedProperties = "";
                var testedProperties = 0;
                for (var i = 0, length_1 = contextAttributes.length; i < length_1; i++) {
                    var attrName = contextAttributes[i].name;
                    if (legacy_1.RPTUtil.isDefinedAriaAttribute(ruleContext, attrName)) {
                        testedProperties++;
                        // Now we just have aria attributes which can
                        // pass or fail based on whether there property is valid
                        var dataTypes = propertyDataTypes[attrName];
                        if (!dataTypes) { // if property is not in valid property list
                            // create failedProperties comma sep list
                            if (failedProperties.length == 0) {
                                failedProperties = attrName;
                            }
                            else {
                                failedProperties = failedProperties + ", " + attrName;
                            }
                        }
                    }
                }
                if (testedProperties == 0) {
                    return null;
                }
                else if (failedProperties.length != 0) {
                    //return new ValidationResult(false, [ruleContext], '', '', [failedProperties, ruleContext.tagName]);
                    return IEngine_1.RuleFail("Fail_1", [failedProperties, ruleContext.tagName]);
                }
                else {
                    //return RulePass(1);
                    return IEngine_1.RulePass("Pass_0");
                }
            }
            else {
                return null;
            }
            // JCH - passing is based on all attributes not just aria attributes
            //       leading to OVER COUNTING so moved pass up
            //return RulePass(1);
        }
    },
    {
        /**
         * Description: Triggers if a role is given and a required property of the role is missing.
         * Origin:  WCAG 2.0 guideline 4.1.2 Name, Role, Value
         * 			CI162 Web checklist checkpoint 4.1b
         *			Open Ajax Alliance Accessibility Working Group ruleset
         */
        id: "Rpt_Aria_RequiredProperties",
        context: "dom:*[role]",
        dependencies: ["Rpt_Aria_ValidRole"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var attrNameArr = new Array();
            var roleNameArr = new Array();
            var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
            var roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
            var hasAttribute = legacy_1.RPTUtil.hasAttribute;
            var testedRoles = 0;
            for (var j = 0, rolesLength = roles.length; j < rolesLength; ++j) {
                if (designPatterns[roles[j]] && legacy_1.RPTUtil.getRoleRequiredProperties(roles[j], ruleContext) != null) {
                    var requiredRoleProps = legacy_1.RPTUtil.getRoleRequiredProperties(roles[j], ruleContext);
                    var roleMissingReqProp = false;
                    testedRoles++;
                    for (var i = 0, propertiesLength = requiredRoleProps.length; i < propertiesLength; i++) {
                        if (!hasAttribute(ruleContext, requiredRoleProps[i])) {
                            // If an aria-labelledby isn't present, an aria-label will meet the requirement.
                            if (requiredRoleProps[i] == "aria-labelledby") {
                                if ((!hasAttribute(ruleContext, "aria-label")) || (roles[i] != "radiogroup")) {
                                    attrNameArr.push(requiredRoleProps[i]);
                                    roleMissingReqProp = true;
                                }
                            }
                            else if (requiredRoleProps[i] == "aria-valuenow") {
                                if ((!hasAttribute(ruleContext, "aria-valuetext")) || (roles[i] != "progressbar")) {
                                    attrNameArr.push(requiredRoleProps[i]);
                                    roleMissingReqProp = true;
                                }
                            }
                            else if (requiredRoleProps[i] == "aria-controls" && roles[j] == "combobox") {
                                // Skip this check since aria-controls in the textbox of a combobox is already handled in rule HAAC_Combobox_Must_have_Text_Input
                            }
                            else {
                                attrNameArr.push(requiredRoleProps[i]);
                                roleMissingReqProp = true;
                            }
                        }
                    }
                    if (roleMissingReqProp == true) {
                        roleNameArr.push(roles[j]);
                    }
                }
            }
            var retToken = new Array();
            var passed = attrNameArr.length == 0; // only aria attributes so NO OUT OF SCOPE
            retToken.push(roleNameArr.join(", "));
            retToken.push(attrNameArr.join(", "));
            //return new ValidationResult(passed, [ruleContext], attrNameArr, '', passed == true ? [] : retToken);
            if (testedRoles == 0) {
                return null;
            }
            else if (!passed) {
                return IEngine_1.RuleFail("Fail_1", retToken);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if a role is given and a property of the role is empty.
         * Origin:  WCAG 2.0 guideline 4.1.2 Name, Role, Value
         * 			CI162 Web checklist checkpoint 4.1b
         *			Open Ajax Alliance Accessibility Working Group ruleset
         */
        id: "Rpt_Aria_EmptyPropertyValue",
        context: "dom:*[role]",
        dependencies: ["Rpt_Aria_ValidRole"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var attrNameArr = new Array();
            var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
            var hasAttribute = legacy_1.RPTUtil.hasAttribute;
            var testedProperties = 0;
            var roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
            for (var j = 0; j < roles.length; ++j) {
                if (designPatterns[roles[j]] && legacy_1.RPTUtil.getRoleRequiredProperties(roles[j], ruleContext) != null) {
                    var requiredRoleProps = legacy_1.RPTUtil.getRoleRequiredProperties(roles[j], ruleContext);
                    for (var i = 0, length_2 = requiredRoleProps.length; i < length_2; i++) {
                        var attribute = requiredRoleProps[i];
                        if (hasAttribute(ruleContext, attribute)) {
                            testedProperties++;
                            var nodeValue = legacy_1.RPTUtil.normalizeSpacing(ruleContext.getAttribute(requiredRoleProps[i]));
                            if (nodeValue.length == 0)
                                attrNameArr.push(requiredRoleProps[i]);
                        }
                        else if (requiredRoleProps[i] == "aria-labelledby") {
                            if ((roles[i] == "radiogroup") && (hasAttribute(ruleContext, "aria-label"))) {
                                testedProperties++;
                                var nodeValue = legacy_1.RPTUtil.normalizeSpacing(ruleContext.getAttribute("aria-label"));
                                if (nodeValue.length == 0)
                                    attrNameArr.push("aria-label");
                            }
                        }
                        else if (requiredRoleProps[i] == "aria-valuenow") {
                            if ((roles[i] == "progressbar") && (hasAttribute(ruleContext, "aria-valuetext"))) {
                                testedProperties++;
                                var nodeValue = legacy_1.RPTUtil.normalizeSpacing(ruleContext.getAttribute("aria-valuetext"));
                                if (nodeValue.length == 0)
                                    attrNameArr.push("aria-valuetext");
                            }
                        }
                    }
                }
                if (designPatterns[roles[j]]) {
                    var tagProperty = legacy_1.RPTUtil.getElementAriaProperty(ruleContext);
                    var permittedRoles = [];
                    permittedRoles.push(roles[j]);
                    var allowedAttributes = legacy_1.RPTUtil.getAllowedAriaAttributes(ruleContext, permittedRoles, tagProperty);
                    for (var i = 0, length_3 = allowedAttributes.length; i < length_3; i++) {
                        var attribute = allowedAttributes[i];
                        if (attribute == "aria-checked" || attribute == "aria-selected" ||
                            attribute == "aria-expanded" || attribute == "aria-orientation" ||
                            attribute == "aria-level") {
                            if (hasAttribute(ruleContext, attribute)) {
                                testedProperties++;
                                var nodeValue = legacy_1.RPTUtil.normalizeSpacing(ruleContext.getAttribute(attribute));
                                if (nodeValue.length == 0) {
                                    attrNameArr.push(attribute);
                                }
                            }
                        }
                    }
                }
            }
            var retMsg = new Array();
            var passed = attrNameArr.length == 0;
            retMsg.push(attrNameArr.join(", "));
            //return new ValidationResult(passed, [ruleContext], attrNameArr, '', retMsg);
            if (testedProperties == 0) {
                return null;
            }
            else if (!passed) {
                return IEngine_1.RuleFail("Fail_1", retMsg);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if a WAI-ARIA property of type NMTOKEN, int, decimal and boolean has an invalid value.
         * Origin:  WCAG 2.0 guideline 4.1.2 Name, Role, Value
         * 			CI162 Web checklist checkpoint 4.1b
         *			Open Ajax Alliance Accessibility Working Group ruleset
         */
        id: "Rpt_Aria_ValidPropertyValue",
        context: "dom:*",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var valueArr = new Array();
            var attrNameArr = new Array();
            var dataTypeArr = new Array();
            var propertyDataTypes = ARIADefinitions_1.ARIADefinitions.propertyDataTypes;
            var contextAttributes = ruleContext.attributes;
            var testedPropertyValues = 0;
            if (contextAttributes) {
                for (var i = 0, length_4 = contextAttributes.length; i < length_4; i++) {
                    var attrName = contextAttributes[i].name;
                    if (legacy_1.RPTUtil.isDefinedAriaAttribute(ruleContext, attrName)) {
                        var dataTypes = propertyDataTypes[attrName];
                        var nodeValue = legacy_1.RPTUtil.normalizeSpacing(contextAttributes[i].nodeValue);
                        testedPropertyValues++;
                        if (dataTypes && dataTypes.values) {
                            if (dataTypes.values.indexOf(nodeValue) == -1) {
                                if (dataTypes.values.indexOf('undefined') != -1 && nodeValue.length == 0) {
                                    //translate 'undefined' to mean ''
                                }
                                else {
                                    // aria-relevant is represented as a space delimited list of the following values: 
                                    // additions, removals, text; or a single catch-all value all.
                                    if (dataTypes.type === "http://www.w3.org/2001/XMLSchema#nmtokens") {
                                        var attrValues = contextAttributes[i].nodeValue.trim().split(" ");
                                        // if the value all is specified, it cannot have any other value
                                        if (attrValues.length > 1 && attrValues.includes("all")) {
                                            valueArr.push(contextAttributes[i].nodeValue.split(" "));
                                            attrNameArr.push(attrName);
                                            dataTypeArr.push(dataTypes.values.toString());
                                        }
                                        else {
                                            var hash = {};
                                            for (var j = 0; j < attrValues.length; j++) {
                                                // if the individual value is not in the list of allowed values
                                                if (attrValues[j] != "" && !dataTypes.values.includes(attrValues[j])) {
                                                    if (!hash.hasOwnProperty(attrName)) {
                                                        hash[attrName] = true;
                                                        attrNameArr.push(attrName);
                                                    }
                                                    valueArr.push(attrValues[j]);
                                                    dataTypeArr.push(dataTypes.values.toString());
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        valueArr.push(contextAttributes[i].nodeValue.split(" "));
                                        attrNameArr.push(attrName);
                                        dataTypeArr.push(dataTypes.values.toString());
                                    }
                                }
                            }
                        }
                        else if (dataTypes && dataTypes.type && (dataTypes.type == "http://www.w3.org/2001/XMLSchema#int" || dataTypes.type == "http://www.w3.org/2001/XMLSchema#decimal")) {
                            if (isNaN(nodeValue)) {
                                valueArr.push(nodeValue);
                                attrNameArr.push(attrName);
                            }
                        }
                        else if (dataTypes && dataTypes.type && (dataTypes.type == "http://www.w3.org/2001/XMLSchema#boolean")) {
                            var tmpV = nodeValue.trim().toLowerCase();
                            if (tmpV !== "true" && tmpV !== "false") {
                                valueArr.push(nodeValue);
                                attrNameArr.push(attrName);
                            }
                        }
                        else {
                            testedPropertyValues--;
                        }
                    }
                }
            }
            var retMsg = new Array();
            var passed = attrNameArr.length == 0;
            retMsg.push(valueArr.join(", "));
            retMsg.push(attrNameArr.join(", "));
            retMsg.push(ruleContext.nodeName.toLowerCase());
            // retMsg.push (dataTypeArr.join(", "));
            //return new ValidationResult(passed, [ruleContext], attrNameArr, '', retMsg);
            if (testedPropertyValues == 0) {
                return null;
            }
            else if (!passed) {
                return IEngine_1.RuleFail("Fail_1", retMsg);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if an WAI-ARIA property id reference is invalid.  For example:
         * 				For a given id, triggers if an element doesn't exists that contains the id.
         * 				Triggers if there are multiple ids when only one is valid.
         * 				Triggers if there is an empty id value.
         *              Triggers if there is only a space in the id value.
         *              Triggers if the ID reference is a hidden element and the aria-* attribute
         *              does not support hidden element reference.
         * Origin:  WCAG 2.0 guideline 4.1.2 Name, Role, Value
         * 			CI162 Web checklist checkpoint 4.1b
         *			Open Ajax Alliance Accessibility Working Group ruleset
         */
        id: "Rpt_Aria_ValidIdRef",
        context: "dom:*",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var pass = true;
            var attrNameArr = new Array();
            var nonExistantIDs = new Array();
            var ownerDocument = ruleContext.ownerDocument;
            var contextAttributes = ruleContext.attributes;
            var idTokens = new Array();
            var testedReferences = 0;
            if (contextAttributes) {
                for (var i = 0, attrLength = contextAttributes.length; i < attrLength; i++) {
                    pass = true;
                    var attrName = contextAttributes[i].name;
                    if (legacy_1.RPTUtil.isDefinedAriaAttribute(ruleContext, attrName)) {
                        var dataTypes = ARIADefinitions_1.ARIADefinitions.propertyDataTypes[attrName];
                        if (dataTypes && dataTypes.type) {
                            var supportsOneIDRef = (dataTypes.type == "http://www.w3.org/2001/XMLSchema#idref") ? true : false;
                            //If the data type supports one or more id refs do error checking
                            if (supportsOneIDRef || (dataTypes.type == "http://www.w3.org/2001/XMLSchema#idrefs")) {
                                testedReferences++;
                                var nodeValueLength = legacy_1.RPTUtil.normalizeSpacing(contextAttributes[i].nodeValue).length;
                                var idArray = contextAttributes[i].nodeValue.split(" ");
                                // Check for an empty ID Ref
                                if (nodeValueLength < 1) {
                                    pass = false;
                                    idTokens.push("\"" + contextAttributes[i].nodeValue + "\"");
                                }
                                // check to see if too many IDRefs
                                else if (supportsOneIDRef) {
                                    //If has too many IDRefs it is an error
                                    if (nodeValueLength >= 1) {
                                        if (idArray.length > 1) {
                                            pass = false;
                                            // Need to capture all the IDRefs for idTokens
                                            for (var z = 0, length_5 = idArray.length; z < length_5; ++z) {
                                                if (idArray[z] != "") {
                                                    idTokens.push(idArray[z]);
                                                }
                                            }
                                        }
                                    }
                                }
                                // check to see if id refs are invalid
                                if (pass && nodeValueLength >= 1) {
                                    for (var j = 0, length_6 = idArray.length; j < length_6; ++j) {
                                        if (idArray[j].length > 0) { // it is an empty string if spaces are one after the other
                                            // Get the element by Id
                                            var elementById = ownerDocument.getElementById(idArray[j]);
                                            // Pass if the element exists
                                            pass = elementById != null;
                                            // If the element exists and this is an aria attribute that doesn't support hidden ID reference
                                            // then perform a isNodeVisible check, in the case the node is not visible then we return
                                            // false and true otherwise.
                                            if (pass && !dataTypes.hiddenIDRefSupported) {
                                                pass = legacy_1.RPTUtil.isNodeVisible(elementById);
                                            }
                                            if (!pass) {
                                                if (idArray[j] != "") {
                                                    idTokens.push(idArray[j]);
                                                }
                                            }
                                            // Only one of the id references need to be valid to mark the rule as passed.
                                            // Therefore if we find a single visible element then stop checking and mark as
                                            // passed.
                                            else {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (!pass)
                            attrNameArr.push(attrName);
                    }
                }
            }
            var passed = attrNameArr.length == 0;
            var retToken1 = new Array();
            var retToken2 = new Array();
            var retToken3 = new Array();
            if (!passed) {
                retToken2.push(attrNameArr.join(", "));
                retToken3.push(ruleContext.nodeName.toLowerCase());
                if (idTokens.length > 0) {
                    retToken1.push(idTokens.join(", "));
                }
            }
            //return new ValidationResult(passed, [ruleContext], attrNameArr, '', passed == true ? [] : [retToken1, retToken2, retToken3]);
            if (testedReferences == 0) {
                return null;
            }
            else if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [retToken1.toString(), retToken2.toString(), retToken3.toString()]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if a required child role is not found.
         * Origin:  WCAG 2.0 guideline 4.1.2 Name, Role, Value, g1080
         * 			CI162 Web checklist checkpoint 4.1b
         *			Open Ajax Alliance Accessibility Working Group ruleset
         */
        id: "Rpt_Aria_RequiredChildren_Native_Host_Sematics",
        context: "dom:*[role]",
        dependencies: ["Rpt_Aria_ValidRole"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = false;
            var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
            var roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
            var doc = ruleContext.ownerDocument;
            var roleNameArr = new Array();
            var requiredChildren = new Array();
            var nodeName = ruleContext.nodeName.toLowerCase();
            // Handle the case where the element is hidden by disabled html5 attribute or aria-disabled:
            //  1. In the case that this element has a disabled attribute and the element supports it, we mark this rule as passed.
            //  2. In the case that this element has a aria-disabled attribute then, we mark this rule as passed.
            // For both of the cases above we do not need to perform any further checks, as the element is disabled in some form or another.
            if (legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
                return IEngine_1.RulePass("Pass_0");
            }
            for (var j = 0, length_7 = roles.length; j < length_7; ++j) {
                if (roles[j] === "combobox") {
                    //  For combobox, we have g1193 ... g1199 to check the values etc.
                    //  We don't want to trigger 1152 again. So, we bypass it here.
                    passed = true;
                    continue;
                }
                if (designPatterns[roles[j]] && designPatterns[roles[j]].reqChildren != null) {
                    requiredChildren = designPatterns[roles[j]].reqChildren;
                    var roleMissingReqChild = false;
                    for (var i = 0, requiredChildrenLength = requiredChildren.length; i < requiredChildrenLength; i++) {
                        passed = legacy_1.RPTUtil.getDescendantWithRoleHidden(ruleContext, requiredChildren[i], true, true) || legacy_1.RPTUtil.getAriaOwnsWithRoleHidden(ruleContext, requiredChildren[i], true);
                        if (!passed) {
                            // See if an html equivalent child meets the requirement (e.g., radiogroup contains html radio buttons)
                            var htmlEquiv = designPatterns[requiredChildren[i]].htmlEquiv;
                            if (htmlEquiv) {
                                var nw = new legacy_1.NodeWalker(ruleContext);
                                while (!passed && nw.nextNode() && nw.node != ruleContext) {
                                    // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                                    // or not.
                                    //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                                    //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                                    //     add it to the roleToElems hash at all or even do any checking for it at all.
                                    //
                                    // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                                    //       so on and so forth.
                                    if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(nw.node)) {
                                        continue;
                                    }
                                    //Check if the element has explicit role specified. If so, honor the role
                                    if (!legacy_1.RPTUtil.hasAnyRole(nw.node, false)) {
                                        passed = legacy_1.RPTUtil.isHtmlEquiv(nw.node, htmlEquiv);
                                    }
                                }
                                if (passed)
                                    break; // break incrementing over required children. At least one required child was found.
                            }
                        }
                        else
                            break; // break incrementing over required children. At least one required child was found.
                    }
                }
                else
                    passed = true; // No required children for this role
                if (!passed) {
                    roleNameArr.push(roles[j]);
                }
            }
            var retToken = new Array();
            retToken.push(roleNameArr.join(", "));
            retToken.push(requiredChildren.join(", "));
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1", retToken);
        }
    },
    {
        /**
         * Description: Triggers if there is a valid role and the role is required to have a container but the container is missing.
         * Origin:  WCAG 2.0 guideline 4.1.2 Name, Role, Value
         * 			CI162 Web checklist checkpoint 4.1b
         *			Open Ajax Alliance Accessibility Working Group ruleset
         *
         *TODO: Does this rule need to check for html equivalents like the Rpt_Aria_RequiredChildren rule does?
         * For now, don't check html equivalents until there are use cases found that will benefit from this check.
         *
         * The Xpath "contains" function is used because there could be multiple roles specified. Also, a search for menu where
         * role="navigation menubar" will return a node.  So all parent roles must be tokenized and searched.
         */
        id: "Rpt_Aria_RequiredParent_Native_Host_Sematics",
        context: "dom:*[role]",
        dependencies: ["Rpt_Aria_ValidRole"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            var parentRoles = new Array();
            var doc = ruleContext.ownerDocument;
            var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
            var roleNameArr = new Array();
            var containerRoles = new Array();
            var testedContainer = 0;
            var roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
            for (var j = 0, length_8 = roles.length; j < length_8; ++j) {
                if (designPatterns[roles[j]] && designPatterns[roles[j]].container != null) {
                    testedContainer++;
                    passed = false;
                    containerRoles = designPatterns[roles[j]].container;
                    for (var i = 0, containersLength = containerRoles.length; !passed && i < containersLength; i++) {
                        passed = legacy_1.RPTUtil.getAncestorWithRole(ruleContext, containerRoles[i], true) != null;
                        if (passed)
                            break;
                    }
                    if (passed == false) {
                        roleNameArr.push(roles[j]);
                    }
                }
            }
            var retToken1 = new Array();
            retToken1.push(roleNameArr.join(", "));
            var retToken2 = new Array();
            retToken2.push(containerRoles.join(", "));
            //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [retToken1, retToken2]);
            if (testedContainer == 0) {
                return null;
            }
            else if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [retToken1.toString(), retToken2.toString()]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if content is not enclosed in a landmark role
         * Origin: CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_OrphanedContent_Native_Host_Sematics",
        context: "dom:*",
        run: function (context, options) {
            var params = legacy_1.RPTUtil.getCache(context.dom.node.ownerDocument, "Rpt_Aria_OrphanedContent_Native_Host_Sematics", null);
            if (!params) {
                params = {
                    landmarks: {
                        value: ["banner", "complementary", "contentinfo", "form", "main", "navigation", "region", "search"],
                        type: "array"
                    },
                    possibleOrphanedWidgets: {
                        value: ["button", "combobox", "checkbox", "grid", "heading", "link", "list",
                            "listbox", "menu", "menubar", "progressbar", "radio", "tablist", "textbox", "toolbar", "tree",
                            "treegrid"
                        ],
                        type: "array"
                    },
                    possibleOrphanedElements: {
                        value: ["p", "table", "input", "textarea", "select", "button", "a", "ol", "ul", "dl", "h1", "h2", "h3", "h4", "h5",
                            "h6", "embed", "object", "area"
                        ],
                        type: "array"
                    },
                    noLandmarkedRoles: {
                        // These roles don't require landmarks
                        value: ["alert", "alertdialog", "dialog", "tooltip"],
                        type: "array"
                    },
                    mapLandmarks: {},
                    mapPossibleOrphanedWidgets: {},
                    mapPossibleOrphanedElements: {},
                    mapNoLandmarkedRoles: {}
                };
                // Convert arrays to maps
                params.mapLandmarks = {};
                for (var i = 0; i < params.landmarks.value.length; ++i) {
                    params.mapLandmarks[params.landmarks.value[i]] = true;
                }
                params.mapPossibleOrphanedWidgets = {};
                for (var i = 0; i < params.possibleOrphanedWidgets.value.length; ++i) {
                    params.mapPossibleOrphanedWidgets[params.possibleOrphanedWidgets.value[i]] = true;
                }
                params.mapPossibleOrphanedElements = {};
                for (var i = 0; i < params.possibleOrphanedElements.value.length; ++i) {
                    params.mapPossibleOrphanedElements[params.possibleOrphanedElements.value[i]] = true;
                }
                params.mapNoLandmarkedRoles = {};
                for (var i = 0; i < params.noLandmarkedRoles.value.length; ++i) {
                    params.mapNoLandmarkedRoles[params.noLandmarkedRoles.value[i]] = true;
                }
                legacy_1.RPTUtil.setCache(context.dom.node.ownerDocument, "Rpt_Aria_OrphanedContent_Native_Host_Sematics", params);
            }
            var ruleContext = context["dom"].node;
            var nodeName = ruleContext.nodeName.toLowerCase();
            if (!legacy_1.RPTUtil.isNodeVisible(ruleContext) || // avoid diagnosing g1157 for non-visible nodes
                (legacy_1.RPTUtil.hiddenByDefaultElements != null &&
                    legacy_1.RPTUtil.hiddenByDefaultElements != undefined &&
                    legacy_1.RPTUtil.hiddenByDefaultElements.indexOf(nodeName) > -1)) {
                return IEngine_1.RulePass("Pass_0");
            }
            var elemsWithoutContent = ["area", "input", "embed", "button", "textarea", "select"];
            if (!legacy_1.RPTUtil.hasInnerContentHidden(ruleContext) && //only trigger the rule on elements that have content
                elemsWithoutContent.indexOf(nodeName) === -1) { // a few elems wihout content should not be skipped
                return IEngine_1.RulePass("Pass_0");
            }
            // Short circuit for layout tables
            if (nodeName == "table" && legacy_1.RPTUtil.isLayoutTable(ruleContext)) {
                return null;
            }
            // Check if it is a possible orphan
            var passed = true;
            var isPossibleOrphanedWidget = legacy_1.RPTUtil.hasRole(ruleContext, params.mapPossibleOrphanedWidgets, true);
            //exclude <link rel="stylesheet" href="xyz.css"> in the <head> and <body>(#608)
            //having link in the head could cause lot of violaions                    
            if (nodeName === 'link') {
                isPossibleOrphanedWidget = false;
            }
            var isPossibleOrphanedElement = nodeName in params.mapPossibleOrphanedElements;
            if (isPossibleOrphanedWidget || isPossibleOrphanedElement) {
                // See if ancestor has landmark roles or implicit land mark roles
                passed = legacy_1.RPTUtil.getAncestorWithRole(ruleContext, params.mapLandmarks, true);
                if (!passed) {
                    // Don't fail elements when a parent or sibling has failed - causes too many messages.
                    var walkElement = ruleContext.parentElement;
                    while (!passed && walkElement != null) {
                        passed = legacy_1.RPTUtil.getCache(walkElement, "Rpt_Aria_OrphanedContent", false);
                        walkElement = walkElement.parentElement;
                    }
                    walkElement = ruleContext.nextElementSibling;
                    while (!passed && walkElement != null) {
                        passed = legacy_1.RPTUtil.getCache(walkElement, "Rpt_Aria_OrphanedContent", false);
                        walkElement = walkElement.nextElementSibling;
                    }
                    walkElement = ruleContext.previousElementSibling;
                    while (!passed && walkElement != null) {
                        passed = legacy_1.RPTUtil.getCache(walkElement, "Rpt_Aria_OrphanedContent", false);
                        walkElement = walkElement.previousElementSibling;
                    }
                    if (!passed) {
                        legacy_1.RPTUtil.setCache(ruleContext, "Rpt_Aria_OrphanedContent", true);
                        // Don't trigger rule if element is a stand-alone widget
                        passed = legacy_1.RPTUtil.getCache(ruleContext, "Rpt_Aria_OrphanedContent_NoTrigger", false) ||
                            legacy_1.RPTUtil.hasRole(ruleContext, params.mapNoLandmarkedRoles, true) ||
                            legacy_1.RPTUtil.getAncestorWithRole(ruleContext, params.mapNoLandmarkedRoles, true);
                        if (passed) {
                            legacy_1.RPTUtil.setCache(ruleContext, "Rpt_Aria_OrphanedContent_NoTrigger", true);
                            return null;
                        }
                    }
                    else {
                        return null;
                    }
                }
            }
            else {
                return null;
            }
            //return new ValidationResult(passed, [ruleContext], '', '', []);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    //--------
    // Keyboard Accessible
    // --------
    {
        /**
         * Description: Triggers if an element contains an aria-activedescendant and does not contain a tabindex attribue with a value greater than or equal to zero.
         *              Do not trigger if the element has disabled (if supported on element), or the element has aria-disabled set to true.
         * Origin:  WCAG 2.0 guideline 2.1.1 Keyboard, g1084
         * 			CI162 Web checklist checkpoint 2.1a
         *			Open Ajax Alliance Accessibility Working Group ruleset
         */
        id: "Rpt_Aria_InvalidTabindexForActivedescendant",
        context: "dom:*[aria-activedescendant]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = false;
            var nodeName = ruleContext.nodeName.toLowerCase();
            // Rule not supported on mobile
            if (ruleContext.hasAttribute("class") && ruleContext.getAttribute("class").substring(0, 3) == "mbl") {
                return null;
            }
            // Handle the case where the element is hidden by disabled html5 attribute or aria-disabled:
            //  1. In the case that this element has a disabled attribute and the element supports it, we mark this rule as passed.
            //  2. In the case that this element has a aria-disabled attribute then, we mark this rule as passed.
            // For both of the cases above we do not need to perform any further checks, as the element is disabled in some form or another.
            if (legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
                return null;
            }
            // If the tabindex attribute is provided then verify that it is 0 or -1
            passed = legacy_1.RPTUtil.tabIndexLEZero(ruleContext);
            // Build array for node token
            var retToken1 = new Array();
            retToken1.push(nodeName);
            // Build array for id referenced by aria-activedescendant
            var retToken2 = new Array();
            retToken2.push(ruleContext.getAttribute("aria-activedescendant").split(" ").join(", "));
            //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [retToken1, retToken2]);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [retToken1.toString(), retToken2.toString()]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if a non-form or non-anchor element has an event handler but is missing a role attribute.
         * Origin:  WCAG 2.0 guideline 4.1.2 Name, Role, Value
         * 			CI162 Web checklist checkpoint 4.1b
         *			Open Ajax Alliance Accessibility Working Group ruleset
         */
        id: "Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics",
        context: "dom:*[onclick],dom:*[onblur], dom:*[ondblclick], dom:*[onfocus], dom:*[onkeydown]," +
            "dom:*[onkeypress], dom:*[onkeyup], dom:*[onmousedown], dom:*[onmouseup], dom:*[onmousemove], " +
            "dom:*[onmouseout], dom:*[onmouseover], dom:*[onresize], dom:*[onchange]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Don't trigger this for SVG element for now until a determination is made (by Rich)
            // to support SVG at a point when the SVG a11y spec is ready.
            if (legacy_1.RPTUtil.getAncestor(ruleContext, "svg")) {
                return null;
            }
            //this rule is passed if a element has attribut role 
            //also, passed of element has ny implicit roles. 
            if (legacy_1.RPTUtil.hasAnyRole(ruleContext, true)) {
                return IEngine_1.RulePass("Pass_0");
            }
            //pass if this element is received focus by default
            if (legacy_1.RPTUtil.isfocusableByDefault(ruleContext)) {
                return IEngine_1.RulePass("Pass_0");
            }
            //validate if this element has any of the given event handler's
            var retToken1 = new Array();
            retToken1.push(ruleContext.nodeName.toLowerCase());
            var eventArr = new Array();
            // From WCAG20_Script_UseW3CDomFunctions
            //let events = ["onblur", "onfocus", "onchange", "onclick", "oncontextmenu", "ondblclick", "onkeydown",
            //              "onkeypress", "onkeyup", "onload", "onmousedown", "onmouseup", "onmousemove", "onmouseout",
            //              "onmouseover", "onmousewheel", "onreset", "onpaste", "onresize", "onscroll",
            //              "onselect", "onsubmit", "onactivate", "ondeactivate", "onmouseenter", "onmouseleave"];
            var events = ["onblur", "onfocus", "onchange", "onclick", "ondblclick", "onkeydown",
                "onkeypress", "onkeyup", "onmousedown", "onmouseup", "onmousemove", "onmouseout",
                "onmouseover", "onresize"
            ];
            for (var i = 0; i < events.length; ++i) {
                if (ruleContext.hasAttribute(events[i]))
                    eventArr.push(events[i]);
            }
            var retToken2 = new Array();
            retToken2.push(eventArr.join(", "));
            //return new ValidationResult(false, [ruleContext], '', '', [retToken1, retToken2]);
            return IEngine_1.RuleFail("Fail_1", [retToken1.toString(), retToken2.toString()]);
        }
    },
    {
        /**
         * Description: Look for container elements without an 'aria-activedescendant' that have required children.  At least one child must be focusable.
         * Note: Required children won't have multiple roles specified in the role attribute, but this assumption may not be correct.
         * Origin:  WCAG 2.0 guideline 2.1.1 Keyboard, g1086
         * 			CI162 Web checklist checkpoint 2.1a
         *			Open Ajax Alliance Accessibility Working Group ruleset
         */
        id: "Rpt_Aria_MissingFocusableChild",
        context: "dom:*[role]",
        dependencies: ["Rpt_Aria_ValidRole"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // An ARIA list is not interactive
            if (legacy_1.RPTUtil.hasRole(ruleContext, { "list": true, "row": true })) {
                return null;
            }
            // Not a valid message for mobile because all elements are focusable in iOS when VoiceOver is enabled.
            if (ruleContext.hasAttribute("class") && ruleContext.getAttribute("class").substring(0, 3) == "mbl") {
                return null;
            }
            // Handle the case where the element is hidden by disabled html5 attribute or aria-disabled:
            //  1. In the case that this element has a disabled attribute and the element supports it, we mark this rule as passed.
            //  2. In the case that this element has a aria-disabled attribute then, we mark this rule as passed.
            // For both of the cases above we do not need to perform any further checks, as the element is disabled in some form or another.
            if (legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
                return null;
            }
            var passed = true;
            var doc = ruleContext.ownerDocument;
            var hasAttribute = legacy_1.RPTUtil.hasAttribute;
            var roleNameArr = new Array();
            var nodeName = "";
            var inScope = false;
            var roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
            for (var j = 0; j < roles.length; ++j) {
                if (ARIADefinitions_1.ARIADefinitions.containers.includes(roles[j])) {
                    var disabled = hasAttribute(ruleContext, 'aria-disabled') ? ruleContext.getAttribute("aria-disabled") : '';
                    if (disabled != 'true' && !hasAttribute(ruleContext, 'aria-activedescendant')) {
                        var reqChildren = ARIADefinitions_1.ARIADefinitions.designPatterns[roles[j]].reqChildren;
                        if (reqChildren) {
                            inScope = true;
                            passed = false;
                            var xp = "descendant::*[";
                            for (var i = 0; i < reqChildren.length; i++) {
                                xp += "@role='" + reqChildren[i] + "' or ";
                            }
                            xp = xp.substring(0, xp.length - 4) + ']';
                            var xpathResult = doc.evaluate(xp, ruleContext, legacy_1.RPTUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                            var r = xpathResult.iterateNext();
                            while (r && !passed) {
                                // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                                // or not.
                                //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                                //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                                //     add it to the roleToElems hash at all or even do any checking for it at all.
                                //
                                // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                                //       so on and so forth.
                                if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(r)) {
                                    r = xpathResult.iterateNext();
                                    continue;
                                }
                                passed = legacy_1.RPTUtil.tabIndexLEZero(r);
                                if (!passed)
                                    passed = legacy_1.RPTUtil.isfocusableByDefault(r);
                                // Required child is not focusable via tabindex.  See if there is a grandchild that is focusable by default or by tabindex.
                                if (!passed) {
                                    var xp2 = "descendant::*";
                                    var xpathResult2 = doc.evaluate(xp2, r, legacy_1.RPTUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                                    var r2 = xpathResult2.iterateNext();
                                    while (r2 && !passed) {
                                        // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                                        // or not.
                                        //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                                        //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                                        //     add it to the roleToElems hash at all or even do any checking for it at all.
                                        //
                                        // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                                        //       so on and so forth.
                                        if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(r2)) {
                                            r2 = xpathResult2.iterateNext();
                                            continue;
                                        }
                                        passed = legacy_1.RPTUtil.tabIndexLEZero(r2);
                                        if (!passed)
                                            passed = legacy_1.RPTUtil.isfocusableByDefault(r2);
                                        r2 = xpathResult2.iterateNext();
                                    }
                                }
                                if (!passed) {
                                    roleNameArr = r.getAttribute("role").trim().split(" ");
                                    nodeName = r.nodeName.toLowerCase();
                                }
                                r = xpathResult.iterateNext();
                            }
                        }
                    }
                }
            }
            // Variable Decleration
            var retToken1 = new Array();
            var retToken2 = new Array();
            // In the case the arrays/strings are empty, that means that there is no violation so we can reset it back to passed, the reason for this
            // is that we are setting passed=false while we perform a loop which causes violation to trigger even if there is no issues. Instead of
            // updating the whole rule to switch from using passed in that way simply do the check at this point.
            if (nodeName.length > 0 && roleNameArr.length > 0) {
                retToken1.push(nodeName);
                retToken2.push(roleNameArr.join(", "));
            }
            else {
                passed = true;
            }
            //return new ValidationResult(passed, [ruleContext], 'role', '', passed == true ? [] : [retToken1, retToken2]);
            if (!inScope) {
                return null;
            }
            else if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [retToken1.toString(), retToken2.toString()]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Find elements without aria-activedescendant that have roles with required children.
         * Either the children or the parent must have keyboard event handlers.
         * Note: Required children won't have multiple roles specified in the role attribute, but this assumption may not be correct.
         * Origin:  WCAG 2.0 guideline 2.1.1 Keyboard, g1087
         * 			CI162 Web checklist checkpoint 2.1a
         *			Open Ajax Alliance Accessibility Working Group ruleset
         */
        id: "Rpt_Aria_MissingKeyboardHandler",
        context: "dom:*[role]",
        dependencies: ["Rpt_Aria_ValidRole"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            var savedPassed = passed;
            var doc = ruleContext.ownerDocument;
            var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
            var roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
            var hasAttribute = legacy_1.RPTUtil.hasAttribute;
            // Composite user interface widget roles. They act as containers that manage other, contained widgets.
            var roleContainers = ["combobox", "grid", "listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"];
            var roleNameArr = new Array();
            for (var j = 0; j < roles.length; ++j) {
                var pattern = designPatterns[roles[j]];
                if (roleContainers.indexOf(roles[j]) >= 0) {
                    var disabled = hasAttribute(ruleContext, 'aria-disabled') ? ruleContext.getAttribute("aria-disabled") : '';
                    if (!disabled) {
                        // See if there is a keyboard event handler on the parent element.
                        passed = (ruleContext.hasAttribute("onkeydown") || ruleContext.hasAttribute("onkeypress"));
                        // No keyboard event handler found on parent.  See if keyboard event handlers are on required child elements.
                        if (!passed) {
                            if (!hasAttribute(ruleContext, 'aria-activedescendant')) {
                                var reqChildren = ARIADefinitions_1.ARIADefinitions.designPatterns[roles[j]].reqChildren;
                                if (reqChildren) { /* SMF TODO menubar does not have any reqChildren */
                                    for (var i = 0, requiredChildrenLength = reqChildren.length; i < requiredChildrenLength; i++) {
                                        var xp = "*[contains(@role,'" + reqChildren[i] + "')]";
                                        var xpathResult = doc.evaluate(xp, ruleContext, legacy_1.RPTUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                                        var r = xpathResult.iterateNext();
                                        while (r) {
                                            passed = (r.hasAttribute("onkeydown") || r.hasAttribute("onkeypress"));
                                            if (!passed) {
                                                // Child did not have a key handler.  See if any of the grandchildren do.
                                                var xp2 = "descendant::*";
                                                var xpathResult2 = doc.evaluate(xp2, r, legacy_1.RPTUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                                                var r2 = xpathResult2.iterateNext();
                                                while (r2 && !passed) {
                                                    // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                                                    // or not.
                                                    //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                                                    //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                                                    //     add it to the roleToElems hash at all or even do any checking for it at all.
                                                    //
                                                    // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                                                    //       so on and so forth.
                                                    if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(r2)) {
                                                        r2 = xpathResult2.iterateNext();
                                                        continue;
                                                    }
                                                    passed = legacy_1.RPTUtil.tabIndexLEZero(r2) &&
                                                        (r2.hasAttribute("onkeydown") || r2.hasAttribute("onkeypress"));
                                                    if (!passed) {
                                                        // No tabindex focusable element found with a key handler.  See if an element focusable by default has a handler.
                                                        if (legacy_1.RPTUtil.isfocusableByDefault(r2)) {
                                                            passed = (r2.hasAttribute("onkeydown") || r2.hasAttribute("onkeypress"));
                                                            // Is this an action link?
                                                            if (r2.nodeName.toLowerCase() == "a" && r2.hasAttribute("href")) {
                                                                var href = r2.getAttribute("href");
                                                                // Action link must start with "javascript:", must not contain a "void" and
                                                                // must have a function name following "javascript:" (i.e., href.length > 11)
                                                                passed = (href.startsWith("javascript:") && href.indexOf("void") == -1 && href.length > 11);
                                                            }
                                                        }
                                                    }
                                                    r2 = xpathResult2.iterateNext();
                                                }
                                            }
                                            if (!passed) {
                                                // All the required children (or any descendants of the required children) must have keypress/keydown
                                                // If not, it is a failure, no need to keep checking any more.
                                                break;
                                            }
                                            r = xpathResult.iterateNext();
                                        }
                                    }
                                }
                                else {
                                    // The current element failed the keydown/keypress, and it does not have required children, such as menubar.
                                    // Let's check its descendants.
                                    var xp2 = "descendant::*";
                                    var xpathResult2 = doc.evaluate(xp2, ruleContext, legacy_1.RPTUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                                    var r2 = xpathResult2.iterateNext();
                                    while (r2 && !passed) {
                                        // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                                        // or not.
                                        //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                                        //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                                        //     add it to the roleToElems hash at all or even do any checking for it at all.
                                        //
                                        // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                                        //       so on and so forth.
                                        if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(r2)) {
                                            r2 = xpathResult2.iterateNext();
                                            continue;
                                        }
                                        passed = legacy_1.RPTUtil.tabIndexLEZero(r2) &&
                                            (r2.hasAttribute("onkeydown") || r2.hasAttribute("onkeypress"));
                                        if (!passed) {
                                            // No tabindex focusable element found with a key handler.  See if an element focusable by default has a handler.
                                            if (legacy_1.RPTUtil.isfocusableByDefault(r2)) {
                                                passed = (r2.hasAttribute("onkeydown") || r2.hasAttribute("onkeypress"));
                                                // Is this an action link?
                                                if (r2.nodeName.toLowerCase() == "a" && r2.hasAttribute("href")) {
                                                    var href = r2.getAttribute("href");
                                                    // Action link must start with "javascript:", must not contain a "void" and
                                                    // must have a function name following "javascript:" (i.e., href.length > 11)
                                                    passed = (href.startsWith("javascript:") && href.indexOf("void") == -1 && href.length > 11);
                                                }
                                            }
                                        }
                                        r2 = xpathResult2.iterateNext();
                                    }
                                }
                            }
                            else {
                                // Attribute 'aria-activedescendant' is specified.
                                passed = true;
                            }
                        }
                    }
                }
                if (!passed) {
                    roleNameArr.push(roles[j]);
                }
                if (!passed && savedPassed) {
                    savedPassed = passed;
                }
            }
            var retToken1 = new Array();
            retToken1.push(ruleContext.nodeName.toLowerCase());
            var retToken2 = new Array();
            retToken2.push(roleNameArr.join(", "));
            return savedPassed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1", [retToken1.toString(), retToken2.toString()]);
        }
    },
    {
        /**
         * Description: Triggers if both HTML 5 attribute and the associated WAI-ARIA attribute are in an element
         * Origin:  HTML 5 - per Richard Schwerdtfeger's requirements. g1141
         */
        id: "HAAC_Aria_Or_HTML5_Attr",
        context: "dom:*[aria-required], dom:*[aria-autocomplete], dom:*[aria-readonly], dom:*[aria-disabled], dom:*[aria-placeholder]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            if (ruleContext.hasAttribute("required") && ruleContext.hasAttribute("aria-required") &&
                ruleContext.getAttribute("aria-required").trim().toLowerCase() == "false") {
                passed = false;
            }
            if (passed && ruleContext.hasAttribute("placeholder") && ruleContext.hasAttribute("aria-placeholder")) {
                passed = false;
            }
            if (passed && ruleContext.hasAttribute("aria-autocomplete")) {
                var ariaAutoCompleteAttr = ruleContext.getAttribute("aria-autocomplete").trim().toLowerCase();
                var myNode = ruleContext;
                var html5AutoCompleteAttr = null;
                // There is no need to do a consideration for hidden in this node walk if the ruleContext node is hidden then
                // this rule will not trigger as hidden takes inheritance from the parent nodes that this is walking up to.
                // In the case that we ever need to consider hidden for this case need to add if (RPTUtil.shouldNodeBeSkippedHidden(myNode)
                // and continue to the next node.
                while ((myNode != null) && (myNode.nodeName.toLowerCase() != 'html') && (!(myNode.hasAttribute("autocomplete")))) {
                    myNode = myNode.parentElement;
                }
                if ((myNode != null) && (myNode.hasAttribute("autocomplete"))) {
                    html5AutoCompleteAttr = myNode.getAttribute("autocomplete").trim().toLowerCase();
                }
                // if HTML5 autocomplete attribute is specified and conflicting with aria tag
                if ((html5AutoCompleteAttr != null) &&
                    (html5AutoCompleteAttr == "on" &&
                        ariaAutoCompleteAttr == "none")) {
                    passed = false;
                }
            }
            if (passed && ruleContext.hasAttribute("readonly") && ruleContext.hasAttribute("aria-readonly") &&
                ruleContext.getAttribute("aria-readonly").trim().toLowerCase() == "false") {
                passed = false;
            }
            if (passed && ruleContext.hasAttribute("aria-disabled")) {
                // && ruleContext.getAttribute("aria-disabled").trim().toLowerCase() == "false"){
                var ariaDisabledAttr = ruleContext.getAttribute("aria-disabled").trim().toLowerCase();
                var myNode = ruleContext;
                var html5DisabledAttr = myNode.hasAttribute("disabled");
                // There is no need to do a consideration for hidden in this node walk if the ruleContext node is hidden then
                // this rule will not trigger as hidden takes inheritance from the parent nodes that this is walking up to.
                // In the case that we ever need to consider hidden for this case need to add if (RPTUtil.shouldNodeBeSkippedHidden(myNode)
                // and continue to the next node.
                while ((myNode != null) && (myNode.nodeName.toLowerCase() != 'html') && (!(myNode.hasAttribute("disabled")))) {
                    myNode = myNode.parentElement;
                }
                if ((myNode != null) && (myNode.hasAttribute("disabled"))) {
                    html5DisabledAttr = myNode.getAttribute("disabled");
                }
                // if HTML5 disabled attribute is specified and conflicting with aria tag
                // Note RPT WebApp has a bug that inject disabled or DISABLED as the attribute value.
                if (((html5DisabledAttr == true || html5DisabledAttr == "" || html5DisabledAttr == "DISABLED" || html5DisabledAttr == "disabled") && myNode.nodeName.toLowerCase() != 'html') &&
                    (ariaDisabledAttr == "false")) {
                    passed = false;
                }
            }
            //return new ValidationResult(passed, [ruleContext], '', '', []);
            if (passed) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail("Fail_1");
            }
        }
    },
    {
        /**
         * Description: Triggers if role conflict with ARIA implicitSemantics restrictions
         * Native host semantics 1146
         */
        id: "HAAC_Aria_Native_Host_Sematics",
        context: "dom:*",
        dependencies: ["Rpt_Aria_ValidProperty"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            var roles = [];
            if (ruleContext.getAttribute("role") !== null) {
                roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/); // separated by one or more white spaces
            }
            var tagName = ruleContext.tagName.toLowerCase();
            var allowedRoles = [];
            var allowedAttributes = [];
            var roleTokens = [];
            var attributeTokens = [];
            var allowedRoleTokens = [];
            var allowedAttributeTokens = [];
            var permittedRoles = [];
            var tagProperty = legacy_1.RPTUtil.getElementAriaProperty(ruleContext);
            allowedRoles = legacy_1.RPTUtil.getAllowedAriaRoles(ruleContext, tagProperty);
            // Testing restrictions for each role and adding the corresponding attributes to the allowed attribute list
            for (var i = 0; i < roles.length; i++) {
                if (allowedRoles.length === 0) {
                    passed = false;
                    if (roleTokens.indexOf(roles[i]) === -1) {
                        roleTokens.push(roles[i]);
                    }
                }
                else if (allowedRoles.indexOf("any") === -1) { // any role is valid so no checking here. the validity of the aria role is checked by Rpt_Aria_ValidRole
                    if (allowedRoles.indexOf(roles[i]) === -1) {
                        if (roleTokens.indexOf(roles[i]) === -1) {
                            roleTokens.push(roles[i]);
                            passed = false;
                        }
                    }
                    else {
                        if (permittedRoles.indexOf(roles[i]) === -1) {
                            permittedRoles.push(roles[i]);
                        }
                    }
                }
                else if (allowedRoles.indexOf("any") > -1) {
                    //First check special case: <img> with nonempty alt only allows 'any' except 'presentation/none'
                    if (tagName === "img" && legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "alt") &&
                        (roles[i] === "presentation" || roles[i] === "none")) {
                        if (roleTokens.indexOf(roles[i]) === -1) {
                            roleTokens.push(roles[i]);
                            passed = false;
                        }
                    }
                    else 
                    // Then check the normal case 
                    if (permittedRoles.indexOf(roles[i]) === -1) {
                        permittedRoles.push(roles[i]);
                    }
                }
            } // for loop
            allowedAttributes = legacy_1.RPTUtil.getAllowedAriaAttributes(ruleContext, permittedRoles, tagProperty);
            // input type="password" has no role but it can take an aria-required. This is the only case like this.
            // So we add it in the code instead of adding new mechanism to the aria-definition.js
            if (ruleContext.nodeName.toLowerCase() == "input" && legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "type") && ruleContext.getAttribute("type").trim().toLowerCase() == "password") {
                allowedAttributes.push("aria-required");
            }
            var contextAttributes = ruleContext.attributes;
            if (contextAttributes) {
                for (var i = 0; i < contextAttributes.length; i++) {
                    var attrName = contextAttributes[i].name.trim().toLowerCase();
                    var defined = attrName.substring(0, 5) === 'aria-';
                    if (defined && allowedAttributes.indexOf(attrName) === -1) {
                        //valid attributes can be none also which is covered here
                        passed = false;
                        attributeTokens.indexOf(attrName) === -1 ? attributeTokens.push(attrName) : false;
                    }
                }
            }
            //		if(!passed){
            //			  if(roleTokens.length !== 0){ // Rule failure is present
            //		   			allowedRoleTokens = allowedRoleTokens.concat(allowedRoles); // This can be concatenating empty list
            //			  }
            //
            //	    	  if(attributeTokens.length !== 0){ // Attribute failure is present
            //	    		  allowedAttributeTokens = allowedAttributeTokens.concat(allowedAttributes);
            //	    	  }
            //
            //	    }
            var roleOrAttributeTokens = roleTokens.concat(attributeTokens).join(", ");
            //      let allowedRoleOrAttributeTokens = allowedRoleTokens.concat(allowedAttributeTokens).join(", ");
            //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [roleOrAttributeTokens, tagName]);
            if (passed) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail("Fail_1", [roleOrAttributeTokens, tagName]);
            }
            // below for listing all allowed role and attributes.  We can delete it if we are not using it next year (2018) #283
            //      return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [roleOrAttributeTokens, tagName, allowedRoleOrAttributeTokens]);
        }
    },
    {
        /**
         * Description: Triggers if ARIA error message is hidden or doesn't exist
         * 				when aria-invalid is true.
         * Origin:  IBM Web checklist checkpoint 3.3.1
         *
         */
        id: "HAAC_Aria_ErrorMessage",
        context: "dom:*[aria-invalid=true]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var aria_errMsgId = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-errormessage");
            // If aria-errormessage is not provided, then OUT_OF_SCOPE
            if (!aria_errMsgId) {
                return null;
            }
            var msg_ele = ruleContext.ownerDocument.getElementById(aria_errMsgId);
            // POF0: Invalid id reference
            if (!msg_ele) {
                return IEngine_1.RuleFail("Fail_1");
            }
            // POF1: Referenced element is not visible
            if (!legacy_1.RPTUtil.isNodeVisible(msg_ele)) {
                return IEngine_1.RuleFail("Fail_2");
            }
            return IEngine_1.RulePass("Pass_0");
        }
    }
    //next rule
];
exports.a11yRulesAria = a11yRulesAria;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesFieldset = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesFieldset = [
    {
        /**
         * Description: Trigger if fieldset is missing a legend
         * Origin: WCAG 2.0 Technique H71
         */
        id: "WCAG20_Fieldset_HasLegend",
        context: "dom:fieldset",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // In the case a legend is hidden, we should still trigger a violations for this
            var legends = legacy_1.RPTUtil.getChildByTagHidden(ruleContext, "legend", true, false);
            if (legends.length === 0) {
                // Fieldset has NO Legend
                return IEngine_1.RuleFail("Fail_1");
            }
            else if (legends.length > 1) {
                // Fieldset has more than one legend
                return IEngine_1.RuleFail("Fail_2");
            }
            else if (legacy_1.RPTUtil.getInnerText(legends[0]).trim().length === 0) {
                // Fieldset has legend but legend is empty
                return IEngine_1.RuleFail("Fail_3");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    }
];
exports.a11yRulesFieldset = a11yRulesFieldset;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesInput = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesInput = [
    {
        /**
         * Description: Trigger if an input isn't labeled or titled
         * Origin: WCAG 2.0 Technique H44, H65, H91
         */
        id: "WCAG20_Input_ExplicitLabel",
        context: "aria:button,aria:checkbox,aria:combobox,aria:listbox,aria:menuitemcheckbox"
            + ",aria:menuitemradio,aria:radio,aria:searchbox,aria:slider,aria:spinbutton"
            + ",aria:switch,aria:textbox,aria:progressbar,dom:input[type=file],dom:output",
        // the datalist element do not require any explicit or implicit label, might need to exclude it from the scope of the rules
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // JCH - NO OUT OF SCOPE hidden in context
            /* removed the  check role= presentation since according to latest native host semantics https://www.w3.org/TR/html-aria/#docconformance  table,  these two roles are not applicable to the elements are in the  scope of this role
            if (RPTUtil.hasRole(ruleContext, "presentation") || RPTUtil.hasRole(ruleContext, "none"))
                return RulePass(1);
            */
            // Determine the input type
            var passed = true;
            var nodeName = ruleContext.nodeName.toLowerCase();
            var type = "text";
            if (nodeName == "input" && ruleContext.hasAttribute("type")) {
                type = ruleContext.getAttribute("type").toLowerCase();
            }
            else if (nodeName === "button" || legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "button")) {
                type = "buttonelem";
            }
            if (nodeName == "input" && type == "") {
                type = "text";
            }
            var POF = -1;
            var textTypes = [
                "text", "file", "password",
                "checkbox", "radio",
                "search", "tel", "url", "email",
                "date", "number", "range",
                "time", "color"
            ];
            var buttonTypes = [
                "button", "reset", "submit"
            ];
            var buttonTypesWithDefaults = ["reset", "submit"]; // 'submit' and 'reset' have visible defaults.
            if (textTypes.indexOf(type) !== -1) { // If type is in the list
                // Get only the non-hidden labels for element, in the case that an label is hidden then it is a violation
                var labelElem = legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true);
                var hasLabelElemContent = false;
                if (labelElem) {
                    if (legacy_1.RPTUtil.hasInnerContentHidden(labelElem)) {
                        hasLabelElemContent = true;
                    }
                    else if ((labelElem.getAttribute("aria-label") || "").trim().length > 0) {
                        hasLabelElemContent = true;
                    }
                    else if (labelElem.hasAttribute("aria-labelledby")) {
                        var labelledByElem = labelElem.ownerDocument.getElementById(labelElem.getAttribute('aria-labelledby'));
                        if (labelledByElem && legacy_1.RPTUtil.hasInnerContent(labelledByElem)) {
                            hasLabelElemContent = true;
                        }
                    }
                }
                passed = (labelElem != null && hasLabelElemContent) ||
                    (labelElem == null && legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title")) ||
                    legacy_1.RPTUtil.hasAriaLabel(ruleContext) || legacy_1.RPTUtil.hasImplicitLabel(ruleContext);
                if (!passed)
                    POF = 2 + textTypes.indexOf(type);
            }
            else if (buttonTypes.indexOf(type) !== -1) { // If type is a button
                if (buttonTypesWithDefaults.indexOf(type) !== -1 && !ruleContext.hasAttribute("value")) {
                    // 'submit' and 'reset' have visible defaults so pass if there is no 'value' attribute
                    passed = true;
                }
                else {
                    passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "value") || legacy_1.RPTUtil.hasAriaLabel(ruleContext);
                    if (!passed)
                        POF = 2 + textTypes.length + buttonTypes.indexOf(type);
                }
            }
            else if (type == "buttonelem") {
                passed = legacy_1.RPTUtil.hasInnerContentHidden(ruleContext) || legacy_1.RPTUtil.hasAriaLabel(ruleContext);
                if (!passed)
                    POF = 2 + textTypes.length + buttonTypes.length + 1;
            }
            // Rpt_Aria_ValidIdRef determines if the aria-labelledby id points to a valid element
            if (!passed && (buttonTypes.indexOf(type) !== -1)) {
                if (ruleContext.hasAttribute("class") && ruleContext.getAttribute("class") == "dijitOffScreen" && ruleContext.parentElement.hasAttribute("widgetid")) {
                    // Special handling for dijit buttons
                    var labelId = ruleContext.parentElement.getAttribute("widgetid") + "_label";
                    var label = ruleContext.ownerDocument.getElementById(labelId);
                    if (label != null) {
                        passed = legacy_1.RPTUtil.hasInnerContentHidden(label);
                        // This means I failed above also
                        if (!passed)
                            POF = 2 + textTypes.length + buttonTypes.length + 4 + buttonTypes.indexOf(type);
                    }
                }
            }
            if (!passed && nodeName == "optgroup") {
                passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "label");
                if (!passed)
                    POF = 2 + textTypes.length + buttonTypes.length + 2;
            }
            if (!passed && nodeName == "option") {
                // Is a non-empty value attribute also enough for an option element?
                passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "label") || ruleContext.innerHTML.trim().length > 0;
                if (!passed)
                    POF = 2 + textTypes.length + buttonTypes.length + 3;
            }
            if (passed) {
                return IEngine_1.RulePass("Pass_0");
            }
            else if (ruleContext.hasAttribute("role") && ruleContext.getAttribute("role").trim().length > 0) {
                return IEngine_1.RuleFail("Fail_2", ruleContext.getAttribute("role").split(" "));
            }
            else {
                return IEngine_1.RuleFail("Fail_1", [nodeName]);
            }
        }
    },
    {
        /**
         * Description: Trigger if an image input does not have alt.
         * Origin: WCAG 2.0 Technique H91
         */
        id: "WCAG20_Input_ExplicitLabelImage",
        context: "dom:input",
        run: function (context, options) {
            // See https://www.w3.org/WAI/WCAG21/Techniques/failures/F65
            var ruleContext = context["dom"].node;
            if (!ruleContext.hasAttribute("type") || ruleContext.getAttribute("type").toLowerCase() != "image") {
                return null;
            }
            if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "alt")) {
                return IEngine_1.RulePass("Pass_0");
            }
            else if (legacy_1.RPTUtil.hasAriaLabel(ruleContext)) {
                return IEngine_1.RulePass("Pass_1");
            }
            else if (ruleContext.hasAttribute("title") && ruleContext.getAttribute("title").length > 0) {
                return IEngine_1.RulePass("Pass_2");
            }
            return IEngine_1.RuleFail("Fail");
        }
    },
    {
        /**
         * Description: Trigger if the label is supposed to be before the input, but is not.
         * Origin: WCAG 2.0 Technique H44
         */
        id: "WCAG20_Input_LabelBefore",
        context: "dom:input, dom:textarea, dom:select",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            if (ruleContext.nodeName.toLowerCase() == "input" && ruleContext.hasAttribute("type")) {
                var type = ruleContext.getAttribute("type").toLowerCase();
                if (type != "text" && type != "file" && type != "password") {
                    return null;
                }
            }
            // Get only the non-hidden labels for element
            var labelElem = legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true);
            if (labelElem == null || !legacy_1.RPTUtil.hasInnerContentHidden(labelElem)) {
                // Due to dependency, label must be done via title - this rule doesn't apply
                return null;
            }
            var value = legacy_1.RPTUtil.compareNodeOrder(labelElem, ruleContext);
            if (value == -2) {
                // input nested in label
                var passed = false;
                var walkNode = ruleContext.previousSibling;
                while (!passed && walkNode != null) {
                    passed = ((walkNode.nodeName.toLowerCase() == "#text" && walkNode.nodeValue.trim().length > 0)
                        || (walkNode.nodeName.toLowerCase() == "span" && walkNode.textContent.trim().length > 0));
                    walkNode = walkNode.previousSibling;
                }
                if (!passed) {
                    // Input nested in label and text after input
                    return IEngine_1.RuleFail("Fail_1");
                }
            }
            else {
                if (value != -1) {
                    // label is after input
                    return IEngine_1.RuleFail("Fail_2");
                }
            }
            // Haven't returned yet, then I pass
            return IEngine_1.RulePass("Pass_0");
        }
    },
    {
        /**
         * Description: Trigger if the label is supposed to be after the input, but is not.
         * Origin: WCAG 2.0 Technique H44
         */
        id: "WCAG20_Input_LabelAfter",
        context: "dom:input",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var type = "";
            if (ruleContext.hasAttribute("type"))
                type = ruleContext.getAttribute("type").toLowerCase();
            if (type != "checkbox" && type != "radio") {
                return null;
            }
            // Get only the non-hidden labels for element
            var labelElem = legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true);
            if (labelElem == null || !legacy_1.RPTUtil.hasInnerContentHidden(labelElem)) {
                // Due to dependency, label must be done via title - this rule doesn't apply
                return null;
            }
            var value = legacy_1.RPTUtil.compareNodeOrder(labelElem, ruleContext);
            var passed;
            if (value == -2) {
                // input nested in label
                passed = false;
                var walkNode = ruleContext.nextSibling;
                while (!passed && walkNode != null) {
                    passed = ((walkNode.nodeName.toLowerCase() == "#text" && walkNode.nodeValue.trim().length > 0)
                        || (walkNode.nodeName.toLowerCase() == "span" && walkNode.textContent.trim().length > 0));
                    walkNode = walkNode.nextSibling;
                }
                if (!passed) {
                    // Input nested in label and text before input
                    return IEngine_1.RuleFail("Fail_1");
                }
            }
            else {
                if (value != 1) {
                    // label is before input
                    return IEngine_1.RuleFail("Fail_2");
                }
            }
            return IEngine_1.RulePass("Pass_0");
        }
    },
    {
        /**
         * Description: Trigger if non-radio/chk inputs are not in a fieldset
         * Origin: WCAG 2.0 Technique H71
         */
        id: "WCAG20_Input_InFieldSet",
        context: "dom:input, dom:textarea, dom:select",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Don't trigger for other input types or if we're in a fieldset
            if (ruleContext.nodeName.toLowerCase() == "input" && ruleContext.hasAttribute("type")) {
                var type = ruleContext.getAttribute("type").toLowerCase();
                if (type != "text" && type != "file" && type != "password")
                    return IEngine_1.RulePass("Pass_0");
            }
            if (legacy_1.RPTUtil.getAncestor(ruleContext, "fieldset") != null)
                return IEngine_1.RulePass("Pass_0");
            // No fieldset - see if this input is all by itself - no need to group single inputs
            var parent = legacy_1.RPTUtil.getAncestor(ruleContext, ["form", "body"]);
            var checkTypes = ["input", "textarea", "select"];
            var passed = true;
            for (var i = 0; passed && i < checkTypes.length; ++i) {
                var controls = parent.getElementsByTagName(checkTypes[i]);
                for (var j = 0; passed && j < controls.length; ++j) {
                    // Check if the node should be skipped or not based on the Check Hidden Content setting and if the node isVisible or
                    // not.
                    if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(controls[j])) {
                        continue;
                    }
                    // Note that textareas and selects will be called type='text'
                    var type = controls[j].hasAttribute("type") ? controls[j].getAttribute("type").toLowerCase() : "text";
                    // Only fail if this is another control in the form and its type is another text-like input
                    passed = controls[j] == ruleContext || (type != "text" && type != "password" && type != "file");
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger if a radio/checkbox with same name is not grouped
         * (e.g., in a fieldset, with role = "group", etc.)
         * Origin: WCAG 2.0 Technique H71, H91
         *
         * Failures:
         * 0a. radio not in fieldset, group or radiogroup - AND I find another radio or check with the same 'name' attribute- AND I'm not in a table
         * 0b. checkbox not in fieldset or group - AND I find another radio or check with the same 'name' attribute - AND I'm not in a table
         * 1. radio or checkbox missing a name [IGNORE?]
         * 2. radio or checkbox has the same "name" attribute as another radio or checkbox in a separate fieldset, group or radiogroup
         * 3. am in table and some combination of the above
         */
        id: "WCAG20_Input_RadioChkInFieldSet",
        context: "dom:input",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            if (context["aria"].role === 'none' || context["aria"].role === 'presentation')
                return null;
            var getGroup = function (e) {
                var retVal = legacy_1.RPTUtil.getAncestor(e, "fieldset")
                    || legacy_1.RPTUtil.getAncestorWithRole(e, "radiogroup")
                    || legacy_1.RPTUtil.getAncestorWithRole(e, "group");
                if (!retVal) {
                    retVal = legacy_1.RPTUtil.getAncestor(e, "table");
                    if (retVal && !legacy_1.RPTUtil.isDataTable(retVal)) {
                        retVal = null;
                    }
                }
                return retVal;
            };
            // Only radio buttons and checkboxes are in scope
            var ctxType = ruleContext.hasAttribute("type") ? ruleContext.getAttribute("type").toLowerCase() : "text";
            if (ctxType != "checkbox" && ctxType != "radio") {
                return null;
            }
            // Determine which form we're in (if any) to determine our scope
            var ctxForm = legacy_1.RPTUtil.getAncestorWithRole(ruleContext, "form") || ruleContext.ownerDocument.documentElement;
            // Get data about all of the visible checkboxes and radios in the scope of this form 
            // and cache it for all of the other inputs in this scope
            var formCache = legacy_1.RPTUtil.getCache(ctxForm, "WCAG20_Input_RadioChkInFieldSet", null);
            if (!formCache) {
                formCache = {
                    checkboxByName: {},
                    radiosByName: {},
                    nameToGroup: {},
                    numCheckboxes: 0,
                    numRadios: 0
                };
                // Get all of the checkboxes in the form or body (but not nested in something else and not hidden)
                // And get a mapping of these checkboxes to 
                var checkboxQ = ctxForm.querySelectorAll("input[type=checkbox]");
                for (var idx = 0; idx < checkboxQ.length; ++idx) {
                    var cb = checkboxQ[idx];
                    if ((legacy_1.RPTUtil.getAncestorWithRole(cb, "form") || ruleContext.ownerDocument.documentElement) === ctxForm
                        && !legacy_1.RPTUtil.shouldNodeBeSkippedHidden(cb)) {
                        var name_1 = cb.getAttribute("name") || "";
                        (formCache.checkboxByName[name_1] = formCache.checkboxByName[name_1] || []).push(cb);
                        formCache.nameToGroup[name_1] = formCache.nameToGroup[name_1] || getGroup(cb);
                        ++formCache.numCheckboxes;
                    }
                }
                // Get all of the radios in the form or body (but not nested in something else and not hidden)
                var radiosQ = ctxForm.querySelectorAll("input[type=radio]");
                for (var idx = 0; idx < radiosQ.length; ++idx) {
                    var r = radiosQ[idx];
                    if ((legacy_1.RPTUtil.getAncestorWithRole(r, "form") || ruleContext.ownerDocument.documentElement) === ctxForm
                        && !legacy_1.RPTUtil.shouldNodeBeSkippedHidden(r)) {
                        var name_2 = r.getAttribute("name") || "";
                        (formCache.radiosByName[name_2] = formCache.radiosByName[name_2] || []).push(r);
                        formCache.nameToGroup[name_2] = formCache.nameToGroup[name_2] || getGroup(r);
                        ++formCache.numRadios;
                    }
                }
                legacy_1.RPTUtil.setCache(ctxForm, "WCAG20_Input_RadioChkInFieldSet", formCache);
            }
            ///////////// Calculated everything, now check the various cases
            var ctxName = ruleContext.getAttribute("name");
            var ctxGroup = getGroup(ruleContext);
            ctxType = ctxType === "radio" ? "Radio" : "Checkbox";
            if (!ctxName || ctxName === "") {
                // First process cases where the control is not named
                if (ctxType === "Radio") {
                    // Radios without names don't act like groups, so don't enforce grouping
                    if (ctxGroup === null) {
                        return IEngine_1.RulePass("Pass_RadioNoName", [ctxType]);
                    }
                    else {
                        return IEngine_1.RulePass("Pass_Grouped", [ctxType]);
                    }
                }
                else {
                    // Must be an unnamed checkbox
                    if (ctxGroup === null) {
                        if ((formCache.checkboxByName[""] || []).length > 1) {
                            return IEngine_1.RulePotential("Potential_UnnamedCheckbox", [ctxType]);
                        }
                        else {
                            return IEngine_1.RulePass("Pass_LoneNogroup", [ctxType]);
                        }
                    }
                    else {
                        return IEngine_1.RulePass("Pass_Grouped", [ctxType]);
                    }
                }
            }
            else {
                // Considering a named checkbox
                var numRadiosWithName = (formCache.radiosByName[ctxName] || []).length;
                var numCheckboxesWithName = (formCache.checkboxByName[ctxName] || []).length;
                // Capitalize the input type for messages
                if (numRadiosWithName > 0 && numCheckboxesWithName > 0) {
                    // We have a naming mismatch between different controls
                    return IEngine_1.RuleFail("Fail_ControlNameMismatch", [ctxType, ctxType === "checkbox" ? "radio" : "checkbox", ctxName]);
                }
                else if (ctxType === "Radio" && (formCache.numRadios === 1 || numRadiosWithName === 1)
                    || ctxType === "Checkbox" && formCache.numCheckboxes === 1) {
                    // This is a lone control (either only control of this type on the page, or a radio button without any others by that name)
                    // We pass this control in all cases
                    if (ctxGroup === null) {
                        return IEngine_1.RulePass("Pass_LoneNogroup", [ctxType]);
                    }
                    else {
                        return IEngine_1.RulePass("Pass_Grouped", [ctxType]);
                    }
                }
                else if (ctxType === "Checkbox" && formCache.numCheckboxes > 1 && numCheckboxesWithName === 1) {
                    // We have only one checkbox with this name, but there are other checkboxes in the form. 
                    // If we're not grouped, ask them to examine it
                    if (ctxGroup === null) {
                        return IEngine_1.RulePotential("Potential_LoneCheckbox", [ctxType]);
                    }
                    else {
                        return IEngine_1.RulePass("Pass_Grouped", [ctxType]);
                    }
                }
                else {
                    // We share a name with another similar control. Are we grouped together?
                    if (ctxGroup === null) {
                        if (formCache.nameToGroup[ctxName] !== null) {
                            // We're not grouped, but some control with the same name is in a group
                            return IEngine_1.RuleFail("Fail_NotGroupedOtherGrouped", [ctxType, ctxName]);
                        }
                        else {
                            // None of us are grouped
                            return IEngine_1.RuleFail("Fail_NotGroupedOtherNotGrouped", [ctxType, ctxName]);
                        }
                    }
                    else if (formCache.nameToGroup[ctxName] !== ctxGroup) {
                        // We're not in the main group with the others
                        return IEngine_1.RuleFail("Fail_NotSameGroup", [ctxType, ctxName]);
                    }
                    else {
                        // We're all grouped up!
                        return IEngine_1.RulePass("Pass_Grouped", [ctxType]);
                    }
                }
            }
        }
    },
    {
        /**
         * Description: Triggers if input has an onchange event handler
         * Origin: WCAG 2.0 Technique G13
         */
        id: "WCAG20_Input_HasOnchange",
        context: "dom:input, dom:textarea, dom:select",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            if (ruleContext.nodeName.toLowerCase() == "input" && ruleContext.hasAttribute("type")) {
                var type = ruleContext.getAttribute("type").toLowerCase();
                if (type != "text" && type != "file" && type != "password" && type != "checkbox" && type != "radio")
                    return IEngine_1.RulePass("Pass_0");
            }
            var passed = !ruleContext.hasAttribute("onchange");
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Triggers if input has a HTML 5 required property: HAAC, G1124
         */
        id: "HAAC_Input_HasRequired",
        context: "dom:input, dom:textarea, dom:select",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            if (ruleContext.hasAttribute("required")) {
                passed = false;
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Triggers if placeholder is used as a replacement of label
         *
         * Origin:  HTML 5 - per Richard Schwerdtfeger's requirements. g1145
         */
        id: "HAAC_Input_Placeholder",
        context: "dom:input[placeholder], dom:textarea[placeholder]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            if (ruleContext.hasAttribute("type")) {
                var type = ruleContext.getAttribute("type").toLowerCase();
                if (type == "hidden" || type == "button") {
                    return IEngine_1.RulePass("Pass_0");
                }
            }
            if (ruleContext.hasAttribute("hidden")) {
                var hidden = ruleContext.getAttribute("hidden");
                if (hidden == "" || hidden.toLowerCase() == "hidden") { // when hidden is empty in the element, "" is returned, same as it has a value of "".
                    return IEngine_1.RulePass("Pass_0");
                }
            }
            if (ruleContext.hasAttribute("aria-label")) {
                return IEngine_1.RulePotential("Potential_1");
            }
            if (ruleContext.hasAttribute("aria-labelledby") && ruleContext.hasAttribute("id")) {
                var id = ruleContext.getAttribute("id").trim();
                var refIds = ruleContext.getAttribute("aria-labelledby").trim().split(/\s+/); // separated by one or more white spaces
                if (!refIds.includes(id)) {
                    return IEngine_1.RulePass("Pass_0");
                }
                else {
                    return IEngine_1.RulePotential("Potential_2");
                }
            }
            return IEngine_1.RulePass("Pass_0");
        }
    },
    {
        /**
         * Description: Checks that the HTML autocomplete attribute has a correct value.
         * The rule applies to any HTML input, select and textarea element with a non-empty HTML autocomplete attribute except when one of the following is true:
         *  - The element is not visible on the page, not included in the accessibility tree, and not focusable
         *  - The element is an input element with a type property of hidden, button, submit or reset
         *  - The element has a disabled or aria-disabled="true" attribute
         *  - The element has tabindex="-1" and has a semantic role that is not a widget. (Disabled for now)
    
         * Origin: WCAG 2.1 Success Criterion 1.3.5 (Identify Input Purpose)
         */
        id: "WCAG21_Input_Autocomplete",
        context: "dom:input[autocomplete], dom:textarea[autocomplete], dom:select[autocomplete]",
        run: function (context, options) {
            var cache = {
                "tokensOnOff": ["on", "off"],
                "tokenOptionalSection": "section-",
                "tokensOptionalPurpose": ["shipping", "billing"],
                "tokensMandatoryGroup1_password": ["new-password", "current-password"],
                "tokensMandatoryGroup1_multiline": ["street-address"],
                "tokensMandatoryGroup1_month": ["cc-exp"],
                "tokensMandatoryGroup1_numeric": ["cc-exp-month",
                    "cc-exp-year",
                    "transaction-amount",
                    "bday-day",
                    "bday-month",
                    "bday-year"],
                "tokensMandatoryGroup1_date": ["bday"],
                "tokensMandatoryGroup1_url": ["url", "photo"],
                "tokensMandatoryGroup1_text": ["name",
                    "honorific-prefix",
                    "given-name",
                    "additional-name",
                    "family-name",
                    "honorific-suffix",
                    "nickname",
                    "username",
                    "organization-title",
                    "organization",
                    "address-line1",
                    "address-line2",
                    "address-line3",
                    "address-level4",
                    "address-level3",
                    "address-level2",
                    "address-level1",
                    "country",
                    "country-name",
                    "postal-code",
                    "cc-name",
                    "cc-given-name",
                    "cc-additional-name",
                    "cc-family-name",
                    "cc-number",
                    "cc-csc",
                    "cc-type",
                    "transaction-currency",
                    "language",
                    "sex"],
                "tokensMandatoryGroup1_all": ["name",
                    "honorific-prefix",
                    "given-name",
                    "additional-name",
                    "family-name",
                    "honorific-suffix",
                    "nickname",
                    "username",
                    "new-password",
                    "current-password",
                    "organization-title",
                    "organization",
                    "street-address",
                    "address-line1",
                    "address-line2",
                    "address-line3",
                    "address-level4",
                    "address-level3",
                    "address-level2",
                    "address-level1",
                    "country",
                    "country-name",
                    "postal-code",
                    "cc-name",
                    "cc-given-name",
                    "cc-additional-name",
                    "cc-family-name",
                    "cc-number",
                    "cc-exp",
                    "cc-exp-month",
                    "cc-exp-year",
                    "cc-csc",
                    "cc-type",
                    "transaction-currency",
                    "transaction-amount",
                    "language",
                    "bday",
                    "bday-day",
                    "bday-month",
                    "bday-year",
                    "sex",
                    "url",
                    "photo"],
                "tokensOptionalGroup2": ["home",
                    "work",
                    "mobile",
                    "fax",
                    "pager"],
                "tokensMandatoryGroup2_tel": ["tel"],
                "tokensMandatoryGroup2_email": ["email"],
                "tokensMandatoryGroup2_url": ["impp"],
                "tokensMandatoryGroup2_text": ["tel-country-code",
                    "tel-national",
                    "tel-area-code",
                    "tel-local",
                    "tel-local-prefix",
                    "tel-local-suffix",
                    "tel-extension"],
                "tokensMandatoryGroup2_all": ["tel",
                    "tel-country-code",
                    "tel-national",
                    "tel-area-code",
                    "tel-local",
                    "tel-local-prefix",
                    "tel-local-suffix",
                    "tel-extension",
                    "email",
                    "impp"]
            };
            var ruleContext = context["dom"].node;
            var foundMandatoryToken = false;
            var nodeName = ruleContext.nodeName.toLowerCase();
            if (!legacy_1.RPTUtil.isNodeVisible(ruleContext) ||
                legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
                return null;
            }
            var type = ruleContext.hasAttribute("type") ? ruleContext.getAttribute("type").trim().toLowerCase() : "text";
            var autocompleteAttr = ruleContext.getAttribute("autocomplete").trim().toLowerCase();
            var tokens = autocompleteAttr.split(/\s+/);
            if (tokens.length === 0 || autocompleteAttr.length === 0) {
                return null;
            }
            var tokensMandatoryGroup1 = [];
            var tokensMandatoryGroup2 = [];
            if (nodeName === "textarea" || nodeName === "select") {
                // accept all tokens
                tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_all;
                tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_all;
            }
            else if (nodeName === "input") {
                // handle the various 'input' types
                switch (type) {
                    // Disable check for input type=hidden for now based on scrum discussion
                    /*
                    case "hidden":
                        // accept all tokens
                        tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_all;
                        tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_all;
                        break;
                    */
                    case "text":
                    case "search":
                        tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_text.concat(cache.tokensMandatoryGroup1_password, cache.tokensMandatoryGroup1_url, cache.tokensMandatoryGroup1_numeric, cache.tokensMandatoryGroup1_month, cache.tokensMandatoryGroup1_date);
                        tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_all;
                        break;
                    case "password":
                        tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_password;
                        break;
                    case "url":
                        tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_url;
                        tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_url;
                        break;
                    case "email":
                        tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_email;
                        break;
                    case "tel":
                        tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_tel;
                        break;
                    case "number":
                        tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_numeric;
                        break;
                    case "month":
                        tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_month;
                        break;
                    case "date":
                        tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_date;
                        break;
                    default:
                        // unsupported type for this rule.
                        return null;
                }
            }
            else {
                // should never get here.
                return null;
            }
            // Disable check for input type=hidden for now based on scrum discussion
            var autofillMantle = /* (nodeName==="input" && type==="hidden") ? "anchor" : */ "expectation";
            if (autofillMantle === "expectation") {
                // check on|off for expectation mantle.
                if (tokens.includes("on") || tokens.includes("off")) {
                    // on|off should be the only token
                    if (tokens.length === 1) {
                        return IEngine_1.RulePass(1);
                    }
                    else {
                        return IEngine_1.RuleFail(2);
                    }
                }
            }
            // check detail autofill tokens
            var currIndex = 0;
            // check optional 'section-*' tokens
            if (tokens[currIndex].startsWith(cache.tokenOptionalSection) &&
                tokens[currIndex].length > 8) {
                currIndex++; // consume token
            }
            // check optional 'shipping|billing' tokens
            if (tokens.length > currIndex &&
                cache.tokensOptionalPurpose.includes(tokens[currIndex])) {
                currIndex++; // consume  token
            }
            // check either mandatory group 1 or 2 tokens
            if (tokens.length > currIndex) {
                // check mandatory group 1
                if (tokensMandatoryGroup1.includes(tokens[currIndex])) {
                    foundMandatoryToken = true;
                    currIndex++;
                }
                else {
                    // check optional tokens for group 2
                    if (cache.tokensOptionalGroup2.includes(tokens[currIndex])) {
                        currIndex++;
                    }
                    // check mandatory group 2
                    if (tokensMandatoryGroup2.includes(tokens[currIndex])) {
                        foundMandatoryToken = true;
                        currIndex++;
                    }
                }
            }
            // Only pass if we have seen either of the mandatory groups and all tokens have been consumed
            if (foundMandatoryToken && tokens.length === currIndex) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail("Fail_1");
            }
        }
    },
    {
        /**
         * Description: Trigger if an input does not have a visible label
         * Origin: WCAG 2.0 Success Criterion 3.3.2
         */
        id: "WCAG20_Input_VisibleLabel",
        context: "aria:button,aria:checkbox,aria:combobox,aria:listbox,aria:menuitemcheckbox"
            + ",aria:menuitemradio,aria:radio,aria:searchbox,aria:slider,aria:spinbutton"
            + ",aria:switch,aria:textbox,aria:progressbar,dom:input[type=file],dom:output",
        dependencies: ["WCAG20_Input_ExplicitLabel"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var nodeName = ruleContext.nodeName.toLowerCase();
            if (!legacy_1.RPTUtil.isNodeVisible(ruleContext) ||
                legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
                return null;
            }
            // when in a combobox, only look at the input textbox.
            if (legacy_1.RPTUtil.getAncestorWithRole(ruleContext, "combobox") &&
                !(legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "textbox") || legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "searchbox") ||
                    nodeName === "input" || (nodeName === "select" && legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "combobox")))) {
                return null;
            }
            // avoid diagnosing the popup list of a combobox.
            var rolesToCheck = ["listbox", "tree", "grid", "dialog"];
            for (var j = 0; j < rolesToCheck.length; j++) {
                if (legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, rolesToCheck[j])) {
                    var comboboxes = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "combobox", true, true);
                    for (var k = 0; k < comboboxes.length; k++) {
                        var combobox = comboboxes[k];
                        var aria_owns = legacy_1.RPTUtil.getElementAttribute(combobox, "aria-owns");
                        if (aria_owns) {
                            var owns = legacy_1.RPTUtil.normalizeSpacing(aria_owns.trim()).split(" ");
                            for (var i = 0; i < owns.length; i++) {
                                var owned = ruleContext.ownerDocument.getElementById(owns[i]);
                                if (owned === ruleContext) {
                                    return null;
                                }
                            }
                        }
                    }
                }
            }
            // Determine the input type
            var passed = true;
            var type = "text";
            if (nodeName == "input" && ruleContext.hasAttribute("type")) {
                type = ruleContext.getAttribute("type").toLowerCase();
            }
            else if (nodeName === "button" || legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "button")) {
                type = "buttonelem";
            }
            if (nodeName == "input" && type == "") {
                type = "text";
            }
            var textTypes = ["text", "file", "password",
                "checkbox", "radio",
                "search", "tel", "url", "email",
                "date", "number", "range",
                "time", "color",
                "month", "week", "datetime-local"];
            var buttonTypes = ["button", "reset", "submit"];
            var buttonTypesWithDefaults = ["reset", "submit"]; // 'submit' and 'reset' have visible defaults.
            if (textTypes.indexOf(type) !== -1) { // If type is in the list
                // Get only the non-hidden labels for element, in the case that an label is hidden then it is a violation
                var labelElem = legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true);
                passed = (labelElem != null && legacy_1.RPTUtil.hasInnerContentHidden(labelElem)) ||
                    legacy_1.RPTUtil.hasImplicitLabel(ruleContext) ||
                    type === "file"; // input type=file has a visible default.
            }
            else if (buttonTypes.indexOf(type) !== -1) { // If type is a button
                if (buttonTypesWithDefaults.indexOf(type) !== -1 && !ruleContext.hasAttribute("value")) {
                    // 'submit' and 'reset' have visible defaults so pass if there is no 'value' attribute
                    passed = true;
                }
                else {
                    passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "value");
                }
            }
            else if (type == "buttonelem") {
                var labelElem = legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true); // check label 'for'
                passed = (labelElem != null && legacy_1.RPTUtil.hasInnerContentHidden(labelElem)) || legacy_1.RPTUtil.hasInnerContentHidden(ruleContext);
                if (!passed) {
                    // check implicit label around button.
                    var parentNode = ruleContext.parentElement;
                    if (parentNode.tagName.toLowerCase() === "label") {
                        var parentClone = parentNode.cloneNode(true);
                        parentClone = legacy_1.RPTUtil.removeAllFormElementsFromLabel(parentClone);
                        passed = legacy_1.RPTUtil.hasInnerContentHidden(parentClone);
                    }
                }
            }
            // check if there is a visible label pointed to by the aria-labelledby attribute.
            if (!passed && legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "aria-labelledby")) {
                var theLabel = ruleContext.getAttribute("aria-labelledby");
                var labelValues = theLabel.split(/\s+/);
                for (var j = 0; j < labelValues.length; ++j) {
                    var elementById = ruleContext.ownerDocument.getElementById(labelValues[j]);
                    if (elementById && legacy_1.RPTUtil.isNodeVisible(elementById) && legacy_1.RPTUtil.hasInnerContentHidden(elementById)) {
                        passed = true;
                        break;
                    }
                }
            }
            if (!passed && nodeName == "optgroup") {
                passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "label");
            }
            if (!passed && nodeName == "option") {
                passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "label") || ruleContext.innerHTML.trim().length > 0;
            }
            // One last check for roles that support name from content
            if (!passed) {
                // list from https://www.w3.org/TR/wai-aria-1.1/#namefromcontent
                var rolesWithNameFromContent = ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "link",
                    "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row",
                    "rowgroup", "rowheader", "switch", "tab", "tooltip", /*"tree",*/ "treeitem"];
                //get attribute roles as well as implicit roles.
                var roles = legacy_1.RPTUtil.getRoles(ruleContext, true);
                for (var i = 0; i < roles.length; i++) {
                    if (rolesWithNameFromContent.indexOf(roles[i]) !== -1) {
                        passed = legacy_1.RPTUtil.hasInnerContentHidden(ruleContext);
                        break;
                    }
                }
            }
            if (passed) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RulePotential("Potential_1");
            }
        }
    }
];
exports.a11yRulesInput = a11yRulesInput;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesStyle = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesStyle = [
    {
        /**
         * Description: Trigger on all pages containing CSS (trigger once)
         * Origin: RPT 5.6
         */
        id: "RPT_Style_Trigger2",
        context: "dom:style, dom:link, dom:*[style]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var nodeName = ruleContext.nodeName.toLowerCase();
            if (nodeName === "link" &&
                (!ruleContext.hasAttribute("rel") || ruleContext.getAttribute("rel").toLowerCase() != "stylesheet"))
                return IEngine_1.RulePass("Pass_0");
            if (nodeName != "style" && nodeName != "link" &&
                ruleContext.hasAttribute("style") && ruleContext.getAttribute("style").trim().length == 0)
                return IEngine_1.RulePass("Pass_0");
            var triggered = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "RPT_Style_Trigger2", false);
            var passed = triggered;
            //        Packages.java.lang.System.out.println(triggered);
            legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "RPT_Style_Trigger2", true);
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RuleManual("Manual_1");
        }
    },
    {
        /**
         * Description: Trigger for use of CSS background images
         * Origin: RPT 5.6 G456
         */
        id: "RPT_Style_BackgroundImage",
        context: "dom:style, dom:*[style]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var nodeName = ruleContext.nodeName.toLowerCase();
            var passed = true;
            if (nodeName == "link" && ruleContext.hasAttribute("rel") &&
                ruleContext.getAttribute("rel").toLowerCase() == "stylesheet") {
                // External stylesheet - trigger
                passed = legacy_1.RPTUtil.triggerOnce(ruleContext, "RPT_Style_BackgroundImage", false);
            }
            if (passed && nodeName == "style" || ruleContext.hasAttribute("style")) {
                var styleText = void 0;
                if (nodeName == "style")
                    styleText = legacy_1.RPTUtil.getInnerText(ruleContext);
                else
                    styleText = ruleContext.getAttribute("style");
                var bgMatches = styleText.match(/background:[^;]*/g);
                if (bgMatches != null) {
                    for (var i = 0; passed && i < bgMatches.length; ++i)
                        passed = bgMatches[i].indexOf("url(") == -1;
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger when color is used, but has no semantic meaning.
         * Origin: RPT 5.6 G466 Error
         */
        id: "RPT_Style_ColorSemantics1",
        context: "dom:style, dom:*[style], dom:font[color], dom:link",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var nodeName = ruleContext.nodeName.toLowerCase();
            var styleText = "";
            if (nodeName == "style") {
                styleText = legacy_1.RPTUtil.getInnerText(ruleContext).toLowerCase();
                // check import
                for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                    var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                    if (sheet && sheet.ownerNode == ruleContext) {
                        try {
                            var styleRules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                            for (var styleRuleIndex = 0; styleRuleIndex < styleRules.length; styleRuleIndex++) {
                                var styleRule = styleRules[styleRuleIndex];
                                var styleImportRule = void 0;
                                if (styleRule.type && styleRule.type === CSSRule.IMPORT_RULE && (styleImportRule = styleRule).styleSheet) {
                                    var importRules = styleImportRule.styleSheet.cssRules ? styleImportRule.styleSheet.cssRules : styleImportRule.styleSheet.rules;
                                    for (var rIndex = 0; rIndex < importRules.length; rIndex++) {
                                        var iRule = importRules[rIndex];
                                        styleText += iRule.cssText;
                                    }
                                }
                            }
                        }
                        catch (e) {
                            // Silence css access issues
                        }
                    }
                }
            }
            else if (ruleContext.hasAttribute("style")) {
                styleText = ruleContext.getAttribute("style").toLowerCase();
            }
            else if (nodeName == "link" && //check external styles
                ruleContext.hasAttribute("rel") &&
                ruleContext.getAttribute("rel").toLowerCase() == "stylesheet" &&
                ruleContext.hasAttribute("href") &&
                ruleContext.getAttribute("href").trim().length !== 0) {
                for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                    var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                    if (sheet && sheet.ownerNode === ruleContext) {
                        try {
                            var rules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                            for (var rIndex = 0; rIndex < rules.length; rIndex++) {
                                styleText += rules[rIndex].cssText;
                            }
                        }
                        catch (e) {
                            // Silence css access issues
                        }
                    }
                }
            }
            var passed = true;
            // Defect 1022: Find uses of 'color' and '*background*' only
            var isBgUsed = styleText.match(/\bbackground\b/i);
            var theColorStyleToCheck = styleText.replace(/-color/g, "");
            var isColorUsed = theColorStyleToCheck.match(/\bcolor\b/i);
            if (ruleContext.hasAttribute("color") || isColorUsed || isBgUsed) {
                var goodTagNames = {
                    "em": "", "strong": "", "cite": "", "dfn": "",
                    "code": "", "samp": "", "kbd": "", "var": "", "abbr": "", "acronym": ""
                };
                // Color used � are there semantics involved?
                passed = nodeName in goodTagNames ||
                    legacy_1.RPTUtil.getAncestor(ruleContext, goodTagNames) != null;
                if (!passed && ruleContext.hasChildNodes()) {
                    var nw = new legacy_1.NodeWalker(ruleContext);
                    while (!passed && nw.nextNode() && nw.node != ruleContext) {
                        passed = nw.node.nodeName.toLowerCase() in goodTagNames;
                    }
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger when color is used, but has no semantic meaning.
         * Origin: Various
         */
        id: "RPT_Style_ExternalStyleSheet",
        context: "dom:link[rel], dom:style",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            var nodeName = ruleContext.nodeName.toLowerCase();
            if (nodeName == "style") {
                passed = legacy_1.RPTUtil.getInnerText(ruleContext).indexOf("@import url") == -1;
            }
            else if (nodeName == "link") {
                passed = !ruleContext.hasAttribute("rel") ||
                    ruleContext.getAttribute("rel").toLowerCase() != "stylesheet";
            }
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger on CSS that affects the focus box
         * Origin: RPT 5.6 G506 Error
         */
        id: "RPT_Style_HinderFocus1",
        context: "dom:style, dom:*[style]",
        run: function (context, options) {
            var validateParams = {
                skipNodes: {
                    value: ["table"],
                    type: "[string]"
                },
                regex1: {
                    value: /(^|})([^{]*){[^}]*(outline|border)[ \t]*\:/gi,
                    type: "regex"
                },
                regex2: {
                    value: /([a-z]+)[ \t]*(,|$)/gi,
                    type: "regex"
                }
            };
            var ruleContext = context["dom"].node;
            var skipNodes = validateParams.skipNodes.value;
            var passed = true;
            // Note: link to be handled by RPT_Style_ExternalStyleSheet
            var nodeName = ruleContext.nodeName.toLowerCase();
            if (nodeName == "style") {
                var textValue = legacy_1.RPTUtil.getInnerText(ruleContext);
                var r = validateParams.regex1.value;
                r.lastIndex = 0;
                var m = void 0;
                var m2 = void 0;
                while (passed && (m = r.exec(textValue)) != null) {
                    var selector = m[2];
                    var r2 = validateParams.regex2.value;
                    r2.lastIndex = 0;
                    while (passed && (m2 = r2.exec(selector)) != null) {
                        passed = skipNodes.includes(m2[1].trim().toLowerCase());
                    }
                }
            }
            else if (!ruleContext.hasAttribute("disabled") ||
                ruleContext.getAttribute("disabled").toLowerCase() == "false") {
                var textValue = ruleContext.getAttribute('style');
                passed = skipNodes.includes(nodeName) ||
                    !(/(outline|border)[ \t]*\:/.test(textValue));
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger if :before and :after are used in CSS (Internal and External) with content
         * Origin: WCAG 2.0 F87
         */
        id: "WCAG20_Style_BeforeAfter",
        context: "dom:style, dom:link",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            //check Internal styles        
            if (ruleContext.nodeName.toLowerCase() == "style") {
                var css = legacy_1.RPTUtil.CSS(ruleContext);
                for (var i = 0; passed && i < css.length; ++i) {
                    // Guard against bad CSS
                    if (css[i].selector) {
                        passed = (css[i].selector.indexOf(":before") == -1 && css[i].selector.indexOf(":after") == -1) ||
                            !("content" in css[i].values) || css[i].values["content"].trim().length == 0 || css[i].values["content"].trim() == "\"\""
                            || css[i].values["content"].trim() == "\'\'" || css[i].values["content"].trim() == "none" || css[i].values["content"].trim() == "attr(x)"
                            || css[i].values["content"].trim() == "attr(y)";
                    }
                }
                // check special rules in the stylesheets
                if (passed) {
                    for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                        var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                        if (sheet.ownerNode === ruleContext) {
                            try {
                                var styleRules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                                if (styleRules) {
                                    for (var styleRuleIndex = 0; passed && styleRuleIndex < styleRules.length; styleRuleIndex++) {
                                        var styleRule = styleRules[styleRuleIndex];
                                        // check @media rules 
                                        //
                                        // The check 'if (styleRule instanceof CSSMediaRule)' doesn't work when run in Karma(but works in DAP) 
                                        // so let's access the type directly as a workaround
                                        var styleMediaRule = void 0;
                                        var styleImportRule = void 0;
                                        if (styleRule.type && styleRule.type === CSSRule.MEDIA_RULE) {
                                            var styleMediaRule_1 = styleRule;
                                            var mediaRules = styleMediaRule_1.cssRules;
                                            if (mediaRules) {
                                                for (var rIndex = 0; passed && rIndex < mediaRules.length; rIndex++) {
                                                    var mRule = mediaRules[rIndex]; // selectorText not recognized
                                                    if (mRule.selectorText !== null && mRule.selectorText !== undefined) {
                                                        var rule = mRule.selectorText.toLowerCase();
                                                        if (rule.indexOf(":before") !== -1 || rule.indexOf(":after") !== -1) {
                                                            var content = mRule.style['content'];
                                                            if (content && content.trim().length) {
                                                                if (content.trim() !== "\"\"" &&
                                                                    content.trim() !== "\'\'" &&
                                                                    content.trim() !== "none" &&
                                                                    content.trim() !== "attr(x)" &&
                                                                    content.trim() !== "attr(y)") {
                                                                    passed = false;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        // check import rules
                                        else if (styleRule.type && styleRule.type === CSSRule.IMPORT_RULE && (styleImportRule = styleRule).styleSheet) {
                                            var rules = styleImportRule.styleSheet.cssRules ?
                                                styleImportRule.styleSheet.cssRules :
                                                styleImportRule.styleSheet.rules;
                                            if (rules) {
                                                for (var rIndex = 0; passed && rIndex < rules.length; rIndex++) {
                                                    var importedRule = rules[rIndex];
                                                    // check @media rules 
                                                    if (importedRule.type && importedRule.type === CSSRule.MEDIA_RULE) {
                                                        var mediaRules = importedRule.cssRules;
                                                        if (mediaRules) {
                                                            for (var mIndex = 0; mIndex < mediaRules.length; mIndex++) {
                                                                var mRule = mediaRules[mIndex]; // selectorText not recognized
                                                                if (mRule.selectorText !== null && mRule.selectorText !== undefined) {
                                                                    var rule = mRule.selectorText.toLowerCase();
                                                                    if (rule.indexOf(":before") !== -1 || rule.indexOf(":after") !== -1) {
                                                                        var content = mRule.style['content'];
                                                                        if (content && content.trim().length) {
                                                                            if (content.trim() !== "\"\"" &&
                                                                                content.trim() !== "\'\'" &&
                                                                                content.trim() !== "none" &&
                                                                                content.trim() !== "attr(x)" &&
                                                                                content.trim() !== "attr(y)") {
                                                                                passed = false;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else if (importedRule.selectorText !== null && importedRule.selectorText !== undefined) {
                                                        var rule = importedRule.selectorText.toLowerCase();
                                                        //support both single colon (:) and double colon (::) pseudo                        
                                                        if (rule.indexOf(":before") !== -1 || rule.indexOf(":after") !== -1) {
                                                            var content = importedRule.style['content'];
                                                            if (content && content.trim().length) {
                                                                if (content.trim() !== "\"\"" &&
                                                                    content.trim() !== "\'\'" &&
                                                                    content.trim() !== "none" &&
                                                                    content.trim() !== "attr(x)" &&
                                                                    content.trim() !== "attr(y)") {
                                                                    passed = false;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            catch (e) {
                                // Ignore css access issues
                            }
                        }
                    }
                }
            }
            //check external styles 
            if (ruleContext.nodeName.toLowerCase() == "link" && ruleContext.hasAttribute("rel") &&
                ruleContext.getAttribute("rel").toLowerCase() == "stylesheet" &&
                ruleContext.hasAttribute("href") && ruleContext.getAttribute("href").trim().length !== 0) {
                for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                    var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                    if (sheet && sheet.ownerNode === ruleContext) {
                        try {
                            var rules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                            if (rules) {
                                for (var rIndex = 0; passed && rIndex < rules.length; rIndex++) {
                                    var ruleFromLink = rules[rIndex];
                                    // check @media rules 
                                    if (ruleFromLink.type && ruleFromLink.type === CSSRule.MEDIA_RULE) {
                                        var mediaRules = ruleFromLink.cssRules;
                                        if (mediaRules) {
                                            for (var mIndex = 0; passed && mIndex < mediaRules.length; mIndex++) {
                                                var mRule = mediaRules[mIndex];
                                                if (mRule.selectorText !== null && mRule.selectorText !== undefined) {
                                                    var ruleSelTxt = mRule.selectorText.toLowerCase();
                                                    if (ruleSelTxt.indexOf(":before") !== -1 || ruleSelTxt.indexOf(":after") !== -1) {
                                                        var content = mRule.style['content'];
                                                        if (content && content.trim().length) {
                                                            if (content.trim() !== "\"\"" &&
                                                                content.trim() !== "\'\'" &&
                                                                content.trim() !== "none" &&
                                                                content.trim() !== "attr(x)" &&
                                                                content.trim() !== "attr(y)") {
                                                                passed = false;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else if (rules[rIndex].selectorText !== null && rules[rIndex].selectorText !== undefined) {
                                        var rule = rules[rIndex].selectorText.toLowerCase();
                                        //support both single colon (:) and double colon (::) pseudo                        
                                        if (rule.indexOf(":before") !== -1 || rule.indexOf(":after") !== -1) {
                                            var content = rules[rIndex].style['content'];
                                            if (content && content.trim().length) {
                                                if (content.trim() !== "\"\"" &&
                                                    content.trim() !== "\'\'" &&
                                                    content.trim() !== "none" &&
                                                    content.trim() !== "attr(x)" &&
                                                    content.trim() !== "attr(y)") {
                                                    passed = false;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        catch (e) {
                            // Ignore css access issues
                        }
                    }
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger when viewport units are used for font size.
         * Origin: Various
         */
        id: "WCAG21_Style_Viewport",
        context: "dom:link, dom:style, dom:*[style]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            var thePattern = /\d+(vw|vh|vmin|vmax)/gi;
            var nodeName = ruleContext.nodeName.toLowerCase();
            if (nodeName == "style") {
                for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                    var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                    if (sheet.ownerNode === ruleContext) {
                        try {
                            var styleRules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                            if (styleRules) {
                                for (var styleRuleIndex = 0; passed && styleRuleIndex < styleRules.length; styleRuleIndex++) {
                                    var rule = styleRules[styleRuleIndex];
                                    if (rule.type && rule.type === CSSRule.STYLE_RULE) {
                                        var styleRule = rule;
                                        if (styleRule.style['fontSize']) {
                                            var fontSize = styleRule.style['fontSize'].trim();
                                            var found = fontSize.match(thePattern);
                                            if (fontSize.length && found) {
                                                passed = false;
                                            }
                                        }
                                    }
                                    // check import rules
                                    else if (rule.type && rule.type === CSSRule.IMPORT_RULE && rule.styleSheet) {
                                        var importRule = rule;
                                        var rules = importRule.styleSheet.cssRules ? importRule.styleSheet.cssRules : importRule.styleSheet.rules;
                                        if (rules) {
                                            for (var rIndex = 0; passed && rIndex < rules.length; rIndex++) {
                                                var importedRule = rules[rIndex];
                                                if (importedRule.type && importedRule.type === CSSRule.STYLE_RULE) {
                                                    if (importedRule.style['fontSize']) {
                                                        var fontSize = importedRule.style['fontSize'].trim();
                                                        var found = fontSize.match(thePattern);
                                                        if (fontSize.length && found) {
                                                            passed = false;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        catch (e) {
                            // Ignore css access issues
                        }
                    }
                }
            }
            else if (nodeName == "link") {
                for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                    var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                    if (sheet && sheet.ownerNode === ruleContext) {
                        try {
                            var rules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                            if (rules) {
                                for (var rIndex = 0; passed && rIndex < rules.length; rIndex++) {
                                    var ruleFromLink = rules[rIndex];
                                    // check rules 
                                    if (ruleFromLink.type && ruleFromLink.type === CSSRule.STYLE_RULE) {
                                        if (ruleFromLink.style['fontSize']) {
                                            var fontSize = ruleFromLink.style['fontSize'].trim();
                                            var found = fontSize.match(thePattern);
                                            if (fontSize.length && found) {
                                                passed = false;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        catch (e) {
                            // Ignore css access issues
                        }
                    }
                }
            }
            else {
                var styleValue = ruleContext.getAttribute('style');
                if (styleValue) {
                    var stylePattern = /font-size:\s*\d+(vw|vh|vmin|vmax)/gi;
                    var found = styleValue.match(stylePattern);
                    if (found) {
                        passed = false;
                    }
                }
            }
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesStyle = a11yRulesStyle;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesLabeling = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var ARIADefinitions_1 = __webpack_require__(2);
var a11yRulesLabeling = [
    {
        /**
         * Description: Triggers if a region role is not labeled with an aria-label or aria-labelledby
         * also, check <section> element as this element has 'region' as implicit role
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_RegionLabel_Implicit",
        context: "dom:*[role], dom:section",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var tagName = ruleContext.tagName.toLowerCase();
            if (tagName === "section" && !legacy_1.RPTUtil.hasRole(ruleContext, "region", false)) {
                return null;
            }
            if (tagName !== "section" && !legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "region")) {
                return null;
            }
            var passed = legacy_1.RPTUtil.hasAriaLabel(ruleContext);
            if (passed) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail(tagName === "section" ? "Fail_1" : "Fail_2");
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple main landmarks are present and they don't have unique labels
         * Also, conside elements with implicit roles such as <main> element
         * Origin:  CI162 Web checklist checkpoint 2.4a  Rule 1182
         */
        id: "Rpt_Aria_MultipleMainsRequireLabel_Implicit_2",
        context: "aria:main",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var parentDocRole = legacy_1.RPTUtil.getAncestorWithRole(ruleContext, "document", true);
            var mains = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "main", true, true);
            var result = null;
            for (var i = 0; i < mains.length; ++i) {
                if (mains[i] === ruleContext)
                    continue;
                result = IEngine_1.RulePass("Pass_0");
                var thisParentDocRole = legacy_1.RPTUtil.getAncestorWithRole(mains[i], "document", true);
                if (thisParentDocRole == parentDocRole) {
                    result = IEngine_1.RuleFail("Fail_1");
                    break;
                }
            }
            return result;
        }
    },
    {
        /**
         * Description: Triggers if multiple main landmarks are present and
         * they don't have unique, visible labels.
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleMainsVisibleLabel_Implicit",
        context: "dom:body",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Consider the Check Hidden Content setting that is set by the rules
            //call getElementsByRoleHidden with considerImplicit flag as true 
            //so that the method returs <main> elements 
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "main", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var passed = legacy_1.RPTUtil.hasUniqueAriaLabelledby(landmarks);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple banner landmarks are present and they don't have unique labels
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleBannerLandmarks_Implicit",
        context: "aria:banner",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Consider the Check Hidden Content setting that is set by the rules
            // Also, consider Implicit role checking. 
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "banner", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var dupes = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleBannerLandmarks_Implicit", null);
            if (!dupes) {
                dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleBannerLandmarks_Implicit", dupes);
            }
            var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
            //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_0", [myLabel]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if there are multiple banner landmarks in a set of siblings
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_OneBannerInSiblingSet_Implicit",
        context: "dom:*[role], dom:header",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            if (!legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "banner")) {
                return null;
            }
            var passed = legacy_1.RPTUtil.getSiblingWithRoleHidden(ruleContext, "banner", true, true) == null;
            //return new ValidationResult(passed, [ruleContext], 'role', '', []);
            if (passed) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail("Fail_1");
            }
        }
    },
    {
        /**
        * Description: Triggers if a complementary role is not labeled with an aria-label or aria-labelledby
         * also, consider <aside> as this element has implicit 'complementary' role.
         * Origin:  CI162 Web checklist checkpoint 2.4a
        */
        id: "Rpt_Aria_ComplementaryRequiredLabel_Implicit",
        context: "dom:*[role], dom:aside",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            if (!legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "complementary")) {
                return null;
            }
            var passed = legacy_1.RPTUtil.hasAriaLabel(ruleContext);
            //return new ValidationResult(passed, [ruleContext], 'role', '', []);
            if (passed) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail("Fail_1");
            }
        }
    },
    {
        /**
         * Description: Triggers if a complementary role is not labeled with an aria-labelledby
         * Origin:  CI162 Web checklist checkpoint 2.4a
         * Note this is a recommendation. Rpt_Aria_ComplementaryRequiredLabel is required.
         */
        id: "Rpt_Aria_ComplementaryLandmarkLabel_Implicit",
        context: "dom:*[role], dom:aside",
        dependencies: ["Rpt_Aria_ComplementaryRequiredLabel_Implicit"],
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            if (!legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "complementary")) {
                return null;
            }
            var passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "aria-labelledby");
            //return new ValidationResult(passed, [ruleContext], 'role', '', []);
            if (passed) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail("Fail_1");
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple complementary landmarks are present and
         * they don't have unique labels.
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleComplementaryLandmarks_Implicit",
        context: "aria:complementary",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Consider the Check Hidden Content setting that is set by the rules
            // Also, consider Implicit role checking. 
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "complementary", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var dupes = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleComplementaryLandmarks_Implicit", null);
            if (!dupes) {
                dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleComplementaryLandmarks_Implicit", dupes);
            }
            var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
            //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [myLabel]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple contentinfo landmarks are present and they don't have unique labels
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleContentinfoLandmarks_Implicit",
        context: "aria:contentinfo",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Consider the Check Hidden Content setting that is set by the rules
            // Also, consider Implicit role checking. 
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "contentinfo", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var dupes = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleContentinfoLandmarks_Implicit", null);
            if (!dupes) {
                dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleContentinfoLandmarks_Implicit", dupes);
            }
            var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
            //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [myLabel]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if there is more than one contentinfo nodes in a set of siblings.
         * Also, consider <footer> element which has implicit role
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit",
        context: "dom:*[role], dom:footer, dom:address",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            //find out if <footer> element has siblings as <footer> has implicit contentinfo role
            if (!legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "contentinfo")) {
                return null;
            }
            var passed = !legacy_1.RPTUtil.getSiblingWithRoleHidden(ruleContext, "contentinfo", true, true);
            //return new ValidationResult(passed, [ruleContext], 'role', '', []);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if a contentinfo role is present, but no main role is present.
         * Also, consider implict roles for <main>, <footer> and <address> elements as these elements
         * have implicit contentinfo roles.
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_ContentinfoWithNoMain_Implicit",
        context: "dom:*[role], dom:footer, dom:address",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            //consider implicit role
            if (!legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "contentinfo")) {
                return null;
            }
            // Consider the Check Hidden Content setting that is set by the rules
            var passed = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "main", true, true).length > 0;
            //return new ValidationResult(passed, [ruleContext], 'role', '', []);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple form landmarks are present and they don't have unique labels
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleFormLandmarks",
        context: "dom:body",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Consider the Check Hidden Content setting that is set by the rules
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "form", true, true);
            if (landmarks.length === 0) {
                return null;
            }
            var passed = legacy_1.RPTUtil.hasUniqueAriaLabelsLocally(landmarks, false);
            //return new ValidationResult(passed, landmarks, '', '', []);
            if (!passed) {
                return IEngine_1.RuleFail(2);
            }
            else {
                return IEngine_1.RulePass(1);
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple form landmarks are present and they don't have unique labels
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleFormLandmarks_Implicit",
        context: "aria:form",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Per https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/landmarks/HTML5.html
            // form element should only be considered if it has an aria label or title
            if (ruleContext.getAttribute("role") === "form"
                || ruleContext.hasAttribute("aria-label")
                || ruleContext.hasAttribute("aria-labelledby")
                || ruleContext.hasAttribute("title")) {
                // Consider the Check Hidden Content setting that is set by the rules
                // Also, consider Implicit role checking. 
                var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "form", true, true);
                if (landmarks.length === 0 || landmarks.length === 1) {
                    return null;
                }
                var dupes = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleFormLandmarks_Implicit", null);
                if (!dupes) {
                    dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                    legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleFormLandmarks_Implicit", dupes);
                }
                var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
                var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
                if (!passed) {
                    return IEngine_1.RuleFail("Fail_1", [myLabel]);
                }
                else {
                    return IEngine_1.RulePass("Pass_0");
                }
            }
            else {
                return null;
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple navigation landmarks are present and they don't have unique labels
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleNavigationLandmarks_Implicit",
        context: "aria:navigation",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Consider the Check Hidden Content setting that is set by the rules
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "navigation", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var dupes = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleNavigationLandmarks_Implicit", null);
            if (!dupes) {
                dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleNavigationLandmarks_Implicit", dupes);
            }
            var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
            //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [myLabel]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple search landmarks are present and they don't have unique labels
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleSearchLandmarks",
        context: "aria:search",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Consider the Check Hidden Content setting that is set by the rules
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "search", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var dupes = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleSearchLandmarks", null);
            if (!dupes) {
                dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleSearchLandmarks", dupes);
            }
            var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
            // return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [myLabel]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * <cp> Description: Triggers if multiple region role are present and they don't have unique labels
         * Also, consider  <section> element as this element has implicit 'region' role
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleRegionsUniqueLabel_Implicit",
        context: "aria:region",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Per https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/landmarks/HTML5.html
            // form element should only be considered if it has an aria label or title
            if (ruleContext.getAttribute("role") === "region"
                || ruleContext.hasAttribute("aria-label")
                || ruleContext.hasAttribute("aria-labelledby")
                || ruleContext.hasAttribute("title")) {
                // Consider the Check Hidden Content setting that is set by the rules
                // Also, consider Implicit role checking. 
                var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "region", true, true);
                if (landmarks.length === 0 || landmarks.length === 1) {
                    return null;
                }
                var dupes = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleRegionsUniqueLabel_Implicit", null);
                if (!dupes) {
                    dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                    legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleRegionsUniqueLabel_Implicit", dupes);
                }
                var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
                var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
                if (!passed) {
                    return IEngine_1.RuleFail("Fail_1", [myLabel]);
                }
                else {
                    return IEngine_1.RulePass("Pass_0");
                }
            }
            else {
                return null;
            }
        }
    },
    {
        /**
         * Description: Triggers if an application role is not labeled with an aria-labelledby or aria-label
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_ApplicationLandmarkLabel",
        context: "aria:application",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = legacy_1.RPTUtil.hasAriaLabel(ruleContext);
            // return new ValidationResult(passed, [ruleContext], 'role', '', []);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple application landmarks are present and they don't have unique labels
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleApplicationLandmarks",
        context: "aria:application",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Consider the Check Hidden Content setting that is set by the rules
            // Also, consider Implicit role checking. 
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "application", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var dupes = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleApplicationLandmarks", null);
            if (!dupes) {
                dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleApplicationLandmarks", dupes);
            }
            var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
            //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [myLabel]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple document roles are present and they don't have unique labels
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleDocumentRoles",
        context: "aria:document",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Consider the Check Hidden Content setting that is set by the rules
            // Also, consider Implicit role checking. 
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "document", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var dupes = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleDocumentRoles", null);
            if (!dupes) {
                dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleDocumentRoles", dupes);
            }
            var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            var passed = myLabel === "" || (!(myLabel in dupes) || dupes[myLabel] <= 1);
            // return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]); 
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [myLabel]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if an article role is not labeled with an aria-labelledby or aria-label
         * consider <article> element with implicit role article
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_ArticleRoleLabel_Implicit",
        context: "aria:article",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = legacy_1.RPTUtil.hasAriaLabel(ruleContext);
            // return new ValidationResult(passed, [ruleContext], 'role', '', []);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple article roles are present and they don't have unique labels
         * Also, consider <article> element with implicit article role.
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleArticleRoles_Implicit",
        context: "aria:article",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Consider the Check Hidden Content setting that is set by the rules
            // Also, consider Implicit role checking. 
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "article", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var dupes = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleArticleRoles_Implicit", null);
            if (!dupes) {
                dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleArticleRoles_Implicit", dupes);
            }
            var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            var passed = myLabel === "" || !(myLabel in dupes) || dupes[myLabel] <= 1;
            //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]); 
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [myLabel]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if a group role is not labeled with an aria-labelledby or aria-label
         * Also, consider <details> element which has implicit article role.
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_GroupRoleLabel_Implicit",
        context: "dom:*[role], dom:details",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var roleName = "group";
            if (!legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, roleName)) {
                return null;
            }
            var passed = legacy_1.RPTUtil.hasAriaLabel(ruleContext);
            if (!passed) {
                passed = legacy_1.RPTUtil.getAncestorWithRole(ruleContext, "menubar") ||
                    legacy_1.RPTUtil.getAncestorWithRole(ruleContext, "menu") ||
                    legacy_1.RPTUtil.getAncestorWithRole(ruleContext, "tree");
                if (passed) {
                    // Rule does not apply in a menubar/menu/tree
                    return null;
                }
            }
            var retToken1 = new Array();
            retToken1.push(ruleContext.nodeName.toLowerCase());
            var retToken2 = new Array();
            retToken2.push(roleName);
            //return new ValidationResult(passed, [ruleContext], 'role', '', passed == true ? [] : [retToken1, retToken2]);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [retToken1.toString(), retToken2.toString()]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple group roles are present and they don't have unique labels
         * Also, consider <details> element which has implicit 'group' role
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_MultipleGroupRoles_Implicit",
        context: "aria:group",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Consider the Check Hidden Content setting that is set by the rules
            // Also, consider Implicit role checking. 
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "group", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var dupes = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleGroupRoles_Implicit", null);
            if (!dupes) {
                dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleGroupRoles_Implicit", dupes);
            }
            var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            var passed = myLabel === "" || !(myLabel in dupes) || dupes[myLabel] <= 1;
            //return new ValidationResult(passed, ruleContext, '', '', [ myLabel ]);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [myLabel]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if a WAI-ARIA widget does not have an accessible name via an ARIA label or inner text
         * Also, consider widgets with implicit roles.
         * Origin:  CI162 Web checklist checkpoint 2.4a
         */
        id: "Rpt_Aria_WidgetLabels_Implicit",
        context: "dom:*",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            /* removed the role check role= presentation and role=none since these 2 roles are not in the list of widget type roles */
            if ((ruleContext.hasAttribute("type") && ruleContext.getAttribute("type") == "hidden")
                || (legacy_1.RPTUtil.getAncestorWithRole(ruleContext, "combobox") &&
                    !(legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "textbox") ||
                        legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, "searchbox")))) { // we need to diagnose that a combobox input textbox has a label(github issue #1104) 
                return null;
            }
            // Form/input elements are checked by G41, we skip them from this rule. Github issue 449
            var skipElements = ["input", "textarea", "select", "button", "datalist", "optgroup", "option", "keygen", "output", "progress", "meter"];
            if (skipElements.indexOf(ruleContext.nodeName.toLowerCase()) != -1) {
                return null;
            }
            // exclude <link>, <area> and <a>(#775) that has href.
            if ((ruleContext.nodeName.toLowerCase() === "link" ||
                ruleContext.nodeName.toLowerCase() === "a" ||
                ruleContext.nodeName.toLowerCase() === "area") && ruleContext.hasAttribute("href")) {
                return null;
            }
            // avoid diagnosing the popup list of a combobox.
            var rolesToCheck = ["listbox", "tree", "grid", "dialog"];
            for (var j = 0; j < rolesToCheck.length; j++) {
                if (legacy_1.RPTUtil.hasRoleInSemantics(ruleContext, rolesToCheck[j])) {
                    var comboboxes = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "combobox", true, true);
                    for (var k = 0; k < comboboxes.length; k++) {
                        var combobox = comboboxes[k];
                        var aria_owns = legacy_1.RPTUtil.getElementAttribute(combobox, "aria-owns");
                        if (aria_owns) {
                            var owns = legacy_1.RPTUtil.normalizeSpacing(aria_owns.trim()).split(" ");
                            for (var i = 0; i < owns.length; i++) {
                                var owned = ruleContext.ownerDocument.getElementById(owns[i]);
                                if (owned === ruleContext) {
                                    return null;
                                }
                            }
                        }
                    }
                }
            }
            var passed = true;
            var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
            //get attribute roles as well as implicit roles.
            var roles = legacy_1.RPTUtil.getRoles(ruleContext, true);
            var numWidgetsTested = 0;
            for (var i = 0, length_1 = roles.length; passed && i < length_1; ++i) {
                var pattern = designPatterns[roles[i]];
                if (pattern && pattern.nameRequired && pattern.roleType && pattern.roleType == "widget") {
                    ++numWidgetsTested;
                    // All widgets may have an author supplied accessible name.
                    // Title is legal, but don't advertise its use in documentation.
                    // Encourage use of aria-label, aria-labelledby or html label element.
                    passed = legacy_1.RPTUtil.hasAriaLabel(ruleContext) || legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "title") || legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true);
                    if (!passed && pattern.nameFrom && pattern.nameFrom.indexOf("contents") >= 0) {
                        // See if widget's accessible name is supplied by element's inner text
                        // nameFrom: ["author", "content"]
                        passed = legacy_1.RPTUtil.hasInnerContentOrAlt(ruleContext);
                    }
                    if (!passed) { // check if it has implicit label, like <label><input ....>abc </label>
                        passed = legacy_1.RPTUtil.hasImplicitLabel(ruleContext);
                    }
                }
            }
            //return new ValidationResult(passed, [ruleContext], '', '', []);
            if (numWidgetsTested === 0) {
                return null;
            }
            else if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if multiple toolbars are present and they don't have unique labels
         * Origin:  WAI-ARIA
         * 			https://www.w3.org/TR/wai-aria-1.1/#toolbar
         */
        id: "Rpt_Aria_MultipleToolbarUniqueLabel",
        context: "aria:toolbar",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Consider the Check Hidden Content setting that is set by the rules
            // Also, consider Implicit role checking. 
            var landmarks = legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "toolbar", true, true);
            if (landmarks.length === 0 || landmarks.length === 1) {
                return null;
            }
            var dupes = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleToolbarUniqueLabel", null);
            if (!dupes) {
                dupes = legacy_1.RPTUtil.findAriaLabelDupes(landmarks);
                legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "Rpt_Aria_MultipleToolbarUniqueLabel", dupes);
            }
            var myLabel = legacy_1.RPTUtil.getAriaLabel(ruleContext);
            var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", [myLabel]);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    }
];
exports.a11yRulesLabeling = a11yRulesLabeling;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesFig = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesFig = [
    {
        /**
         * Description: Triggers if the figure doesn't have a <figcaption> and doesn't have a valid aria-labelledby
         * Origin:  HTML 5 - per Richard Schwerdtfeger's requirements. g1144
         */
        id: "HAAC_Figure_label",
        context: "dom:figure",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // JCH - NO OUT OF SCOPE hidden in context
            var passed = false;
            var figures = ruleContext.getElementsByTagName("figcaption");
            // Loop over all the figcaption elements to make sure there is at least one that is not empty and not hidden.
            for (var i = 0; !passed && i < figures.length; ++i) {
                // Mark this rule as passed if any one of the figurecaption element has content and is visible
                if (figures[i].innerHTML.trim().length > 0 && legacy_1.RPTUtil.isNodeVisible(figures[i])) {
                    passed = true;
                }
            }
            if (!passed) {
                // we only check if the "aria-labelledby" is there. There is a different rule to check if the id is valid.
                passed = ruleContext.hasAttribute("aria-labelledby") && ruleContext.getAttribute("aria-labelledby").trim().length > 0;
            }
            //return new ValidationResult(passed, [ruleContext], '', '', []);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", []);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    }
];
exports.a11yRulesFig = a11yRulesFig;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesLabel = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesLabel = [
    {
        /**
         * Description: Raise if more than one <label> found with the same for value.
         * Origin: RPT 5.6
         */
        id: "RPT_Label_UniqueFor",
        context: "dom:label[for]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // JCH - NO OUT OF SCOPE hidden in context
            var labelIds = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "RPT_Label_Single", {});
            var id = ruleContext.getAttribute("for");
            var passed = !(id in labelIds);
            labelIds[id] = true;
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Trigger label has no content
         * Origin: RPT 5.6
         */
        id: "Valerie_Label_HasContent",
        context: "dom:label",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            if (legacy_1.RPTUtil.hasInnerContentHidden(ruleContext)) {
                return IEngine_1.RulePass("Pass_Regular");
            }
            else if ((ruleContext.getAttribute("aria-label") || "").trim().length > 0) {
                return IEngine_1.RulePass("Pass_AriaLabel");
            }
            else if (ruleContext.hasAttribute("aria-labelledby")) {
                var labelElem = ruleContext.ownerDocument.getElementById(ruleContext.getAttribute('aria-labelledby'));
                if (labelElem && legacy_1.RPTUtil.hasInnerContent(labelElem)) {
                    return IEngine_1.RulePass("Pass_LabelledBy");
                }
            }
            return IEngine_1.RuleFail("Fail_1");
        }
    },
    {
        /**
         * Description: Trigger if label for points to an invalid id
         * Origin: WCAG 2.0 Technique F17
         */
        id: "WCAG20_Label_RefValid",
        context: "dom:label[for]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var id = ruleContext.getAttribute("for");
            var doc = ruleContext.ownerDocument;
            var passed = false;
            var target = doc.getElementById(id);
            if (target) {
                passed = true;
                // handles null and undefined
                if (!target.hasAttribute("role")) {
                    // Fail if we're pointing at something that is labelled by another mechanism
                    var nodeName = target.nodeName.toLowerCase();
                    passed = nodeName == "input" || nodeName == "select" || nodeName == "textarea"
                        || nodeName == "button" || nodeName == "datalist"
                        || nodeName == "optgroup" || nodeName == "option"
                        || nodeName == "keygen" || nodeName == "output"
                        || nodeName == "progress" || nodeName == "meter"
                        || nodeName == "fieldset" || nodeName == "legend";
                    if (target.nodeName.toLowerCase() == "input" && target.hasAttribute("type")) {
                        var type = target.getAttribute("type").toLowerCase();
                        passed = type == "text" || type == "password" || type == "file" ||
                            type == "checkbox" || type == "radio" ||
                            type == "hidden" || type == "search" || type == "tel" || type == "url" || type == "email" || //HTML 5
                            type == "date" || type == "number" || type == "range" || type == "image" || //HTML 5
                            type == "time" || type == "color" || // HTML 5
                            type == "datetime" || type == "month" || type == "week"; //HTML5.1
                    }
                }
                // Add one more check to make sure the target element is NOT hidden, in the case the target is hidden
                // flag a violation regardless of what the Check Hidden Content setting is.
                if (passed && !legacy_1.RPTUtil.isNodeVisible(target)) {
                    passed = false;
                }
            }
            var retToken = [];
            if (!passed) {
                retToken.push(id);
            }
            //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [retToken]);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1", retToken);
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Trigger if label "for" points to an hidden element.
         * Note: RPT doesn't support querying style information,
         * so this rule only addresses type="hidden" elements.
         * Origin: WCAG 2.0 Technique F68
         */
        id: "WCAG20_Label_TargetInvisible",
        context: "dom:label[for]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            var id = ruleContext.getAttribute("for");
            var target = ruleContext.ownerDocument.getElementById(id);
            if (target) {
                passed = legacy_1.RPTUtil.getElementAttribute(target, "type") != "hidden";
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Flag a violation if Accessible name does not match or contain the visible label text.
         * Origin: WCAG 2.1 Success Criterion 2.5.3: Label in Name
         */
        id: "WCAG21_Label_Accessible",
        context: "aria:button,aria:checkbox,aria:gridcell,aria:link,aria:menuitem,aria:menuitemcheckbox"
            + ",aria:menuitemradio,aria:option,aria:radio,aria:switch,aria:tab,aria:treeitem"
            + ",dom:input,dom:textarea,dom:select,dom:output,dom:meter",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            if (!legacy_1.RPTUtil.isNodeVisible(ruleContext) ||
                legacy_1.RPTUtil.isNodeDisabled(ruleContext)) {
                return null;
            }
            var passed = true;
            var nodeName = ruleContext.nodeName.toLowerCase();
            var isInputButton = false;
            var buttonTypes = ["button", "reset", "submit" /*, "image"*/];
            var inputType = null;
            if (nodeName === "input" && ruleContext.hasAttribute("type")) {
                inputType = ruleContext.getAttribute("type").toLowerCase();
                if (buttonTypes.indexOf(inputType) !== -1) {
                    isInputButton = true;
                }
            }
            var theLabelBy = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-labelledby");
            if (theLabelBy && !isInputButton) {
                // skip the checks if it has an aria-labelledby since it takes precedence.
            }
            else {
                var theLabel = null;
                if (theLabelBy) {
                    var labelValues = theLabelBy.split(/\s+/);
                    for (var j = 0; j < labelValues.length; ++j) {
                        var elementById = ruleContext.ownerDocument.getElementById(labelValues[j]);
                        if (elementById) {
                            theLabel = legacy_1.RPTUtil.getInnerText(elementById);
                            break;
                        }
                    }
                }
                else {
                    theLabel = legacy_1.RPTUtil.getAriaAttribute(ruleContext, "aria-label");
                }
                if (!theLabel) {
                    return null;
                }
                var text = null;
                if (isInputButton) {
                    /* Note: Disable the alt check in images until we get confirmation
                    if (inputType==="image" && ruleContext.hasAttribute("alt")){
                        // use 'alt' attribute as visible text
                        text = ruleContext.getAttribute("alt");
                    }else
                    */
                    if (ruleContext.hasAttribute("value")) {
                        // use 'value' attribute as visible text
                        text = ruleContext.getAttribute("value");
                    }
                    else {
                        // use default value
                        if (inputType === "submit" /*||inputType==="image"*/) {
                            text = "submit";
                        }
                        else if (inputType === "reset") {
                            text = "reset";
                        }
                    }
                }
                if (!text) {
                    // look for a <label> element
                    var labelElem = legacy_1.RPTUtil.getLabelForElementHidden(ruleContext, true);
                    if (!labelElem) {
                        var parentNode = ruleContext.parentNode;
                        if (parentNode.nodeName.toLowerCase() === "label" /*&& RPTUtil.isFirstFormElement(parentNode, ruleContext)*/) {
                            var parentClone = parentNode.cloneNode(true);
                            // exclude all form elements from the label since they might also have inner content
                            labelElem = legacy_1.RPTUtil.removeAllFormElementsFromLabel(parentClone);
                        }
                    }
                    var element = labelElem ? labelElem : ruleContext;
                    var elementsToSkipContentCheck = ["meter", "output", "progress", "select", "textarea"];
                    if (!labelElem && elementsToSkipContentCheck.indexOf(nodeName) !== -1) {
                        text = ""; // skip content check for some elements
                    }
                    else {
                        // get the visible text
                        text = legacy_1.RPTUtil.getInnerText(element);
                    }
                    /* Note: Disable this alt check in images for now until we get confirmation
                    // Look for the alt attribute of an image which is considered visible text.
                    let hasImgAlt = false;
                    if (element.firstChild != null) {
                        let nw = RPTUtil.new NodeWalker(element);
                        while (!hasImgAlt && nw.nextNode() && nw.node != element && nw.node != element.nextSibling) {
                            hasImgAlt = (nw.node.nodeName.toLowerCase() == "img" && RPTUtil.attributeNonEmpty(nw.node, "alt"));
                            if (hasImgAlt) {
                                text = text ? text + nw.node.getAttribute("alt") : nw.node.getAttribute("alt");
                            }
                        }
                    }
                    */
                }
                var nonalphanumeric = /[^a-zA-Z0-9]/g;
                text = text.replace(nonalphanumeric, " "); // only consider alphanumeric characters
                var normalizedText = legacy_1.RPTUtil.normalizeSpacing(text).toLowerCase(); // Leading and trailing whitespace and difference in case sensitivity should be ignored.
                theLabel = theLabel.replace(nonalphanumeric, " "); // only consider alphanumeric characters
                var normalizedLabel = legacy_1.RPTUtil.normalizeSpacing(theLabel).toLowerCase();
                if (normalizedText.length > 1) { // skip non-text content. e.g. <button aria-label="close">X</button>
                    var location_1 = normalizedLabel.indexOf(normalizedText);
                    // Avoid matching partial words.e.g. text "name" should not match 'surname' or 'names'
                    if (location_1 >= 0 && normalizedLabel.length > normalizedText.length) {
                        var letters = /^[0-9a-zA-Z]+$/;
                        if ((location_1 + normalizedText.length) < normalizedLabel.length) {
                            // check ending
                            var theChar = normalizedLabel.charAt(location_1 + normalizedText.length);
                            if (theChar.match(letters)) {
                                passed = false;
                            }
                        }
                        if (passed && location_1 > 0) {
                            // check beginning
                            var theChar = normalizedLabel.charAt(location_1 - 1);
                            if (theChar.match(letters)) {
                                passed = false;
                            }
                        }
                    }
                    if (location_1 === -1) { // check that visible text content of the target is contained within its accessible name.
                        passed = false;
                    }
                }
            }
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    }
];
exports.a11yRulesLabel = a11yRulesLabel;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesTable = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesTable = [
    {
        /**
         * Description: Trigger if caption and summary say the same thing
         * Origin: WCAG 2.0 Technique H39, H73
         */
        id: "WCAG20_Table_CapSummRedundant",
        context: "dom:table",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var pofId;
            var passed = true;
            var sumStr;
            if (ruleContext.hasAttribute("summary")) {
                pofId = 0;
                sumStr = ruleContext.getAttribute("summary").trim().toLowerCase();
            }
            else if (ruleContext.hasAttribute("aria-describedby")) {
                pofId = 1;
                var summaryNodeId = ruleContext.getAttribute("aria-describedby");
                if (summaryNodeId) {
                    var summaryNode = ruleContext.ownerDocument.getElementById(summaryNodeId);
                    if (summaryNode) {
                        sumStr = legacy_1.RPTUtil.getInnerText(summaryNode).trim().toLowerCase();
                    }
                }
            }
            if (!sumStr) {
                return null;
            }
            else {
                var capElems = ruleContext.getElementsByTagName("caption");
                if (capElems.length === 0) {
                    return null;
                }
                else if (sumStr.length > 0) {
                    var capStr = legacy_1.RPTUtil.getInnerText(capElems[0]).trim().toLowerCase();
                    if (sumStr != capStr) {
                        return IEngine_1.RulePass("Pass_0");
                    }
                    else {
                        return IEngine_1.RuleFail("Fail_1");
                    }
                }
            }
        }
    },
    {
        /**
         * Description: Ensure that table captions have content
         * Origin: Valerie
         */
        id: "Valerie_Caption_HasContent",
        context: "dom:caption",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = legacy_1.RPTUtil.hasInnerContentHidden(ruleContext);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Ensure that table captions are in tables
         * Origin: Valerie
         */
        id: "Valerie_Caption_InTable",
        context: "dom:caption",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = legacy_1.RPTUtil.getAncestor(ruleContext, "table") != null;
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Trigger if role!="presentation" or role!="none", and missing a summary or summary does not correspond to aria-label or aria-labelledby
         * Origin: WCAG 2.0 Technique H73
         */
        id: "WCAG20_Table_SummaryAria3",
        context: "dom:table",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = !legacy_1.RPTUtil.isComplexDataTable(ruleContext) || legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "summary") || ruleContext.hasAttribute("aria-describedby");
            // check if aria-describedby points to valid id or valid summary
            var summaryNodeId = ruleContext.getAttribute("aria-describedby");
            var sumStr;
            if (summaryNodeId) {
                var summaryNode = ruleContext.ownerDocument.getElementById(summaryNodeId);
                if (summaryNode) {
                    sumStr = legacy_1.RPTUtil.getInnerText(summaryNode).trim().toLowerCase();
                    if (sumStr) {
                        passed = true;
                    }
                    else
                        passed = false;
                }
                else
                    passed = false;
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Require that there be at least one header row or header column for a data table.
         * Origin: RPT 5.6 G113
         */
        id: "RPT_Table_DataHeadingsAria",
        context: "dom:table",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // If this is a layout table or there are no rows, the rule does not apply.
            var rows = ruleContext.rows;
            if (!legacy_1.RPTUtil.isDataTable(ruleContext) || rows == null || rows.length == 0)
                return null;
            var passed = legacy_1.RPTUtil.isTableHeaderInFirstRowOrColumn(ruleContext);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Every heading must point to some cell, and every cell must reference
         * some heading
         * Origin: Valerie
         */
        id: "Valerie_Table_DataCellRelationships",
        context: "dom:td, dom:th",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var parentTable = legacy_1.RPTUtil.getAncestor(ruleContext, "table");
            // If this is a layout table or a simple table the rule does not apply.
            if (parentTable == null || !legacy_1.RPTUtil.isComplexDataTable(parentTable))
                return null;
            // If this table hasn't been preprocessed, process it.
            if (legacy_1.RPTUtil.getCache(ruleContext, "Valerie_Table_DataCellRelationships", null) === null) {
                // Build a grid that's actually usable (rowspan and colspan elements are duplicated)
                // This builds a real 2d table array.
                var grid = [];
                for (var i = 0; i < parentTable.rows.length; ++i) {
                    var row = parentTable.rows[i];
                    if (!grid[i])
                        grid[i] = [];
                    for (var j = 0; j < row.cells.length; ++j) {
                        var cell = row.cells[j];
                        legacy_1.RPTUtil.setCache(cell, "Valerie_Table_DataCellRelationships", i + ":" + j);
                        var width = parseInt(cell.getAttribute("colspan"));
                        if (!width)
                            width = 1;
                        var height = parseInt(cell.getAttribute("rowspan"));
                        if (!height)
                            height = 1;
                        var gX = 0;
                        while (grid[i][gX])
                            gX += 1;
                        for (var k = 0; k < height; ++k) {
                            if (!grid[i + k])
                                grid[i + k] = [];
                            for (var l = 0; l < width; ++l) {
                                grid[i + k][gX + l] = cell;
                            }
                        }
                    }
                }
                // Iterate through the table grid and record headers that point to cells and
                // cells that are pointed to by headers
                var doc = ruleContext.ownerDocument;
                var lookup = {};
                var scopedCols = {};
                for (var i = 0; i < grid.length; ++i) {
                    var rowScoped = false;
                    for (var j = 0; j < grid[i].length; ++j) {
                        var gridCell = grid[i][j];
                        var gridNodeName = gridCell.nodeName.toLowerCase();
                        if (gridNodeName == "th") {
                            if (gridCell.getAttribute("scope") == "row") {
                                rowScoped = true;
                                // If there's an axis attribute, it must be referred to by headers,
                                // scope is not enough.
                                if (!legacy_1.RPTUtil.attributeNonEmpty(gridCell, "axis"))
                                    lookup[legacy_1.RPTUtil.getCache(gridCell, "Valerie_Table_DataCellRelationships", null)] = true;
                            }
                            else if (gridCell.getAttribute("scope") == "col") {
                                scopedCols[j] = true;
                                // If there's an axis attribute, it must be referred to by headers,
                                // scope is not enough.
                                if (!legacy_1.RPTUtil.attributeNonEmpty(gridCell, "axis"))
                                    lookup[legacy_1.RPTUtil.getCache(gridCell, "Valerie_Table_DataCellRelationships", null)] = true;
                            }
                            // Headers can refer to other headers
                            if (legacy_1.RPTUtil.attributeNonEmpty(gridCell, "headers")) {
                                var hdrs = gridCell.getAttribute("headers").split(" ");
                                for (var k = 0; k < hdrs.length; ++k) {
                                    var headElem = doc.getElementById(hdrs[k].trim());
                                    if (headElem && legacy_1.RPTUtil.getAncestor(headElem, "table") == parentTable) {
                                        lookup[legacy_1.RPTUtil.getCache(headElem, "Valerie_Table_DataCellRelationships", null)] = true;
                                    }
                                }
                            }
                        }
                        else if (gridNodeName == "td") {
                            if (rowScoped || scopedCols[j]) {
                                lookup[legacy_1.RPTUtil.getCache(gridCell, "Valerie_Table_DataCellRelationships", null)] = true;
                            }
                            else if (legacy_1.RPTUtil.attributeNonEmpty(gridCell, "headers")) {
                                var hdrs = gridCell.getAttribute("headers").split(" ");
                                for (var k = 0; k < hdrs.length; ++k) {
                                    var headElem = doc.getElementById(hdrs[k].trim());
                                    if (headElem && legacy_1.RPTUtil.getAncestor(headElem, "table") == parentTable) {
                                        lookup[legacy_1.RPTUtil.getCache(gridCell, "Valerie_Table_DataCellRelationships", null)] = true;
                                        lookup[legacy_1.RPTUtil.getCache(headElem, "Valerie_Table_DataCellRelationships", null)] = true;
                                    }
                                }
                            }
                        }
                    }
                }
                legacy_1.RPTUtil.setCache(parentTable, "Valerie_Table_DataCellRelationships", lookup);
            }
            var rcInfo = legacy_1.RPTUtil.getCache(ruleContext, "Valerie_Table_DataCellRelationships", null);
            var tInfo = legacy_1.RPTUtil.getCache(parentTable, "Valerie_Table_DataCellRelationships", null);
            var passed = rcInfo !== null && tInfo !== null && rcInfo in tInfo;
            if (!passed && rcInfo === "0:0" &&
                legacy_1.RPTUtil.getInnerText(ruleContext).trim().length == 0) {
                // We don't test if it's the upper-left cell and it's empty
                return null;
            }
            // If the table has no th's, it may just be that this was supposed to be a layout
            // table, which introduces a lot of noise.  In that case, only trigger this error
            // once per table.
            if (!passed && parentTable.getElementsByTagName("th").length == 0) {
                if (legacy_1.RPTUtil.getCache(parentTable, "Valerie_Table_DataCellRelationships_TrigOnce", false) === true) {
                    passed = true;
                }
                else {
                    legacy_1.RPTUtil.setCache(parentTable, "Valerie_Table_DataCellRelationships_TrigOnce", true);
                }
            }
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Trigger if the values in scope attribute are invalid
         * Origin: WCAG 2.0 Technique H63
         */
        id: "WCAG20_Table_Scope_Valid",
        context: "dom:td[scope], dom:th[scope]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var scopeVal = ruleContext.getAttribute("scope").trim().toLowerCase();
            var passed = /^(row|col|rowgroup|colgroup)$/.test(scopeVal);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Trigger on all tables that are determined to be layout tables.
         * Origin: RPT 5.6
         */
        id: "RPT_Table_LayoutTrigger",
        context: "dom:table",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = !legacy_1.RPTUtil.isLayoutTable(ruleContext);
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger if role=="presentation" or role=="none" and has table structure
         * Origin: WCAG 2.0 Technique H39, H43, H73, RPT 5.6 471
         */
        id: "WCAG20_Table_Structure",
        context: "dom:table",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // JCH - OUT OF SCOPE hidden in context
            if (legacy_1.RPTUtil.isDataTable(ruleContext))
                return null;
            if (legacy_1.RPTUtil.isNodeInGrid(ruleContext))
                return null;
            var errorNodes = [];
            if (legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "summary"))
                errorNodes.push(ruleContext);
            var captionElems = ruleContext.getElementsByTagName("caption");
            for (var i = 0; i < captionElems.length; ++i) {
                if (legacy_1.RPTUtil.getAncestor(captionElems[i], "table") == ruleContext) {
                    // Check if the node should be skipped or not based on the Check Hidden Content setting and if the node isVisible or
                    // not. 
                    if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(captionElems[i])) {
                        continue;
                    }
                    // Add the node to the errorNodes
                    errorNodes.push(captionElems[i]);
                    // Since we are not actually making use of theses errorNodes even though they are passed along with
                    // ValidationResult, we do not need to keep looping over and getting every single violating node under
                    // the rule context. This can be a future enhancenment where we actually make use of the error nodes that
                    // are passed along. Adding this break to speed up performance at this point.
                    break; // There is no point to keep adding the error nodes, stop after finding the first one
                }
            }
            var thNodes = ruleContext.getElementsByTagName("th");
            for (var i = 0; i < thNodes.length; ++i) {
                if (legacy_1.RPTUtil.getAncestor(thNodes[i], "table") == ruleContext) {
                    // Check if the node should be skipped or not based on the Check Hidden Content setting and if the node isVisible or
                    // not.
                    if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(thNodes[i])) {
                        continue;
                    }
                    // Add the node to the errorNodes
                    errorNodes.push(thNodes[i]);
                    // Since we are not actually making use of theses errorNodes even though they are passed along with
                    // ValidationResult, we do not need to keep looping over and getting every single violating node under
                    // the rule context. This can be a future enhancenment where we actually make use of the error nodes that
                    // are passed along. Adding this break to speed up performance at this point.
                    break; // There is no point to keep adding the error nodes, stop after finding the first one
                }
            }
            var tdNodes = ruleContext.getElementsByTagName("td");
            for (var i = 0; i < tdNodes.length; ++i) {
                if ((tdNodes[i].hasAttribute("scope") || tdNodes[i].hasAttribute("headers")) &&
                    legacy_1.RPTUtil.getAncestor(tdNodes[i], "table") == ruleContext) {
                    // Check if the node should be skipped or not based on the Check Hidden Content setting and if the node isVisible or
                    // not.
                    if (legacy_1.RPTUtil.shouldNodeBeSkippedHidden(tdNodes[i])) {
                        continue;
                    }
                    // Add the node to the errorNodes
                    errorNodes.push(tdNodes[i]);
                    // Since we are not actually making use of theses errorNodes even though they are passed along with
                    // ValidationResult, we do not need to keep looping over and getting every single violating node under
                    // the rule context. This can be a future enhancenment where we actually make use of the error nodes that
                    // are passed along. Adding this break to speed up performance at this point.
                    break; // There is no point to keep adding the error nodes, stop after finding the first one
                }
            }
            // Get the node name for the rule context element in this case it will always be table
            var currentElementToken = ruleContext.nodeName.toLowerCase();
            // Construct a new array which will contan only the element tag for the violation elements
            var structuralElementTokens = new Array();
            // Construct a seen hash that will keep trask of all the elements that were already added to the token array, to make sure
            // we do not duplicate any of the elements. Duplicate element tags in the token message looks bad and confusing.
            var seen = {};
            // Loop through all the violating structural elements and extract the element tag to be used as a token
            for (var i = 0; i < errorNodes.length; i++) {
                // Get the node name (tag name) for the violating structural element
                var nodeName = errorNodes[i].nodeName.toLowerCase();
                // Only need to add the violating element once
                if (!seen.hasOwnProperty(nodeName)) {
                    // Since we are adding the token as elements and attributes we need to handle
                    // the summary attribute on the ruleContext (table). We only add summary once, same as
                    // for elements to avoid duplication in the message. (Summary should not duplicate, but just in case)
                    if (nodeName == "table" && !seen.hasOwnProperty["summary"]) {
                        // Mark this as a new attribute
                        seen["summary"] = true;
                        // Since this is a new violating element add it to the structural element tokens array
                        structuralElementTokens.push("summary");
                    }
                    else {
                        // Mark this as a new element
                        seen[nodeName] = true;
                        // Since this is a new violating element add it to the structural element tokens array
                        structuralElementTokens.push(nodeName);
                    }
                }
            }
            // We need to take the array of structural elements and join them with a comma and a space to make grammatical correct in
            // the message.
            var structuralElementTokensStr = structuralElementTokens.join(", ");
            //return new ValidationResult(errorNodes.length == 0, errorNodes, '', '', [currentElementToken, structuralElementTokens]);
            if (errorNodes.length == 0) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail("Fail_1", [currentElementToken, structuralElementTokensStr]);
            }
        }
    }
];
exports.a11yRulesTable = a11yRulesTable;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesBlink = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesBlink = [
    {
        /**
         * Description: Triggers if there is a blink element
         * Origin: WCAG 2.0 Technique G11
         */
        id: "WCAG20_Blink_AlwaysTrigger",
        context: "dom:blink",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            return IEngine_1.RuleFail("Fail_1");
        }
    },
    {
        /**
         * Description: Trigger for CSS usage that blinks
         * Origin: RPT 5.6 G479
         */
        id: "RPT_Blink_CSSTrigger1",
        context: "dom:style, dom:*[style]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var textValue = legacy_1.RPTUtil.getInnerText(ruleContext);
            if (ruleContext.hasAttribute('style')) {
                textValue = ruleContext.getAttribute('style');
            }
            var passed = textValue.toLowerCase().indexOf("text-decoration:blink") == -1;
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesBlink = a11yRulesBlink;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesFocus = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var __1 = __webpack_require__(8);
var a11yRulesFocus = [
    {
        /**
         * Description: Determine if widgets that should have focus have a tab stop
         */
        id: "IBMA_Focus_Tabbable",
        context: 
        // widget
        // - command 
        "aria:button,aria:link"
            // ",menuitem"
            // - composite
            + ",aria:spinbutton,aria:tablist"
            // ",grid"
            // -- select
            + ",aria:combobox,aria:listbox,aria:menu,aria:radiogroup,aria:tree"
            // - input
            + ",aria:checkbox,aria:slider,aria:spinbutton,aria:textbox"
            // + ",option,radio"
            // - gridcell
            // + ",columnheader,rowheader"
            // - range
            //        + ",progressbar"
            + ",aria:scrollbar,aria:slider,aria:spinbutton"
        // - row,separator,tab
        // other
        //        + ",article"
        ,
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var role = __1.ARIAMapper.nodeToRole(ruleContext);
            var count = 0;
            if (legacy_1.RPTUtil.isTabbable(ruleContext)) {
                ++count;
            }
            // If node has children, look for tab stops in the children
            if (count < 1 && ruleContext.firstChild) {
                var nw = new legacy_1.NodeWalker(ruleContext);
                while (count < 1 && nw.nextNode() && nw.node != ruleContext) {
                    if (nw.node.nodeType == 1 && !nw.bEndTag && legacy_1.RPTUtil.isTabbable(nw.node)) {
                        ++count;
                    }
                }
            }
            var passed = count >= 1;
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1", [role]);
        }
    },
    {
        /**
         * Description: Flag if widgets have more than one tab stop
         */
        id: "IBMA_Focus_MultiTab",
        context: 
        // widget
        // - command 
        "aria:button,aria:link,aria:menuitem"
            // - composite
            // + ",grid"
            + ",aria:spinbutton,aria:tablist"
            // -- select
            + ",aria:combobox,aria:listbox,aria:menu,aria:radiogroup,aria:tree"
            // - input
            + ",aria:checkbox,aria:option,aria:radio,aria:slider,aria:spinbutton,aria:textbox"
            // - gridcell
            + ",aria:columnheader,aria:rowheader"
            // - range
            //        + ",progressbar"
            //        + ",scrollbar"
            //        + ",spinbutton"
            + ",aria:slider,aria:tab"
        // - row,separator
        // other
        // + ",article"
        ,
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var role = __1.ARIAMapper.nodeToRole(ruleContext);
            var count = 0;
            if (legacy_1.RPTUtil.isTabbable(ruleContext)) {
                ++count;
            }
            // If node has children, look for tab stops in the children
            if (count < 2 && ruleContext.firstChild) {
                var nw = new legacy_1.NodeWalker(ruleContext);
                while (count < 2 && nw.nextNode() && nw.node != ruleContext) {
                    if (nw.node.nodeType == 1 && !nw.bEndTag && legacy_1.RPTUtil.isTabbable(nw.node)) {
                        ++count;
                    }
                }
            }
            var passed = count < 2;
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1", [role]);
        }
    }
];
exports.a11yRulesFocus = a11yRulesFocus;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesList = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesList = [
    {
        id: "RPT_List_Misuse",
        context: "dom:dl, dom:ul, dom:ol, dom:dir, dom:menu, dom:li, dom:dd, dom:dt",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed;
            var nodeName = ruleContext.nodeName.toLowerCase();
            // Get all the childrens of the ruleContext
            var children = ruleContext.children;
            if (nodeName == "dl") {
                var first = "";
                var last = "";
                var walkChildren = ruleContext.firstChild;
                passed = true;
                var presentationalFound = false;
                // If there are no childrens set as passed, since dl elements can have
                // zero or more of: one or more dt elements, followed by one or more dd elements
                if (!ruleContext.children || ruleContext.children.length == 0) {
                    passed = true;
                }
                else {
                    while (passed && walkChildren != null) {
                        if (walkChildren.nodeType == 1) {
                            var nodeName_1 = walkChildren.nodeName.toLowerCase();
                            // While walking through the elements under dl, if we find a 
                            // presentational element we move to the next element as presentational
                            // elements are allowed under list elements as they are only for
                            // formatting text nodes.
                            if (legacy_1.RPTUtil.isPresentationalElement(walkChildren)) {
                                presentationalFound = true;
                                walkChildren = walkChildren.nextSibling;
                                continue;
                            }
                            // Only set to pass if we find dd or dt element, in the case of
                            // an element that is not supported we will catch it here. i.e. img 
                            // element
                            passed = nodeName_1 == "dd" || nodeName_1 == "dt";
                            // Set the first and last node depending on which is found first and last
                            if (first == "")
                                first = nodeName_1;
                            last = nodeName_1;
                        }
                        walkChildren = walkChildren.nextSibling;
                    }
                    // In the case that we have found dt and dd elements under dl we pass right away.
                    // In the case that there is no dt or dd element, but bunch of presentational elements we mark this as a
                    // pass. In the case that there are other elements such as img we will still trigger a violation.
                    passed = (passed && first == "dt" && last == "dd") || (passed && presentationalFound);
                }
            }
            else if (nodeName == "li") {
                passed = legacy_1.RPTUtil.getAncestor(ruleContext, ["ul", "ol", "dir", "menu"]) != null;
            }
            else if (nodeName == "dd" || nodeName == "dt") {
                passed = legacy_1.RPTUtil.getAncestor(ruleContext, "dl") != null;
            }
            else {
                var walkChildren = ruleContext.firstChild;
                // Zero or more li elements are permitted inside of <ol>, <ul> or <menu> elements now as per the html5 spec. This handles the case
                // when there are zero elements under the <ol>, <ul> or <menu>.
                if ((nodeName == "ul" || nodeName == "ol" || nodeName == "menu") && (!ruleContext.children || ruleContext.children.length == 0)) {
                    passed = true;
                }
                else {
                    var liFound = false;
                    var presentationalFound = false;
                    passed = true;
                    while (passed && walkChildren != null) {
                        // While walking through the list elements, if we find a 
                        // presentational element we skip checking as presentational
                        // elements are allowed under list elements as they are only for
                        // formatting text.
                        if (legacy_1.RPTUtil.isPresentationalElement(walkChildren)) {
                            presentationalFound = true;
                            walkChildren = walkChildren.nextSibling;
                            continue;
                        }
                        // Pass if the node type is anything but 1, or in the case that it is a li element. For any other node 
                        // it will be caught here that element is not allowed under list node.
                        // Furthermore in the case that there is a template element with the parent being ul/ol don't flag a violation
                        passed = walkChildren.nodeType != 1 || walkChildren.nodeName.toLowerCase() == "li" || (walkChildren.nodeName.toLowerCase() == "template" && (nodeName == "ul" || nodeName == "ol"));
                        // Set li found to true if the current element (nodeType=1) is an li element
                        liFound = liFound || (walkChildren.nodeType == 1 && walkChildren.nodeName.toLowerCase() == "li");
                        walkChildren = walkChildren.nextSibling;
                    }
                    // In the case that it has passed and also li element is found under list node, we pass right away.
                    // In the case that there is no li element, but bunch of presentational elements we mark this as a
                    // pass. In the case that there are other elements such as img we will still trigger a violation.
                    passed = (passed && liFound) || (passed && presentationalFound);
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        id: "RPT_List_UseMarkup",
        context: "dom:*",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            var walkNode = ruleContext.firstChild;
            while (passed && walkNode) {
                // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
                // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
                // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
                // a node walk only on siblings so it would not get text nodes from other siblings at all.
                // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
                // if.
                if (walkNode.nodeName == "#text") {
                    var txtVal = walkNode.nodeValue;
                    var failure = /^[ \t\r\n]*[( ]*[1-9]*[\*\-).][ \t][A-Z,a-z]+/.test(txtVal);
                    passed = !failure;
                    if (!passed) {
                        // Ensure that there's some sort of block level element before this
                        // Avoid failures due to things like <i>Some sentence</i>. New sentence.
                        var nw = new legacy_1.NodeWalker(walkNode);
                        while (!passed && nw.prevNode()) {
                            var nodeName = nw.node.nodeName.toLowerCase();
                            if (["blockquote", "center", "dir", "div", "form", "h1",
                                "h2", "h3", "h4", "h5", "h6", "hr", "br", "menu", "p",
                                "pre"].includes(nodeName)) {
                                break;
                            }
                            if (nodeName == "#text") {
                                var txt = nw.node.nodeValue;
                                passed = txt.length > 0 && ![" ", "\t", "\n"].includes(txt.charAt(txt.length - 1));
                            }
                        }
                    }
                }
                walkNode = walkNode.nextSibling;
            }
            if (!passed) {
                // Don't trigger if we're not in the body or if we're in a script
                var checkAncestor = legacy_1.RPTUtil.getAncestor(ruleContext, ["body", "script"]);
                passed = checkAncestor == null || checkAncestor.nodeName.toLowerCase() != "body";
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesList = a11yRulesList;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesText = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesText = [
    {
        /**
         * Description: Trigger for possible uses of sensory text
         * Origin: RPT 5.6 G502
         */
        id: "RPT_Text_SensoryReference",
        context: "dom:*",
        run: function (context, options) {
            var validateParams = {
                sensoryText: {
                    value: ["top-left", "top-right", "bottom-right", "bottom-left",
                        "round", "square", "shape", "rectangle", "triangle",
                        "right", "left", "above", "below", "top", "bottom",
                        "upper", "lower", "corner", "beside"],
                    type: "[string]"
                }
            };
            var ruleContext = context["dom"].node;
            // Extract the nodeName of the context node
            var nodeName = ruleContext.nodeName.toLowerCase();
            // In the case this is a style or link element, skip triggering rule as we do not want to scan
            // CSS for sensory words, as there can be CSS keys which contain theses sensory text that is matching.
            if (nodeName === "style" || nodeName === "link") {
                return IEngine_1.RulePass(1);
            }
            var violatedtextArray = null;
            var violatedtext = null;
            var sensoryRegex = legacy_1.RPTUtil.getCache(ruleContext.ownerDocument, "RPT_Text_SensoryReference", null);
            if (sensoryRegex == null) {
                var sensoryText = validateParams.sensoryText.value;
                var regexStr = "(" + sensoryText[0];
                for (var j = 1; j < sensoryText.length; ++j)
                    regexStr += "|" + sensoryText[j];
                regexStr += ")\\W";
                sensoryRegex = new RegExp(regexStr, "gi");
                legacy_1.RPTUtil.setCache(ruleContext.ownerDocument, "RPT_Text_SensoryReference", sensoryRegex);
            }
            var passed = true;
            var walkNode = ruleContext.firstChild;
            var _loop_1 = function () {
                // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
                // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
                // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
                // a node walk only on siblings so it would not get text nodes from other siblings at all.
                // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
                // if.
                if (walkNode.nodeName == "#text") {
                    var txtVal = walkNode.nodeValue.trim();
                    if (txtVal.length > 0) {
                        violatedtextArray = txtVal.match(sensoryRegex);
                        if (violatedtextArray != null) {
                            var hash_1 = {}, result_1 = [];
                            var exemptWords_1 = ["right-click", "left-click", "right-clicking", "right-clicks", "left-clicking", "left-clicks"];
                            // Note: split(/[\n\r ]+/) will spread the string into group of words using space, 
                            // carriage return or linefeed as separators.
                            var counts = txtVal.split(/[\n\r ]+/).reduce(function (map, word) {
                                var sensoryTextArr = validateParams.sensoryText.value;
                                var wordWoTrailingPunc = word.replace(/[.?!:;()'",`\]]+$/, "");
                                var lcWordWoPunc = word.toLowerCase().replace(/[.?!:;()'",`\]]/g, "");
                                for (var counter = 0; counter < sensoryTextArr.length; counter++) {
                                    var a = lcWordWoPunc.indexOf(sensoryTextArr[counter]);
                                    var b = exemptWords_1.indexOf(lcWordWoPunc);
                                    var sensoryWordLen = sensoryTextArr[counter].length;
                                    var charFollowSensoryText = lcWordWoPunc.charAt(sensoryWordLen + a);
                                    // If the word does not contains substring of sensoryTextArr[counter]
                                    // proceed to the next loop iteration for next sensoryText.
                                    if (a < 0) {
                                        continue;
                                    }
                                    var isPuncfollowing = ((charFollowSensoryText == '\-') ||
                                        (charFollowSensoryText == '\.') ||
                                        (charFollowSensoryText == '\?') || (charFollowSensoryText == '\!') ||
                                        (charFollowSensoryText == '\:') || (charFollowSensoryText == '\;') ||
                                        (charFollowSensoryText == '\(') || (charFollowSensoryText == '\)') ||
                                        (charFollowSensoryText == '\'') || (charFollowSensoryText == '\"') ||
                                        (charFollowSensoryText == '\,') || (charFollowSensoryText == '.\`') ||
                                        (charFollowSensoryText == '\\') || (charFollowSensoryText == '\]'));
                                    var isPuncPreceding = false;
                                    if (a > 0) {
                                        var charPrecedeSensoryText = lcWordWoPunc.charAt(a - 1);
                                        isPuncPreceding = ((charPrecedeSensoryText == '\-') ||
                                            (charPrecedeSensoryText == '\.') ||
                                            (charPrecedeSensoryText == '\?') || (charPrecedeSensoryText == '\!') ||
                                            (charPrecedeSensoryText == '\:') || (charPrecedeSensoryText == '\;') ||
                                            (charPrecedeSensoryText == '\(') || (charPrecedeSensoryText == '\)') ||
                                            (charPrecedeSensoryText == '\'') || (charPrecedeSensoryText == '\"') ||
                                            (charPrecedeSensoryText == '\,') || (charPrecedeSensoryText == '.\`') ||
                                            (charPrecedeSensoryText == '\\') || (charPrecedeSensoryText == '\]'));
                                    }
                                    if (((lcWordWoPunc.length == sensoryWordLen) || (isPuncfollowing == true) || (isPuncPreceding == true)) && (b < 0)) {
                                        passed = false;
                                        if (!hash_1.hasOwnProperty(wordWoTrailingPunc)) {
                                            hash_1[wordWoTrailingPunc] = true;
                                            result_1.push(wordWoTrailingPunc);
                                        }
                                        counter = sensoryTextArr.length;
                                    }
                                }
                                map[wordWoTrailingPunc] = (map[wordWoTrailingPunc] || 0) + 1;
                                return map;
                            }, Object.create(null));
                            violatedtext = result_1.join(", ");
                        }
                    }
                }
                walkNode = walkNode.nextSibling;
            };
            while (passed && walkNode) {
                _loop_1();
            }
            if (!passed) {
                // Don't trigger if we're not in the body or if we're in a script
                var checkAncestor = legacy_1.RPTUtil.getAncestor(ruleContext, ["body", "script"]);
                passed = (checkAncestor == null || checkAncestor.nodeName.toLowerCase() != "body");
            }
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1", [violatedtext]);
        }
    },
    {
        /**
         * Description: Trigger for detected emoticons
         * Origin: WCAG H86
         */
        id: "WCAG20_Text_Emoticons",
        context: "dom:*",
        run: function (context, options) {
            var validateParams = {
                emoticons: {
                    value: [":-)", ":)", ":o)", ":]", ":3", ":c)", ":>", "=]", "8)", "=)", ":D", "C:",
                        ":-D", ":D", "8D", "XD", "=D", "=3", "<=3", "<=8", "--!--", ":-(", ":(", ":c", ":<", ":[",
                        "D:", "D8", "D;", "D=", "DX", "v.v", ":-9", ";-)", ";)", "*)", ";]", ";D", ":-P", ":P",
                        ":-p", ":p", "=p", ":-Þ", ":Þ", ":-b", ":b", ":-O", ":O", "O_O", "o_o", "8O", "OwO", "O-O",
                        "0_o", "O_o", "O3O", "o0o ;o_o;", "o...o", "0w0", ":-/", ":/", ":\\", "=/", "=\\", ":S", ":|",
                        "d:-)", "qB-)", ":)~", ":-)>....", ":-X", ":X", ":-#", ":#", "O:-)", "0:3", "O:)", ":'(", ";*(",
                        "T_T", "TT_TT", "T.T", ":-*", ":*", "^o)", ">:)", ">;)", ">:-)", "B)", "B-)", "8)", "8-)",
                        "^>.>^", "^<.<^", "^>_>^", "^<_<^", "D:<", ">:(", "D-:<", ">:-(", ":-@[1]", ";(", "`_´", "D<",
                        "<3", "<333", "=^_^=", "=>.>=", "=<_<=", "=>.<=", "\\,,/", "\\m/", "\\m/\\>.</\\m/", "\\o/", "\\o o/",
                        "o/\\o", ":&", ":u"
                    ],
                    type: "[string]"
                }
            };
            var ruleContext = context["dom"].node;
            var emoticons = validateParams.emoticons.value;
            var passed = true;
            var testText = "";
            var walkNode = ruleContext.firstChild;
            while (walkNode) {
                // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
                // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
                // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
                // a node walk only on siblings so it would not get text nodes from other siblings at all.
                // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
                // if.
                if (walkNode.nodeName == "#text") {
                    testText += " " + walkNode.nodeValue;
                }
                walkNode = walkNode.nextSibling;
            }
            if (testText.trim().length > 0) {
                for (var j = 0; passed && j < emoticons.length; ++j) {
                    var emotIdx = testText.indexOf(emoticons[j]);
                    var eLngth = emoticons[j].length;
                    while (passed && emotIdx != -1) {
                        // Passes if: the emoticon is not preceded by whitespace,
                        // or the emoticon is not followed by whitespace unless it's punctuation,
                        // or it's in a pre, code, or script
                        passed =
                            (emotIdx > 0 && !/\s/.test(testText.substring(emotIdx - 1, emotIdx))) ||
                                (emotIdx < testText.length - eLngth && !/\s/.test(testText.substring(emotIdx + eLngth, emotIdx + eLngth + 1)) &&
                                    !/[.,!'"?]/.test(testText.substring(emotIdx + eLngth, emotIdx + eLngth + 1)));
                        // Allow usage of (: stuff :) since this is a comment in some languages
                        passed = passed || ((emoticons[j] == ":)" || emoticons[j] == "(:") && /\(\:.*\:\)/.test(testText));
                        passed = passed || ((emoticons[j] == ";)" || emoticons[j] == "(;") && /\(\;.*\;\)/.test(testText));
                        emotIdx = testText.indexOf(emoticons[j], emotIdx + 1);
                    }
                }
            }
            if (!passed) {
                // Don't trigger if we're not in the body or if we're in a script, pre, code
                var checkAncestor = legacy_1.RPTUtil.getAncestor(ruleContext, ["pre", "code", "script", "body"]);
                passed = checkAncestor == null || checkAncestor.nodeName.toLowerCase() != "body";
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger for words that are spaced out (e.g., I B M).  CSS should be used instead for this
         * Origin: WCAG 2.0 F32, C8
         */
        id: "WCAG20_Text_LetterSpacing",
        context: "dom:*",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            var walkNode = ruleContext.firstChild;
            while (passed && walkNode) {
                // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
                // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
                // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
                // a node walk only on siblings so it would not get text nodes from other siblings at all.
                // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
                // if.
                if (walkNode.nodeName == "#text") {
                    var txtVal = walkNode.nodeValue;
                    passed = !(/(^|\s)[a-zA-Z] [a-zA-Z] [a-zA-Z]($|\s)/.test(txtVal));
                }
                walkNode = walkNode.nextSibling;
            }
            if (!passed) {
                // Don't trigger if we're not in the body or if we're in a script
                var checkAncestor = legacy_1.RPTUtil.getAncestor(ruleContext, ["body", "script", "code"]);
                passed = checkAncestor == null || checkAncestor.nodeName.toLowerCase() != "body";
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger for possible ASCII art in a <pre>
         * Origin: RPT 5.6 G458
         */
        id: "RPT_Pre_ASCIIArt",
        context: "dom:pre, dom:listing, dom:xmp, dom:plaintext",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // Fix for IDWB writers. Don't trigger if content is in a code element.  The code element is searched for 
            // in various places because of the weird way various browsers render <code><pre></pre></code.  Firefox, 
            // HtmlUnit and Chrome all render differently.  Firefox: <code></code><pre></pre>  HtmlUnit: </code><pre><code></code></pre>
            // See unit test CodeElementAbovePreElement.html.  Don't know how RPT renders, so cover all the bases.
            if (ruleContext.nodeName.toLowerCase() == "pre") {
                if ((ruleContext.previousSibling && ruleContext.previousSibling.nodeName.toLowerCase() == "code") ||
                    ruleContext.getElementsByTagName("code").length > 0 ||
                    legacy_1.RPTUtil.getAncestor(ruleContext, "code")) {
                    return IEngine_1.RulePass("Pass_0");
                }
            }
            var passed = true;
            var txtValue = legacy_1.RPTUtil.getInnerText(ruleContext);
            var nonAlphaNumericNorSpaceCount = 0;
            var alphNumSameCharacterCount = 0;
            var lastCharacter = "";
            // Iterate through the text content
            for (var idx = 0; passed && (idx < txtValue.length); ++idx) {
                var chStr = txtValue.substr(idx, 1);
                // Check if it is alphanumeric or punctuation
                if (/[\w!@#$%&\*().,?\[\]{}<>=":\/\\-]/.test(chStr)) {
                    // Detect same character sequence
                    if (lastCharacter == chStr) {
                        alphNumSameCharacterCount = alphNumSameCharacterCount + 1;
                        ;
                    }
                    else {
                        alphNumSameCharacterCount = 0;
                    }
                }
                else if (/\s/.test(chStr)) {
                    alphNumSameCharacterCount = 0;
                }
                else {
                    nonAlphaNumericNorSpaceCount = nonAlphaNumericNorSpaceCount + 1;
                    alphNumSameCharacterCount = 0;
                }
                lastCharacter = chStr;
                // Make the decision
                if (nonAlphaNumericNorSpaceCount >= 5 || alphNumSameCharacterCount >= 4) {
                    passed = false;
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesText = a11yRulesText;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesBlockquote = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesBlockquote = [
    {
        /**
         * Description: Trigger <blockquote> without cite, or with cite that is only whitespace.
         * Origin: RPT 5.6
         */
        id: "RPT_Blockquote_HasCite",
        context: "dom:blockquote",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = legacy_1.RPTUtil.attributeNonEmpty(ruleContext, "cite");
            if (!passed) {
                var citeElems = legacy_1.RPTUtil.getDocElementsByTag(ruleContext, "cite");
                passed = citeElems != null && citeElems.length > 0;
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger if quotes are used that are not in <q> or <blockquote> or <script>
         * Origin: RPT 5.6 G263
         */
        id: "ext_quoted_valid",
        context: "dom:*",
        run: function (context, options) {
            var validateParams = {
                minWords: {
                    value: 3,
                    type: "integer"
                }
            };
            var ruleContext = context["dom"].node;
            var minWords = validateParams.minWords.value;
            var passed = true;
            var walkNode = ruleContext.firstChild;
            var violatedtext = null;
            while (passed && walkNode) {
                // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
                // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
                // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
                // a node walk only on siblings so it would not get text nodes from other siblings at all.
                // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
                // if.
                if (walkNode.nodeName == "#text") {
                    var txtVal = walkNode.nodeValue;
                    // Do the regex tests first - should be fast
                    // Remove apostrophe's
                    txtVal = txtVal.replace(/(\S)'(\S)/g, "$1$2");
                    var dblQuotes = txtVal.match(/("[^"]+")/g);
                    var snglQuotes = txtVal.match(/('[^']+')/g);
                    // Walk the parents - only continue testing if we found a quote, but
                    // we're not already marked up
                    // Also skip if we're in a script - there's lots of quotes used in scripts
                    if ((dblQuotes != null || snglQuotes != null) &&
                        legacy_1.RPTUtil.getAncestor(walkNode, ["blockquote", "q", "script"]) == null) {
                        if (dblQuotes != null) {
                            for (var i = 0; passed && i < dblQuotes.length; ++i)
                                passed = legacy_1.RPTUtil.wordCount(dblQuotes[i]) < minWords;
                        }
                        if (snglQuotes != null) {
                            for (var i = 0; passed && i < snglQuotes.length; ++i)
                                passed = legacy_1.RPTUtil.wordCount(snglQuotes[i]) < minWords;
                        }
                        // Remove any linefeed inside the quote
                        // violatedtext = txtVal.replace(new RegExp("\\r?\\n|\\r","g"),"");
                        if (dblQuotes == null) {
                            violatedtext = snglQuotes.join(", ").replace(new RegExp("\\r?\\n|\\r", "g"), "");
                        }
                        else if (snglQuotes == null) {
                            violatedtext = dblQuotes.join(", ").replace(new RegExp("\\r?\\n|\\r", "g"), "");
                        }
                        else {
                            violatedtext = dblQuotes.concat(snglQuotes).join(", ").replace(new RegExp("\\r?\\n|\\r", "g"), "");
                        }
                    }
                }
                walkNode = walkNode.nextSibling;
            }
            if (!passed) {
                // Don't trigger if we're not in the body or if we're in a script or code segment
                var checkAncestor = legacy_1.RPTUtil.getAncestor(ruleContext, ["body", "script", "code"]);
                passed = checkAncestor == null || checkAncestor.nodeName.toLowerCase() != "body";
            }
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RulePotential("Potential_1", [violatedtext]);
        }
    }
];
exports.a11yRulesBlockquote = a11yRulesBlockquote;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesFont = void 0;
var IEngine_1 = __webpack_require__(0);
var a11yRulesFont = [
    {
        /**
         * Description: Trigger if font with color is used in a form
         * Origin: RPT 5.6
         */
        id: "RPT_Font_ColorInForm",
        context: "dom:form",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            var fonts = ruleContext.getElementsByTagName("font");
            if (fonts != null) {
                for (var i = 0; i < fonts.length; ++i) {
                    passed = !fonts[i].hasAttribute("color");
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesFont = a11yRulesFont;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesMarquee = void 0;
var IEngine_1 = __webpack_require__(0);
var a11yRulesMarquee = [
    {
        /**
         * Description: Triggers if there is a marquee element
         * Origin: RPT 5.6 G5
         */
        id: "RPT_Marquee_Trigger",
        context: "dom:marquee",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            // JCH - NO OUT OF SCOPE hidden in context
            return IEngine_1.RuleFail("Fail_1");
        }
    }
];
exports.a11yRulesMarquee = a11yRulesMarquee;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesTitle = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var ancestor_1 = __webpack_require__(7);
var a11yRulesTitle = [
    {
        /**
         * Description: Triggers if a document does not have a title
         * Origin: WCAG 2.0 Technique H25
         */
        id: "WCAG20_Doc_HasTitle",
        // Note: context is HTML, because a document with no head at all is also missing a title.
        // HTMLUnit seems to add a head in anyway, but we cannot rely on that.
        context: "dom:html",
        run: function (context, options, contextHierarchies) {
            // This rule does not apply inside a presentational frame
            if (ancestor_1.AncestorUtil.isPresentationFrame(contextHierarchies)) {
                return null;
            }
            var ruleContext = context["dom"].node;
            // JCH - NO OUT OF SCOPE hidden in context
            var offNode = ruleContext;
            // First, find the head element
            var findHead = ruleContext.firstChild;
            var findTitle = null;
            while (findHead != null) {
                if (findHead.nodeName.toLowerCase() == "head")
                    break;
                findHead = findHead.nextSibling;
            }
            if (findHead != null) { // have head
                offNode = findHead;
                findTitle = findHead.firstChild;
                while (findTitle != null) {
                    if (findTitle.nodeName.toLowerCase() == "title")
                        break;
                    findTitle = findTitle.nextSibling;
                }
            }
            else { // don't have head so first PoF
                return IEngine_1.RuleFail("Fail_1");
            }
            if (findTitle == null) { // don't have title second PoF
                return IEngine_1.RuleFail("Fail_2");
            }
            // if we get here we have <head> and <title>
            if (findTitle != null && legacy_1.RPTUtil.getInnerText(findTitle).trim().length > 0) {
                return IEngine_1.RulePass("Pass_0");
            }
            else { // <title> has no innerHTML third PoF
                return IEngine_1.RuleFail("Fail_3");
            }
        }
    },
    {
        /**
         * Description: Trigger if title contains bad values
         * Origin: RPT 5.6 G484
         */
        id: "RPT_Title_Valid",
        context: "dom:head dom:title",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var titleStr = legacy_1.RPTUtil.getInnerText(ruleContext).trim();
            // allow .com, .net and .org
            var titleStrLowercase = titleStr.toLowerCase();
            if (titleStrLowercase.includes(".com") || titleStrLowercase.includes(".net") || titleStrLowercase.includes(".org")) {
                return IEngine_1.RulePass("Pass_0", [titleStr]);
            }
            if (titleStr.length === 0) {
                // This is covered by WCAG20_Doc_HasTitle
                return null; //RuleFail("Fail_1");
            }
            else {
                var passed = !/^\S*\.[a-zA-Z]{1,4}(?!.)|^https?:\/\/\S*/i.test(titleStr);
                if (!passed) {
                    return IEngine_1.RulePotential("Potential_2");
                }
                else {
                    return IEngine_1.RulePass("Pass_0", [titleStr]);
                }
            }
        }
    }
];
exports.a11yRulesTitle = a11yRulesTitle;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesBody = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var ancestor_1 = __webpack_require__(7);
var a11yRulesBody = [
    {
        id: "WCAG20_Body_FirstASkips_Native_Host_Sematics",
        context: "dom:body",
        run: function (context, options, contextHierarchies) {
            // This rule does not apply inside a presentational frame
            if (ancestor_1.AncestorUtil.isPresentationFrame(contextHierarchies)) {
                return null;
            }
            var ruleContext = context["dom"].node;
            // Get the anchors on the page
            var doc = ruleContext.ownerDocument;
            // Check for landmarks first
            var passed;
            if (legacy_1.RPTUtil.getCache(ruleContext, "IBM_hasLandmarks_Implicit", null) === null) {
                legacy_1.RPTUtil.setCache(ruleContext, "IBM_hasLandmarks_Implicit", legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, ["application", "banner", "complementary", "contentinfo",
                    "form", "main", "navigation", "search"
                ], true, true).length > 0);
            }
            passed = legacy_1.RPTUtil.getCache(ruleContext, "IBM_hasLandmarks_Implicit", false);
            if (!passed) { // No landmarks, check for skip links
                var anchors = legacy_1.RPTUtil.getDocElementsByTag(ruleContext, "a");
                // Skip anchor should be the first one on the page with an href attribute
                var testAnchor = null;
                for (var i = 0; i < anchors.length; ++i) {
                    if (anchors[i].hasAttribute("href") && legacy_1.RPTUtil.isNodeVisible(anchors[i])) {
                        testAnchor = anchors[i];
                        break;
                    }
                }
                // Pull out the target id
                var targetId = null;
                if (testAnchor != null) {
                    var hrefStr = testAnchor.getAttribute("href");
                    var idx = hrefStr.indexOf("#");
                    if (idx != -1) {
                        targetId = hrefStr.substring(idx + 1);
                    }
                }
                // Determine if there is an element id or named anchor on the page with this
                // target id.
                if (targetId != null) {
                    passed = doc.getElementById(targetId) != null;
                    for (var i = 0; !passed && i < anchors.length; ++i) {
                        if (!anchors[i].hasAttribute("href") &&
                            anchors[i].hasAttribute("name") &&
                            anchors[i].getAttribute("name") == targetId) {
                            passed = true;
                        }
                    }
                }
            }
            //return new ValidationResult(passed, [ruleContext], '', '', []);
            if (!passed) {
                return IEngine_1.RuleFail("Fail_1");
            }
            else {
                return IEngine_1.RulePass("Pass_0");
            }
        }
    },
    {
        /**
         * Description: Triggers if skip text does not contain certain text strings and
         *  there are no landmarks used on the page.
         * Origin: WCAG 2.0 Technique G1
         */
        id: "WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics",
        context: "dom:body",
        dependencies: ["WCAG20_Body_FirstASkips_Native_Host_Sematics"],
        run: function (context, options) {
            var validateParams = {
                paramSkipText: {
                    value: ["skip", "jump"],
                    type: "[string]"
                }
            };
            var ruleContext = context["dom"].node;
            // Get the anchors on the page
            var doc = ruleContext.ownerDocument;
            // Check for landmarks first
            var passed;
            if (legacy_1.RPTUtil.getCache(ruleContext, "IBM_hasLandmarks_Implicit", null) === null) {
                legacy_1.RPTUtil.setCache(ruleContext, "IBM_hasLandmarks_Implicit", legacy_1.RPTUtil.getElementsByRoleHidden(ruleContext.ownerDocument, ["application", "banner", "complementary", "contentinfo",
                    "form", "main", "navigation", "search"
                ], true, true).length > 0);
            }
            passed = legacy_1.RPTUtil.getCache(ruleContext, "IBM_hasLandmarks_Implicit", false);
            if (!passed) { // No landmarks, check for skip links
                var links = doc.links;
                // Skip link should be the first one on the page with an href attribute (i.e., links[0])
                // also if the first link is hidden then we should also trigger a violation.
                if (links && links.length > 0 && legacy_1.RPTUtil.isNodeVisible(links[0])) {
                    var testText = legacy_1.RPTUtil.getInnerText(doc.links[0]).toLowerCase();
                    for (var i = 0; !passed && i < validateParams.paramSkipText.value.length; ++i) {
                        passed = testText.indexOf(validateParams.paramSkipText.value[i]) != -1;
                    }
                }
                else
                    passed = false;
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesBody = a11yRulesBody;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesForm = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesForm = [
    {
        /**
         * Description: Trigger if a form does not have a submit button
         * Origin: WCAG 2.0 Technique H32
         */
        id: "WCAG20_Form_HasSubmit",
        context: "dom:form",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = false;
            if (ruleContext.firstChild) {
                // submit buttons are usually at the bottom - walk backwards
                var nw = new legacy_1.NodeWalker(ruleContext, true);
                while (!passed && nw.prevNode() && nw.node != ruleContext) {
                    if (!nw.bEndTag) {
                        var nodeName = nw.node.nodeName.toLowerCase();
                        if (nodeName == "input") {
                            var type = nw.node.getAttribute("type");
                            passed = type == "submit" || type == "image";
                        }
                        else if (nodeName == "button") {
                            passed = nw.node.getAttribute("type") == "submit";
                        }
                        else if (nw.node.nodeType == 1) {
                            passed = legacy_1.RPTUtil.hasRole(nw.node, "button");
                        }
                    }
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger if onchange is non-empty
         * Origin: RPT 5.6 G492
         */
        id: "RPT_Form_ChangeEmpty",
        context: "dom:select[onchange], dom:input[onchange]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = ruleContext.getAttribute("onchange").trim().length == 0;
            if (passed)
                return null;
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Triggers if there is a target, and text does not specify a new window.
         * Origin: WCAG 2.0 Technique H83, RPT G491
         */
        id: "WCAG20_Form_TargetAndText",
        context: "dom:form[target]",
        run: function (context, options) {
            var validateParams = {
                paramWinText: {
                    value: ["new window"],
                    type: "array"
                }
            };
            var ruleContext = context["dom"].node;
            var tStr = ruleContext.getAttribute("target");
            var passed = tStr == "_parent" || tStr == "_self" || tStr == "_top" || legacy_1.RPTUtil.getFrameByName(ruleContext, tStr) != null;
            if (!passed) {
                // Name is not part of this frameset – must have potential to create new window?
                // See if a new window is mentioned
                var textStr = legacy_1.RPTUtil.getInnerText(ruleContext);
                if (ruleContext.hasAttribute("title"))
                    textStr += " " + ruleContext.getAttribute("title");
                for (var i = 0; !passed && i < validateParams.paramWinText.value.length; ++i)
                    if (textStr.indexOf(validateParams.paramWinText.value[i]) != -1)
                        passed = true;
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    }
];
exports.a11yRulesForm = a11yRulesForm;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesMedia = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var a11yRulesMedia = [
    {
        /**
         * Description: Raise error if number of alt characters is greater than N.
         * Origin: RPT 5.6
         */
        id: "RPT_Media_AltBrief",
        context: "dom:img[alt], dom:applet[alt], dom:area[alt], dom:embed[alt], dom:input[type][alt]",
        run: function (context, options) {
            var validateParams = {
                maxAlt: {
                    value: 150,
                    type: "integer"
                }
            };
            var ruleContext = context["dom"].node;
            var altLength = ruleContext.getAttribute("alt").trim().length;
            var passed = altLength <= validateParams.maxAlt.value;
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger for various media types
         * Origin: RPT 5.6 G24
         */
        id: "RPT_Media_AudioTrigger",
        context: "dom:bgsound, dom:a[href], dom:area[href], dom:embed, dom:object",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed;
            var thisNode = ruleContext.nodeName.toLowerCase();
            if (thisNode == "bgsound") {
                passed = false;
            }
            else {
                passed = !legacy_1.RPTUtil.isAudioObjEmbedLink(ruleContext);
            }
            if (passed)
                return null; // Out of Scope
            if (!passed)
                return IEngine_1.RuleManual("Manual_1");
        }
    },
    {
        /**
         * Description: Trigger for possible video
         * Origin: RPT 5.6 G459
         */
        id: "RPT_Media_VideoReferenceTrigger",
        context: "dom:a[href], dom:area[href], dom:applet, dom:embed, dom:object",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var nodeName = ruleContext.nodeName.toLowerCase();
            var passed = true;
            if (nodeName == "applet") {
                passed = false;
            }
            else {
                passed = !legacy_1.RPTUtil.isVideoObjEmbedLink(ruleContext);
            }
            if (passed)
                return null;
            if (!passed)
                return IEngine_1.RuleManual("Manual_1");
        }
    },
    {
        /**
         * Description: Trigger for audio/video with an alt attribute
         * Origin: RPT 5.6 G460
         */
        id: "RPT_Media_AudioVideoAltFilename",
        context: "dom:area[alt], dom:embed[alt]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var uri = "";
            if (ruleContext.nodeName.toLowerCase() == "area") {
                uri = ruleContext.getAttribute("href");
            }
            else {
                uri = ruleContext.getAttribute("src");
            }
            if (uri == null)
                uri = "";
            var ext = legacy_1.RPTUtil.getFileExt(uri);
            var isAudVid = ext.length != 0 && (legacy_1.RPTUtil.isAudioExt(ext) || legacy_1.RPTUtil.isVideoExt(ext));
            var altText = ruleContext.getAttribute("alt");
            var passed = !isAudVid || (altText.length > 0 && altText.indexOf(ext) == -1);
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger for possible video
         * Origin: RPT 5.6 G501
         */
        id: "RPT_Media_VideoObjectTrigger",
        context: "dom:embed, dom:object",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = !legacy_1.RPTUtil.isVideoObjEmbedLink(ruleContext);
            if (passed)
                return null;
            if (!passed)
                return IEngine_1.RuleManual("Manual_1");
        }
    },
    {
        /**
         * Description: Trigger for various image and color usage
         * Origin: RPT 5.6 G245
         */
        id: "RPT_Media_ImgColorUsage",
        context: "dom:embed, dom:object, dom:img, dom:applet, dom:script, dom:style, dom:input, dom:link," +
            "dom:*[style], dom:font[color], dom:tr[bgcolor], dom:th[bgcolor], " +
            "dom:td[bgcolor]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = false;
            // If there's style used, it fails anyway
            if (!ruleContext.hasAttribute("style")) {
                var nodeName = ruleContext.nodeName.toLowerCase();
                if (nodeName == "input") {
                    passed = !ruleContext.hasAttribute("type") ||
                        ruleContext.getAttribute("type").toLowerCase() != 'image';
                }
                else if (nodeName == "link") {
                    passed = !ruleContext.hasAttribute("rel") ||
                        ruleContext.getAttribute("rel").toLowerCase() != 'stylesheet';
                    // Only trigger on one link to prompt the manual check - that's enough
                    passed = legacy_1.RPTUtil.triggerOnce(ruleContext.ownerDocument, "RPT_Media_ImgColorUsage_Links", passed);
                }
                else if (nodeName == "embed" || nodeName == "object") {
                    if (ruleContext.hasAttribute("type")) {
                        var type = ruleContext.getAttribute("type");
                        passed = type.startsWith("text") || type.startsWith("audio");
                    }
                    if (!passed && ruleContext.hasAttribute("codetype")) {
                        var type = ruleContext.getAttribute("codetype");
                        passed = type.startsWith("text") || type.startsWith("audio");
                    }
                    if (!passed) {
                        var filename = ruleContext.getAttribute((nodeName == "embed") ? "src" : "data");
                        if (filename == null)
                            filename = "";
                        var ext = legacy_1.RPTUtil.getFileExt(filename);
                        passed = ext.length > 0 && legacy_1.RPTUtil.isAudioExt(ext);
                    }
                }
                else if (nodeName == "script") {
                    // Only trigger on one script to prompt the manual check - that's enough
                    passed = legacy_1.RPTUtil.triggerOnce(ruleContext.ownerDocument, "RPT_Media_ImgColorUsage_Scripts", passed);
                }
            }
            if (passed)
                return IEngine_1.RulePass("Pass_0");
            if (!passed)
                return IEngine_1.RulePotential("Potential_1");
        }
    },
    {
        /**
         * Description: Trigger for links to documents
         * Origin: CI162
         */
        id: "HAAC_Media_DocumentTrigger2",
        context: "dom:a[href],dom:area[href]",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var href = ruleContext.getAttribute("href");
            var ext = legacy_1.RPTUtil.getFileExt(href);
            var passed = ![".docx", ".doc", ".pdf", ".odt"].includes(ext);
            if (passed)
                return null;
            if (!passed)
                return IEngine_1.RuleManual("Manual_1");
        }
    }
];
exports.a11yRulesMedia = a11yRulesMedia;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesVideo = void 0;
var IEngine_1 = __webpack_require__(0);
var a11yRulesVideo = [
    {
        /**
         * Description: Trigger if video is missing Track with an attribute kind="caption"
         * Origin: CI162-HTML 5, G1117
         */
        id: "HAAC_Video_HasNoTrack",
        context: "dom:video",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = false;
            var tracks = ruleContext.getElementsByTagName("track");
            for (var i = 0; i < tracks.length; ++i) {
                passed = passed || tracks[i].getAttribute("kind") == 'captions';
            }
            // checks for addition of dynamic tracks
            if (ruleContext.textTracks && ruleContext.textTracks.length > 0) {
                for (var i = 0; i < ruleContext.textTracks.length; i++) {
                    passed = passed || ruleContext.textTracks[i].kind == 'captions';
                }
            }
            if (passed) {
                return IEngine_1.RulePass("Pass_0");
            }
            else {
                return IEngine_1.RuleFail("Fail_1");
            }
        }
    },
    {
        /**
         * Description: Trigger if HTML5 <audio> or <video> elements are used
         * Origin: CI162-HTML 5, G1119
         */
        id: "HAAC_Audio_Video_Trigger",
        context: "dom:audio, dom:video",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var passed = true;
            var nodeName = ruleContext.nodeName.toLowerCase();
            if (nodeName == "audio" || nodeName == "video") {
                passed = false;
            }
            return passed ? IEngine_1.RulePass("Pass_0") : IEngine_1.RuleManual("Manual_1");
        }
    }
];
exports.a11yRulesVideo = a11yRulesVideo;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.designRules = void 0;
var design_color_1 = __webpack_require__(58);
var design_gridlayout_1 = __webpack_require__(59);
var design_typography_1 = __webpack_require__(60);
var designRules = [].concat(design_color_1.designRulesColor, design_gridlayout_1.designRulesGrid, design_typography_1.designRulesType);
exports.designRules = designRules;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.designRulesColor = void 0;
var IEngine_1 = __webpack_require__(0);
var legacy_1 = __webpack_require__(1);
var PALETTE = [
    "#2c080a", "#4f0408", "#750e13", "#a51920", "#da1e28", "#fb4b53", "#ff767c", "#ffa4a9", "#fcd0d3", "#fff0f1", "#2a0a16", "#4f0027", "#760a3a", "#a11950", "#d12765", "#ee538b", "#fa75a6", "#ffa0c2", "#ffcfe1", "#fff0f6", "#1e1033", "#321260", "#4f2196", "#6e32c9", "#8a3ffc", "#a970ff", "#bb8eff", "#d0b0ff", "#e6d6ff", "#f7f1ff", "#051243", "#051b75", "#0530ad", "#054ada", "#0062ff", "#418cff", "#6ea6ff", "#97c1ff", "#c9deff", "#edf4ff", "#07192b", "#002749", "#003d73", "#0058a1", "#0072c3", "#1193e8", "#30b0ff", "#6ccaff", "#b3e6ff", "#e3f6ff", "#081a1c", "#002b30", "#004548", "#006161", "#007d79", "#009e9a", "#00bab6", "#20d5d2", "#87eded", "#dbfbfb", "#081b09", "#012e0e", "#054719", "#10642a", "#198038", "#24a249", "#3dbb61", "#56d679", "#9deeb2", "#dafbe4", "#000000", "#13171a", "#202529", "#373d42", "#50565b", "#697077", "#868d95", "#9fa5ad", "#b9bfc7", "#d8dce3", "#f2f4f8", "#ffffff", "#000000", "#171717", "#252525", "#3d3d3d", "#565656", "#6f6f6f", "#8c8c8c", "#a4a4a4", "#bebebe", "#dcdcdc", "#f3f3f3", "#ffffff", "#000000", "#1a1717", "#272424", "#403c3c", "#595555", "#726e6e", "#8f8b8b", "#a7a2a2", "#c1bcbb", "#e0dbda", "#f7f3f1", "#ffffff"
];
var designRulesColor = [{
        id: "DESIGN_COLOR_Palette_Foreground",
        context: "dom:*",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var hasText = false;
            var child = ruleContext.firstChild;
            while (child) {
                if (child.nodeType === 3 && child.nodeValue.trim().length > 0) {
                    hasText = true;
                }
                child = child.nextSibling;
            }
            var inBody = false;
            var parentWalk = ruleContext;
            while (parentWalk) {
                if (parentWalk.nodeName.toLowerCase() === "body") {
                    inBody = true;
                }
                parentWalk = parentWalk.parentElement;
            }
            if (!hasText || !inBody) {
                return null;
            }
            var colorCombo = legacy_1.RPTUtil.ColorCombo(ruleContext);
            var fg = colorCombo.fg.toHex();
            if (PALETTE.indexOf(fg) !== -1) {
                return IEngine_1.RulePass(1, [fg]);
            }
            else {
                return IEngine_1.RuleFail(2, [fg]);
            }
        }
    },
    {
        /**
         * Description: Trigger if the link text is empty or content under link is hidden
         * Origin: WCAG 2.0 Technique H30, H91
         */
        id: "DESIGN_COLOR_Palette_Background",
        context: "dom:*",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var parentWalk = ruleContext.parentElement;
            while (parentWalk) {
                if (legacy_1.RPTUtil.getCache(parentWalk, "DESIGN_COLOR_Palette_Background", null)) {
                    return null;
                }
                parentWalk = parentWalk.parentElement;
            }
            var colorCombo = legacy_1.RPTUtil.ColorCombo(ruleContext);
            var bg = colorCombo.bg.toHex();
            if (PALETTE.indexOf(bg) !== -1) {
                return IEngine_1.RulePass(1, [bg]);
            }
            else {
                legacy_1.RPTUtil.setCache(ruleContext, "DESIGN_COLOR_Palette_Background", true);
                return IEngine_1.RuleFail(2, [bg]);
            }
        }
    }
];
exports.designRulesColor = designRulesColor;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.designRulesGrid = void 0;
var IEngine_1 = __webpack_require__(0);
var designRulesGrid = [{
        id: "DESIGN_GridLayout_ImgAspectRatio",
        context: "aria:img",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var EPSILON = .0000001;
            var w = ruleContext.naturalWidth;
            var h = ruleContext.naturalHeight;
            var ratio = Math.max(w / h, h / w);
            if (Math.abs(ratio - 16 / 9.0) < EPSILON
                || Math.abs(ratio - 4 / 3.0) < EPSILON
                || Math.abs(ratio - 3 / 2.0) < EPSILON
                || Math.abs(ratio - 2 / 1.0) < EPSILON
                || Math.abs(ratio - 1 / 1.0) < EPSILON) {
                return IEngine_1.RulePass(1);
            }
            else {
                return IEngine_1.RuleFail(2);
            }
        }
    }];
exports.designRulesGrid = designRulesGrid;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.designRulesType = void 0;
var IEngine_1 = __webpack_require__(0);
var designRulesType = [{
        id: "DESIGN_Typography_Plex",
        context: "dom:*",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var inBody = false;
            var parentWalk = ruleContext;
            while (parentWalk) {
                if (parentWalk.nodeName.toLowerCase() === "style" || parentWalk.nodeName.toLowerCase() === "script") {
                    inBody = false;
                    break;
                }
                if (parentWalk.nodeName.toLowerCase() === "body") {
                    inBody = true;
                }
                parentWalk = parentWalk.parentElement;
            }
            var hasText = false;
            var child = ruleContext.firstChild;
            while (child) {
                if (child.nodeType === 3 && child.nodeValue.trim().length > 0) {
                    hasText = true;
                }
                child = child.nextSibling;
            }
            if (!inBody || !hasText) {
                return null;
            }
            var doc = ruleContext.ownerDocument;
            var style = doc.defaultView.getComputedStyle(ruleContext);
            var fontFamily = style.fontFamily;
            if (fontFamily.substring(0, "\"IBM Plex".length) === "\"IBM Plex") {
                return IEngine_1.RulePass(1, [fontFamily]);
            }
            else {
                return IEngine_1.RuleFail(2, [fontFamily]);
            }
        }
    },
    {
        id: "DESIGN_Typography_TextAlignLeft",
        context: "dom:*",
        run: function (context, options) {
            var ruleContext = context["dom"].node;
            var inBody = false;
            var parentWalk = ruleContext;
            while (parentWalk) {
                if (parentWalk.nodeName.toLowerCase() === "body") {
                    inBody = true;
                }
                parentWalk = parentWalk.parentElement;
            }
            var hasText = (ruleContext.innerText || "").trim().length > 0;
            if (!inBody || !hasText) {
                return null;
            }
            var doc = ruleContext.ownerDocument;
            var style = doc.defaultView.getComputedStyle(ruleContext);
            var textAlign = style.textAlign;
            if (!textAlign || textAlign === "left" || textAlign === "start") {
                return IEngine_1.RulePass(1);
            }
            else {
                return IEngine_1.RuleFail(2);
            }
        }
    }];
exports.designRulesType = designRulesType;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkNls = void 0;
var nls_1 = __webpack_require__(62);
var nls_2 = __webpack_require__(63);
var checkNls = {};
exports.checkNls = checkNls;
function addNls(nlsMap) {
    for (var key in nlsMap) {
        checkNls[key] = nlsMap[key];
    }
}
addNls(nls_1.a11yNls);
addNls(nls_2.designNls);


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yNls = void 0;
var a11yNls = {
    // JCH - DONE
    "RPT_List_Misuse": {
        0: "List elements should only be used for lists of related items",
        "Pass_0": "Rule Passed",
        "Potential_1": "List element is missing or improperly structured"
    },
    // JCH - DONE
    "RPT_Marquee_Trigger": {
        0: "The <marquee> element is obsolete and should not be used",
        "Passed_0": "Rule Passed",
        "Fail_1": "Scrolling content found that uses the obsolete <marquee> element"
    },
    // JCH - DONE
    "RPT_Headers_FewWords": {
        0: "Heading elements must not be used for presentation",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that the heading element is a genuine heading"
    },
    // JCH - DONE
    "WCAG20_Input_ExplicitLabelImage": {
        0: "The <input> element of type \"image\" should have a text alternative",
        "Pass_0": "Image button provides alternative text using the 'alt' attribute",
        "Pass_1": "Image button provides alternative text using a WAI-ARIA label",
        "Pass_2": "Image button provides alternative text using the 'title' attribute",
        "Fail": "The <input> element of type \"image\" has no text alternative"
    },
    // JCH - DONE
    "RPT_Img_UsemapValid": {
        0: "Server-side image map hot-spots must have duplicate text links",
        "Pass_0": "Rule Passed",
        "Potential_1": "Server-side image map hot-spots do not have duplicate text links"
    },
    // JCH - DONE
    "WCAG20_Object_HasText": {
        0: "<object> elements must have a text alternative for the content rendered by the object",
        "Pass_0": "Rule Passed",
        "Fail_1": "An <object> element does not have a text alternative"
    },
    // JCH - DONE
    "WCAG20_Applet_HasAlt": {
        0: "<applet> elements must provide an 'alt' attribute and an alternative description",
        "Pass_0": "Rule Passed",
        "Fail_1": "An <applet> element does not have an 'alt' attribute that provides a short text alternative",
        "Fail_2": "The 'alt' attribute value for an <applet> element duplicates the 'code' attribute",
        "Fail_3": "An <applet> element provides alternative text, but does not provide inner content"
    },
    // JCH - DONE
    "RPT_Media_AudioTrigger": {
        0: "Audio information should also be available in text form",
        "Pass_0": "Rule Passed",
        "Manual_1": "Provide transcripts for audio files"
    },
    // JCH - DONE
    "RPT_Blockquote_HasCite": {
        0: "Use <blockquote> only for quotations, not indentation",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that <blockquote> is used only for quotations, not indentation"
    },
    // JCH - DONE
    "RPT_Meta_Refresh": {
        0: "Pages should not refresh automatically",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify page is not being caused to refresh automatically"
    },
    // JCH - DONE
    "WCAG20_Frame_HasTitle": {
        0: "Inline frames must have a unique, non-empty 'title' attribute",
        "Pass_0": "Rule Passed",
        "Fail_1": "Inline frame does not have a 'title' attribute"
    },
    // JCH - DONE
    "WCAG20_Input_ExplicitLabel": {
        0: "Each form control must have an associated label",
        "Pass_0": "Rule Passed",
        "Fail_1": "Form control element <{0}> has no associated label",
        "Fail_2": "Form control with \"{0}\" role has no associated label"
    },
    // JCH - DONE
    "RPT_Media_AltBrief": {
        0: "Alternative text in 'alt' attribute should be brief (<150 characters)",
        "Pass_0": "Rule Passed",
        "Potential_1": "Text alternative is more than 150 characters"
    },
    // JCH - DONE
    "WCAG20_A_TargetAndText": {
        0: "Users should be warned in advance if their input action will open a new window or otherwise change their context",
        "Pass_0": "Rule Passed",
        "Potential_1": "Inform the user when their input action will open a new window or otherwise change their context"
    },
    // JCH - DONE
    "WCAG20_Area_HasAlt": {
        0: "<area> elements in an image map must have a text alternative",
        "Pass_0": "Rule Passed",
        "Fail_1": "<area> element in an image map has no text alternative"
    },
    // JCH - DONE
    "RPT_Media_ImgColorUsage": {
        0: "Do not use color as the only means to convey information, provide an additional non-color cue",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify color is not the only means to convey information"
    },
    // JCH - DONE
    "WCAG20_Meta_RedirectZero": {
        0: "Page should not automatically refresh without warning or option to turn it off or adjust the time limit",
        "Pass_0": "Rule Passed",
        "Fail_1": "Check page does not automatically refresh without warning or options"
    },
    // JCH - DONE
    "RPT_Elem_Deprecated": {
        0: "Avoid use of obsolete language features if possible",
        "Pass_0": "Rule Passed",
        "Potential_1": "Obsolete language features are being used"
    },
    // JCH - DONE
    "ext_quoted_valid": {
        0: "Quotations should be marked with <q> or <blockquote> elements",
        "Pass_0": "Rule Passed",
        "Potential_1": "If the following text is a quotation, mark it as a <q> or <blockquote> element: {0}"
    },
    // JCH - DONE
    "RPT_Elem_EventMouseAndKey": {
        0: "All interactive content with mouse event handlers must have equivalent keyboard access",
        "Pass_0": "Rule Passed",
        "Manual_1": "Confirm the <{0}> element with mouse event handler(s) '{1}' has a corresponding keyboard handler(s)"
    },
    // JCH - DONE
    "WCAG20_Doc_HasTitle": {
        0: "The page should have a title that correctly identifies the subject of the page",
        "Pass_0": "Rule Passed",
        "Fail_1": "Missing <head> element so there can be no <title> element present",
        "Fail_2": "Missing <title> element in <head> element",
        "Fail_3": "The <title> element is empty (no innerHTML)"
    },
    // JCH - DONE
    "RPT_Block_ShouldBeHeading": {
        0: "Heading text must use a heading element",
        "Pass_0": "Rule Passed",
        "Potential_1": "Check text that looks like a heading but is not within a heading element"
    },
    // JCH - DONE
    "WCAG20_Form_HasSubmit": {
        0: "A <form> element should have a submit button or an image button",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify the <form> element has a submit button or an image button"
    },
    // JCH - DONE
    "RPT_Elem_UniqueId": {
        0: "Element 'id' attribute values must be unique within a document",
        "Pass_0": "Rule Passed",
        "Fail_1": "The <{0}> element has the id \"{1}\" that is empty",
        "Fail_2": "The <{0}> element has the id \"{1}\" that is already in use"
    },
    // JCH - DONE
    "RPT_Font_ColorInForm": {
        0: "Combine color and descriptive markup to indicate required form fields",
        "Pass_0": "Rule Passed",
        "Potential_1": "Check color is not used as the only visual means to convey which fields are required"
    },
    // JCH - DONE
    "RPT_Label_UniqueFor": {
        0: "Form controls should have exactly one label",
        "Pass_0": "Rule Passed",
        "Fail_1": "Form control has more than one label"
    },
    // JCH - DONE
    "RPT_Img_AltCommonMisuse": {
        0: "'alt' attribute value must be a good inline replacement for the image",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that the file name serves as a good inline replacement for the image"
    },
    // JCH - DONE
    "RPT_Img_LongDescription2": {
        0: " The 'longdesc' attribute must reference HTML content",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that the file designated by the 'longdesc' attribute contains valid HTML content (file extension not recognized)"
    },
    // JCH - DONE
    "WCAG20_Img_HasAlt": {
        0: "Images must have an 'alt' attribute with a short text alternative if they convey meaning, or 'alt=\"\" if decorative",
        "Pass_0": "Rule Passed",
        "Fail_1": "Image 'alt' attribute value consists only of whitespace",
        "Fail_2": "Image does not have an 'alt' attribute short text alternative"
    },
    // JCH - DONE
    "RPT_Style_BackgroundImage": {
        0: "Images included by using CSS alone must not convey important information",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify the CSS background image does not convey important information"
    },
    // JCH - DONE
    "RPT_Pre_ASCIIArt": {
        0: "ASCII art must have a text alternative",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that ASCII art has a text alternative"
    },
    // JCH - DONE
    "RPT_Media_VideoReferenceTrigger": {
        0: "Pre-recorded media should have an audio track that describes visual information",
        "Pass_0": "Rule Passed",
        "Manual_1": "Verify availability of a user-selectable audio track with description of visual content"
    },
    // JCH - DONE
    "RPT_Media_AudioVideoAltFilename": {
        0: "Audio or video on the page must have a short text alternative that describes the media content",
        "Pass_0": "Rule Passed",
        "Potential_1": "Filename used as label for embedded audio or video"
    },
    // JCH - DONE
    "RPT_Style_ColorSemantics1": {
        0: "Combine color and descriptive markup to convey information",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify color is not used as the only visual means of conveying information"
    },
    // JCH - DONE
    "WCAG20_Select_HasOptGroup": {
        0: "Groups of related options within a selection list should be grouped with <optgroup>",
        "Pass_0": "Rule Passed",
        "Potential_1": "Group of related options may need <optgroup>"
    },
    // JCH - DONE
    "RPT_List_UseMarkup": {
        0: "Use proper HTML list elements to create lists",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify whether this is a list that should use HTML list elements"
    },
    // JCH - DONE
    "RPT_Script_OnclickHTML1": {
        0: "Scripts should not be used to emulate links",
        "Pass_0": "Rule Passed",
        "Potential_1": "Possible use of a script to emulate a link"
    },
    // JCH - DONE
    "WCAG20_Table_Structure": {
        0: "Table elements with 'role=\"presentation\" or 'role=\"none\" should not have structural elements or attributes",
        "Pass_0": "Rule Passed",
        "Fail_1": "The <{0}> element with \"presentation\" role or \"none\" role has structural element(s) and/or attribute(s) '{1}'"
    },
    // JCH - DONE
    "WCAG20_Img_AltTriggerNonDecorative": {
        0: "Convey information with text rather than images of text",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that images of text are not used to convey information"
    },
    // JCH - DONE
    "WCAG20_Blink_AlwaysTrigger": {
        0: "Content that blinks persistently must not be used",
        "Pass_0": "Rule Passed",
        "Fail_1": "Content found that blinks persistently"
    },
    // JCH - DONE
    "RPT_Blink_CSSTrigger1": {
        0: "Do not use the \"blink\" value of the 'text-decoration' property for longer than five seconds",
        "Pass_0": "Rule Passed",
        "Potential_1": "Check the \"blink\" value of the CSS 'text-decoration' property is not used for more than than five seconds"
    },
    // JCH - DONE
    "RPT_Html_SkipNav": {
        0: "Provide a way to bypass blocks of content that are repeated on multiple Web pages",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify there is a way to bypass blocks of content that are repeated on multiple Web pages"
    },
    // JCH - DONE
    "RPT_Title_Valid": {
        0: "Page <title> should be a descriptive title, rather than a filename",
        "Pass_0": "Rule Passed",
        "Fail_1": "Page <title> is empty",
        "Potential_2": "Verify that using the filename as the page <title> value is descriptive"
    },
    // JCH - DONE
    "RPT_Header_HasContent": {
        0: "Heading elements must provide descriptive text",
        "Pass_0": "Rule Passed",
        "Fail_1": "Heading element has no descriptive content"
    },
    // JCH - DONE
    // JCH - 0: provides the general DAP message for the rule
    //       "Pass_i" ???
    //       "Fail_j" descriptive message for specific failure
    //       "Potential_k" descriptive message describing case when it is not a failure 
    //                     but needs other checking to confirm pass or
    "WCAG20_Html_HasLang": {
        0: "Page must identify the default language of the document with a 'lang' attribute",
        "Pass_0": "Page language detected as \"{0}\"",
        "Fail_1": "Page detected as XHTML 1.0, but has neither 'lang' nor 'xml:lang' attributes",
        "Fail_2": "Page detected as XHTML, but does not have an 'xml:lang' attribute",
        "Fail_3": "Page detected as HTML, but does not have a 'lang' attribute",
        "Fail_4": "Page detected as XHTML 1.0 with 'lang' and 'xml:lang' attributes that do not match: \"{0}\", \"{1}\"",
        "Potential_5": "Page detected as XHTML 1.0 with only a 'lang' attribute. Confirm that page is only delivered via text/html mime type",
        "Potential_6": "Page detected as XHTML 1.0 with only an 'xml:lang' attribute. Confirm that page is only delivered via xml mime type"
    },
    // JCH - DONE
    "WCAG20_Form_TargetAndText": {
        0: "User should be informed in advance when interacting with content causes a change of context",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that interacting with content will not open pop-up windows or change the active window without informing the user"
    },
    // JCH - DONE
    "WCAG20_A_HasText": {
        0: "Hyperlinks must have a text description of their purpose",
        "Pass_0": "Hyperlink has a description of its purpose",
        "Fail_1": "Hyperlink has no link text, label or image with a text alternative"
    },
    // JCH - DONE
    "WCAG20_Fieldset_HasLegend": {
        0: " <fieldset> elements must have a single, non-empty <legend> as a label",
        "Pass_0": "Rule Passed",
        "Fail_1": "<fieldset> element does not have a <legend>",
        "Fail_2": "<fieldset> element has more than one <legend>",
        "Fail_3": "<fieldset> element <legend> is empty"
    },
    // JCH - DONE
    "RPT_Media_VideoObjectTrigger": {
        0: "Live media (streaming video with audio) should have captions for audio content",
        "Pass_0": "Rule Passed",
        "Manual_1": "Verify captions are provided for live media (streaming video with audio)"
    },
    // JCH - DONE
    "RPT_Text_SensoryReference": {
        0: "Instructions must be meaningful without shape or location words",
        "Pass_0": "Rule Passed",
        "Potential_1": "If the word(s) '{0}' is part of instructions for using page content, check it is still understandable without this location or shape information"
    },
    // JCH - DONE
    "RPT_Embed_AutoStart": {
        0: "Mechanism must be available to pause or stop and control the volume of the audio that plays automatically",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify there is a mechanism to pause or stop and control the volume for the audio that plays automatically"
    },
    // JCH - DONE
    "RPT_Style_HinderFocus1": {
        0: "The keyboard focus indicator must be highly visible when default border or outline is modified by CSS",
        "Pass_0": "Rule Passed",
        "Potential_1": "Check the keyboard focus indicator is highly visible when using CSS elements for border or outline"
    },
    // JCH - DONE
    "WCAG20_Elem_Lang_Valid": {
        0: "The language of content must be specified in accordance with BCP 47",
        "Pass_0": "Rule Passed",
        "Fail_1": "Specified language is not valid BCP 47"
    },
    // JCH - DONE
    "WCAG20_Img_LinkTextNotRedundant": {
        0: "The text alternative for an image within a link should not repeat the link text or adjacent link text",
        "Pass_0": "Rule Passed",
        "Fail_1": "Link text is repeated in an image 'alt' value within the same link",
        "Fail_2": "Link text of previous link is repeated in image 'alt' value of a link",
        "Fail_3": "Image 'alt' value within a link is repeated in link text of the link after"
    },
    // JCH - DONE
    "RPT_Style_ExternalStyleSheet": {
        0: "Check external style sheets to ensure that CSS is not used to add images that convey important information in the content.",
        "Pass_0": "Rule Passed",
        "Potential_1": "External style sheets detected ensure that CSS does not add images that convey important information in the content."
    },
    // JCH - DONE
    "RPT_Header_Trigger": {
        0: "Heading text should correctly describe the subject of the web page sections",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that heading text correctly describes the subject of each web page section"
    },
    // JCH - DONE
    "RPT_Script_OnclickHTML2": {
        0: "Scripts should not be used to emulate links",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that 'onclick' events are not used in script to emulate a link"
    },
    // JCH - DONE
    "WCAG20_Table_CapSummRedundant": {
        0: "The table summary must not duplicate the caption",
        "Pass_0": "Rule Passed",
        "Fail_1": "The table summary duplicates the caption"
    },
    // JCH - DONE
    "WCAG20_Input_LabelBefore": {
        0: "Text inputs and <select> elements must have a label before the input control",
        "Pass_0": "Rule Passed",
        "Fail_1": "Text input is nested in label, so label is not before the text input control",
        "Fail_2": "Label text is located after its associated text input or <select> element"
    },
    // JCH - DONE
    "WCAG20_Input_LabelAfter": {
        0: "Checkboxes and radio buttons must have a label after the input control",
        "Pass_0": "Rule Passed",
        "Fail_1": "Checkbox or radio button is nested in label, so label is not after the input control",
        "Fail_2": "Label text is located before its associated checkbox or radio button element"
    },
    // JCH - DONE
    "WCAG20_Embed_HasNoEmbed": {
        0: "<embed> elements should be immediately followed by a non-embedded element",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that the <embed> element is immediately followed by a non-embedded element"
    },
    // JCH - DONE
    "WCAG20_Table_Scope_Valid": {
        0: "Value for 'scope' attribute must be \"row\", \"col\", \"rowgroup\", or \"colgroup\"",
        "Pass_0": "Rule Passed",
        "Fail_1": "Value provided is invalid for the 'scope' attribute"
    },
    // JCH - DONE
    "WCAG20_Img_TitleEmptyWhenAltNull": {
        0: "When the image 'alt' attribute is empty, the 'title' attribute must also be empty",
        "Pass_0": "Rule Passed",
        "Fail_1": "The image 'alt' attribute is empty, but the 'title' attribute is not empty"
    },
    // JCH - DONE
    "WCAG20_Input_InFieldSet": {
        0: "Groups of logically related input elements should be contained within a <fieldset> element",
        "Pass_0": "Rule Passed",
        "Potential_1": "Use the <fieldset> element to group logically related input elements"
    },
    // JCH - DONE
    "WCAG20_Input_RadioChkInFieldSet": {
        0: "Related sets of radio buttons or checkboxes should be programmatically grouped",
        "Pass_LoneNogroup": "{0} grouping not required for a control of this type",
        "Pass_Grouped": "{0} input is grouped with other related controls with the same name",
        "Pass_RadioNoName": "Radio input is not grouped, but passes because it has no name to group with other radio inputs",
        "Fail_ControlNameMismatch": "{0} input found that has the same name, \"{2}\" as a {1} input",
        "Potential_LoneCheckbox": "Verify that this ungrouped checkbox input is not related to other checkboxes",
        "Potential_UnnamedCheckbox": "Verify that this un-named, ungrouped checkbox input is not related to other checkboxes",
        "Fail_NotGroupedOtherGrouped": "{0} input is not in the group with another {0} with the name \"{1}\"",
        "Fail_NotGroupedOtherNotGrouped": "{0} input and others with the name \"{1}\" are not grouped together",
        "Fail_NotSameGroup": "{0} input is in a different group than another {0} with the name \"{1}\""
    },
    // JCH - DONE
    "WCAG20_Select_NoChangeAction": {
        0: "No changes of context should occur when a selection value receives focus",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that no change of context or action occurs when selection options in this component receive focus"
    },
    // JCH - DONE
    "WCAG20_Input_HasOnchange": {
        0: "Verify that any changes of context are explained in advance to the user",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that any changes of context are explained in advance to the user"
    },
    // JCH - DONE
    "RPT_Embed_HasAlt": {
        0: "Provide alternative content for <embed> elements",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that the <embed> element has alternative content"
    },
    // JCH - DONE
    "Valerie_Noembed_HasContent": {
        0: "<noembed> elements should contain descriptive text",
        "Pass_0": "Rule Passed",
        "Potential_1": "Add descriptive text to the <noembed> element"
    },
    // JCH - DONE
    "Valerie_Caption_HasContent": {
        0: "A <caption> element for a <table> element must contain descriptive text",
        "Pass_0": "Rule Passed",
        "Fail_1": "The <table> element has an empty <caption> element"
    },
    // JCH - DONE
    "Valerie_Caption_InTable": {
        0: "The <caption> element must be nested inside the associated <table> element",
        "Pass_0": "Rule Passed",
        "Fail_1": "<caption> element is not nested inside a <table> element"
    },
    // JCH - DONE
    "Valerie_Label_HasContent": {
        0: "A <label> element must have non-empty descriptive text that identifies the purpose of the interactive component",
        "Pass_Regular": "<label> element has accessible name with inner content",
        "Pass_AriaLabel": "<label> element has accessible name via 'aria-label'",
        "Pass_LabelledBy": "<label> element has accessible name via 'aria-labelledby'",
        "Fail_1": "The <label> element does not have descriptive text that identifies the expected input"
    },
    // JCH - DONE
    "Valerie_Elem_DirValid": {
        0: "'dir' attribute value must be \"ltr\", \"rtl\", or \"auto\"",
        "Pass_0": "Rule Passed",
        "Fail_1": "Invalid value used for the 'dir' attribute"
    },
    // JCH - DONE
    "Valerie_Frame_SrcHtml": {
        0: "A <frame> containing non-HTML content must be made accessible",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify <frame> content is accessible"
    },
    // JCH - DONE
    "Valerie_Table_DataCellRelationships": {
        0: "For a complex data table, all <th> and <td> elements must be related via 'header' or 'scope' attributes",
        "Pass_0": "Rule Passed",
        "Fail_1": "Complex table does not have headers for each cell properly defined with 'header' or 'scope'"
    },
    // JCH - DONE
    "RPT_Table_LayoutTrigger": {
        0: "Avoid using tables to format text documents in columns unless the table can be linearized",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify table is not being used to format text content in columns unless the table can be linearized"
    },
    // JCH - DONE
    "RPT_Table_DataHeadingsAria": {
        0: "Data table must identify headers",
        "Pass_0": "Rule Passed",
        "Fail_1": "Table has no headers identified"
    },
    // JCH - DONE
    "WCAG20_Label_RefValid": {
        0: "The 'for' attribute must reference a non-empty, unique 'id' attribute of an <input> element",
        "Pass_0": "Rule Passed",
        "Fail_1": "The value \"{0}\" of the 'for' attribute is not the 'id' of a valid <input> element"
    },
    // JCH - DONE
    "WCAG20_Elem_UniqueAccessKey": {
        0: "'accesskey' attribute values on each element must be unique for the page",
        "Pass_0": "Rule Passed",
        "Fail_1": "'accesskey' attribute value on the element is not unique"
    },
    // JCH - DONE
    "WCAG20_Script_FocusBlurs": {
        0: "Scripting must not remove focus from content that normally receives focus",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify script does not remove focus from content that normally receives focus"
    },
    // JCH - DONE
    "HAAC_Img_UsemapAlt": {
        0: "An image map and each <area> element in an image map must have text alternative(s)",
        "Pass_0": "Rule Passed",
        "Fail_1": "Image map or child <area> has no text alternative"
    },
    // JCH - DONE
    "WCAG20_Text_Emoticons": {
        0: "Emoticons must have a short text alternative that describes their purpose",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that emoticons have a text alternative"
    },
    // JCH - DONE
    "WCAG20_Style_BeforeAfter": {
        0: "Do not use CSS '::before' and '::after' pseudo-elements to insert non-decorative content",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify the '::before' and '::after' pseudo-elements do not insert non-decorative content"
    },
    // JCH - DONE
    "WCAG20_Text_LetterSpacing": {
        0: "Use CSS 'letter-spacing' to control spacing within a word",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify space characters are not being used to create space between the letters of a word"
    },
    // JCH - DONE
    "Rpt_Aria_ValidRole": {
        0: "Elements must have a valid 'role' per WAI-ARIA specification",
        "Pass_0": "Rule Passed",
        "Fail_1": "The 'role' defined on the element is not valid per WAI-ARIA specification"
    },
    // JCH - DONE
    "Rpt_Aria_ValidPropertyValue": {
        0: "WAI-ARIA property values must be valid",
        "Pass_0": "Rule Passed",
        "Fail_1": "The value \"{0}\" specified for attribute '{1}' on element <{2}> is not valid"
    },
    // JCH - DONE
    "Rpt_Aria_ValidIdRef": {
        0: "The WAI-ARIA property must reference a non-empty unique id of an existing element that is visible",
        "Pass_0": "Rule Passed",
        "Fail_1": "The 'id' \"{0}\" specified for the WAI-ARIA property '{1}' value is not valid"
    },
    // JCH - DONE
    "Rpt_Aria_RequiredProperties": {
        0: "When using a WAI-ARIA role on an element, the required attributes for that role must be defined",
        "Pass_0": "Rule Passed",
        "Fail_1": "An element with WAI-ARIA role '{0}' does not have the required WAI-ARIA attribute(s): '{1}'"
    },
    // JCH - DONE
    "Rpt_Aria_EmptyPropertyValue": {
        0: "When specifying a required WAI-ARIA attribute, the value must not be empty",
        "Pass_0": "Rule Passed",
        "Fail_1": "The element attribute(s): '{0}' value is empty"
    },
    // JCH - DONE
    "Rpt_Aria_ValidProperty": {
        0: "WAI-ARIA attributes must be valid for the element's role",
        "Pass_0": "Rule Passed",
        "Fail_1": "The attribute(s) '{0}' referenced by the element <{1}> is not a valid WAI-ARIA state or property"
    },
    // JCH - DONE
    "Rpt_Aria_InvalidTabindexForActivedescendant": {
        0: "Element using 'aria-activedescendant' property must have its 'tabindex' attribute value set to 0 or -1 to be keyboard accessible",
        "Pass_0": "Rule Passed",
        "Fail_1": "The <{0}> element using 'aria-activedescendant' set to \"{1}\" does not have its 'tabindex' attribute value set to 0 or -1"
    },
    // JCH - DONE
    "Rpt_Aria_MissingFocusableChild": {
        0: "UI component must have at least one focusable child element for keyboard access",
        "Pass_0": "Rule Passed",
        "Fail_1": "The descendent <{0}> element with \"{1}\" role has no focusable child element"
    },
    // JCH - DONE
    "Rpt_Aria_MissingKeyboardHandler": {
        0: "Interactive WAI_ARIA UI components must provide keyboard access",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify the <{0}> element with \"{1}\" role has keyboard access"
    },
    // JCH - DONE
    "WCAG20_Img_PresentationImgHasNonNullAlt": {
        0: "Image designated as decorative must have 'alt=\"\"",
        "Pass_0": "Rule Passed",
        "Fail_1": "Image designated as decorative has non-null 'alt' attribute"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleSearchLandmarks": {
        0: "Each element with \"search\" role must have a unique label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"search\" role do not have unique labels"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleApplicationLandmarks": {
        0: "Each element with \"application\" role must have a unique label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"application\" role do not have unique labels"
    },
    // JCH - DONE
    "Rpt_Aria_ApplicationLandmarkLabel": {
        0: "An element with \"application\" role must have a label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "Element with \"application\" role does not have a label"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleDocumentRoles": {
        0: "All elements with a \"document\" role must have unique labels",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with a \"document\" role do not have unique labels"
    },
    // JCH - DONE
    "WCAG20_Label_TargetInvisible": {
        0: "Do not label hidden <input> elements ('type=\"hidden\")",
        "Pass_0": "Rule Passed",
        "Potential_1": "Hidden <input> element ('type=\"hidden\") is possibly labelled"
    },
    // JCH - DONE
    "HAAC_Video_HasNoTrack": {
        0: "Media embedded with a <video> element must have a <track> element to provide text alternatives for audio or visual content",
        "Pass_0": "Rule Passed",
        "Fail_1": "Media embedded with a <video> element does not have a <track> element to provide text alternatives for audio or visual content"
    },
    // JCH - DONE
    "HAAC_Audio_Video_Trigger": {
        0: "Media using <audio> and/or <video> elements must have keyboard accessible controls",
        "Pass_0": "Rule Passed",
        "Manual_1": "Verify media using <audio> and/or <video> elements have keyboard accessible controls"
    },
    // JCH - DONE
    "HAAC_Input_HasRequired": {
        0: "If the application must be accessible in Internet Explorer 8, use 'aria-required' instead of the HTML5 'required' property",
        "Pass_0": "Rule Passed",
        "Potential_1": "If the application must be accessible in Internet Explorer 8, use 'aria-required' instead of the HTML5 'required' property"
    },
    // JCH - DONE
    "HAAC_Aria_ImgAlt": {
        0: "An element with \"img\" role must have a non-empty label",
        "Pass_0": "Rule Passed",
        "Fail_1": "Element with \"img\" role has no label",
        "Fail_2": "Element with \"img\" role has no label or an empty label",
        "Fail_3": "Element with \"img\" role missing non-empty 'aria-label' or 'aria-labelledby'"
    },
    // JCH - DONE
    "HAAC_BackgroundImg_HasTextOrTitle": {
        0: "Background images that convey important information must have a text alternative that describes the image",
        "Pass_0": "Rule Passed",
        "Manual_1": "Verify important background image information has a text alternative in system high contrast mode"
    },
    // JCH - DONE
    "HAAC_Accesskey_NeedLabel": {
        0: "An HTML element with an assigned 'accesskey' attribute must have an associated label",
        "Pass_0": "Rule Passed",
        "Potential_1": "The HTML element with an assigned 'accesskey' attribute does not have an associated label"
    },
    // JCH - DONE
    "HAAC_Aria_Or_HTML5_Attr": {
        0: "HTML5 attributes must not conflict with the associated WAI-ARIA attribute used on an input element",
        "Pass_0": "Rule Passed",
        "Fail_1": "HTML5 attribute is in conflict with the associated WAI-ARIA attribute used on an input element"
    },
    // JCH - DONE
    "HAAC_Canvas": {
        0: "The <canvas> element may not be accessible",
        "Pass_0": "Rule Passed",
        "Manual_1": "Verify accessibility of the <canvas> element"
    },
    // JCH - DONE
    "HAAC_Figure_label": {
        0: "A <figure> element must have an associated label",
        "Pass_0": "Rule Passed",
        "Fail_1": "The <figure> element does not have an associated label"
    },
    // JCH - DONE
    "HAAC_Input_Placeholder": {
        0: "HTML5 'placeholder' attribute must not be used as a visible label replacement",
        "Pass_0": "Rule Passed",
        "Potential_1": "HTML5 placeholder is the only visible label",
        "Potential_2": "Additional visible label referenced by 'aria-labelledby' is not valid"
    },
    // JCH - DONE
    "HAAC_Aria_Native_Host_Sematics": {
        0: "WAI-ARIA roles and attributes must be valid for the element they are assigned to",
        "Pass_0": "Rule Passed",
        "Fail_1": "The WAI-ARIA role or attribute '{0}' is not valid for the element <{1}>"
    },
    // JCH - DONE
    "RPT_Form_ChangeEmpty": {
        0: "A form should not be submitted automatically without warning the user",
        "Pass_0": "Rule Passed",
        "Potential_1": "Confirm the form does not submit automatically without warning"
    },
    // JCH - DONE
    "IBMA_Color_Contrast_WCAG2AA": {
        0: "The contrast ratio of text with its background must meet WCAG 2.1 AA requirements",
        "Pass_0": "Rule Passed",
        "Fail_1": "Text contrast of {0} with its background is less than the WCAG AA minimum requirements for text of size {1}px and weight of {2}"
    },
    // JCH - DONE
    "IBMA_Color_Contrast_WCAG2AA_PV": {
        0: "The contrast ratio of text with its background (i.e. background with a color gradient or a background image) must meet WCAG 2.1 AA requirements",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify the contrast ratio of the text against the lightest and the darkest colors of the background meets the WCAG 2.1 AA minimum requirements for text of size {1}px and weight of {2}"
    },
    // JCH - DONE
    "WCAG20_Body_FirstASkips_Native_Host_Sematics": {
        0: "Pages must provide a way to skip directly to the main content",
        "Pass_0": "Rule Passed",
        "Fail_1": "The page does not provide a way to quickly navigate to the main content (WAI-ARIA \"main\" landmark or a skip link)"
    },
    // JCH - DONE
    "WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics": {
        0: "The description of a hyperlink used to skip content must communicate where it links to",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that if this hyperlink skips content, the description communicates where it links to"
    },
    // JCH - DONE
    "Rpt_Aria_RequiredChildren_Native_Host_Sematics": {
        0: "An element with a WAI-ARIA role must contain required children",
        "Pass_0": "Rule Passed",
        "Potential_1": "The element with WAI-ARIA role of \"{0}\" does not contain or own at least one child element with each of the following WAI-ARIA roles: \"{1}\""
    },
    // JCH - DONE
    "Rpt_Aria_RequiredParent_Native_Host_Sematics": {
        0: "An element with a WAI-ARIA role must be contained within a valid element",
        "Pass_0": "Rule Passed",
        "Fail_1": "The element with \"{0}\" role is not contained in or owned by an element with one of the following WAI-ARIA roles: \"{1}\""
    },
    // JCH - DONE
    "Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics": {
        0: "Elements with event handlers must have a valid WAI-ARIA role",
        "Pass_0": "Rule Passed",
        "Fail_1": "The <{0}> element with '{1}' does not have a valid WAI-ARIA role specified"
    },
    // JCH - DONE
    "Rpt_Aria_WidgetLabels_Implicit": {
        0: "Interactive component must have a programmatically associated name",
        "Pass_0": "Rule Passed",
        "Fail_1": "Interactive component does not have a programmatically associated name"
    },
    // JCH - DONE
    "Rpt_Aria_OrphanedContent_Native_Host_Sematics": {
        0: "All content must reside within an element with a landmark role",
        "Pass_0": "Rule Passed",
        "Fail_1": "Content is not within a landmark element"
    },
    // JCH - DONE
    "Rpt_Aria_RegionLabel_Implicit": {
        0: "Each element with \"region\" role must have a label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "Section element with an implicit \"region\" role is not labeled with an 'aria-label' or 'aria-labelledby'",
        "Fail_2": "The element with \"region\" role is not labeled with an 'aria-label' or 'aria-labelledby'"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleMainsVisibleLabel_Implicit": {
        0: "Each element with \"main\" role should have a unique visible label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"main\" role do not have unique visible labels"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleBannerLandmarks_Implicit": {
        0: "Each element with \"banner\" role must have a unique label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"banner\" role do not have unique labels"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleComplementaryLandmarks_Implicit": {
        0: "Each element with \"complementary\" role must have a unique label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"complementary\" role do not have unique labels"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleContentinfoLandmarks_Implicit": {
        0: "Each element with \"contentinfo\" role must have a unique label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"contentinfo\" role do not have unique labels"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleFormLandmarks_Implicit": {
        0: "Each element with \"form\" role must have a unique label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"form\" role do not have unique labels"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleNavigationLandmarks_Implicit": {
        0: "Each element with \"nav\" role must have a unique label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"nav\" role do not have unique labels"
    },
    // JCH - DONE
    "Rpt_Aria_ComplementaryLandmarkLabel_Implicit": {
        0: "Each element with \"complementary\" role should have a visible label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "The element with \"complementary\" role does not have a visible label"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleArticleRoles_Implicit": {
        0: "Each element with \"article\" role must have a unique label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"article\" role do not have unique labels"
    },
    // JCH - DONE
    "Rpt_Aria_ArticleRoleLabel_Implicit": {
        0: "An element with \"article\" role must have a label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "The element with \"article\" role does not have a label"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleGroupRoles_Implicit": {
        0: "Each element with \"group\" role must have a unique label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"group\" role do not have unique labels"
    },
    // JCH - DONE
    "Rpt_Aria_GroupRoleLabel_Implicit": {
        0: "An element with \"group\" role should have a unique label that describes its purpose",
        "Pass_0": "Rule Passed",
        "Fail_1": "The <{0}> element with \"group\" role does not have a label"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit": {
        0: "A page, document or application should only have one element with \"contentinfo\" role",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"contentinfo\" role found on a page"
    },
    // JCH - DONE
    "Rpt_Aria_OneBannerInSiblingSet_Implicit": {
        0: "There must be only one element with \"banner\" role on the page",
        "Pass_0": "Rule Passed",
        "Fail_1": "There is more than one element with \"banner\" role on the page"
    },
    // JCH - DONE
    "Rpt_Aria_ContentinfoWithNoMain_Implicit": {
        0: "An element with \"contentinfo\" role is only permitted with an element with \"main\" role",
        "Pass_0": "Rule Passed",
        "Fail_1": "The element with \"contentinfo\" role is present without an element with \"main\" role"
    },
    // JCH - DONE
    "Rpt_Aria_ComplementaryRequiredLabel_Implicit": {
        0: "An element with \"complementary\" role must have a label",
        "Pass_0": "Rule Passed",
        "Fail_1": "The element with \"complementary\" role does not have a label"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleRegionsUniqueLabel_Implicit": {
        0: "Each element with a \"region\" role must have a unique label",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"region\" role do not have unique labels"
    },
    // JCH - DONE
    "IBMA_Focus_Tabbable": {
        0: "Component must have at least one tabbable element",
        "Pass_0": "Rule Passed",
        "Potential_1": "Component with \"{0}\" role does not have a tabbable element"
    },
    // JCH - DONE
    "IBMA_Focus_MultiTab": {
        0: "Certain components must have no more than one tabbable element",
        "Pass_0": "Rule Passed",
        "Potential_1": "Component with \"{0}\" role has more than one tabbable element"
    },
    // JCH - DONE
    "WCAG20_Table_SummaryAria3": {
        0: "Complex data tables should have a 'summary' or an 'aria-describedby' that references an overview of the table",
        "Pass_0": "Rule Passed",
        "Potential_1": "A complex data table should have a 'summary' or an 'aria-describedby' that references an overview of the table"
    },
    // JCH - DONE
    "RPT_Style_Trigger2": {
        0: "Windows high contrast mode must be supported for CSS background images",
        "Pass_0": "Rule Passed",
        "Manual_1": "Confirm Windows high contrast mode is supported for CSS background images"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleMainsRequireLabel_Implicit_2": {
        0: "Elements with \"main\" role must have unique labels",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple elements with \"main\" role do not have unique labels"
    },
    // JCH - DONE
    "HAAC_Media_DocumentTrigger2": {
        0: "File download mechanisms should be keyboard-operable and preserve page focus location",
        "Pass_0": "Rule Passed",
        "Manual_1": "Verify that the file download mechanism does not cause a keyboard trap"
    },
    // JCH - DONE
    "HAAC_Aria_ErrorMessage": {
        0: "A custom error message must reference a valid 'id' value and when triggered the message must be appropriately exposed",
        "Pass_0": "Rule Passed",
        "Fail_1": "Custom error message has invalid reference 'id' value",
        "Fail_2": "Custom error message is not visible"
    },
    // JCH - DONE
    "HAAC_List_Group_ListItem": {
        0: "List component with \"group\" role must limit children to <listitem> elements",
        "Pass_0": "Rule Passed",
        "Fail_1": "List component with \"group\" role has children that are not <listitem> elements"
    },
    // JCH - DONE
    "HAAC_ActiveDescendantCheck": {
        0: "The 'aria-activedescendant' property must reference the 'id' of a non-empty, non-hidden active child element",
        "Pass_0": "Rule Passed",
        "Fail_1": "The 'aria-activedescendant' property is empty",
        "Fail_2": "The 'aria-activedescendant' property references a hidden node",
        "Fail_3": "Element is not a combobox, and the referenced active-descendant element is not a valid descendant",
        "Fail_4": "Element is a combobox, and the referenced active-descendant element is not controlled by this component"
    },
    // JCH - DONE
    "HAAC_Application_Role_Text": {
        0: "Non-decorative static text and image content within an element with \"application\" role must be accessible",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that the non-decorative static text and image content within an element with \"application\" role are accessible"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleToolbarUniqueLabel": {
        0: "All toolbar components on a page must have unique labels specified",
        "Pass_0": "Rule Passed",
        "Fail_1": "Multiple toolbar components do not have unique labels"
    },
    // JCH - DONE
    "HAAC_Combobox_ARIA_11_Guideline": {
        0: "Combobox component must be coded to WAI-ARIA 1.2 Authoring Practices",
        "Pass_0": "Rule Passed",
        "Manual_1": "Confirm combobox component is coded to WAI-ARIA 1.2 Authoring Practices"
    },
    // JCH - DONE
    "HAAC_Combobox_Must_Have_Text_Input": {
        0: "A combobox must have a single line text input element with a valid role",
        "Pass_0": "Rule Passed",
        "Fail_1": "The text input element or number of lines is not valid for the combobox"
    },
    // JCH - DONE
    "HAAC_Combobox_DOM_Focus": {
        0: "Initial DOM focus on the combobox must be set on the text input",
        "Pass_0": "Rule Passed",
        "Fail_1": "Initial DOM focus on the combobox is not set on the text input when the combobox receives focus"
    },
    // JCH - DONE
    "HAAC_Combobox_Autocomplete": {
        0: "A combobox that supports autocompletion behavior must have the 'aria-autocomplete' attribute only on its text input element",
        "Pass_0": "Rule Passed",
        "Fail_1": "The combobox has the 'aria-autocomplete' attribute set on an element that isn't a text input"
    },
    // JCH - DONE
    "HAAC_Combobox_Autocomplete_Invalid": {
        0: "The 'aria-autocomplete' attribute value for a combobox text input element must not be \"inline\"",
        "Pass_0": "Rule Passed",
        "Fail_1": "The 'aria-autocomplete' attribute value of \"inline\" is not valid for the combobox"
    },
    // JCH - DONE
    "HAAC_Combobox_Expanded": {
        0: "The 'aria-owns' or the 'aria-controls' attribute of the expanded combobox must reference a valid popup 'id' value",
        "Pass_0": "Rule Passed",
        "Fail_1": "The 'aria-owns' or the 'aria-controls' attribute of the expanded combobox does not reference a valid popup 'id' value"
    },
    // JCH - DONE
    "HAAC_Combobox_Popup": {
        0: "The value of the combobox 'aria-haspopup' attribute must match the 'role' value of the popup element",
        "Pass_0": "Rule Passed",
        "Fail_1": "The value of the combobox 'aria-haspopup' attribute does not match the 'role' value of the popup element"
    },
    // JCH - DONE
    "WCAG21_Style_Viewport": {
        0: "Text must scale up to 200% without loss of content or functionality",
        "Pass_0": "Rule Passed",
        "Potential_1": "Verify that text sized using viewport units can be resized up to 200%"
    },
    // JCH - DONE
    "WCAG21_Label_Accessible": {
        0: "Accessible name must match or contain the visible label text",
        "Pass_0": "Rule Passed",
        "Fail_1": "Accessible name does not match or contain the visible label text"
    },
    // JCH - DONE
    "WCAG21_Input_Autocomplete": {
        0: "The 'autocomplete' attribute's token(s) must be appropriate for the input form field",
        "Pass_0": "Rule Passed",
        "Fail_1": "The 'autocomplete' attribute's token(s) are not appropriate for the input form field"
    },
    // JCH - DONE
    "WCAG20_Input_VisibleLabel": {
        0: "An input element must have an associated visible label",
        "Pass_0": "Rule Passed",
        "Potential_1": "The input element does not have an associated visible label"
    }
};
exports.a11yNls = a11yNls;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.designNls = void 0;
var designNls = {
    "DESIGN_COLOR_Palette_Foreground": [
        "Foreground color {0} is in the standard palette.",
        "Foreground color {0} is not in the standard palette."
    ],
    "DESIGN_COLOR_Palette_Background": [
        "Background color {0} is in the standard palette.",
        "Background color {0} is not in the standard palette."
    ],
    "DESIGN_Typography_Plex": [
        "Font Family \"{0}\" begins with \"IBM Plex\"",
        "Font Family \"{0}\" is not a standard font, it does not begin with \"IBM Plex\"."
    ],
    "DESIGN_Typography_TextAlignLeft": [
        "Text is left justified",
        "Text is not left justified"
    ],
    "DESIGN_GridLayout_ImgAspectRatio": [
        "Rule Passed",
        "Image is not a supported aspect ratio (16:9, 4:3, 3:2, 2:1, or 1:1)"
    ]
};
exports.designNls = designNls;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkHelp = void 0;
var help_1 = __webpack_require__(65);
var checkHelp = {};
exports.checkHelp = checkHelp;
function addHelp(helpMap) {
    for (var key in helpMap) {
        checkHelp[key] = helpMap[key];
    }
}
addHelp(help_1.a11yHelp);


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yHelp = void 0;
var Config_1 = __webpack_require__(4);
var a11yHelp = {
    // JCH - DONE
    "RPT_List_Misuse": {
        0: Config_1.Config.helpRoot + "/RPT_List_Misuse",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_List_Misuse",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_List_Misuse"
    },
    // JCH - DONE
    "RPT_Marquee_Trigger": {
        0: Config_1.Config.helpRoot + "/RPT_Marquee_Trigger",
        "Passed_0": Config_1.Config.helpRoot + "/RPT_Marquee_Trigger",
        "Fail_1": Config_1.Config.helpRoot + "/RPT_Marquee_Trigger"
    },
    // JCH - DONE
    "RPT_Headers_FewWords": {
        0: Config_1.Config.helpRoot + "/RPT_Headers_FewWords",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Headers_FewWords",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Headers_FewWords"
    },
    // JCH - DONE
    "WCAG20_Input_ExplicitLabelImage": {
        0: Config_1.Config.helpRoot + "/WCAG20_Input_ExplicitLabelImage",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Input_ExplicitLabelImage",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Input_ExplicitLabelImage"
    },
    // JCH - DONE
    "RPT_Img_UsemapValid": {
        0: Config_1.Config.helpRoot + "/RPT_Img_UsemapValid",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Img_UsemapValid",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Img_UsemapValid"
    },
    // JCH - DONE
    "WCAG20_Object_HasText": {
        0: Config_1.Config.helpRoot + "/WCAG20_Object_HasText",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Object_HasText",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Object_HasText"
    },
    // JCH - DONE
    "WCAG20_Applet_HasAlt": {
        0: Config_1.Config.helpRoot + "/WCAG20_Applet_HasAlt",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Applet_HasAlt",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Applet_HasAlt",
        "Fail_2": Config_1.Config.helpRoot + "/WCAG20_Applet_HasAlt",
        "Fail_3": Config_1.Config.helpRoot + "/WCAG20_Applet_HasAlt"
    },
    // JCH - DONE
    "RPT_Media_AudioTrigger": {
        0: Config_1.Config.helpRoot + "/RPT_Media_AudioTrigger",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Media_AudioTrigger",
        "Manual_1": Config_1.Config.helpRoot + "/RPT_Media_AudioTrigger"
    },
    // JCH - DONE
    "RPT_Blockquote_HasCite": {
        0: Config_1.Config.helpRoot + "/RPT_Blockquote_HasCite",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Blockquote_HasCite",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Blockquote_HasCite"
    },
    // JCH - DONE
    "RPT_Meta_Refresh": {
        0: Config_1.Config.helpRoot + "/RPT_Meta_Refresh",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Meta_Refresh",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Meta_Refresh"
    },
    // JCH - DONE
    "WCAG20_Frame_HasTitle": {
        0: Config_1.Config.helpRoot + "/WCAG20_Frame_HasTitle",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Frame_HasTitle",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Frame_HasTitle"
    },
    // JCH - DONE
    "WCAG20_Input_ExplicitLabel": {
        0: Config_1.Config.helpRoot + "/WCAG20_Input_ExplicitLabel",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Input_ExplicitLabel",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Input_ExplicitLabel",
        "Fail_2": Config_1.Config.helpRoot + "/WCAG20_Input_ExplicitLabel"
    },
    // JCH - DONE
    "RPT_Media_AltBrief": {
        0: Config_1.Config.helpRoot + "/RPT_Media_AltBrief",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Media_AltBrief",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Media_AltBrief"
    },
    // JCH - DONE
    "WCAG20_A_TargetAndText": {
        0: Config_1.Config.helpRoot + "/WCAG20_A_TargetAndText",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_A_TargetAndText",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_A_TargetAndText"
    },
    // JCH - DONE
    "WCAG20_Area_HasAlt": {
        0: Config_1.Config.helpRoot + "/WCAG20_Area_HasAlt",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Area_HasAlt",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Area_HasAlt"
    },
    // JCH - DONE
    "RPT_Media_ImgColorUsage": {
        0: Config_1.Config.helpRoot + "/RPT_Media_ImgColorUsage",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Media_ImgColorUsage",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Media_ImgColorUsage"
    },
    // JCH - DONE
    "WCAG20_Meta_RedirectZero": {
        0: Config_1.Config.helpRoot + "/WCAG20_Meta_RedirectZero",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Meta_RedirectZero",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Meta_RedirectZero"
    },
    // JCH - DONE
    "RPT_Elem_Deprecated": {
        0: Config_1.Config.helpRoot + "/RPT_Elem_Deprecated",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Elem_Deprecated",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Elem_Deprecated"
    },
    // JCH - DONE
    "ext_quoted_valid": {
        0: Config_1.Config.helpRoot + "/ext_quoted_valid",
        "Pass_0": Config_1.Config.helpRoot + "/ext_quoted_valid",
        "Potential_1": Config_1.Config.helpRoot + "/ext_quoted_valid"
    },
    // JCH - DONE
    "RPT_Elem_EventMouseAndKey": {
        0: Config_1.Config.helpRoot + "/RPT_Elem_EventMouseAndKey",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Elem_EventMouseAndKey",
        "Manual_1": Config_1.Config.helpRoot + "/RPT_Elem_EventMouseAndKey"
    },
    // JCH - DONE
    "WCAG20_Doc_HasTitle": {
        0: Config_1.Config.helpRoot + "/WCAG20_Doc_HasTitle",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Doc_HasTitle",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Doc_HasTitle",
        "Fail_2": Config_1.Config.helpRoot + "/WCAG20_Doc_HasTitle",
        "Fail_3": Config_1.Config.helpRoot + "/WCAG20_Doc_HasTitle"
    },
    // JCH - DONE
    "RPT_Block_ShouldBeHeading": {
        0: Config_1.Config.helpRoot + "/RPT_Block_ShouldBeHeading",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Block_ShouldBeHeading",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Block_ShouldBeHeading"
    },
    // JCH - DONE
    "WCAG20_Form_HasSubmit": {
        0: Config_1.Config.helpRoot + "/WCAG20_Form_HasSubmit",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Form_HasSubmit",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Form_HasSubmit"
    },
    // JCH - DONE
    "RPT_Elem_UniqueId": {
        0: Config_1.Config.helpRoot + "/RPT_Elem_UniqueId",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Elem_UniqueId",
        "Fail_1": Config_1.Config.helpRoot + "/RPT_Elem_UniqueId",
        "Fail_2": Config_1.Config.helpRoot + "/XXX"
    },
    // JCH - DONE
    "RPT_Font_ColorInForm": {
        0: Config_1.Config.helpRoot + "/RPT_Font_ColorInForm",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Font_ColorInForm",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Font_ColorInForm"
    },
    // JCH - DONE
    "RPT_Label_UniqueFor": {
        0: Config_1.Config.helpRoot + "/RPT_Label_UniqueFor",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Label_UniqueFor",
        "Fail_1": Config_1.Config.helpRoot + "/RPT_Label_UniqueFor"
    },
    // JCH - DONE
    "RPT_Img_AltCommonMisuse": {
        0: Config_1.Config.helpRoot + "/RPT_Img_AltCommonMisuse",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Img_AltCommonMisuse",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Img_AltCommonMisuse"
    },
    // JCH - DONE
    "RPT_Img_LongDescription2": {
        0: Config_1.Config.helpRoot + "/RPT_Img_LongDescription2",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Img_LongDescription2",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Img_LongDescription2"
    },
    // JCH - DONE
    "WCAG20_Img_HasAlt": {
        0: Config_1.Config.helpRoot + "/WCAG20_Img_HasAlt",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Img_HasAlt",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Img_HasAlt",
        "Fail_2": Config_1.Config.helpRoot + "/WCAG20_Img_HasAlt"
    },
    // JCH - DONE
    "RPT_Style_BackgroundImage": {
        0: Config_1.Config.helpRoot + "/RPT_Style_BackgroundImage",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Style_BackgroundImage",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Style_BackgroundImage"
    },
    // JCH - DONE
    "RPT_Pre_ASCIIArt": {
        0: Config_1.Config.helpRoot + "/RPT_Pre_ASCIIArt",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Pre_ASCIIArt",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Pre_ASCIIArt"
    },
    // JCH - DONE
    "RPT_Media_VideoReferenceTrigger": {
        0: Config_1.Config.helpRoot + "/RPT_Media_VideoReferenceTrigger",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Media_VideoReferenceTrigger",
        "Manual_1": Config_1.Config.helpRoot + "/RPT_Media_VideoReferenceTrigger"
    },
    // JCH - DONE
    "RPT_Media_AudioVideoAltFilename": {
        0: Config_1.Config.helpRoot + "/RPT_Media_AudioVideoAltFilename",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Media_AudioVideoAltFilename",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Media_AudioVideoAltFilename"
    },
    // JCH - DONE
    "RPT_Style_ColorSemantics1": {
        0: Config_1.Config.helpRoot + "/RPT_Style_ColorSemantics1",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Style_ColorSemantics1",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Style_ColorSemantics1"
    },
    // JCH - DONE
    "WCAG20_Select_HasOptGroup": {
        0: Config_1.Config.helpRoot + "/WCAG20_Select_HasOptGroup",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Select_HasOptGroup",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Select_HasOptGroup"
    },
    // JCH - DONE
    "RPT_List_UseMarkup": {
        0: Config_1.Config.helpRoot + "/RPT_List_UseMarkup",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_List_UseMarkup",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_List_UseMarkup"
    },
    // JCH - DONE
    "RPT_Script_OnclickHTML1": {
        0: Config_1.Config.helpRoot + "/RPT_Script_OnclickHTML1",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Script_OnclickHTML1",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Script_OnclickHTML1"
    },
    // JCH - DONE
    "WCAG20_Table_Structure": {
        0: Config_1.Config.helpRoot + "/WCAG20_Table_Structure",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Table_Structure",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Table_Structure"
    },
    // JCH - DONE
    "WCAG20_Img_AltTriggerNonDecorative": {
        0: Config_1.Config.helpRoot + "/WCAG20_Img_AltTriggerNonDecorative",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Img_AltTriggerNonDecorative",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Img_AltTriggerNonDecorative"
    },
    // JCH - DONE
    "WCAG20_Blink_AlwaysTrigger": {
        0: Config_1.Config.helpRoot + "/WCAG20_Blink_AlwaysTrigger",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Blink_AlwaysTrigger",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Blink_AlwaysTrigger"
    },
    // JCH - DONE
    "RPT_Blink_CSSTrigger1": {
        0: Config_1.Config.helpRoot + "/RPT_Blink_CSSTrigger1",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Blink_CSSTrigger1",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Blink_CSSTrigger1"
    },
    // JCH - DONE
    "RPT_Html_SkipNav": {
        0: Config_1.Config.helpRoot + "/RPT_Html_SkipNav",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Html_SkipNav",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Html_SkipNav"
    },
    // JCH - DONE
    "RPT_Title_Valid": {
        0: Config_1.Config.helpRoot + "/RPT_Title_Valid",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Title_Valid",
        "Fail_1": Config_1.Config.helpRoot + "/RPT_Title_Valid",
        "Potential_2": Config_1.Config.helpRoot + "/RPT_Title_Valid"
    },
    // JCH - DONE
    "RPT_Header_HasContent": {
        0: Config_1.Config.helpRoot + "/RPT_Header_HasContent",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Header_HasContent",
        "Fail_1": Config_1.Config.helpRoot + "/RPT_Header_HasContent"
    },
    // JCH - DONE
    // JCH - 0: provides the general DAP message for the rule
    //       "Pass_i" ???
    //       "Fail_j" descriptive message for specific failure
    //       "Potential_k" descriptive message describing case when it is not a failure 
    //                     but needs other checking to confirm pass or
    "WCAG20_Html_HasLang": {
        0: Config_1.Config.helpRoot + "/WCAG20_Html_HasLang",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Html_HasLang",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Html_HasLang",
        "Fail_2": Config_1.Config.helpRoot + "/WCAG20_Html_HasLang",
        "Fail_3": Config_1.Config.helpRoot + "/WCAG20_Html_HasLang",
        "Fail_4": Config_1.Config.helpRoot + "/WCAG20_Html_HasLang",
        "Potential_5": Config_1.Config.helpRoot + "/WCAG20_Html_HasLang",
        "Potential_6": Config_1.Config.helpRoot + "/WCAG20_Html_HasLang"
    },
    // JCH - DONE
    "WCAG20_Form_TargetAndText": {
        0: Config_1.Config.helpRoot + "/WCAG20_Form_TargetAndText",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Form_TargetAndText",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Form_TargetAndText"
    },
    // JCH - DONE
    "WCAG20_A_HasText": {
        0: Config_1.Config.helpRoot + "/WCAG20_A_HasText",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_A_HasText",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_A_HasText"
    },
    // JCH - DONE
    "WCAG20_Fieldset_HasLegend": {
        0: Config_1.Config.helpRoot + "/WCAG20_Fieldset_HasLegend",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Fieldset_HasLegend",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Fieldset_HasLegend",
        "Fail_2": Config_1.Config.helpRoot + "/WCAG20_Fieldset_HasLegend",
        "Fail_3": Config_1.Config.helpRoot + "/WCAG20_Fieldset_HasLegend"
    },
    // JCH - DONE
    "RPT_Media_VideoObjectTrigger": {
        0: Config_1.Config.helpRoot + "/RPT_Media_VideoObjectTrigger",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Media_VideoObjectTrigger",
        "Manual_1": Config_1.Config.helpRoot + "/RPT_Media_VideoObjectTrigger"
    },
    // JCH - DONE
    "RPT_Text_SensoryReference": {
        0: Config_1.Config.helpRoot + "/RPT_Text_SensoryReference",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Text_SensoryReference",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Text_SensoryReference"
    },
    // JCH - DONE
    "RPT_Embed_AutoStart": {
        0: Config_1.Config.helpRoot + "/RPT_Embed_AutoStart",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Embed_AutoStart",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Embed_AutoStart"
    },
    // JCH - DONE
    "RPT_Style_HinderFocus1": {
        0: Config_1.Config.helpRoot + "/RPT_Style_HinderFocus1",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Style_HinderFocus1",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Style_HinderFocus1"
    },
    // JCH - DONE
    "WCAG20_Elem_Lang_Valid": {
        0: Config_1.Config.helpRoot + "/WCAG20_Elem_Lang_Valid",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Elem_Lang_Valid",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Elem_Lang_Valid"
    },
    // JCH - DONE
    "WCAG20_Img_LinkTextNotRedundant": {
        0: Config_1.Config.helpRoot + "/WCAG20_Img_LinkTextNotRedundant",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Img_LinkTextNotRedundant",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Img_LinkTextNotRedundant",
        "Fail_2": Config_1.Config.helpRoot + "/WCAG20_Img_LinkTextNotRedundant",
        "Fail_3": Config_1.Config.helpRoot + "/WCAG20_Img_LinkTextNotRedundant"
    },
    // JCH - DONE
    "RPT_Style_ExternalStyleSheet": {
        0: Config_1.Config.helpRoot + "/RPT_Style_ExternalStyleSheet",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Style_ExternalStyleSheet",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Style_ExternalStyleSheet"
    },
    // JCH - DONE
    "RPT_Header_Trigger": {
        0: Config_1.Config.helpRoot + "/RPT_Header_Trigger",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Header_Trigger",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Header_Trigger"
    },
    // JCH - DONE
    "RPT_Script_OnclickHTML2": {
        0: Config_1.Config.helpRoot + "/RPT_Script_OnclickHTML2",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Script_OnclickHTML2",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Script_OnclickHTML2"
    },
    // JCH - DONE
    "WCAG20_Table_CapSummRedundant": {
        0: Config_1.Config.helpRoot + "/WCAG20_Table_CapSummRedundant",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Table_CapSummRedundant",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Table_CapSummRedundant"
    },
    // JCH - DONE
    "WCAG20_Input_LabelBefore": {
        0: Config_1.Config.helpRoot + "/WCAG20_Input_LabelBefore",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Input_LabelBefore",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Input_LabelBefore",
        "Fail_2": Config_1.Config.helpRoot + "/WCAG20_Input_LabelBefore"
    },
    // JCH - DONE
    "WCAG20_Input_LabelAfter": {
        0: Config_1.Config.helpRoot + "/WCAG20_Input_LabelAfter",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Input_LabelAfter",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Input_LabelAfter",
        "Fail_2": Config_1.Config.helpRoot + "/WCAG20_Input_LabelAfter"
    },
    // JCH - DONE
    "WCAG20_Embed_HasNoEmbed": {
        0: Config_1.Config.helpRoot + "/WCAG20_Embed_HasNoEmbed",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Embed_HasNoEmbed",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Embed_HasNoEmbed"
    },
    // JCH - DONE
    "WCAG20_Table_Scope_Valid": {
        0: Config_1.Config.helpRoot + "/WCAG20_Table_Scope_Valid",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Table_Scope_Valid",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Table_Scope_Valid"
    },
    // JCH - DONE
    "WCAG20_Img_TitleEmptyWhenAltNull": {
        0: Config_1.Config.helpRoot + "/WCAG20_Img_TitleEmptyWhenAltNull",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Img_TitleEmptyWhenAltNull",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Img_TitleEmptyWhenAltNull"
    },
    // JCH - DONE
    "WCAG20_Input_InFieldSet": {
        0: Config_1.Config.helpRoot + "/WCAG20_Input_InFieldSet",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Input_InFieldSet",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Input_InFieldSet"
    },
    // JCH - DONE
    "WCAG20_Input_RadioChkInFieldSet": {
        0: Config_1.Config.helpRoot + "/WCAG20_Input_RadioChkInFieldSet",
        "Pass_LoneNogroup": Config_1.Config.helpRoot + "/WCAG20_Input_RadioChkInFieldSet",
        "Pass_Grouped": Config_1.Config.helpRoot + "/WCAG20_Input_RadioChkInFieldSet",
        "Pass_RadioNoName": Config_1.Config.helpRoot + "/WCAG20_Input_RadioChkInFieldSet",
        "Fail_ControlNameMismatch": Config_1.Config.helpRoot + "/WCAG20_Input_RadioChkInFieldSet",
        "Potential_LoneCheckbox": Config_1.Config.helpRoot + "/WCAG20_Input_RadioChkInFieldSet",
        "Potential_UnnamedCheckbox": Config_1.Config.helpRoot + "/WCAG20_Input_RadioChkInFieldSet",
        "Fail_NotGroupedOtherGrouped": Config_1.Config.helpRoot + "/WCAG20_Input_RadioChkInFieldSet",
        "Fail_NotGroupedOtherNotGrouped": Config_1.Config.helpRoot + "/WCAG20_Input_RadioChkInFieldSet",
        "Fail_NotSameGroup": Config_1.Config.helpRoot + "/WCAG20_Input_RadioChkInFieldSet"
    },
    // JCH - DONE
    "WCAG20_Select_NoChangeAction": {
        0: Config_1.Config.helpRoot + "/WCAG20_Select_NoChangeAction",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Select_NoChangeAction",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Select_NoChangeAction"
    },
    // JCH - DONE
    "WCAG20_Input_HasOnchange": {
        0: Config_1.Config.helpRoot + "/WCAG20_Input_HasOnchange",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Input_HasOnchange",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Input_HasOnchange"
    },
    // JCH - DONE
    "RPT_Embed_HasAlt": {
        0: Config_1.Config.helpRoot + "/RPT_Embed_HasAlt",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Embed_HasAlt",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Embed_HasAlt"
    },
    // JCH - DONE
    "Valerie_Noembed_HasContent": {
        0: Config_1.Config.helpRoot + "/Valerie_Noembed_HasContent",
        "Pass_0": Config_1.Config.helpRoot + "/Valerie_Noembed_HasContent",
        "Potential_1": Config_1.Config.helpRoot + "/Valerie_Noembed_HasContent"
    },
    // JCH - DONE
    "Valerie_Caption_HasContent": {
        0: Config_1.Config.helpRoot + "/Valerie_Caption_HasContent",
        "Pass_0": Config_1.Config.helpRoot + "/Valerie_Caption_HasContent",
        "Fail_1": Config_1.Config.helpRoot + "/Valerie_Caption_HasContent"
    },
    // JCH - DONE
    "Valerie_Caption_InTable": {
        0: Config_1.Config.helpRoot + "/Valerie_Caption_InTable",
        "Pass_0": Config_1.Config.helpRoot + "/Valerie_Caption_InTable",
        "Fail_1": Config_1.Config.helpRoot + "/Valerie_Caption_InTable"
    },
    // JCH - DONE
    "Valerie_Label_HasContent": {
        0: Config_1.Config.helpRoot + "/Valerie_Label_HasContent",
        "Pass_Regular": Config_1.Config.helpRoot + "/Valerie_Label_HasContent",
        "Pass_AriaLabel": Config_1.Config.helpRoot + "/Valerie_Label_HasContent",
        "Pass_LabelledBy": Config_1.Config.helpRoot + "/Valerie_Label_HasContent",
        "Fail_1": Config_1.Config.helpRoot + "/Valerie_Label_HasContent"
    },
    // JCH - DONE
    "Valerie_Elem_DirValid": {
        0: Config_1.Config.helpRoot + "/Valerie_Elem_DirValid",
        "Pass_0": Config_1.Config.helpRoot + "/Valerie_Elem_DirValid",
        "Fail_1": Config_1.Config.helpRoot + "/Valerie_Elem_DirValid"
    },
    // JCH - DONE
    "Valerie_Frame_SrcHtml": {
        0: Config_1.Config.helpRoot + "/Valerie_Frame_SrcHtml",
        "Pass_0": Config_1.Config.helpRoot + "/Valerie_Frame_SrcHtml",
        "Potential_1": Config_1.Config.helpRoot + "/Valerie_Frame_SrcHtml"
    },
    // JCH - DONE
    "Valerie_Table_DataCellRelationships": {
        0: Config_1.Config.helpRoot + "/Valerie_Table_DataCellRelationships",
        "Pass_0": Config_1.Config.helpRoot + "/Valerie_Table_DataCellRelationships",
        "Fail_1": Config_1.Config.helpRoot + "/Valerie_Table_DataCellRelationships"
    },
    // JCH - DONE
    "RPT_Table_LayoutTrigger": {
        0: Config_1.Config.helpRoot + "/RPT_Table_LayoutTrigger",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Table_LayoutTrigger",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Table_LayoutTrigger"
    },
    // JCH - DONE
    "RPT_Table_DataHeadingsAria": {
        0: Config_1.Config.helpRoot + "/RPT_Table_DataHeadingsAria",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Table_DataHeadingsAria",
        "Fail_1": Config_1.Config.helpRoot + "/RPT_Table_DataHeadingsAria"
    },
    // JCH - DONE
    "WCAG20_Label_RefValid": {
        0: Config_1.Config.helpRoot + "/WCAG20_Label_RefValid",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Label_RefValid",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Label_RefValid"
    },
    // JCH - DONE
    "WCAG20_Elem_UniqueAccessKey": {
        0: Config_1.Config.helpRoot + "/WCAG20_Elem_UniqueAccessKey",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Elem_UniqueAccessKey",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Elem_UniqueAccessKey"
    },
    // JCH - DONE
    "WCAG20_Script_FocusBlurs": {
        0: Config_1.Config.helpRoot + "/WCAG20_Script_FocusBlurs",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Script_FocusBlurs",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Script_FocusBlurs"
    },
    // JCH - DONE
    "HAAC_Img_UsemapAlt": {
        0: Config_1.Config.helpRoot + "/HAAC_Img_UsemapAlt",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Img_UsemapAlt",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Img_UsemapAlt"
    },
    // JCH - DONE
    "WCAG20_Text_Emoticons": {
        0: Config_1.Config.helpRoot + "/WCAG20_Text_Emoticons",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Text_Emoticons",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Text_Emoticons"
    },
    // JCH - DONE
    "WCAG20_Style_BeforeAfter": {
        0: Config_1.Config.helpRoot + "/WCAG20_Style_BeforeAfter",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Style_BeforeAfter",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Style_BeforeAfter"
    },
    // JCH - DONE
    "WCAG20_Text_LetterSpacing": {
        0: Config_1.Config.helpRoot + "/WCAG20_Text_LetterSpacing",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Text_LetterSpacing",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Text_LetterSpacing"
    },
    // JCH - DONE
    "Rpt_Aria_ValidRole": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_ValidRole",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_ValidRole",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_ValidRole"
    },
    // JCH - DONE
    "Rpt_Aria_ValidPropertyValue": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_ValidPropertyValue",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_ValidPropertyValue",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_ValidPropertyValue"
    },
    // JCH - DONE
    "Rpt_Aria_ValidIdRef": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_ValidIdRef",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_ValidIdRef",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_ValidIdRef"
    },
    // JCH - DONE
    "Rpt_Aria_RequiredProperties": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_RequiredProperties",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_RequiredProperties",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_RequiredProperties"
    },
    // JCH - DONE
    "Rpt_Aria_EmptyPropertyValue": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_EmptyPropertyValue",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_EmptyPropertyValue",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_EmptyPropertyValue"
    },
    // JCH - DONE
    "Rpt_Aria_ValidProperty": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_ValidProperty",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_ValidProperty",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_ValidProperty"
    },
    // JCH - DONE
    "Rpt_Aria_InvalidTabindexForActivedescendant": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_InvalidTabindexForActivedescendant",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_InvalidTabindexForActivedescendant",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_InvalidTabindexForActivedescendant"
    },
    // JCH - DONE
    "Rpt_Aria_MissingFocusableChild": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MissingFocusableChild",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MissingFocusableChild",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MissingFocusableChild"
    },
    // JCH - DONE
    "Rpt_Aria_MissingKeyboardHandler": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MissingKeyboardHandler",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MissingKeyboardHandler",
        "Potential_1": Config_1.Config.helpRoot + "/Rpt_Aria_MissingKeyboardHandler"
    },
    // JCH - DONE
    "WCAG20_Img_PresentationImgHasNonNullAlt": {
        0: Config_1.Config.helpRoot + "/WCAG20_Img_PresentationImgHasNonNullAlt",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Img_PresentationImgHasNonNullAlt",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Img_PresentationImgHasNonNullAlt"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleSearchLandmarks": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleSearchLandmarks",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleSearchLandmarks",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleSearchLandmarks"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleApplicationLandmarks": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleApplicationLandmarks",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleApplicationLandmarks",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleApplicationLandmarks"
    },
    // JCH - DONE
    "Rpt_Aria_ApplicationLandmarkLabel": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_ApplicationLandmarkLabel",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_ApplicationLandmarkLabel",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_ApplicationLandmarkLabel"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleDocumentRoles": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleDocumentRoles",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleDocumentRoles",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleDocumentRoles"
    },
    // JCH - DONE
    "WCAG20_Label_TargetInvisible": {
        0: Config_1.Config.helpRoot + "/WCAG20_Label_TargetInvisible",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Label_TargetInvisible",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Label_TargetInvisible"
    },
    // JCH - DONE
    "HAAC_Video_HasNoTrack": {
        0: Config_1.Config.helpRoot + "/HAAC_Video_HasNoTrack",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Video_HasNoTrack",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Video_HasNoTrack"
    },
    // JCH - DONE
    "HAAC_Audio_Video_Trigger": {
        0: Config_1.Config.helpRoot + "/HAAC_Audio_Video_Trigger",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Audio_Video_Trigger",
        "Manual_1": Config_1.Config.helpRoot + "/HAAC_Audio_Video_Trigger"
    },
    // JCH - DONE
    "HAAC_Input_HasRequired": {
        0: Config_1.Config.helpRoot + "/HAAC_Input_HasRequired",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Input_HasRequired",
        "Potential_1": Config_1.Config.helpRoot + "/HAAC_Input_HasRequired"
    },
    // JCH - DONE
    "HAAC_Aria_ImgAlt": {
        0: Config_1.Config.helpRoot + "/HAAC_Aria_ImgAlt",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Aria_ImgAlt",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Aria_ImgAlt",
        "Fail_2": Config_1.Config.helpRoot + "/HAAC_Aria_ImgAlt",
        "Fail_3": Config_1.Config.helpRoot + "/HAAC_Aria_ImgAlt"
    },
    // JCH - DONE
    "HAAC_BackgroundImg_HasTextOrTitle": {
        0: Config_1.Config.helpRoot + "/HAAC_BackgroundImg_HasTextOrTitle",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_BackgroundImg_HasTextOrTitle",
        "Manual_1": Config_1.Config.helpRoot + "/HAAC_BackgroundImg_HasTextOrTitle"
    },
    // JCH - DONE
    "HAAC_Accesskey_NeedLabel": {
        0: Config_1.Config.helpRoot + "/HAAC_Accesskey_NeedLabel",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Accesskey_NeedLabel",
        "Potential_1": Config_1.Config.helpRoot + "/HAAC_Accesskey_NeedLabel"
    },
    // JCH - DONE
    "HAAC_Aria_Or_HTML5_Attr": {
        0: Config_1.Config.helpRoot + "/HAAC_Aria_Or_HTML5_Attr",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Aria_Or_HTML5_Attr",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Aria_Or_HTML5_Attr"
    },
    // JCH - DONE
    "HAAC_Canvas": {
        0: Config_1.Config.helpRoot + "/HAAC_Canvas",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Canvas",
        "Manual_1": Config_1.Config.helpRoot + "/HAAC_Canvas"
    },
    // JCH - DONE
    "HAAC_Figure_label": {
        0: Config_1.Config.helpRoot + "/HAAC_Figure_label",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Figure_label",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Figure_label"
    },
    // JCH - DONE
    "HAAC_Input_Placeholder": {
        0: Config_1.Config.helpRoot + "/HAAC_Input_Placeholder",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Input_Placeholder",
        "Potential_1": Config_1.Config.helpRoot + "/HAAC_Input_Placeholder",
        "Potential_2": Config_1.Config.helpRoot + "/HAAC_Input_Placeholder"
    },
    // JCH - DONE
    "HAAC_Aria_Native_Host_Sematics": {
        0: Config_1.Config.helpRoot + "/HAAC_Aria_Native_Host_Sematics",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Aria_Native_Host_Sematics",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Aria_Native_Host_Sematics"
    },
    // JCH - DONE
    "RPT_Form_ChangeEmpty": {
        0: Config_1.Config.helpRoot + "/RPT_Form_ChangeEmpty",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Form_ChangeEmpty",
        "Potential_1": Config_1.Config.helpRoot + "/RPT_Form_ChangeEmpty"
    },
    // JCH - DONE
    "IBMA_Color_Contrast_WCAG2AA": {
        0: Config_1.Config.helpRoot + "/IBMA_Color_Contrast_WCAG2AA",
        "Pass_0": Config_1.Config.helpRoot + "/IBMA_Color_Contrast_WCAG2AA",
        "Fail_1": Config_1.Config.helpRoot + "/IBMA_Color_Contrast_WCAG2AA"
    },
    // JCH - DONE
    "IBMA_Color_Contrast_WCAG2AA_PV": {
        0: Config_1.Config.helpRoot + "/IBMA_Color_Contrast_WCAG2AA_PV",
        "Pass_0": Config_1.Config.helpRoot + "/IBMA_Color_Contrast_WCAG2AA_PV",
        "Potential_1": Config_1.Config.helpRoot + "/IBMA_Color_Contrast_WCAG2AA_PV"
    },
    // JCH - DONE
    "WCAG20_Body_FirstASkips_Native_Host_Sematics": {
        0: Config_1.Config.helpRoot + "/WCAG20_Body_FirstASkips_Native_Host_Sematics",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Body_FirstASkips_Native_Host_Sematics",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG20_Body_FirstASkips_Native_Host_Sematics"
    },
    // JCH - DONE
    "WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics": {
        0: Config_1.Config.helpRoot + "/WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics"
    },
    // JCH - DONE
    "Rpt_Aria_RequiredChildren_Native_Host_Sematics": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_RequiredChildren_Native_Host_Sematics",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_RequiredChildren_Native_Host_Sematics",
        "Potential_1": Config_1.Config.helpRoot + "/Rpt_Aria_RequiredChildren_Native_Host_Sematics"
    },
    // JCH - DONE
    "Rpt_Aria_RequiredParent_Native_Host_Sematics": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_RequiredParent_Native_Host_Sematics",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_RequiredParent_Native_Host_Sematics",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_RequiredParent_Native_Host_Sematics"
    },
    // JCH - DONE
    "Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics"
    },
    // JCH - DONE
    "Rpt_Aria_WidgetLabels_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_WidgetLabels_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_WidgetLabels_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_WidgetLabels_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_OrphanedContent_Native_Host_Sematics": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_OrphanedContent_Native_Host_Sematics",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_OrphanedContent_Native_Host_Sematics",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_OrphanedContent_Native_Host_Sematics"
    },
    // JCH - DONE
    "Rpt_Aria_RegionLabel_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_RegionLabel_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_RegionLabel_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_RegionLabel_Implicit",
        "Fail_2": Config_1.Config.helpRoot + "/Rpt_Aria_RegionLabel_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleMainsVisibleLabel_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleMainsVisibleLabel_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleMainsVisibleLabel_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleMainsVisibleLabel_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleBannerLandmarks_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleBannerLandmarks_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleBannerLandmarks_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleBannerLandmarks_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleComplementaryLandmarks_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleComplementaryLandmarks_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleComplementaryLandmarks_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleComplementaryLandmarks_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleContentinfoLandmarks_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleContentinfoLandmarks_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleContentinfoLandmarks_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleContentinfoLandmarks_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleFormLandmarks_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleFormLandmarks_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleFormLandmarks_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleFormLandmarks_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleNavigationLandmarks_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleNavigationLandmarks_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleNavigationLandmarks_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleNavigationLandmarks_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_ComplementaryLandmarkLabel_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_ComplementaryLandmarkLabel_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_ComplementaryLandmarkLabel_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_ComplementaryLandmarkLabel_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleArticleRoles_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleArticleRoles_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleArticleRoles_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleArticleRoles_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_ArticleRoleLabel_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_ArticleRoleLabel_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_ArticleRoleLabel_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_ArticleRoleLabel_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleGroupRoles_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleGroupRoles_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleGroupRoles_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleGroupRoles_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_GroupRoleLabel_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_GroupRoleLabel_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_GroupRoleLabel_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_GroupRoleLabel_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_OneBannerInSiblingSet_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_OneBannerInSiblingSet_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_OneBannerInSiblingSet_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_OneBannerInSiblingSet_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_ContentinfoWithNoMain_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_ContentinfoWithNoMain_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_ContentinfoWithNoMain_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_ContentinfoWithNoMain_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_ComplementaryRequiredLabel_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_ComplementaryRequiredLabel_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_ComplementaryRequiredLabel_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_ComplementaryRequiredLabel_Implicit"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleRegionsUniqueLabel_Implicit": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleRegionsUniqueLabel_Implicit",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleRegionsUniqueLabel_Implicit",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleRegionsUniqueLabel_Implicit"
    },
    // JCH - DONE
    "IBMA_Focus_Tabbable": {
        0: Config_1.Config.helpRoot + "/IBMA_Focus_Tabbable",
        "Pass_0": Config_1.Config.helpRoot + "/IBMA_Focus_Tabbable",
        "Potential_1": Config_1.Config.helpRoot + "/IBMA_Focus_Tabbable"
    },
    // JCH - DONE
    "IBMA_Focus_MultiTab": {
        0: Config_1.Config.helpRoot + "/IBMA_Focus_MultiTab",
        "Pass_0": Config_1.Config.helpRoot + "/IBMA_Focus_MultiTab",
        "Potential_1": Config_1.Config.helpRoot + "/IBMA_Focus_MultiTab"
    },
    // JCH - DONE
    "WCAG20_Table_SummaryAria3": {
        0: Config_1.Config.helpRoot + "/WCAG20_Table_SummaryAria3",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Table_SummaryAria3",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Table_SummaryAria3"
    },
    // JCH - DONE
    "RPT_Style_Trigger2": {
        0: Config_1.Config.helpRoot + "/RPT_Style_Trigger2",
        "Pass_0": Config_1.Config.helpRoot + "/RPT_Style_Trigger2",
        "Manual_1": Config_1.Config.helpRoot + "/RPT_Style_Trigger2"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleMainsRequireLabel_Implicit_2": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleMainsRequireLabel_Implicit_2",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleMainsRequireLabel_Implicit_2",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleMainsRequireLabel_Implicit_2"
    },
    // JCH - DONE
    "HAAC_Media_DocumentTrigger2": {
        0: Config_1.Config.helpRoot + "/HAAC_Media_DocumentTrigger2",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Media_DocumentTrigger2",
        "Manual_1": Config_1.Config.helpRoot + "/HAAC_Media_DocumentTrigger2"
    },
    // JCH - DONE
    "HAAC_Aria_ErrorMessage": {
        0: Config_1.Config.helpRoot + "/HAAC_Aria_ErrorMessage",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Aria_ErrorMessage",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Aria_ErrorMessage",
        "Fail_2": Config_1.Config.helpRoot + "/HAAC_Aria_ErrorMessage"
    },
    // JCH - DONE
    "HAAC_List_Group_ListItem": {
        0: Config_1.Config.helpRoot + "/HAAC_List_Group_ListItem",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_List_Group_ListItem",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_List_Group_ListItem"
    },
    // JCH - DONE
    "HAAC_ActiveDescendantCheck": {
        0: Config_1.Config.helpRoot + "/HAAC_ActiveDescendantCheck",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_ActiveDescendantCheck",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_ActiveDescendantCheck",
        "Fail_2": Config_1.Config.helpRoot + "/HAAC_ActiveDescendantCheck",
        "Fail_3": Config_1.Config.helpRoot + "/HAAC_ActiveDescendantCheck",
        "Fail_4": Config_1.Config.helpRoot + "/HAAC_ActiveDescendantCheck"
    },
    // JCH - DONE
    "HAAC_Application_Role_Text": {
        0: Config_1.Config.helpRoot + "/HAAC_Application_Role_Text",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Application_Role_Text",
        "Potential_1": Config_1.Config.helpRoot + "/HAAC_Application_Role_Text"
    },
    // JCH - DONE
    "Rpt_Aria_MultipleToolbarUniqueLabel": {
        0: Config_1.Config.helpRoot + "/Rpt_Aria_MultipleToolbarUniqueLabel",
        "Pass_0": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleToolbarUniqueLabel",
        "Fail_1": Config_1.Config.helpRoot + "/Rpt_Aria_MultipleToolbarUniqueLabel"
    },
    // JCH - DONE
    "HAAC_Combobox_ARIA_11_Guideline": {
        0: Config_1.Config.helpRoot + "/HAAC_Combobox_ARIA_11_Guideline",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Combobox_ARIA_11_Guideline",
        "Manual_1": Config_1.Config.helpRoot + "/HAAC_Combobox_ARIA_11_Guideline"
    },
    // JCH - DONE
    "HAAC_Combobox_Must_Have_Text_Input": {
        0: Config_1.Config.helpRoot + "/HAAC_Combobox_Must_Have_Text_Input",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Combobox_Must_Have_Text_Input",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Combobox_Must_Have_Text_Input"
    },
    // JCH - DONE
    "HAAC_Combobox_DOM_Focus": {
        0: Config_1.Config.helpRoot + "/HAAC_Combobox_DOM_Focus",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Combobox_DOM_Focus",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Combobox_DOM_Focus"
    },
    // JCH - DONE
    "HAAC_Combobox_Autocomplete": {
        0: Config_1.Config.helpRoot + "/HAAC_Combobox_Autocomplete",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Combobox_Autocomplete",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Combobox_Autocomplete"
    },
    // JCH - DONE
    "HAAC_Combobox_Autocomplete_Invalid": {
        0: Config_1.Config.helpRoot + "/HAAC_Combobox_Autocomplete_Invalid",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Combobox_Autocomplete_Invalid",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Combobox_Autocomplete_Invalid"
    },
    // JCH - DONE
    "HAAC_Combobox_Expanded": {
        0: Config_1.Config.helpRoot + "/HAAC_Combobox_Expanded",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Combobox_Expanded",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Combobox_Expanded"
    },
    // JCH - DONE
    "HAAC_Combobox_Popup": {
        0: Config_1.Config.helpRoot + "/HAAC_Combobox_Popup",
        "Pass_0": Config_1.Config.helpRoot + "/HAAC_Combobox_Popup",
        "Fail_1": Config_1.Config.helpRoot + "/HAAC_Combobox_Popup"
    },
    // JCH - DONE
    "WCAG21_Style_Viewport": {
        0: Config_1.Config.helpRoot + "/WCAG21_Style_Viewport",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG21_Style_Viewport",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG21_Style_Viewport"
    },
    // JCH - DONE
    "WCAG21_Label_Accessible": {
        0: Config_1.Config.helpRoot + "/WCAG21_Label_Accessible",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG21_Label_Accessible",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG21_Label_Accessible"
    },
    // JCH - DONE
    "WCAG21_Input_Autocomplete": {
        0: Config_1.Config.helpRoot + "/WCAG21_Input_Autocomplete",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG21_Input_Autocomplete",
        "Fail_1": Config_1.Config.helpRoot + "/WCAG21_Input_Autocomplete"
    },
    // JCH - DONE
    "WCAG20_Input_VisibleLabel": {
        0: Config_1.Config.helpRoot + "/WCAG20_Input_VisibleLabel",
        "Pass_0": Config_1.Config.helpRoot + "/WCAG20_Input_VisibleLabel",
        "Potential_1": Config_1.Config.helpRoot + "/WCAG20_Input_VisibleLabel"
    }
};
exports.a11yHelp = a11yHelp;
var a11yHelpOld = {
    "RPT_List_Misuse": ["idhi_accessibility_check_g3.html"],
    "RPT_Marquee_Trigger": ["idhi_accessibility_check_g5.html"],
    "RPT_Headers_FewWords": ["idhi_accessibility_check_g7.html"],
    "WCAG20_Input_ExplicitLabelImage": ["idhi_accessibility_check_g10.html"],
    "RPT_Img_UsemapValid": ["idhi_accessibility_check_g11.html"],
    "WCAG20_Object_HasText": ["idhi_accessibility_check_g20.html"],
    "WCAG20_Applet_HasAlt": ["idhi_accessibility_check_g21.html"],
    "RPT_Media_AudioTrigger": ["idhi_accessibility_check_g24.html"],
    "RPT_Blockquote_HasCite": ["idhi_accessibility_check_g25.html"],
    "RPT_Meta_Refresh": ["idhi_accessibility_check_g33.html"],
    "WCAG20_Frame_HasTitle": ["idhi_accessibility_check_g39.html"],
    "WCAG20_Input_ExplicitLabel": ["idhi_accessibility_check_g41.html"],
    "RPT_Media_AltBrief": ["idhi_accessibility_check_g99.html"],
    "WCAG20_A_TargetAndText": ["idhi_accessibility_check_g112.html"],
    "WCAG20_Area_HasAlt": ["idhi_accessibility_check_g240.html"],
    "RPT_Media_ImgColorUsage": ["idhi_accessibility_check_g245.html"],
    "WCAG20_Meta_RedirectZero": ["idhi_accessibility_check_g254.html"],
    "RPT_Elem_Deprecated": ["idhi_accessibility_check_g256.html"],
    "ext_quoted_valid": ["idhi_accessibility_check_g263.html"],
    "RPT_Elem_EventMouseAndKey": ["idhi_accessibility_check_g269.html"],
    "WCAG20_Doc_HasTitle": ["idhi_accessibility_check_g273.html"],
    "RPT_Block_ShouldBeHeading": ["idhi_accessibility_check_g322.html"],
    "WCAG20_Form_HasSubmit": ["idhi_accessibility_check_g324.html"],
    "RPT_Elem_UniqueId": ["idhi_accessibility_check_g377.html"],
    "RPT_Font_ColorInForm": ["idhi_accessibility_check_g394.html"],
    "RPT_Label_UniqueFor": ["idhi_accessibility_check_g398.html"],
    "RPT_Img_AltCommonMisuse": ["idhi_accessibility_check_g453.html"],
    "RPT_Img_LongDescription2": ["idhi_accessibility_check_g454.html"],
    "WCAG20_Img_HasAlt": ["idhi_accessibility_check_g455.html"],
    "RPT_Style_BackgroundImage": ["idhi_accessibility_check_g456.html"],
    "RPT_Pre_ASCIIArt": ["idhi_accessibility_check_g458.html"],
    "RPT_Media_VideoReferenceTrigger": ["idhi_accessibility_check_g511.html"],
    "RPT_Media_AudioVideoAltFilename": ["idhi_accessibility_check_g460.html"],
    "RPT_Style_ColorSemantics1": ["idhi_accessibility_check_g466.html"],
    "WCAG20_Select_HasOptGroup": ["idhi_accessibility_check_g467.html"],
    "RPT_List_UseMarkup": ["idhi_accessibility_check_g468.html"],
    "RPT_Script_OnclickHTML1": ["idhi_accessibility_check_g470.html"],
    "WCAG20_Table_Structure": ["idhi_accessibility_check_g471.html"],
    "WCAG20_Img_AltTriggerNonDecorative": ["idhi_accessibility_check_g473.html"],
    "WCAG20_Blink_AlwaysTrigger": ["idhi_accessibility_check_g478.html"],
    "RPT_Blink_CSSTrigger1": ["idhi_accessibility_check_g479.html"],
    "RPT_Html_SkipNav": ["idhi_accessibility_check_g481.html"],
    "RPT_Title_Valid": ["idhi_accessibility_check_g484.html"],
    "RPT_Header_HasContent": ["idhi_accessibility_check_g488.html"],
    "WCAG20_Html_HasLang": ["idhi_accessibility_check_g490.html"],
    "WCAG20_Form_TargetAndText": ["idhi_accessibility_check_g491.html"],
    "WCAG20_A_HasText": ["idhi_accessibility_check_g495.html"],
    "WCAG20_Fieldset_HasLegend": ["idhi_accessibility_check_g497.html"],
    "RPT_Media_VideoObjectTrigger": ["idhi_accessibility_check_g501.html"],
    "RPT_Text_SensoryReference": ["idhi_accessibility_check_g502.html"],
    "RPT_Embed_AutoStart": ["idhi_accessibility_check_g503.html"],
    "RPT_Style_HinderFocus1": ["idhi_accessibility_check_g506.html"],
    "WCAG20_Elem_Lang_Valid": ["idhi_accessibility_check_g507.html"],
    "WCAG20_Img_LinkTextNotRedundant": ["idhi_accessibility_check_g1000.html"],
    "RPT_Style_ExternalStyleSheet": ["idhi_accessibility_check_g1073.html"],
    "RPT_Header_Trigger": ["idhi_accessibility_check_g1002.html"],
    "RPT_Script_OnclickHTML2": ["idhi_accessibility_check_g1007.html"],
    "WCAG20_Table_CapSummRedundant": ["idhi_accessibility_check_g1011.html"],
    "WCAG20_Input_LabelBefore": ["idhi_accessibility_check_g1017.html"],
    "WCAG20_Input_LabelAfter": ["idhi_accessibility_check_g1018.html"],
    "WCAG20_Embed_HasNoEmbed": ["idhi_accessibility_check_g1020.html"],
    "WCAG20_Table_Scope_Valid": ["idhi_accessibility_check_g1025.html"],
    "WCAG20_Img_TitleEmptyWhenAltNull": ["idhi_accessibility_check_g1027.html"],
    "WCAG20_Input_InFieldSet": ["idhi_accessibility_check_g1028.html"],
    "WCAG20_Input_RadioChkInFieldSet": ["idhi_accessibility_check_g1029.html"],
    "WCAG20_Select_NoChangeAction": ["idhi_accessibility_check_g1035.html"],
    "WCAG20_Input_HasOnchange": ["idhi_accessibility_check_g1050.html"],
    "RPT_Embed_HasAlt": ["idhi_accessibility_check_g1051.html"],
    "Valerie_Noembed_HasContent": ["idhi_accessibility_check_g1052.html"],
    "Valerie_Caption_HasContent": ["idhi_accessibility_check_g1053.html"],
    "Valerie_Caption_InTable": ["idhi_accessibility_check_g1054.html"],
    "Valerie_Label_HasContent": ["idhi_accessibility_check_g1055.html"],
    "Valerie_Elem_DirValid": ["idhi_accessibility_check_g1056.html"],
    "Valerie_Frame_SrcHtml": ["idhi_accessibility_check_g1057.html"],
    "Valerie_Table_DataCellRelationships": ["idhi_accessibility_check_g1059.html"],
    "RPT_Table_LayoutTrigger": ["idhi_accessibility_check_g1060.html"],
    "RPT_Table_DataHeadingsAria": ["idhi_accessibility_check_g1061.html"],
    "WCAG20_Label_RefValid": ["idhi_accessibility_check_g1062.html"],
    "WCAG20_Elem_UniqueAccessKey": ["idhi_accessibility_check_g1063.html"],
    "WCAG20_Script_FocusBlurs": ["idhi_accessibility_check_g1064.html"],
    "HAAC_Img_UsemapAlt": ["idhi_accessibility_check_g1067.html"],
    "WCAG20_Text_Emoticons": ["idhi_accessibility_check_g1068.html"],
    "WCAG20_Style_BeforeAfter": ["idhi_accessibility_check_g1069.html"],
    "WCAG20_Text_LetterSpacing": ["idhi_accessibility_check_g1070.html"],
    "Rpt_Aria_ValidRole": ["idhi_accessibility_check_g1074.html"],
    "Rpt_Aria_ValidPropertyValue": ["idhi_accessibility_check_g1076.html"],
    "Rpt_Aria_ValidIdRef": ["idhi_accessibility_check_g1077.html"],
    "Rpt_Aria_RequiredProperties": ["idhi_accessibility_check_g1079.html"],
    "Rpt_Aria_EmptyPropertyValue": ["idhi_accessibility_check_g1082.html"],
    "Rpt_Aria_ValidProperty": ["idhi_accessibility_check_g1083.html"],
    "Rpt_Aria_InvalidTabindexForActivedescendant": ["idhi_accessibility_check_g1084.html"],
    "Rpt_Aria_MissingFocusableChild": ["idhi_accessibility_check_g1086.html"],
    "Rpt_Aria_MissingKeyboardHandler": ["idhi_accessibility_check_g1087.html"],
    "WCAG20_Img_PresentationImgHasNonNullAlt": ["idhi_accessibility_check_g1090.html"],
    "Rpt_Aria_MultipleSearchLandmarks": ["idhi_accessibility_check_g1097.html"],
    "Rpt_Aria_MultipleApplicationLandmarks": ["idhi_accessibility_check_g1099.html"],
    "Rpt_Aria_ApplicationLandmarkLabel": ["idhi_accessibility_check_g1100.html"],
    "Rpt_Aria_MultipleDocumentRoles": ["idhi_accessibility_check_g1101.html"],
    "WCAG20_Label_TargetInvisible": ["idhi_accessibility_check_g1112.html"],
    "HAAC_Video_HasNoTrack": ["idhi_accessibility_check_g1117.html"],
    "HAAC_Audio_Video_Trigger": ["idhi_accessibility_check_g1119.html"],
    "HAAC_Aria_ImgAlt": ["idhi_accessibility_check_g1128.html"],
    "HAAC_BackgroundImg_HasTextOrTitle": ["idhi_accessibility_check_g1132.html"],
    "HAAC_Accesskey_NeedLabel": ["idhi_accessibility_check_g1140.html"],
    "HAAC_Aria_Or_HTML5_Attr": ["idhi_accessibility_check_g1141.html"],
    "HAAC_Canvas": ["idhi_accessibility_check_g1143.html"],
    "HAAC_Figure_label": ["idhi_accessibility_check_g1144.html"],
    "HAAC_Input_Placeholder": ["idhi_accessibility_check_g1145.html"],
    "HAAC_Aria_Native_Host_Sematics": ["idhi_accessibility_check_g1146.html"],
    "RPT_Form_ChangeEmpty": ["idhi_accessibility_check_g1147.html"],
    "IBMA_Color_Contrast_WCAG2AA": ["idhi_accessibility_check_g1148.html"],
    "IBMA_Color_Contrast_WCAG2AA_PV": ["idhi_accessibility_check_g1149.html"],
    "WCAG20_Body_FirstASkips_Native_Host_Sematics": ["idhi_accessibility_check_g1150.html"],
    "WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics": ["idhi_accessibility_check_g1151.html"],
    "Rpt_Aria_RequiredChildren_Native_Host_Sematics": ["idhi_accessibility_check_g1152.html"],
    "Rpt_Aria_RequiredParent_Native_Host_Sematics": ["idhi_accessibility_check_g1153.html"],
    "Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics": ["idhi_accessibility_check_g1154.html"],
    "Rpt_Aria_WidgetLabels_Implicit": ["idhi_accessibility_check_g1156.html"],
    "Rpt_Aria_OrphanedContent_Native_Host_Sematics": ["idhi_accessibility_check_g1157.html"],
    "Rpt_Aria_RegionLabel_Implicit": ["idhi_accessibility_check_g1158.html"],
    "Rpt_Aria_MultipleMainsVisibleLabel_Implicit": ["idhi_accessibility_check_g1159.html"],
    "Rpt_Aria_MultipleBannerLandmarks_Implicit": ["idhi_accessibility_check_g1160.html"],
    "Rpt_Aria_MultipleComplementaryLandmarks_Implicit": ["idhi_accessibility_check_g1161.html"],
    "Rpt_Aria_MultipleContentinfoLandmarks_Implicit": ["idhi_accessibility_check_g1162.html"],
    "Rpt_Aria_MultipleFormLandmarks_Implicit": ["idhi_accessibility_check_g1163.html"],
    "Rpt_Aria_MultipleNavigationLandmarks_Implicit": ["idhi_accessibility_check_g1164.html"],
    "Rpt_Aria_ComplementaryLandmarkLabel_Implicit": ["idhi_accessibility_check_g1165.html"],
    "Rpt_Aria_MultipleArticleRoles_Implicit": ["idhi_accessibility_check_g1166.html"],
    "Rpt_Aria_ArticleRoleLabel_Implicit": ["idhi_accessibility_check_g1167.html"],
    "Rpt_Aria_MultipleGroupRoles_Implicit": ["idhi_accessibility_check_g1168.html"],
    "Rpt_Aria_GroupRoleLabel_Implicit": ["idhi_accessibility_check_g1169.html"],
    "Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit": ["idhi_accessibility_check_g1170.html"],
    "Rpt_Aria_OneBannerInSiblingSet_Implicit": ["idhi_accessibility_check_g1172.html"],
    "Rpt_Aria_ContentinfoWithNoMain_Implicit": ["idhi_accessibility_check_g1173.html"],
    "Rpt_Aria_ComplementaryRequiredLabel_Implicit": ["idhi_accessibility_check_g1174.html"],
    "Rpt_Aria_MultipleRegionsUniqueLabel_Implicit": ["idhi_accessibility_check_g1176.html"],
    "IBMA_Focus_Tabbable": ["idhi_accessibility_check_g1177.html"],
    "IBMA_Focus_MultiTab": ["idhi_accessibility_check_g1178.html"],
    "WCAG20_Table_SummaryAria3": ["idhi_accessibility_check_g1179.html"],
    "RPT_Style_Trigger2": ["idhi_accessibility_check_g1180.html"],
    "Rpt_Aria_MultipleMainsRequireLabel_Implicit_2": ["idhi_accessibility_check_g1182.html"],
    "HAAC_Media_DocumentTrigger2": ["idhi_accessibility_check_g1183.html"],
    "HAAC_Aria_ErrorMessage": ["idhi_accessibility_check_g1184.html"],
    "HAAC_List_Group_ListItem": ["idhi_accessibility_check_g1185.html"],
    "HAAC_ActiveDescendantCheck": ["idhi_accessibility_check_g1186.html"],
    "HAAC_Application_Role_Text": ["idhi_accessibility_check_g1187.html"],
    "Rpt_Aria_MultipleToolbarUniqueLabel": ["idhi_accessibility_check_g1188.html"],
    "HAAC_Combobox_ARIA_11_Guideline": ["idhi_accessibility_check_g1193.html"],
    "HAAC_Combobox_Must_Have_Text_Input": ["idhi_accessibility_check_g1194.html"],
    "HAAC_Combobox_DOM_Focus": ["idhi_accessibility_check_g1195.html"],
    "HAAC_Combobox_Autocomplete": ["idhi_accessibility_check_g1196.html"],
    "HAAC_Combobox_Autocomplete_Invalid": ["idhi_accessibility_check_g1197.html"],
    "HAAC_Combobox_Expanded": ["idhi_accessibility_check_g1198.html"],
    "HAAC_Combobox_Popup": ["idhi_accessibility_check_g1199.html"],
    "WCAG21_Style_Viewport": ["idhi_accessibility_check_g1200.html"],
    "WCAG21_Label_Accessible": ["idhi_accessibility_check_g1202.html"],
    "WCAG21_Input_Autocomplete": ["idhi_accessibility_check_g1203.html"],
    "WCAG20_Input_VisibleLabel": ["idhi_accessibility_check_g1204.html"]
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkRulesets = void 0;
var rulesets_1 = __webpack_require__(67);
var rulesets_2 = __webpack_require__(68);
var checkRulesets = [];
exports.checkRulesets = checkRulesets;
exports.checkRulesets = checkRulesets = checkRulesets.concat(rulesets_1.a11yRulesets);
exports.checkRulesets = checkRulesets = checkRulesets.concat(rulesets_2.designRulesets);


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.a11yRulesets = void 0;
var IEngine_1 = __webpack_require__(0);
var a11yRulesets = [
    {
        id: "IBM_Accessibility",
        name: "IBM Accessibility",
        category: IEngine_1.eRuleCategory.ACCESSIBILITY,
        description: "Rules for WCAG 2.1 AA plus additional IBM checklist supplemental requirements.",
        "checkpoints": [
            {
                "num": "1.1.1",
                "name": "Non-text Content",
                "summary": "All non-text content that is presented to the user has a text alternative that serves the equivalent purpose.",
                "rules": [
                    {
                        id: "WCAG20_Input_ExplicitLabelImage",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Img_UsemapValid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Object_HasText",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Applet_HasAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_ExplicitLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Area_HasAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Img_AltCommonMisuse",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Img_LongDescription2",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_HasAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Pre_ASCIIArt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_AudioVideoAltFilename",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Style_BackgroundImage",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_LinkTextNotRedundant",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_TitleEmptyWhenAltNull",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Img_UsemapAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Text_Emoticons",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_PresentationImgHasNonNullAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Figure_label",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_AltBrief",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Embed_HasNoEmbed",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Embed_HasAlt",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Style_Trigger2",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_BackgroundImg_HasTextOrTitle",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Valerie_Noembed_HasContent",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Canvas",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "1.2.1",
                "name": "Audio-only and Video-only (Prerecorded)",
                "summary": "For prerecorded audio-only or video-only media, an alternative provides equivalent information.",
                "rules": [
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_AudioTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.2.2",
                "name": "Captions (Prerecorded)",
                "summary": "Captions are provided for all prerecorded audio content in synchronized media.",
                "rules": [
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.2.3",
                "name": "Audio Description or Media Alternative (Prerecorded)",
                "summary": "An alternative for time-based media or audio description of the prerecorded video content is provided for synchronized media.",
                "rules": [
                    {
                        id: "RPT_Media_VideoReferenceTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "1.2.4",
                "name": "Captions (Live)",
                "summary": "Captions are provided for all live audio content in synchronized media.",
                "rules": [
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_VideoObjectTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                ]
            },
            {
                "num": "1.2.5",
                "name": "Audio Description (Prerecorded)",
                "summary": "Audio description is provided for all prerecorded video content in synchronized media.",
                "rules": [
                    {
                        id: "RPT_Media_VideoReferenceTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "1.3.1",
                "name": "Info and Relationships",
                "summary": "Information, structure, and relationships conveyed through presentation can be programmatically determined or are available in text.",
                "rules": [
                    {
                        id: "RPT_Headers_FewWords",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Blockquote_HasCite",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "ext_quoted_valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Block_ShouldBeHeading",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Label_UniqueFor",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_List_UseMarkup",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Script_OnclickHTML1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Fieldset_HasLegend",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Table_CapSummRedundant",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Table_Scope_Valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_RadioChkInFieldSet",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Caption_HasContent",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Caption_InTable",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Table_DataCellRelationships",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Table_DataHeadingsAria",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Label_RefValid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Style_BeforeAfter",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_List_Misuse",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Select_HasOptGroup",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Script_OnclickHTML2",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Input_InFieldSet",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Table_LayoutTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Table_Structure",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Table_SummaryAria3",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                ]
            },
            {
                "num": "1.3.2",
                "name": "Meaningful Sequence",
                "summary": "When the sequence in which content is presented affects its meaning, a correct reading sequence can be programmatically determined.",
                "rules": [
                    {
                        id: "Valerie_Elem_DirValid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Text_LetterSpacing",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.3.3",
                "name": "Sensory Characteristics",
                "summary": "Instructions provided for understanding and operating content do not rely solely on sensory characteristics of components such as shape, size, visual location, orientation, or sound.",
                "rules": [
                    {
                        id: "RPT_Text_SensoryReference",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.3.4",
                "name": "Orientation",
                "summary": "Content does not restrict its view and operation to a single display orientation, such as portrait or landscape.",
                "rules": []
            },
            {
                "num": "1.3.5",
                "name": "Identify Input Purpose",
                "summary": "The purpose of each input field that collects information about the user can be programmatically determined when the field serves a common purpose.",
                "rules": [
                    {
                        id: "WCAG21_Input_Autocomplete",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.1",
                "name": "Use of Color",
                "summary": "Color is not used as the only visual means of conveying information, indicating an action, prompting a response, or distinguishing a visual element.",
                "rules": [
                    {
                        id: "RPT_Font_ColorInForm",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Style_ColorSemantics1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.2",
                "name": "Audio Control",
                "summary": "If any audio plays automatically for more than 3 seconds, either a mechanism is available to pause or stop the audio, or a mechanism is available to control audio volume independently from the overall system volume level.",
                "rules": [
                    {
                        id: "RPT_Embed_AutoStart",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.3",
                "name": "Contrast (Minimum)",
                "summary": "The visual presentation of text and images of text has a contrast ratio of at least 4.5:1, with a 3:1 ratio for large-scale text.",
                "rules": [
                    {
                        id: "IBMA_Color_Contrast_WCAG2AA",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "IBMA_Color_Contrast_WCAG2AA_PV",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.4",
                "name": "Resize Text",
                "summary": "Text can be resized without assistive technology up to 200 percent without loss of content or functionality.",
                "rules": [
                    {
                        id: "WCAG21_Style_Viewport",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.5",
                "name": "Images of Text",
                "summary": "If the technologies being used can achieve the visual presentation, text is used to convey information rather than images of text.",
                "rules": []
            },
            {
                "num": "1.4.10",
                "name": "Reflow",
                "summary": "Content can reflow without loss of information or functionality, and without requiring scrolling in two dimensions.",
                "rules": []
            },
            {
                "num": "1.4.11",
                "name": "Non-text Contrast",
                "summary": "The parts of graphical objects required to understand the content, and the visual information required to identify UI components and states, have a contrast ratio of at least 3:1 against adjacent colors.",
                "rules": []
            },
            {
                "num": "1.4.12",
                "name": "Text Spacing",
                "summary": "No loss of content or functionality occurs when users change letter, word and paragraph spacing, as well as line height.",
                "rules": []
            },
            {
                "num": "1.4.13",
                "name": "Content on Hover or Focus",
                "summary": "Where hover or focus actions cause additional content to become visible and hidden, the additional content is dismissable, hoverable and persistent.",
                "rules": []
            },
            {
                "num": "2.1.1",
                "name": "Keyboard",
                "summary": "All functionality of the content is operable through a keyboard interface without requiring specific timings for individual keystrokes.",
                "rules": [
                    {
                        id: "RPT_Elem_EventMouseAndKey",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_InvalidTabindexForActivedescendant",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MissingFocusableChild",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MissingKeyboardHandler",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Audio_Video_Trigger",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Application_Role_Text",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.1.2",
                "name": "No Keyboard Trap",
                "summary": "If keyboard focus can be moved to a component using a keyboard interface, then focus can be moved away from that component using only a keyboard interface, and, if it requires more than unmodified arrow or tab keys or other standard exit methods, the user is advised of the method for moving focus away.",
                "rules": [
                    {
                        id: "HAAC_Media_DocumentTrigger2",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "2.1.4",
                "name": "Character Key Shortcuts",
                "summary": "If a keyboard shortcut is implemented using only letter, punctuation, number or symbol characters, then the shortcut can be turned off, remapped or activated only on focus.",
                "rules": []
            },
            {
                "num": "2.2.1",
                "name": "Timing Adjustable",
                "summary": "For each time limit that is set by the content, the user can turn off, adjust, or extend the limit.",
                "rules": [
                    {
                        id: "RPT_Meta_Refresh",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Meta_RedirectZero",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.2.2",
                "name": "Pause, Stop, Hide",
                "summary": "For moving, blinking, scrolling, or auto-updating information, the user can pause, stop, hide or adjust the information.",
                "rules": [
                    {
                        id: "RPT_Marquee_Trigger",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Blink_AlwaysTrigger",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Blink_CSSTrigger1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.3.1",
                "name": "Three Flashes or Below Threshold",
                "summary": "Content does not contain anything that flashes more than three times in any one second period, or the flash is below the general flash and red flash thresholds.",
                "rules": []
            },
            {
                "num": "2.4.1",
                "name": "Bypass Blocks",
                "summary": "A mechanism is available to bypass blocks of content that are repeated on multiple Web pages.",
                "rules": [
                    {
                        id: "WCAG20_Frame_HasTitle",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Html_SkipNav",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Frame_SrcHtml",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleSearchLandmarks",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ComplementaryLandmarkLabel_Implicit",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_MultipleApplicationLandmarks",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ApplicationLandmarkLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleDocumentRoles",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Body_FirstASkips_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_OrphanedContent_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RegionLabel_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleMainsVisibleLabel_Implicit",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_MultipleBannerLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleComplementaryLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleContentinfoLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleFormLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleNavigationLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleArticleRoles_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleGroupRoles_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_OneBannerInSiblingSet_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ContentinfoWithNoMain_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ComplementaryRequiredLabel_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleRegionsUniqueLabel_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleMainsRequireLabel_Implicit_2",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.2",
                "name": "Page Titled",
                "summary": "Web pages, non-web documents, and software have titles that describe topic or purpose.",
                "rules": [
                    {
                        id: "WCAG20_Doc_HasTitle",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Title_Valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.3",
                "name": "Focus Order",
                "summary": "If content can be navigated sequentially and the navigation sequences affect meaning or operation, focusable components receive focus in an order that preserves meaning and operability.",
                "rules": []
            },
            {
                "num": "2.4.4",
                "name": "Link Purpose (In Context)",
                "summary": "The purpose of each link can be determined from the link text alone or from the link text together with its programmatically determined link content.",
                "rules": [
                    {
                        id: "WCAG20_A_HasText",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.5",
                "name": "Multiple Ways",
                "summary": "More than one way is available to locate a Web page within a set of Web pages, except where the Web Page is the result of, or a step in, a process.",
                "rules": []
            },
            {
                "num": "2.4.6",
                "name": "Headings and Labels",
                "summary": "Headings and labels describe topic or purpose.",
                "rules": [
                    {
                        id: "RPT_Header_HasContent",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.7",
                "name": "Focus Visible",
                "summary": "Any keyboard operable user interface has a mode of operation where the keyboard focus indicator is visible.",
                "rules": [
                    {
                        id: "RPT_Style_HinderFocus1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Script_FocusBlurs",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.5.1",
                "name": "Pointer Gestures",
                "summary": "All functionality that uses multipoint or path-based gestures for operation can be operated with a single pointer without a path-based gesture.",
                "rules": []
            },
            {
                "num": "2.5.2",
                "name": "Pointer Cancellation",
                "summary": "For functionality that can be operated using a single pointer, completion of the function is on the up-event with an ability to abort, undo or reverse the outcome.",
                "rules": []
            },
            {
                "num": "2.5.3",
                "name": "Label in Name",
                "summary": "For user interface components with labels that include text or images of text, the accessible name contains the text that is presented visually.",
                "rules": [
                    {
                        id: "WCAG21_Label_Accessible",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.5.4",
                "name": "Motion Actuation",
                "summary": "Functionality that can be operated by motion can also be operated by user interface components, and the motion trigger can be disabled.",
                "rules": []
            },
            {
                "num": "3.1.1",
                "name": "Language of Page",
                "summary": "The default human language of Web pages, non-Web documents, or software can be programmatically determined.",
                "rules": [
                    {
                        id: "WCAG20_Html_HasLang",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.1.2",
                "name": "Language of Parts",
                "summary": "The human language of each passage or phrase in the content can be programmatically determined.",
                "rules": [
                    {
                        id: "WCAG20_Elem_Lang_Valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.2.1",
                "name": "On Focus",
                "summary": "When any component receives focus, it does not initiate a change of context.",
                "rules": [
                    {
                        id: "WCAG20_Select_NoChangeAction",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Script_FocusBlurs",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.2.2",
                "name": "On Input",
                "summary": "Changing the setting of any user interface component does not automatically cause a change of context unless the user has been advised of the behavior before using the component.",
                "rules": [
                    {
                        id: "WCAG20_A_TargetAndText",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Form_HasSubmit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Form_TargetAndText",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_HasOnchange",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Form_ChangeEmpty",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "3.2.3",
                "name": "Consistent Navigation",
                "summary": "Navigational mechanisms that are repeated on multiple Web pages within a set of Web pages occur in the same relative order each time they are repeated, unless a change is initiated by the user.",
                "rules": []
            },
            {
                "num": "3.2.4",
                "name": "Consistent Identification",
                "summary": "Components that have the same functionality within a set of Web pages are identified consistently.",
                "rules": []
            },
            {
                "num": "3.3.1",
                "name": "Error Identification",
                "summary": "If an input error is automatically detected, the item that is in error is identified and the error is described to the user in text.",
                "rules": [
                    {
                        id: "HAAC_Aria_ErrorMessage",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.3.2",
                "name": "Labels or Instructions",
                "summary": "Labels or instructions are provided when content requires user input.",
                "rules": [
                    {
                        id: "WCAG20_Input_LabelBefore",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_LabelAfter",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Accesskey_NeedLabel",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Aria_Or_HTML5_Attr",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Input_Placeholder",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_VisibleLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                ]
            },
            {
                "num": "3.3.3",
                "name": "Error Suggestion",
                "summary": "If an input error is automatically detected and suggestions for correction are known, then the suggestions are provided to the user, unless it would jeopardize the security or purpose of the content.",
                "rules": []
            },
            {
                "num": "3.3.4",
                "name": "Error Prevention (Legal, Financial, Data)",
                "summary": "For content that cause legal commitments or financial transactions for the user to occur, that modify or delete user-controllable data in data storage systems, or that submit user test responses, the user can reverse, correct, or confirm the action.",
                "rules": []
            },
            {
                "num": "4.1.1",
                "name": "Parsing",
                "summary": "In content implemented using markup languages, elements have complete start and end tags, elements are nested according to their specifications, elements do not contain duplicate attributes, and any IDs are unique, except where the specifications allow these features.",
                "rules": [
                    {
                        id: "RPT_Elem_UniqueId",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Elem_UniqueAccessKey",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "4.1.2",
                "name": "Name, Role, Value",
                "summary": "For all user interface components (including, but not limited to: form elements, links and components generated by scripts), the name and role can be programmatically determined; states, properties, and values that can be set by the user can be programmatically set; and notification of changes to these items is available to user agents, including assistive technologies.",
                "rules": [
                    {
                        id: "WCAG20_Input_ExplicitLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Label_HasContent",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidRole",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidPropertyValue",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidIdRef",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RequiredProperties",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_EmptyPropertyValue",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidProperty",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Aria_ImgAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Canvas",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Aria_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RequiredChildren_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RequiredParent_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_WidgetLabels_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_ARIA_11_Guideline",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_List_Group_ListItem",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_ActiveDescendantCheck",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleToolbarUniqueLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Must_Have_Text_Input",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_DOM_Focus",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Autocomplete",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Autocomplete_Invalid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Expanded",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Popup",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            }
        ]
    },
    {
        id: "WCAG_2_1",
        name: "WCAG 2.1 (A, AA)",
        category: IEngine_1.eRuleCategory.ACCESSIBILITY,
        description: "Rules for WCAG 2.1 AA. This is the current W3C recommendation. Content that conforms to WCAG 2.1 also conforms to WCAG 2.0.",
        "checkpoints": [
            {
                "num": "1.1.1",
                "name": "Non-text Content",
                "summary": "All non-text content that is presented to the user has a text alternative that serves the equivalent purpose.",
                "rules": [
                    {
                        id: "WCAG20_Input_ExplicitLabelImage",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Img_UsemapValid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Object_HasText",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Applet_HasAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_ExplicitLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Area_HasAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Img_AltCommonMisuse",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Img_LongDescription2",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_HasAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Pre_ASCIIArt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_AudioVideoAltFilename",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Style_BackgroundImage",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_LinkTextNotRedundant",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_TitleEmptyWhenAltNull",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Img_UsemapAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Text_Emoticons",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_PresentationImgHasNonNullAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Figure_label",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_AltBrief",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Embed_HasNoEmbed",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Embed_HasAlt",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Style_Trigger2",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_BackgroundImg_HasTextOrTitle",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Valerie_Noembed_HasContent",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Canvas",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "1.2.1",
                "name": "Audio-only and Video-only (Prerecorded)",
                "summary": "For prerecorded audio-only or video-only media, an alternative provides equivalent information.",
                "rules": [
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_AudioTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.2.2",
                "name": "Captions (Prerecorded)",
                "summary": "Captions are provided for all prerecorded audio content in synchronized media.",
                "rules": [
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.2.3",
                "name": "Audio Description or Media Alternative (Prerecorded)",
                "summary": "An alternative for time-based media or audio description of the prerecorded video content is provided for synchronized media.",
                "rules": [
                    {
                        id: "RPT_Media_VideoReferenceTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "1.2.4",
                "name": "Captions (Live)",
                "summary": "Captions are provided for all live audio content in synchronized media.",
                "rules": [
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_VideoObjectTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                ]
            },
            {
                "num": "1.2.5",
                "name": "Audio Description (Prerecorded)",
                "summary": "Audio description is provided for all prerecorded video content in synchronized media.",
                "rules": [
                    {
                        id: "RPT_Media_VideoReferenceTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "1.3.1",
                "name": "Info and Relationships",
                "summary": "Information, structure, and relationships conveyed through presentation can be programmatically determined or are available in text.",
                "rules": [
                    {
                        id: "RPT_Headers_FewWords",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Blockquote_HasCite",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "ext_quoted_valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Block_ShouldBeHeading",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Label_UniqueFor",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_List_UseMarkup",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Script_OnclickHTML1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Fieldset_HasLegend",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Table_CapSummRedundant",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Table_Scope_Valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_RadioChkInFieldSet",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Caption_HasContent",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Caption_InTable",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Table_DataCellRelationships",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Table_DataHeadingsAria",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Label_RefValid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Style_BeforeAfter",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_List_Misuse",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Select_HasOptGroup",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Script_OnclickHTML2",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Input_InFieldSet",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Table_LayoutTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Table_Structure",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Table_SummaryAria3",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                ]
            },
            {
                "num": "1.3.2",
                "name": "Meaningful Sequence",
                "summary": "When the sequence in which content is presented affects its meaning, a correct reading sequence can be programmatically determined.",
                "rules": [
                    {
                        id: "Valerie_Elem_DirValid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Text_LetterSpacing",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.3.3",
                "name": "Sensory Characteristics",
                "summary": "Instructions provided for understanding and operating content do not rely solely on sensory characteristics of components such as shape, size, visual location, orientation, or sound.",
                "rules": [
                    {
                        id: "RPT_Text_SensoryReference",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.3.4",
                "name": "Orientation",
                "summary": "Content does not restrict its view and operation to a single display orientation, such as portrait or landscape.",
                "rules": []
            },
            {
                "num": "1.3.5",
                "name": "Identify Input Purpose",
                "summary": "The purpose of each input field that collects information about the user can be programmatically determined when the field serves a common purpose.",
                "rules": [
                    {
                        id: "WCAG21_Input_Autocomplete",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.1",
                "name": "Use of Color",
                "summary": "Color is not used as the only visual means of conveying information, indicating an action, prompting a response, or distinguishing a visual element.",
                "rules": [
                    {
                        id: "RPT_Font_ColorInForm",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Style_ColorSemantics1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.2",
                "name": "Audio Control",
                "summary": "If any audio plays automatically for more than 3 seconds, either a mechanism is available to pause or stop the audio, or a mechanism is available to control audio volume independently from the overall system volume level.",
                "rules": [
                    {
                        id: "RPT_Embed_AutoStart",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.3",
                "name": "Contrast (Minimum)",
                "summary": "The visual presentation of text and images of text has a contrast ratio of at least 4.5:1, with a 3:1 ratio for large-scale text.",
                "rules": [
                    {
                        id: "IBMA_Color_Contrast_WCAG2AA",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "IBMA_Color_Contrast_WCAG2AA_PV",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.4",
                "name": "Resize Text",
                "summary": "Text can be resized without assistive technology up to 200 percent without loss of content or functionality.",
                "rules": [
                    {
                        id: "WCAG21_Style_Viewport",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.5",
                "name": "Images of Text",
                "summary": "If the technologies being used can achieve the visual presentation, text is used to convey information rather than images of text.",
                "rules": []
            },
            {
                "num": "1.4.10",
                "name": "Reflow",
                "summary": "Content can reflow without loss of information or functionality, and without requiring scrolling in two dimensions.",
                "rules": []
            },
            {
                "num": "1.4.11",
                "name": "Non-text Contrast",
                "summary": "The parts of graphical objects required to understand the content, and the visual information required to identify UI components and states, have a contrast ratio of at least 3:1 against adjacent colors.",
                "rules": []
            },
            {
                "num": "1.4.12",
                "name": "Text Spacing",
                "summary": "No loss of content or functionality occurs when users change letter, word and paragraph spacing, as well as line height.",
                "rules": []
            },
            {
                "num": "1.4.13",
                "name": "Content on Hover or Focus",
                "summary": "Where hover or focus actions cause additional content to become visible and hidden, the additional content is dismissable, hoverable and persistent.",
                "rules": []
            },
            {
                "num": "2.1.1",
                "name": "Keyboard",
                "summary": "All functionality of the content is operable through a keyboard interface without requiring specific timings for individual keystrokes.",
                "rules": [
                    {
                        id: "RPT_Elem_EventMouseAndKey",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_InvalidTabindexForActivedescendant",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MissingFocusableChild",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MissingKeyboardHandler",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Audio_Video_Trigger",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Application_Role_Text",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.1.2",
                "name": "No Keyboard Trap",
                "summary": "If keyboard focus can be moved to a component using a keyboard interface, then focus can be moved away from that component using only a keyboard interface, and, if it requires more than unmodified arrow or tab keys or other standard exit methods, the user is advised of the method for moving focus away.",
                "rules": [
                    {
                        id: "HAAC_Media_DocumentTrigger2",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "2.1.4",
                "name": "Character Key Shortcuts",
                "summary": "If a keyboard shortcut is implemented using only letter, punctuation, number or symbol characters, then the shortcut can be turned off, remapped or activated only on focus.",
                "rules": []
            },
            {
                "num": "2.2.1",
                "name": "Timing Adjustable",
                "summary": "For each time limit that is set by the content, the user can turn off, adjust, or extend the limit.",
                "rules": [
                    {
                        id: "RPT_Meta_Refresh",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Meta_RedirectZero",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.2.2",
                "name": "Pause, Stop, Hide",
                "summary": "For moving, blinking, scrolling, or auto-updating information, the user can pause, stop, hide or adjust the information.",
                "rules": [
                    {
                        id: "RPT_Marquee_Trigger",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Blink_AlwaysTrigger",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Blink_CSSTrigger1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.3.1",
                "name": "Three Flashes or Below Threshold",
                "summary": "Content does not contain anything that flashes more than three times in any one second period, or the flash is below the general flash and red flash thresholds.",
                "rules": []
            },
            {
                "num": "2.4.1",
                "name": "Bypass Blocks",
                "summary": "A mechanism is available to bypass blocks of content that are repeated on multiple Web pages.",
                "rules": [
                    {
                        id: "WCAG20_Frame_HasTitle",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Html_SkipNav",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Frame_SrcHtml",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleSearchLandmarks",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ComplementaryLandmarkLabel_Implicit",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_MultipleApplicationLandmarks",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ApplicationLandmarkLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleDocumentRoles",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Body_FirstASkips_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_OrphanedContent_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_RegionLabel_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleMainsVisibleLabel_Implicit",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_MultipleBannerLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleComplementaryLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleContentinfoLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleFormLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleNavigationLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleArticleRoles_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleGroupRoles_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_OneBannerInSiblingSet_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ContentinfoWithNoMain_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ComplementaryRequiredLabel_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleRegionsUniqueLabel_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleMainsRequireLabel_Implicit_2",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.2",
                "name": "Page Titled",
                "summary": "Web pages, non-web documents, and software have titles that describe topic or purpose.",
                "rules": [
                    {
                        id: "WCAG20_Doc_HasTitle",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Title_Valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.3",
                "name": "Focus Order",
                "summary": "If content can be navigated sequentially and the navigation sequences affect meaning or operation, focusable components receive focus in an order that preserves meaning and operability.",
                "rules": []
            },
            {
                "num": "2.4.4",
                "name": "Link Purpose (In Context)",
                "summary": "The purpose of each link can be determined from the link text alone or from the link text together with its programmatically determined link content.",
                "rules": [
                    {
                        id: "WCAG20_A_HasText",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.5",
                "name": "Multiple Ways",
                "summary": "More than one way is available to locate a Web page within a set of Web pages, except where the Web Page is the result of, or a step in, a process.",
                "rules": []
            },
            {
                "num": "2.4.6",
                "name": "Headings and Labels",
                "summary": "Headings and labels describe topic or purpose.",
                "rules": [
                    {
                        id: "RPT_Header_HasContent",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.7",
                "name": "Focus Visible",
                "summary": "Any keyboard operable user interface has a mode of operation where the keyboard focus indicator is visible.",
                "rules": [
                    {
                        id: "RPT_Style_HinderFocus1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Script_FocusBlurs",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.5.1",
                "name": "Pointer Gestures",
                "summary": "All functionality that uses multipoint or path-based gestures for operation can be operated with a single pointer without a path-based gesture.",
                "rules": []
            },
            {
                "num": "2.5.2",
                "name": "Pointer Cancellation",
                "summary": "For functionality that can be operated using a single pointer, completion of the function is on the up-event with an ability to abort, undo or reverse the outcome.",
                "rules": []
            },
            {
                "num": "2.5.3",
                "name": "Label in Name",
                "summary": "For user interface components with labels that include text or images of text, the accessible name contains the text that is presented visually.",
                "rules": [
                    {
                        id: "WCAG21_Label_Accessible",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.5.4",
                "name": "Motion Actuation",
                "summary": "Functionality that can be operated by motion can also be operated by user interface components, and the motion trigger can be disabled.",
                "rules": []
            },
            {
                "num": "3.1.1",
                "name": "Language of Page",
                "summary": "The default human language of Web pages, non-Web documents, or software can be programmatically determined.",
                "rules": [
                    {
                        id: "WCAG20_Html_HasLang",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.1.2",
                "name": "Language of Parts",
                "summary": "The human language of each passage or phrase in the content can be programmatically determined.",
                "rules": [
                    {
                        id: "WCAG20_Elem_Lang_Valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.2.1",
                "name": "On Focus",
                "summary": "When any component receives focus, it does not initiate a change of context.",
                "rules": [
                    {
                        id: "WCAG20_Select_NoChangeAction",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Script_FocusBlurs",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.2.2",
                "name": "On Input",
                "summary": "Changing the setting of any user interface component does not automatically cause a change of context unless the user has been advised of the behavior before using the component.",
                "rules": [
                    {
                        id: "WCAG20_A_TargetAndText",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Form_HasSubmit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Form_TargetAndText",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_HasOnchange",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Form_ChangeEmpty",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "3.2.3",
                "name": "Consistent Navigation",
                "summary": "Navigational mechanisms that are repeated on multiple Web pages within a set of Web pages occur in the same relative order each time they are repeated, unless a change is initiated by the user.",
                "rules": []
            },
            {
                "num": "3.2.4",
                "name": "Consistent Identification",
                "summary": "Components that have the same functionality within a set of Web pages are identified consistently.",
                "rules": []
            },
            {
                "num": "3.3.1",
                "name": "Error Identification",
                "summary": "If an input error is automatically detected, the item that is in error is identified and the error is described to the user in text.",
                "rules": [
                    {
                        id: "HAAC_Aria_ErrorMessage",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.3.2",
                "name": "Labels or Instructions",
                "summary": "Labels or instructions are provided when content requires user input.",
                "rules": [
                    {
                        id: "WCAG20_Input_LabelBefore",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_LabelAfter",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Accesskey_NeedLabel",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Aria_Or_HTML5_Attr",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Input_Placeholder",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_VisibleLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                ]
            },
            {
                "num": "3.3.3",
                "name": "Error Suggestion",
                "summary": "If an input error is automatically detected and suggestions for correction are known, then the suggestions are provided to the user, unless it would jeopardize the security or purpose of the content.",
                "rules": []
            },
            {
                "num": "3.3.4",
                "name": "Error Prevention (Legal, Financial, Data)",
                "summary": "For content that cause legal commitments or financial transactions for the user to occur, that modify or delete user-controllable data in data storage systems, or that submit user test responses, the user can reverse, correct, or confirm the action.",
                "rules": []
            },
            {
                "num": "4.1.1",
                "name": "Parsing",
                "summary": "In content implemented using markup languages, elements have complete start and end tags, elements are nested according to their specifications, elements do not contain duplicate attributes, and any IDs are unique, except where the specifications allow these features.",
                "rules": [
                    {
                        id: "RPT_Elem_UniqueId",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Elem_UniqueAccessKey",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "4.1.2",
                "name": "Name, Role, Value",
                "summary": "For all user interface components (including, but not limited to: form elements, links and components generated by scripts), the name and role can be programmatically determined; states, properties, and values that can be set by the user can be programmatically set; and notification of changes to these items is available to user agents, including assistive technologies.",
                "rules": [
                    {
                        id: "WCAG20_Input_ExplicitLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Label_HasContent",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidRole",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidPropertyValue",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidIdRef",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RequiredProperties",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_EmptyPropertyValue",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidProperty",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Aria_ImgAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Canvas",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Aria_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RequiredChildren_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RequiredParent_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_WidgetLabels_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_ARIA_11_Guideline",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_List_Group_ListItem",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_ActiveDescendantCheck",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleToolbarUniqueLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Must_Have_Text_Input",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_DOM_Focus",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Autocomplete",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Autocomplete_Invalid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Expanded",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Popup",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            }
        ]
    },
    {
        id: "WCAG_2_0",
        name: "WCAG 2.0 (A, AA)",
        category: IEngine_1.eRuleCategory.ACCESSIBILITY,
        description: "Rules for WCAG 2.0 AA. Referenced by US Section 508, but not the latest W3C recommendation.",
        "checkpoints": [
            {
                "num": "1.1.1",
                "name": "Non-text Content",
                "summary": "All non-text content that is presented to the user has a text alternative that serves the equivalent purpose.",
                "rules": [
                    {
                        id: "WCAG20_Input_ExplicitLabelImage",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Img_UsemapValid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Object_HasText",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Applet_HasAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_ExplicitLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Area_HasAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Img_AltCommonMisuse",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Img_LongDescription2",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_HasAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Pre_ASCIIArt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_AudioVideoAltFilename",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Style_BackgroundImage",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_LinkTextNotRedundant",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_TitleEmptyWhenAltNull",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Img_UsemapAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Text_Emoticons",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_PresentationImgHasNonNullAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Figure_label",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_AltBrief",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Embed_HasNoEmbed",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Embed_HasAlt",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Style_Trigger2",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_BackgroundImg_HasTextOrTitle",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Valerie_Noembed_HasContent",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Canvas",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "1.2.1",
                "name": "Audio-only and Video-only (Prerecorded)",
                "summary": "For prerecorded audio-only or video-only media, an alternative provides equivalent information.",
                "rules": [
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_AudioTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.2.2",
                "name": "Captions (Prerecorded)",
                "summary": "Captions are provided for all prerecorded audio content in synchronized media.",
                "rules": [
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.2.3",
                "name": "Audio Description or Media Alternative (Prerecorded)",
                "summary": "An alternative for time-based media or audio description of the prerecorded video content is provided for synchronized media.",
                "rules": [
                    {
                        id: "RPT_Media_VideoReferenceTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "1.2.4",
                "name": "Captions (Live)",
                "summary": "Captions are provided for all live audio content in synchronized media.",
                "rules": [
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_VideoObjectTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                ]
            },
            {
                "num": "1.2.5",
                "name": "Audio Description (Prerecorded)",
                "summary": "Audio description is provided for all prerecorded video content in synchronized media.",
                "rules": [
                    {
                        id: "RPT_Media_VideoReferenceTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "1.3.1",
                "name": "Info and Relationships",
                "summary": "Information, structure, and relationships conveyed through presentation can be programmatically determined or are available in text.",
                "rules": [
                    {
                        id: "RPT_Headers_FewWords",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Blockquote_HasCite",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "ext_quoted_valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Block_ShouldBeHeading",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Label_UniqueFor",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_List_UseMarkup",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Script_OnclickHTML1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Fieldset_HasLegend",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Table_CapSummRedundant",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Table_Scope_Valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_RadioChkInFieldSet",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Caption_HasContent",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Caption_InTable",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Table_DataCellRelationships",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Table_DataHeadingsAria",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Label_RefValid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Style_BeforeAfter",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_List_Misuse",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Select_HasOptGroup",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Script_OnclickHTML2",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Input_InFieldSet",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Table_LayoutTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Table_Structure",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Table_SummaryAria3",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                ]
            },
            {
                "num": "1.3.2",
                "name": "Meaningful Sequence",
                "summary": "When the sequence in which content is presented affects its meaning, a correct reading sequence can be programmatically determined.",
                "rules": [
                    {
                        id: "Valerie_Elem_DirValid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Text_LetterSpacing",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.3.3",
                "name": "Sensory Characteristics",
                "summary": "Instructions provided for understanding and operating content do not rely solely on sensory characteristics of components such as shape, size, visual location, orientation, or sound.",
                "rules": [
                    {
                        id: "RPT_Text_SensoryReference",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.1",
                "name": "Use of Color",
                "summary": "Color is not used as the only visual means of conveying information, indicating an action, prompting a response, or distinguishing a visual element.",
                "rules": [
                    {
                        id: "RPT_Font_ColorInForm",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Style_ColorSemantics1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.2",
                "name": "Audio Control",
                "summary": "If any audio plays automatically for more than 3 seconds, either a mechanism is available to pause or stop the audio, or a mechanism is available to control audio volume independently from the overall system volume level.",
                "rules": [
                    {
                        id: "RPT_Embed_AutoStart",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.3",
                "name": "Contrast (Minimum)",
                "summary": "The visual presentation of text and images of text has a contrast ratio of at least 4.5:1, with a 3:1 ratio for large-scale text.",
                "rules": [
                    {
                        id: "IBMA_Color_Contrast_WCAG2AA",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "IBMA_Color_Contrast_WCAG2AA_PV",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.4",
                "name": "Resize Text",
                "summary": "Text can be resized without assistive technology up to 200 percent without loss of content or functionality.",
                "rules": [
                    {
                        id: "WCAG21_Style_Viewport",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.5",
                "name": "Images of Text",
                "summary": "If the technologies being used can achieve the visual presentation, text is used to convey information rather than images of text.",
                "rules": []
            },
            {
                "num": "2.1.1",
                "name": "Keyboard",
                "summary": "All functionality of the content is operable through a keyboard interface without requiring specific timings for individual keystrokes.",
                "rules": [
                    {
                        id: "RPT_Elem_EventMouseAndKey",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_InvalidTabindexForActivedescendant",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MissingFocusableChild",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MissingKeyboardHandler",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Audio_Video_Trigger",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Application_Role_Text",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.1.2",
                "name": "No Keyboard Trap",
                "summary": "If keyboard focus can be moved to a component using a keyboard interface, then focus can be moved away from that component using only a keyboard interface, and, if it requires more than unmodified arrow or tab keys or other standard exit methods, the user is advised of the method for moving focus away.",
                "rules": [
                    {
                        id: "HAAC_Media_DocumentTrigger2",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "2.2.1",
                "name": "Timing Adjustable",
                "summary": "For each time limit that is set by the content, the user can turn off, adjust, or extend the limit.",
                "rules": [
                    {
                        id: "RPT_Meta_Refresh",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Meta_RedirectZero",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.2.2",
                "name": "Pause, Stop, Hide",
                "summary": "For moving, blinking, scrolling, or auto-updating information, the user can pause, stop, hide or adjust the information.",
                "rules": [
                    {
                        id: "RPT_Marquee_Trigger",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Blink_AlwaysTrigger",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Blink_CSSTrigger1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.3.1",
                "name": "Three Flashes or Below Threshold",
                "summary": "Content does not contain anything that flashes more than three times in any one second period, or the flash is below the general flash and red flash thresholds.",
                "rules": []
            },
            {
                "num": "2.4.1",
                "name": "Bypass Blocks",
                "summary": "A mechanism is available to bypass blocks of content that are repeated on multiple Web pages.",
                "rules": [
                    {
                        id: "WCAG20_Frame_HasTitle",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Html_SkipNav",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Frame_SrcHtml",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleSearchLandmarks",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ComplementaryLandmarkLabel_Implicit",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_MultipleApplicationLandmarks",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ApplicationLandmarkLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleDocumentRoles",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Body_FirstASkips_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_OrphanedContent_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_RegionLabel_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleMainsVisibleLabel_Implicit",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_MultipleBannerLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleComplementaryLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleContentinfoLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleFormLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleNavigationLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleArticleRoles_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleGroupRoles_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_OneBannerInSiblingSet_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ContentinfoWithNoMain_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ComplementaryRequiredLabel_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleRegionsUniqueLabel_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleMainsRequireLabel_Implicit_2",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.2",
                "name": "Page Titled",
                "summary": "Web pages, non-web documents, and software have titles that describe topic or purpose.",
                "rules": [
                    {
                        id: "WCAG20_Doc_HasTitle",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Title_Valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.3",
                "name": "Focus Order",
                "summary": "If content can be navigated sequentially and the navigation sequences affect meaning or operation, focusable components receive focus in an order that preserves meaning and operability.",
                "rules": []
            },
            {
                "num": "2.4.4",
                "name": "Link Purpose (In Context)",
                "summary": "The purpose of each link can be determined from the link text alone or from the link text together with its programmatically determined link content.",
                "rules": [
                    {
                        id: "WCAG20_A_HasText",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.5",
                "name": "Multiple Ways",
                "summary": "More than one way is available to locate a Web page within a set of Web pages, except where the Web Page is the result of, or a step in, a process.",
                "rules": []
            },
            {
                "num": "2.4.6",
                "name": "Headings and Labels",
                "summary": "Headings and labels describe topic or purpose.",
                "rules": [
                    {
                        id: "RPT_Header_HasContent",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.7",
                "name": "Focus Visible",
                "summary": "Any keyboard operable user interface has a mode of operation where the keyboard focus indicator is visible.",
                "rules": [
                    {
                        id: "RPT_Style_HinderFocus1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Script_FocusBlurs",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.1.1",
                "name": "Language of Page",
                "summary": "The default human language of Web pages, non-Web documents, or software can be programmatically determined.",
                "rules": [
                    {
                        id: "WCAG20_Html_HasLang",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.1.2",
                "name": "Language of Parts",
                "summary": "The human language of each passage or phrase in the content can be programmatically determined.",
                "rules": [
                    {
                        id: "WCAG20_Elem_Lang_Valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.2.1",
                "name": "On Focus",
                "summary": "When any component receives focus, it does not initiate a change of context.",
                "rules": [
                    {
                        id: "WCAG20_Select_NoChangeAction",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Script_FocusBlurs",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.2.2",
                "name": "On Input",
                "summary": "Changing the setting of any user interface component does not automatically cause a change of context unless the user has been advised of the behavior before using the component.",
                "rules": [
                    {
                        id: "WCAG20_A_TargetAndText",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Form_HasSubmit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Form_TargetAndText",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_HasOnchange",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Form_ChangeEmpty",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "3.2.3",
                "name": "Consistent Navigation",
                "summary": "Navigational mechanisms that are repeated on multiple Web pages within a set of Web pages occur in the same relative order each time they are repeated, unless a change is initiated by the user.",
                "rules": []
            },
            {
                "num": "3.2.4",
                "name": "Consistent Identification",
                "summary": "Components that have the same functionality within a set of Web pages are identified consistently.",
                "rules": []
            },
            {
                "num": "3.3.1",
                "name": "Error Identification",
                "summary": "If an input error is automatically detected, the item that is in error is identified and the error is described to the user in text.",
                "rules": [
                    {
                        id: "HAAC_Aria_ErrorMessage",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.3.2",
                "name": "Labels or Instructions",
                "summary": "Labels or instructions are provided when content requires user input.",
                "rules": [
                    {
                        id: "WCAG20_Input_LabelBefore",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_LabelAfter",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Accesskey_NeedLabel",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Aria_Or_HTML5_Attr",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Input_Placeholder",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_VisibleLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                ]
            },
            {
                "num": "3.3.3",
                "name": "Error Suggestion",
                "summary": "If an input error is automatically detected and suggestions for correction are known, then the suggestions are provided to the user, unless it would jeopardize the security or purpose of the content.",
                "rules": []
            },
            {
                "num": "3.3.4",
                "name": "Error Prevention (Legal, Financial, Data)",
                "summary": "For content that cause legal commitments or financial transactions for the user to occur, that modify or delete user-controllable data in data storage systems, or that submit user test responses, the user can reverse, correct, or confirm the action.",
                "rules": []
            },
            {
                "num": "4.1.1",
                "name": "Parsing",
                "summary": "In content implemented using markup languages, elements have complete start and end tags, elements are nested according to their specifications, elements do not contain duplicate attributes, and any IDs are unique, except where the specifications allow these features.",
                "rules": [
                    {
                        id: "RPT_Elem_UniqueId",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Elem_UniqueAccessKey",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "4.1.2",
                "name": "Name, Role, Value",
                "summary": "For all user interface components (including, but not limited to: form elements, links and components generated by scripts), the name and role can be programmatically determined; states, properties, and values that can be set by the user can be programmatically set; and notification of changes to these items is available to user agents, including assistive technologies.",
                "rules": [
                    {
                        id: "WCAG20_Input_ExplicitLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Label_HasContent",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidRole",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidPropertyValue",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidIdRef",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RequiredProperties",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_EmptyPropertyValue",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidProperty",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Aria_ImgAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Canvas",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Aria_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RequiredChildren_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RequiredParent_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_WidgetLabels_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_ARIA_11_Guideline",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_List_Group_ListItem",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_ActiveDescendantCheck",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleToolbarUniqueLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Must_Have_Text_Input",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_DOM_Focus",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Autocomplete",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Autocomplete_Invalid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Expanded",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Popup",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            }
        ]
    },
    {
        id: "IBM_Accessibility_BETA",
        name: "IBM Accessibility BETA",
        category: IEngine_1.eRuleCategory.ACCESSIBILITY,
        description: "Rules for WCAG 2.1 AA plus additional IBM checklist supplemental requirements and experimental rules.",
        "checkpoints": [
            {
                "num": "1.1.1",
                "name": "Non-text Content",
                "summary": "All non-text content that is presented to the user has a text alternative that serves the equivalent purpose.",
                "rules": [
                    {
                        id: "WCAG20_Input_ExplicitLabelImage",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Img_UsemapValid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Object_HasText",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Applet_HasAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_ExplicitLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Area_HasAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Img_AltCommonMisuse",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Img_LongDescription2",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_HasAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Pre_ASCIIArt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_AudioVideoAltFilename",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Style_BackgroundImage",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_LinkTextNotRedundant",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_TitleEmptyWhenAltNull",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Img_UsemapAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Text_Emoticons",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Img_PresentationImgHasNonNullAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Figure_label",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_AltBrief",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Embed_HasNoEmbed",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Embed_HasAlt",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Style_Trigger2",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_BackgroundImg_HasTextOrTitle",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Valerie_Noembed_HasContent",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Canvas",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "1.2.1",
                "name": "Audio-only and Video-only (Prerecorded)",
                "summary": "For prerecorded audio-only or video-only media, an alternative provides equivalent information.",
                "rules": [
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_AudioTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.2.2",
                "name": "Captions (Prerecorded)",
                "summary": "Captions are provided for all prerecorded audio content in synchronized media.",
                "rules": [
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.2.3",
                "name": "Audio Description or Media Alternative (Prerecorded)",
                "summary": "An alternative for time-based media or audio description of the prerecorded video content is provided for synchronized media.",
                "rules": [
                    {
                        id: "RPT_Media_VideoReferenceTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "1.2.4",
                "name": "Captions (Live)",
                "summary": "Captions are provided for all live audio content in synchronized media.",
                "rules": [
                    {
                        id: "HAAC_Video_HasNoTrack",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Media_VideoObjectTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                ]
            },
            {
                "num": "1.2.5",
                "name": "Audio Description (Prerecorded)",
                "summary": "Audio description is provided for all prerecorded video content in synchronized media.",
                "rules": [
                    {
                        id: "RPT_Media_VideoReferenceTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "1.3.1",
                "name": "Info and Relationships",
                "summary": "Information, structure, and relationships conveyed through presentation can be programmatically determined or are available in text.",
                "rules": [
                    {
                        id: "RPT_Headers_FewWords",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Blockquote_HasCite",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "ext_quoted_valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Block_ShouldBeHeading",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Label_UniqueFor",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_List_UseMarkup",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Script_OnclickHTML1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Fieldset_HasLegend",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Table_CapSummRedundant",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Table_Scope_Valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_RadioChkInFieldSet",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Caption_HasContent",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Caption_InTable",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Table_DataCellRelationships",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Table_DataHeadingsAria",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Label_RefValid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Style_BeforeAfter",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_List_Misuse",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Select_HasOptGroup",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Script_OnclickHTML2",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Input_InFieldSet",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "RPT_Table_LayoutTrigger",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Table_Structure",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Table_SummaryAria3",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                ]
            },
            {
                "num": "1.3.2",
                "name": "Meaningful Sequence",
                "summary": "When the sequence in which content is presented affects its meaning, a correct reading sequence can be programmatically determined.",
                "rules": [
                    {
                        id: "Valerie_Elem_DirValid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Text_LetterSpacing",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.3.3",
                "name": "Sensory Characteristics",
                "summary": "Instructions provided for understanding and operating content do not rely solely on sensory characteristics of components such as shape, size, visual location, orientation, or sound.",
                "rules": [
                    {
                        id: "RPT_Text_SensoryReference",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.3.4",
                "name": "Orientation",
                "summary": "Content does not restrict its view and operation to a single display orientation, such as portrait or landscape.",
                "rules": []
            },
            {
                "num": "1.3.5",
                "name": "Identify Input Purpose",
                "summary": "The purpose of each input field that collects information about the user can be programmatically determined when the field serves a common purpose.",
                "rules": [
                    {
                        id: "WCAG21_Input_Autocomplete",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.1",
                "name": "Use of Color",
                "summary": "Color is not used as the only visual means of conveying information, indicating an action, prompting a response, or distinguishing a visual element.",
                "rules": [
                    {
                        id: "RPT_Font_ColorInForm",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Style_ColorSemantics1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.2",
                "name": "Audio Control",
                "summary": "If any audio plays automatically for more than 3 seconds, either a mechanism is available to pause or stop the audio, or a mechanism is available to control audio volume independently from the overall system volume level.",
                "rules": [
                    {
                        id: "RPT_Embed_AutoStart",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.3",
                "name": "Contrast (Minimum)",
                "summary": "The visual presentation of text and images of text has a contrast ratio of at least 4.5:1, with a 3:1 ratio for large-scale text.",
                "rules": [
                    {
                        id: "IBMA_Color_Contrast_WCAG2AA",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "IBMA_Color_Contrast_WCAG2AA_PV",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.4",
                "name": "Resize Text",
                "summary": "Text can be resized without assistive technology up to 200 percent without loss of content or functionality.",
                "rules": [
                    {
                        id: "WCAG21_Style_Viewport",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "1.4.5",
                "name": "Images of Text",
                "summary": "If the technologies being used can achieve the visual presentation, text is used to convey information rather than images of text.",
                "rules": []
            },
            {
                "num": "1.4.10",
                "name": "Reflow",
                "summary": "Content can reflow without loss of information or functionality, and without requiring scrolling in two dimensions.",
                "rules": []
            },
            {
                "num": "1.4.11",
                "name": "Non-text Contrast",
                "summary": "The parts of graphical objects required to understand the content, and the visual information required to identify UI components and states, have a contrast ratio of at least 3:1 against adjacent colors.",
                "rules": []
            },
            {
                "num": "1.4.12",
                "name": "Text Spacing",
                "summary": "No loss of content or functionality occurs when users change letter, word and paragraph spacing, as well as line height.",
                "rules": []
            },
            {
                "num": "1.4.13",
                "name": "Content on Hover or Focus",
                "summary": "Where hover or focus actions cause additional content to become visible and hidden, the additional content is dismissable, hoverable and persistent.",
                "rules": []
            },
            {
                "num": "2.1.1",
                "name": "Keyboard",
                "summary": "All functionality of the content is operable through a keyboard interface without requiring specific timings for individual keystrokes.",
                "rules": [
                    {
                        id: "RPT_Elem_EventMouseAndKey",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_InvalidTabindexForActivedescendant",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MissingFocusableChild",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MissingKeyboardHandler",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Audio_Video_Trigger",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Application_Role_Text",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.1.2",
                "name": "No Keyboard Trap",
                "summary": "If keyboard focus can be moved to a component using a keyboard interface, then focus can be moved away from that component using only a keyboard interface, and, if it requires more than unmodified arrow or tab keys or other standard exit methods, the user is advised of the method for moving focus away.",
                "rules": [
                    {
                        id: "HAAC_Media_DocumentTrigger2",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "2.1.4",
                "name": "Character Key Shortcuts",
                "summary": "If a keyboard shortcut is implemented using only letter, punctuation, number or symbol characters, then the shortcut can be turned off, remapped or activated only on focus.",
                "rules": []
            },
            {
                "num": "2.2.1",
                "name": "Timing Adjustable",
                "summary": "For each time limit that is set by the content, the user can turn off, adjust, or extend the limit.",
                "rules": [
                    {
                        id: "RPT_Meta_Refresh",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Meta_RedirectZero",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.2.2",
                "name": "Pause, Stop, Hide",
                "summary": "For moving, blinking, scrolling, or auto-updating information, the user can pause, stop, hide or adjust the information.",
                "rules": [
                    {
                        id: "RPT_Marquee_Trigger",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Blink_AlwaysTrigger",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Blink_CSSTrigger1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.3.1",
                "name": "Three Flashes or Below Threshold",
                "summary": "Content does not contain anything that flashes more than three times in any one second period, or the flash is below the general flash and red flash thresholds.",
                "rules": []
            },
            {
                "num": "2.4.1",
                "name": "Bypass Blocks",
                "summary": "A mechanism is available to bypass blocks of content that are repeated on multiple Web pages.",
                "rules": [
                    {
                        id: "WCAG20_Frame_HasTitle",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Html_SkipNav",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Frame_SrcHtml",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleSearchLandmarks",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ComplementaryLandmarkLabel_Implicit",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_MultipleApplicationLandmarks",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ApplicationLandmarkLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleDocumentRoles",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Body_FirstASkips_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_OrphanedContent_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RegionLabel_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleMainsVisibleLabel_Implicit",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "Rpt_Aria_MultipleBannerLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleComplementaryLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleContentinfoLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleFormLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleNavigationLandmarks_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleArticleRoles_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleGroupRoles_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_OneBannerInSiblingSet_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ContentinfoWithNoMain_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ComplementaryRequiredLabel_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleRegionsUniqueLabel_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleMainsRequireLabel_Implicit_2",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.2",
                "name": "Page Titled",
                "summary": "Web pages, non-web documents, and software have titles that describe topic or purpose.",
                "rules": [
                    {
                        id: "WCAG20_Doc_HasTitle",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Title_Valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.3",
                "name": "Focus Order",
                "summary": "If content can be navigated sequentially and the navigation sequences affect meaning or operation, focusable components receive focus in an order that preserves meaning and operability.",
                "rules": [
                    {
                        id: "IBMA_Focus_Tabbable",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "IBMA_Focus_MultiTab",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.4",
                "name": "Link Purpose (In Context)",
                "summary": "The purpose of each link can be determined from the link text alone or from the link text together with its programmatically determined link content.",
                "rules": [
                    {
                        id: "WCAG20_A_HasText",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.5",
                "name": "Multiple Ways",
                "summary": "More than one way is available to locate a Web page within a set of Web pages, except where the Web Page is the result of, or a step in, a process.",
                "rules": []
            },
            {
                "num": "2.4.6",
                "name": "Headings and Labels",
                "summary": "Headings and labels describe topic or purpose.",
                "rules": [
                    {
                        id: "RPT_Header_HasContent",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.4.7",
                "name": "Focus Visible",
                "summary": "Any keyboard operable user interface has a mode of operation where the keyboard focus indicator is visible.",
                "rules": [
                    {
                        id: "RPT_Style_HinderFocus1",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Script_FocusBlurs",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.5.1",
                "name": "Pointer Gestures",
                "summary": "All functionality that uses multipoint or path-based gestures for operation can be operated with a single pointer without a path-based gesture.",
                "rules": []
            },
            {
                "num": "2.5.2",
                "name": "Pointer Cancellation",
                "summary": "For functionality that can be operated using a single pointer, completion of the function is on the up-event with an ability to abort, undo or reverse the outcome.",
                "rules": []
            },
            {
                "num": "2.5.3",
                "name": "Label in Name",
                "summary": "For user interface components with labels that include text or images of text, the accessible name contains the text that is presented visually.",
                "rules": [
                    {
                        id: "WCAG21_Label_Accessible",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "2.5.4",
                "name": "Motion Actuation",
                "summary": "Functionality that can be operated by motion can also be operated by user interface components, and the motion trigger can be disabled.",
                "rules": []
            },
            {
                "num": "3.1.1",
                "name": "Language of Page",
                "summary": "The default human language of Web pages, non-Web documents, or software can be programmatically determined.",
                "rules": [
                    {
                        id: "WCAG20_Html_HasLang",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.1.2",
                "name": "Language of Parts",
                "summary": "The human language of each passage or phrase in the content can be programmatically determined.",
                "rules": [
                    {
                        id: "WCAG20_Elem_Lang_Valid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.2.1",
                "name": "On Focus",
                "summary": "When any component receives focus, it does not initiate a change of context.",
                "rules": [
                    {
                        id: "WCAG20_Select_NoChangeAction",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Script_FocusBlurs",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.2.2",
                "name": "On Input",
                "summary": "Changing the setting of any user interface component does not automatically cause a change of context unless the user has been advised of the behavior before using the component.",
                "rules": [
                    {
                        id: "WCAG20_A_TargetAndText",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "WCAG20_Form_HasSubmit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Form_TargetAndText",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_HasOnchange",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "RPT_Form_ChangeEmpty",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    }
                ]
            },
            {
                "num": "3.2.3",
                "name": "Consistent Navigation",
                "summary": "Navigational mechanisms that are repeated on multiple Web pages within a set of Web pages occur in the same relative order each time they are repeated, unless a change is initiated by the user.",
                "rules": []
            },
            {
                "num": "3.2.4",
                "name": "Consistent Identification",
                "summary": "Components that have the same functionality within a set of Web pages are identified consistently.",
                "rules": []
            },
            {
                "num": "3.3.1",
                "name": "Error Identification",
                "summary": "If an input error is automatically detected, the item that is in error is identified and the error is described to the user in text.",
                "rules": [
                    {
                        id: "HAAC_Aria_ErrorMessage",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "3.3.2",
                "name": "Labels or Instructions",
                "summary": "Labels or instructions are provided when content requires user input.",
                "rules": [
                    {
                        id: "WCAG20_Input_LabelBefore",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_LabelAfter",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Accesskey_NeedLabel",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Aria_Or_HTML5_Attr",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Input_Placeholder",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Input_VisibleLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                ]
            },
            {
                "num": "3.3.3",
                "name": "Error Suggestion",
                "summary": "If an input error is automatically detected and suggestions for correction are known, then the suggestions are provided to the user, unless it would jeopardize the security or purpose of the content.",
                "rules": []
            },
            {
                "num": "3.3.4",
                "name": "Error Prevention (Legal, Financial, Data)",
                "summary": "For content that cause legal commitments or financial transactions for the user to occur, that modify or delete user-controllable data in data storage systems, or that submit user test responses, the user can reverse, correct, or confirm the action.",
                "rules": []
            },
            {
                "num": "4.1.1",
                "name": "Parsing",
                "summary": "In content implemented using markup languages, elements have complete start and end tags, elements are nested according to their specifications, elements do not contain duplicate attributes, and any IDs are unique, except where the specifications allow these features.",
                "rules": [
                    {
                        id: "RPT_Elem_UniqueId",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "WCAG20_Elem_UniqueAccessKey",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            },
            {
                "num": "4.1.2",
                "name": "Name, Role, Value",
                "summary": "For all user interface components (including, but not limited to: form elements, links and components generated by scripts), the name and role can be programmatically determined; states, properties, and values that can be set by the user can be programmatically set; and notification of changes to these items is available to user agents, including assistive technologies.",
                "rules": [
                    {
                        id: "WCAG20_Input_ExplicitLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Valerie_Label_HasContent",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidRole",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidPropertyValue",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidIdRef",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RequiredProperties",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_EmptyPropertyValue",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_ValidProperty",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Aria_ImgAlt",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Canvas",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_Aria_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RequiredChildren_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_RequiredParent_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_WidgetLabels_Implicit",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_ARIA_11_Guideline",
                        level: IEngine_1.eRulePolicy.RECOMMENDATION
                    },
                    {
                        id: "HAAC_List_Group_ListItem",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_ActiveDescendantCheck",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "Rpt_Aria_MultipleToolbarUniqueLabel",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Must_Have_Text_Input",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_DOM_Focus",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Autocomplete",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Autocomplete_Invalid",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Expanded",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    },
                    {
                        id: "HAAC_Combobox_Popup",
                        level: IEngine_1.eRulePolicy.VIOLATION
                    }
                ]
            }
        ]
    }
];
exports.a11yRulesets = a11yRulesets;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.designRulesets = void 0;
var designRulesets = [];
exports.designRulesets = designRulesets;


/***/ })
/******/ ]);