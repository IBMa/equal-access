/*!
 * Copyright:: 2016,2017,2019,2020- IBM, Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 8235:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ARIADefinitions = void 0;
var ARIADefinitions = /** @class */ (function () {
    function ARIADefinitions() {
    }
    ARIADefinitions.nameFromContent = function (role) {
        return (role in ARIADefinitions.designPatterns)
            && ARIADefinitions.designPatterns[role].nameFrom
            && ARIADefinitions.designPatterns[role].nameFrom.includes("contents");
    };
    /*
     * array of WAI-ARIA global states and properties
     * @see https://www.w3.org/TR/wai-aria-1.2/#global_states
     */
    ARIADefinitions.globalProperties = ["aria-atomic", "aria-busy", "aria-controls", "aria-current", "aria-describedby",
        "aria-details", "aria-flowto", "aria-hidden", "aria-keyshortcuts",
        "aria-label", "aria-labelledby", "aria-live", "aria-owns", "aria-relevant", "aria-roledescription"
        // the following are deprecated in ARIA 1.2, will indicate deprecation in individual role
        ,
        'aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid'
    ];
    //properties contains id(s) that refer to other element(s)
    ARIADefinitions.referenceProperties = ["aria-owns", "aria-controls", "aria-describedby", "aria-labelledby", "aria-flowto", "aria-activedescendant"];
    // deprecated roles
    ARIADefinitions.globalDeprecatedRoles = [
        'directory', 'doc-biblioentry', 'doc-endnote'
    ];
    // the following are deprecated in ARIA 1.1 for all the roles
    ARIADefinitions.globalDeprecatedProperties = [
        'aria-grabbed', 'aria-dropeffect'
    ];
    /*
     * XSD data types for all WAI-ARIA properties
     * along with valid values when the data type is NMTOKEN
     * WAI-ARIA properties data types explaned:
     *  type: Used to identify the type of values allowed for the WAI-ARIA property
     *  values: Used to identify specific values of an WAI-ARIA property when type is nmtoken
     *  hiddenIDRefSupported: Used to identify if the WAI-ARIA property supports referencing hidden ID
     *                          true: refers to WAI-ARIA property supports hidden ID references
     *                          false: refers to WAI-ARIA property does not support hidden ID references
     *                        Default value will be set to false, if not specified.
     */
    ARIADefinitions.propertyDataTypes = {
        "aria-activedescendant": {
            type: "http://www.w3.org/2001/XMLSchema#idref",
            hiddenIDRefSupported: true
        },
        "aria-atomic": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-autocomplete": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["inline", "list", "both", "none", "undefined"] //add undefined to handle value empty
        },
        "aria-busy": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-checked": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "mixed", "undefined"]
        },
        "aria-colcount": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-colindex": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-colspan": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-controls": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-current": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["page", "step", "location", "date", "time", "true", "false", "undefined"] //add undefined for empty value
        },
        "aria-describedby": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-details": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs"
        },
        "aria-disabled": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-dropeffect": {
            type: "http://www.w3.org/2001/XMLSchema#nmtokens",
            values: ["copy", "move", "link", "execute", "popup", "none"]
        },
        "aria-errormessage": {
            type: "http://www.w3.org/2001/XMLSchema#idref",
            hiddenIDRefSupported: true
        },
        "aria-expanded": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "undefined"]
        },
        "aria-flowto": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: false
        },
        "aria-grabbed": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "undefined"]
        },
        "aria-haspopup": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "menu", "listbox", "tree", "grid", "dialog"]
        },
        "aria-hidden": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "undefined"]
        },
        "aria-invalid": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "spelling", "grammar", "undefined"] //add undefined for empty value
        },
        "aria-keyshortcuts": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        },
        "aria-label": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        },
        "aria-labelledby": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-level": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-live": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["off", "polite", "assertive"]
        },
        "aria-modal": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-multiline": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-multiselectable": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-orientation": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["horizontal", "vertical", "undefined"]
        },
        "aria-owns": {
            type: "http://www.w3.org/2001/XMLSchema#idrefs",
            hiddenIDRefSupported: true
        },
        "aria-placeholder": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        },
        "aria-posinset": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-pressed": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "mixed", "undefined"]
        },
        "aria-readonly": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-relevant": {
            type: "http://www.w3.org/2001/XMLSchema#nmtokens",
            values: ["additions", "removals", "text", "all"]
        },
        "aria-required": {
            type: "http://www.w3.org/2001/XMLSchema#boolean"
        },
        "aria-roledescription": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        },
        "aria-rowcount": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-rowindex": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-rowspan": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-selected": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["true", "false", "undefined"]
        },
        "aria-setsize": {
            type: "http://www.w3.org/2001/XMLSchema#int"
        },
        "aria-sort": {
            type: "http://www.w3.org/2001/XMLSchema#nmtoken",
            values: ["ascending", "descending", "other", "none"]
        },
        "aria-valuemax": {
            type: "http://www.w3.org/2001/XMLSchema#decimal"
        },
        "aria-valuemin": {
            type: "http://www.w3.org/2001/XMLSchema#decimal"
        },
        "aria-valuenow": {
            type: "http://www.w3.org/2001/XMLSchema#decimal"
        },
        "aria-valuetext": {
            type: "http://www.w3.org/2001/XMLSchema#string"
        }
    };
    /*
     * design patterns for concrete WAI-ARIA roles
     * legitimate keys for each role include:
     *
     * - container: appropriate container(s) for that role
     * - props: states and properties that may be associated with this role (in addition to the global states and properties listed above)
     * - reqProps: required states or properties for this role
     * - reqChildren: required children for this role
     * - htmlEquiv: HTML equivalent for this role
     * - roleType: one of widget, structure, landmark, liveRegion, window (as seen in https://www.w3.org/TR/wai-aria-1.2/#roles_categorization)
     * - nameRequired: determines whether an accessible name is required for a widget (see ARIA spec.)
     * - nameFrom: determines how an accessible name is supplied (author or content - see ARIA spec.)
     * - deprecated: if present, indicates that the role is deprecated, and provides a list of alternative role(s)
     */
    ARIADefinitions.designPatterns = {
        "alert": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "liveRegion",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "alertdialog": {
            container: null,
            props: ["aria-modal"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "window",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "application": {
            container: null,
            props: ["aria-activedescendant", "aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "article": {
            container: null,
            props: ["aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "banner": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "blockquote": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "button": {
            container: null,
            props: ["aria-expanded", "aria-pressed"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "button | input[@type='button']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
        "caption": {
            container: ["figure", "grid", "table", "treegrid"],
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "cell": {
            container: ["row"],
            props: ["aria-colindex", "aria-colspan", "aria-rowindex", "aria-rowspan"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "td",
            roleType: "structure",
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "checkbox": {
            container: null,
            props: ["aria-expanded", "aria-readonly", "aria-required"],
            reqProps: ["aria-checked"],
            reqChildren: null,
            htmlEquiv: "input[@type='checkbox']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-haspopup']
        },
        "code": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "columnheader": {
            container: ["row"],
            props: ["aria-colindex", "aria-colspan", "aria-expanded", "aria-readonly", "aria-required", "aria-rowindex", "aria-rowspan", "aria-selected", "aria-sort"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "th[@scope='col']",
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "combobox": {
            container: null,
            props: ["aria-controls", "aria-activedescendant", "aria-autocomplete", "aria-readonly", "aria-required"],
            reqProps: ["aria-expanded"],
            reqChildren: [],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "complementary": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "comment": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: false,
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "contentinfo": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "definition": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "deletion": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "dialog": {
            container: null,
            props: ["aria-modal"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "window",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "directory": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecated: true,
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "doc-abstract": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-acknowledgments": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-afterword": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-appendix": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-backlink": {
            container: null,
            props: ["aria-disabled", "aria-expanded", "aria-haspopup"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "a | link",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "doc-biblioentry": {
            container: ["list"],
            props: ["aria-level", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "li",
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-bibliography": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-biblioref": {
            container: null,
            props: ["aria-disabled", "aria-expanded", "aria-haspopup"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "a | link",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "doc-chapter": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-colophon": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-conclusion": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-cover": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "img",
            roleType: "structure",
            nameRequired: false,
            nameFrom: ["author"],
            presentationalChildren: true
        },
        "doc-credit": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-credits": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-dedication": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-endnote": {
            container: ["list"],
            props: ["aria-level", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "li",
            roleType: "structure",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-endnotes": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "doc-epigraph": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-epilogue": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-errata": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-example": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-footnote": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-foreword": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-glossary": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-glossref": {
            container: null,
            props: ["aria-disabled", "aria-expanded", "aria-haspopup"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "a | link",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "doc-index": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-introduction": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-noteref": {
            container: null,
            props: ["aria-disabled", "aria-expanded", "aria-haspopup"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "a | link",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "doc-notice": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-pagebreak": {
            container: null,
            props: ["aria-orientation"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true
        },
        "doc-pagelist": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-pagefooter": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
        },
        "doc-pageheader": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
        },
        "doc-part": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-preface": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-prologue": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-pullquote": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-qna": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-subtitle": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: false,
            nameFrom: ["author", "contents"]
        },
        "doc-tip": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "doc-toc": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"]
        },
        "document": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "emphasis": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "feed": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: ["article"],
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "figure": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "form": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "form",
            roleType: "landmark",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "generic": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "div | span",
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby", "aria-roledescription"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "graphics-document": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameRequired: true,
            nameFrom: ["author"]
        },
        "graphics-object": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameRequired: false,
            nameFrom: ["author"]
        },
        "graphics-symbol": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true
        },
        "grid": {
            container: null,
            props: ["aria-activedescendant", "aria-colcount", "aria-multiselectable", "aria-readonly", "aria-rowcount"],
            reqProps: null,
            reqChildren: ["row", "rowgroup"],
            htmlEquiv: "table",
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "gridcell": {
            container: ["row"],
            props: ["aria-colindex", "aria-colspan", "aria-disabled", "aria-errormessage", "aria-expanded", "aria-haspopup", "aria-invalid", "aria-readonly", "aria-required", "aria-rowindex", "aria-rowspan", "aria-selected"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "td",
            roleType: "widget",
            nameFrom: ["author", "contents"]
        },
        "group": {
            container: null,
            props: ["aria-activedescendant"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "heading": {
            container: null,
            props: null,
            reqProps: ["aria-level"],
            reqChildren: null,
            htmlEquiv: "h1 | h2 | h3 | h4 | h5 | h6",
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "img": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "img",
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true,
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "image": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "img",
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true,
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "insertion": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "link": {
            container: null,
            props: ["aria-expanded"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "a | link",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
        "list": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: ["listitem"],
            htmlEquiv: "ol | ul",
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "listbox": {
            container: null,
            props: ["aria-activedescendant", "aria-expanded", "aria-multiselectable", "aria-orientation", "aria-readonly", "aria-required"],
            reqProps: null,
            reqChildren: ["group", "option"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-haspopup']
        },
        "listitem": {
            container: ["list"],
            props: ["aria-level", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "li",
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "log": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "liveRegion",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "main": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "mark": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "mark",
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "marquee": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "liveRegion",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "math": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            presentationalChildren: false,
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "menu": {
            container: null,
            props: ["aria-activedescendant", "aria-orientation"],
            reqProps: null,
            reqChildren: ["group", "menuitem", "menuitemcheckbox", "menuitemradio"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "menubar": {
            container: null,
            props: ["aria-activedescendant", "aria-orientation"],
            reqProps: null,
            reqChildren: ["group", "menuitem", "menuitemcheckbox", "menuitemradio"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "menuitem": {
            container: ["group", "menu", "menubar"],
            props: ["aria-expanded", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
        "menuitemcheckbox": {
            container: ["group", "menu", "menubar"],
            props: ["aria-expanded", "aria-posinset", "aria-setsize"],
            reqProps: ["aria-checked"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
        "menuitemradio": {
            container: ["group", "menu", "menubar"],
            props: ["aria-expanded", "aria-posinset", "aria-setsize"],
            reqProps: ["aria-checked"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
        "meter": {
            container: null,
            props: ["aria-valuemax", "aria-valuemin", "aria-valuetext"],
            reqProps: ["aria-valuenow"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true,
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "navigation": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "none": {
            container: null,
            props: [],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "note": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "option": {
            container: ["group", "listbox"],
            props: ["aria-selected", "aria-checked", "aria-posinset", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "option",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "paragraph": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "presentation": {
            container: null,
            props: [],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "progressbar": {
            container: null,
            props: ["aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true,
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "radio": {
            container: null,
            props: ["aria-posinset", "aria-setsize"],
            reqProps: ["aria-checked"],
            reqChildren: null,
            htmlEquiv: "input[@type='radio']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "radiogroup": {
            container: null,
            props: ["aria-activedescendant", "aria-orientation", "aria-readonly", "aria-required"],
            reqProps: null,
            reqChildren: ["radio"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-haspopup']
        },
        "region": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "row": {
            container: ["grid", "rowgroup", "table", "treegrid"],
            props: ["aria-activedescendant", "aria-colindex", "aria-expanded", "aria-level", "aria-posinset", "aria-rowindex", "aria-selected", "aria-setsize"],
            reqProps: null,
            reqChildren: ["cell", "columnheader", "gridcell", "rowheader"],
            htmlEquiv: "tr",
            roleType: "structure",
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "rowgroup": {
            container: ["grid", "table", "treegrid"],
            props: [],
            reqProps: null,
            reqChildren: ["row"],
            htmlEquiv: "tbody | tfoot | thead",
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "rowheader": {
            container: ["row"],
            props: ["aria-colindex", "aria-colspan", "aria-expanded", "aria-readonly", "aria-required", "aria-rowindex", "aria-rowspan", "aria-selected", "aria-sort"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "th[@scope='row']",
            roleType: "structure",
            nameRequired: true,
            nameFrom: ["author", "contents"]
        },
        "scrollbar": {
            container: null,
            props: ["aria-orientation", "aria-valuemax", "aria-valuemin", "aria-valuetext"],
            reqProps: ["aria-controls", "aria-valuenow"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "search": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "landmark",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "searchbox": {
            container: null,
            props: ["aria-activedescendant", "aria-autocomplete", "aria-multiline", "aria-placeholder", "aria-readonly", "aria-required"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "input[@type='search']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "separator": {
            container: null,
            props: ["aria-orientation"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "slider": {
            container: null,
            props: ["aria-orientation", "aria-readonly", "aria-valuemax", "aria-valuemin", "aria-valuetext"],
            reqProps: ["aria-valuenow"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            presentationalChildren: true
        },
        "spinbutton": {
            container: null,
            props: ["aria-activedescendant", "aria-readonly", "aria-required", "aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-haspopup']
        },
        "status": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "liveRegion",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "strong": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "subscript": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "suggestion": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "superscript": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "switch": {
            container: null,
            props: ["aria-expanded", "aria-readonly", "aria-required"],
            reqProps: ["aria-checked"],
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-haspopup']
        },
        "tab": {
            container: ["tablist"],
            props: ["aria-expanded", "aria-posinset", "aria-selected", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            presentationalChildren: true,
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
        "table": {
            container: null,
            props: ["aria-colcount", "aria-rowcount"],
            reqProps: null,
            reqChildren: ["row", "rowgroup", "caption"],
            htmlEquiv: "table",
            roleType: "structure",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "tablist": {
            container: null,
            props: ["aria-activedescendant", "aria-multiselectable", "aria-orientation"],
            reqProps: null,
            reqChildren: ["tab"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: false,
            nameFrom: ["author"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "tabpanel": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "term": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "dfn",
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "textbox": {
            container: null,
            props: ["aria-activedescendant", "aria-autocomplete", "aria-multiline", "aria-placeholder", "aria-readonly", "aria-required"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: "input[@type='text']",
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"]
        },
        "time": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["prohibited"],
            prohibitedProps: ["aria-label", "aria-labelledby"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "timer": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "liveRegion",
            nameFrom: ["author"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "toolbar": {
            container: null,
            props: ["aria-activedescendant", "aria-orientation"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameFrom: ["author"],
            deprecatedProps: ['aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "tooltip": {
            container: null,
            props: null,
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "structure",
            nameRequired: false,
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-disabled', 'aria-errormessage', 'aria-haspopup', 'aria-invalid']
        },
        "tree": {
            container: null,
            props: ["aria-activedescendant", "aria-multiselectable", "aria-orientation", "aria-required"],
            reqProps: null,
            reqChildren: ["group", "treeitem"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-haspopup']
        },
        "treegrid": {
            container: null,
            props: ["aria-activedescendant", "aria-colcount", "aria-multiselectable", "aria-orientation", "aria-readonly", "aria-required", "aria-rowcount"],
            reqProps: null,
            reqChildren: ["row", "rowgroup"],
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author"],
            deprecatedProps: ['aria-haspopup']
        },
        "treeitem": {
            container: ["group", "tree"],
            props: ["aria-checked", "aria-expanded", "aria-level", "aria-posinset", "aria-selected", "aria-setsize"],
            reqProps: null,
            reqChildren: null,
            htmlEquiv: null,
            roleType: "widget",
            nameRequired: true,
            nameFrom: ["author", "contents"],
            deprecatedProps: ['aria-errormessage', 'aria-invalid']
        },
    }; // end designPatterns
    // copied from https://html.spec.whatwg.org/multipage/semantics-other.html#disabled-elements
    // https://html.spec.whatwg.org/multipage/input.html#input-type-attr-summary
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled
    /** note:
      * if a <fieldset> is disabled, the descendant form controls are all disabled except <legend>
      * If an <optgroup> is disabled, the select is still interactive (unless otherwise disabled), but none of the items in the option group are selectable.
      * When an element has the disabled attribute applied, the :disabled pseudo-class also applies to it.
     */
    ARIADefinitions.elementsAllowedDisabled = ["button", "input", "select", "textarea", "optgroup", "option", "fieldset"]; // also form-associated custom element
    ARIADefinitions.elementsAllowedRequired = ["select", "textarea"]; // remove 'input' and add to the individual element, becuase required is not supported on input@type="range", "color", "hidden" or any button types
    ARIADefinitions.elementsAllowedReadOnly = ["textarea"]; // remove 'input' and add to the individual element, because readonly is not supported on input@type="checkbox", "radio", "range", "color", "file", hidden" or any button types
    /* https://www.w3.org/TR/html-aria/#docconformance
        * documentConformanceRequirement contains properties of the tags related to role without any additional attribute value
        * documentConformanceRequirementSpecialTags contains those tags that require special considerations
        */
    ARIADefinitions.documentConformanceRequirement = {
        "abbr": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true,
            prohibitedAriaAttributesWhenNoImplicitRole: ["aria-label", "aria-labelledby"]
        },
        "address": {
            implicitRole: ["group"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "article": {
            implicitRole: ["article"],
            validRoles: ["application", "document", "feed", "main", "none", "presentation", "region"],
            globalAriaAttributesValid: true
        },
        "aside": {
            implicitRole: ["complementary"],
            validRoles: ["doc-dedication", "doc-example", "doc-footnote", "doc-glossary", "doc-pullquote", "doc-tip", "feed", "none", "note", "presentation", "region", "search"],
            globalAriaAttributesValid: true
        },
        "audio": {
            implicitRole: null,
            validRoles: ["application"],
            globalAriaAttributesValid: true
        },
        "b": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "base": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "bdi": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "bdo": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "blockquote": {
            implicitRole: ["blockquote"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "body": {
            implicitRole: ["generic"],
            validRoles: null,
            otherDisallowedAriaAttributes: ['aria-hidden'],
            globalAriaAttributesValid: true
        },
        "br": {
            implicitRole: null,
            validRoles: ["none", "presentation"],
            globalAriaAttributesValid: false,
            otherAllowedAriaAttributes: ["aria-hidden"]
        },
        "button": {
            implicitRole: ["button"],
            validRoles: ["checkbox", "combobox", "gridcell", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "separator", "slider", "switch", "tab", "treeitem"],
            globalAriaAttributesValid: true
        },
        "canvas": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "caption": {
            implicitRole: ['caption'],
            validRoles: null,
            globalAriaAttributesValid: true,
            allowAttributesFromImplicitRole: false
        },
        "cite": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true,
            prohibitedAriaAttributesWhenNoImplicitRole: ["aria-label", "aria-labelledby"]
        },
        "code": {
            implicitRole: ["code"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "col": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "colgroup": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "data": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "datalist": {
            implicitRole: ["listbox"],
            validRoles: null,
            globalAriaAttributesValid: false,
            allowAttributesFromImplicitRole: false
        },
        "dd": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "del": {
            implicitRole: ["deletion"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "details": {
            implicitRole: ["group"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "dfn": {
            implicitRole: ["term"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "dialog": {
            implicitRole: ["dialog"],
            validRoles: ["alertdialog"],
            globalAriaAttributesValid: true
        },
        "dl": {
            implicitRole: null,
            validRoles: ["group", "list", "none", "presentation"],
            globalAriaAttributesValid: true
        },
        "dt": {
            implicitRole: ["term"],
            validRoles: ["listitem"],
            globalAriaAttributesValid: true
        },
        "em": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "embed": {
            implicitRole: null,
            validRoles: ["application", "document", "img", "none", "presentation"],
            globalAriaAttributesValid: true
        },
        "fieldset": {
            implicitRole: ["group"],
            validRoles: ["none", "presentation", "radiogroup"],
            globalAriaAttributesValid: true
        },
        "figcaption": {
            implicitRole: null,
            validRoles: ["group", "none", "presentation"],
            globalAriaAttributesValid: true,
            prohibitedAriaAttributesWhenNoImplicitRole: ["aria-label", "aria-labelledby"]
        },
        "form": {
            implicitRole: ["form"],
            validRoles: ["none", "presentation", "search"],
            globalAriaAttributesValid: true
        },
        "head": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "hgroup": {
            implicitRole: ["group"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "h1": {
            implicitRole: ["heading"],
            validRoles: ["doc-subtitle", "none", "presentation", "tab"],
            globalAriaAttributesValid: true
        },
        "h2": {
            implicitRole: ["heading"],
            validRoles: ["doc-subtitle", "none", "presentation", "tab"],
            globalAriaAttributesValid: true
        },
        "h3": {
            implicitRole: ["heading"],
            validRoles: ["doc-subtitle", "none", "presentation", "tab"],
            globalAriaAttributesValid: true
        },
        "h4": {
            implicitRole: ["heading"],
            validRoles: ["doc-subtitle", "none", "presentation", "tab"],
            globalAriaAttributesValid: true
        },
        "h5": {
            implicitRole: ["heading"],
            validRoles: ["doc-subtitle", "none", "presentation", "tab"],
            globalAriaAttributesValid: true
        },
        "h6": {
            implicitRole: ["heading"],
            validRoles: ["doc-subtitle", "none", "presentation", "tab"],
            globalAriaAttributesValid: true
        },
        "hr": {
            implicitRole: ["separator"],
            validRoles: ["doc-pagebreak", "none", "presentation"],
            globalAriaAttributesValid: true
        },
        "html": {
            implicitRole: ["document"],
            validRoles: null,
            globalAriaAttributesValid: false,
            allowAttributesFromImplicitRole: false
        },
        "i": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "iframe": {
            implicitRole: null,
            validRoles: ["application", "document", "img", "none", "presentation"],
            globalAriaAttributesValid: true
        },
        "ins": {
            implicitRole: ["insertion"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "kbd": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true,
            prohibitedAriaAttributesWhenNoImplicitRole: ["aria-label", "aria-labelledby"]
        },
        "label": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: true,
            prohibitedAriaAttributesWhenNoImplicitRole: ["aria-label", "aria-labelledby"]
        },
        "legend": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: true,
            prohibitedAriaAttributesWhenNoImplicitRole: ["aria-label", "aria-labelledby"]
        },
        "link": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "main": {
            implicitRole: ["main"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "map": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "mark": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true,
            prohibitedAriaAttributesWhenNoImplicitRole: ["aria-label", "aria-labelledby"]
        },
        "math": {
            implicitRole: ["math"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "menu": {
            implicitRole: ["list"],
            validRoles: ["group", "listbox", "menu", "menubar", "none", "presentation", "radiogroup", "tablist", "toolbar", "tree"],
            globalAriaAttributesValid: true
        },
        "meta": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "meter": {
            implicitRole: ["meter"],
            validRoles: null,
            globalAriaAttributesValid: true,
            otherDisallowedAriaAttributes: ['aria-valuemax', 'aria-valuemin'],
            allowAttributesFromImplicitRole: false
        },
        "nav": {
            implicitRole: ["navigation"],
            validRoles: ["doc-index", "doc-pagelist", "doc-toc", "menu", "menubar", "tablist", "none", "presentation"],
            globalAriaAttributesValid: true
        },
        "noscript": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "object": {
            implicitRole: null,
            validRoles: ["application", "document", "img"],
            globalAriaAttributesValid: true
        },
        "ol": {
            implicitRole: ["list"],
            validRoles: ["group", "listbox", "menu", "menubar", "none", "presentation", "radiogroup", "tablist", "toolbar", "tree"],
            globalAriaAttributesValid: true
        },
        "optgroup": {
            implicitRole: ["group"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "option": {
            implicitRole: ["option"],
            validRoles: null,
            globalAriaAttributesValid: true,
            otherDisallowedAriaAttributes: ["aria-selected"]
        },
        "output": {
            implicitRole: ["status"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "p": {
            implicitRole: ["paragraph"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "param": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "picture": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false,
            otherAllowedAriaAttributes: ["aria-hidden"]
        },
        "pre": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "progress": {
            implicitRole: ["progressbar"],
            validRoles: null,
            globalAriaAttributesValid: true,
            otherDisallowedAriaAttributes: ["aria-valuemax"]
        },
        "q": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "rp": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "rt": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true,
            prohibitedAriaAttributesWhenNoImplicitRole: ["aria-label", "aria-labelledby"]
        },
        "ruby": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "s": {
            implicitRole: ["deletion"],
            validRoles: ["any"],
            globalAriaAttributesValid: true,
            otherDisallowedAriaAttributes: ["aria-label", "aria-labelledby"]
        },
        "samp": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "script": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "search": {
            implicitRole: ['search'],
            validRoles: ['search', 'form', 'group', 'none', 'presentation', 'region'],
            globalAriaAttributesValid: true
        },
        "slot": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "small": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "source": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "span": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "strong": {
            implicitRole: ["strong"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "style": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "sub": {
            implicitRole: ["subscript"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "sup": {
            implicitRole: ["superscript"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "svg": {
            implicitRole: ["graphics-document"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "table": {
            implicitRole: ["table"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "template": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "textarea": {
            implicitRole: ["textbox"],
            validRoles: null,
            globalAriaAttributesValid: true
        },
        "tfoot": {
            implicitRole: ["rowgroup"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "thead": {
            implicitRole: ["rowgroup"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "time": {
            implicitRole: ["time"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "title": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "track": {
            implicitRole: null,
            validRoles: null,
            globalAriaAttributesValid: false
        },
        "u": {
            implicitRole: ["generic"],
            validRoles: ["any"],
            globalAriaAttributesValid: true
        },
        "ul": {
            implicitRole: ["list"],
            validRoles: ["group", "listbox", "menu", "menubar", "none", "presentation", "radiogroup", "tablist", "toolbar", "tree"],
            globalAriaAttributesValid: true
        },
        "var": {
            implicitRole: null,
            validRoles: ["any"],
            globalAriaAttributesValid: true,
            prohibitedAriaAttributesWhenNoImplicitRole: ["aria-label", "aria-labelledby"]
        },
        "video": {
            implicitRole: null,
            validRoles: ["application"],
            globalAriaAttributesValid: true
        },
        "wbr": {
            implicitRole: null,
            validRoles: ["none", "presentation"],
            globalAriaAttributesValid: false,
            otherAllowedAriaAttributes: ["aria-hidden"]
        }
    }; // end documentConformanceRequirement
    ARIADefinitions.documentConformanceRequirementSpecialTags = {
        "a": {
            "with-href": {
                implicitRole: ["link"],
                //roleCondition: " when non-empty href attribute is present",
                validRoles: ["button", "checkbox", "doc-backlink", "doc-biblioref", "doc-glossref", "doc-noteref", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "switch", "tab", "treeitem"],
                globalAriaAttributesValid: true,
                otherDisallowedAriaAttributes: ["aria-disabled=true"]
            },
            "without-href": {
                implicitRole: ["generic"],
                //roleCondition: " when href attribute is not present",
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "area": {
            "with-href": {
                implicitRole: ["link"],
                //roleCondition: " when non-empty href attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "without-href": {
                implicitRole: ["generic"],
                //roleCondition: " when href attribute is not present",
                validRoles: ["button", "link"],
                globalAriaAttributesValid: true
            }
        },
        // TODO
        //        "autonomous custom element": {
        //            implicitRole: ["Role exposed from author defined ElementInternals. Otherwise no corresponding role."],
        //            validRoles: ["If role defined by ElementInternals", "any role", "no role Otherwise"],
        //            globalAriaAttributesValid: true
        //        },
        "div": {
            "child-dl": {
                implicitRole: ["generic"],
                validRoles: ["presentation", "none"],
                globalAriaAttributesValid: true
            },
            "no-child-dl": {
                implicitRole: ["generic"],
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "figure": {
            "child-figcaption": {
                implicitRole: ["figure"],
                validRoles: ['doc-example'],
                globalAriaAttributesValid: true
            },
            "no-child-figcaption": {
                implicitRole: ["figure"],
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "footer": {
            "des-section-article-aside-main-nav": {
                implicitRole: ["generic"],
                //roleCondition: " when descendant of an article, aside, main, nav or section element",
                validRoles: ["doc-footnote", "group", "none", "presentation"],
                globalAriaAttributesValid: true
            },
            "other": {
                implicitRole: ["contentinfo"],
                //roleCondition: " when not a descendant of an article, aside, main, nav or section element",
                validRoles: ["doc-footnote", "group", "none", "presentation"],
                globalAriaAttributesValid: true
            }
        },
        // TODO
        //        "form-associated custom element": {
        //            implicitRole: ["Role exposed from author defined ElementInternals. Otherwise 'generic'."],
        //            validRoles: ["If role defined by ElementInternals", "form-related roles: button", "checkbox", "combobox", "group", "listbox", "progressbar", "radio", "radiogroup", "searchbox", "slider", "spinbutton", "switch", "textbox", "no role Otherwise"],
        //            globalAriaAttributesValid: true
        //        },
        "header": {
            "des-section-article-aside-main-nav": {
                implicitRole: ["generic"],
                //roleCondition: " when descendant of an article, aside, main, nav or section element",
                validRoles: ["group", "none", "presentation"],
                globalAriaAttributesValid: true
            },
            "other": {
                implicitRole: ["banner"],
                //roleCondition: " when not a descendant of an article, aside, main, nav or section element",
                validRoles: ["group", "none", "presentation"],
                globalAriaAttributesValid: true
            }
        },
        "img": {
            "img-with-accname": {
                implicitRole: ["img"],
                //roleCondition: "when accessible name presents",
                validRoles: ["button", "checkbox", "doc-cover", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "meter", "option", "progressbar", "radio", "scrollbar", "separator", "slider", "switch", "tab", "treeitem"],
                globalAriaAttributesValid: true
            },
            "img-without-accname-empty-alt": {
                implicitRole: ["presentation", "none"],
                //roleCondition: "when no accessible name presents and alt=''",
                validRoles: null,
                globalAriaAttributesValid: false,
                otherAllowedAriaAttributes: ["aria-hidden=true"]
            },
            "img-without-accname-no-alt": {
                implicitRole: ["img"],
                //roleCondition: "when neither accessible name no alt presents",
                validRoles: ["presentation", "none"],
                globalAriaAttributesValid: false,
                otherAllowedAriaAttributes: ["aria-hidden=true"]
            }
        },
        "input": {
            "button": {
                implicitRole: ["button"],
                validRoles: ["checkbox", "combobox", "gridcell", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "slider", "switch", "tab", "treeitem"],
                globalAriaAttributesValid: true
            },
            "checkbox-with-aria-pressed": {
                implicitRole: ["checkbox"],
                //roleCondition: " with type=checkbox and aria-pressed attribute is present",
                validRoles: ["menuitemcheckbox", "option", "switch", "button"],
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-required"],
                otherDisallowedAriaAttributes: ["aria-checked"]
            },
            "checkbox-without-aria-pressed": {
                implicitRole: ["checkbox"],
                //roleCondition: " with type=checkbox and aria-pressed attribute is not present",
                validRoles: ["menuitemcheckbox", "option", "switch"],
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-required"],
                otherDisallowedAriaAttributes: ["aria-checked"]
            },
            "color": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "date": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-required", "aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "datetime-local": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-required", "aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "email-no-list": {
                implicitRole: ["textbox"],
                //roleCondition: " with type=email and no list attribute is present",
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "email-with-list": {
                implicitRole: ["combobox"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "file": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-required"],
            },
            "hidden": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: false
            },
            "image": {
                implicitRole: ["button"],
                validRoles: ["checkbox", "gridcell", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "slider", "switch", "tab", "treeitem"],
                globalAriaAttributesValid: true
            },
            "month": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "number": {
                implicitRole: ["spinbutton"],
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"],
            },
            "password": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "radio": {
                implicitRole: ["radio"],
                validRoles: ["menuitemradio"],
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-required"],
                otherDisallowedAriaAttributes: ["aria-checked"]
            },
            "range": {
                implicitRole: ["slider"],
                validRoles: null,
                globalAriaAttributesValid: true,
                otherDisallowedAriaAttributes: ["aria-valuemax", "aria-valuemin"]
            },
            "reset": {
                implicitRole: ["button"],
                validRoles: ["checkbox", "combobox", "gridcell", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "slider", "switch", "tab", "treeitem"],
                globalAriaAttributesValid: true
            },
            "search-no-list": {
                implicitRole: ["searchbox"],
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"]
            },
            "search-with-list": {
                implicitRole: ["combobox"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "submit": {
                implicitRole: ["button"],
                validRoles: ["checkbox", "combobox", "gridcell", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "slider", "switch", "tab", "treeitem"],
                globalAriaAttributesValid: true
            },
            "tel-no-list": {
                implicitRole: ["textbox"],
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"]
            },
            "tel-with-list": {
                implicitRole: ["combobox"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "text-no-list": {
                implicitRole: ["textbox"],
                validRoles: ["combobox", "searchbox", "spinbutton"],
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"]
            },
            "text-with-list": {
                implicitRole: ["combobox"],
                validRoles: null,
                globalAriaAttributesValid: true
                // otherDisallowedAriaAttributes: ["aria-haspopup"]  // covered in a different rule
            },
            "time": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "url-no-list": {
                implicitRole: ["textbox"],
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-placeholder", "aria-required", "aria-readonly"]
            },
            "url-with-list": {
                implicitRole: ["combobox"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "week": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-readonly"],
                otherRolesForAttributes: ["textbox"]
            },
            "default-with-list": {
                // input with a missing or invalid type, with a list attribute
                implicitRole: ["combobox"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "default-no-list": {
                // input with a missing or invalid type, with a list attribute
                implicitRole: ["textbox"],
                validRoles: null,
                globalAriaAttributesValid: true
            }
        },
        "li": {
            "child-of-list-role": {
                implicitRole: ['listitem'],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "no-child-of-list-role": {
                implicitRole: ['generic'],
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "section": {
            "with-name": {
                implicitRole: ["region"],
                validRoles: ["alert", "alertdialog", "application", "banner", "complementary", "contentinfo", "dialog", "doc-abstract", "doc-acknowledgments", "doc-afterword", "doc-appendix", "doc-bibliography", "doc-chapter", "doc-colophon", "doc-conclusion", "doc-credit", "doc-credits", "doc-dedication", "doc-endnotes", "doc-epigraph", "doc-epilogue", "doc-errata", "doc-example", "doc-foreword", "doc-glossary", "doc-index", "doc-introduction", "doc-notice", "doc-pagelist", "doc-part", "doc-preface", "doc-prologue", "doc-pullquote", "doc-qna", "doc-toc", "document", "feed", "group", "log", "main", "marquee", "navigation", "none", "note", "presentation", "search", "status", "tabpanel"],
                globalAriaAttributesValid: true
            },
            "without-name": {
                implicitRole: null,
                validRoles: ["alert", "alertdialog", "application", "banner", "complementary", "contentinfo", "dialog", "doc-abstract", "doc-acknowledgments", "doc-afterword", "doc-appendix", "doc-bibliography", "doc-chapter", "doc-colophon", "doc-conclusion", "doc-credit", "doc-credits", "doc-dedication", "doc-endnotes", "doc-epigraph", "doc-epilogue", "doc-errata", "doc-example", "doc-foreword", "doc-glossary", "doc-index", "doc-introduction", "doc-notice", "doc-pagelist", "doc-part", "doc-preface", "doc-prologue", "doc-pullquote", "doc-qna", "doc-toc", "document", "feed", "group", "log", "main", "marquee", "navigation", "none", "note", "presentation", "search", "status", "tabpanel"],
                globalAriaAttributesValid: true
            }
        },
        "select": {
            "no-multiple-attr-size-gt1": {
                //roleCondition: " with a multiple attribute or a size attribute having value greater than 1"
                implicitRole: ["combobox"],
                validRoles: ["menu"],
                globalAriaAttributesValid: true,
                otherDisallowedAriaAttributes: ["aria-multiselectable"]
            },
            "multiple-attr-size-gt1": {
                //roleCondition: " with no multiple attribute and no size attribute having value greater than 1"
                implicitRole: ["listbox"],
                validRoles: null,
                globalAriaAttributesValid: true,
                otherDisallowedAriaAttributes: ["aria-multiselectable"]
            }
        },
        "summary": {
            "first-summary-of-detail": {
                implicitRole: null,
                validRoles: null,
                globalAriaAttributesValid: true,
                otherAllowedAriaAttributes: ["aria-disabled", "aria-haspopup"]
            },
            "no-first-summary-of-detail": {
                implicitRole: null,
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "tbody": {
            "des-table": {
                implicitRole: ["rowgroup"],
                validRoles: ["any"],
                globalAriaAttributesValid: true
            },
            "des-grid": {
                implicitRole: ["rowgroup"],
                validRoles: ["any"],
                globalAriaAttributesValid: true
            },
            "des-treegrid": {
                implicitRole: ["rowgroup"],
                validRoles: ["any"],
                globalAriaAttributesValid: true
            },
            "des-other": {
                implicitRole: null,
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "td": {
            "des-table": {
                implicitRole: ["cell"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-grid": {
                implicitRole: ["gridcell"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-treegrid": {
                implicitRole: ["gridcell"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-other": {
                implicitRole: null,
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "th": {
            "des-table-grid-treegrid-row-scope": {
                implicitRole: ["rowheader", "cell"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-table-grid-treegrid-column-scope": {
                implicitRole: ["columnheader", "cell"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-other": {
                implicitRole: null,
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "tr": {
            "des-table": {
                implicitRole: ["row"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-grid": {
                implicitRole: ["row"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-treegrid": {
                implicitRole: ["row"],
                validRoles: null,
                globalAriaAttributesValid: true
            },
            "des-other": {
                implicitRole: null,
                validRoles: ["any"],
                globalAriaAttributesValid: true
            }
        },
        "default": {
            implicitRole: null,
            //roleCondition: "",
            validRoles: ["any"],
            globalAriaAttributesValid: true
        }
    }; // end of documentConformanceRequirementSpecialTags
    // map aria attribute to the corresponding native attribute, apply to any element applicable
    // note this mapping is for the related attributes in the same element without checking the parent tree.
    // refer to https://w3c.github.io/html-aria/
    ARIADefinitions.relatedAriaHtmlAttributes = {
        "aria-checked": {
            conflict: [{
                    ariaAttributeValue: "false",
                    htmlAttributeNames: ["checked"],
                    htmlAttributeValues: null
                }],
            overlapping: [{
                    ariaAttributeValue: "true",
                    htmlAttributeNames: ["checked"],
                    htmlAttributeValues: null
                }]
        },
        "aria-disabled": {
            conflict: [{
                    ariaAttributeValue: "false",
                    htmlAttributeNames: ["disabled"],
                    htmlAttributeValues: null
                }],
            overlapping: [{
                    ariaAttributeValue: "true",
                    htmlAttributeNames: ["disabled"],
                    htmlAttributeValues: null
                }]
        },
        "aria-hidden": {
            conflict: [{
                    ariaAttributeValue: "false",
                    htmlAttributeNames: ["hidden"],
                    htmlAttributeValues: ["hidden,null"]
                },
                {
                    ariaAttributeValue: "true",
                    htmlAttributeNames: ["hidden"],
                    htmlAttributeValues: ["until-found"]
                }],
            overlapping: [{
                    ariaAttributeValue: "true",
                    htmlAttributeNames: ["hidden"],
                    htmlAttributeValues: ["hidden,null"]
                }]
        },
        "aria-placeholder": {
            conflict: [{
                    ariaAttributeValue: null,
                    htmlAttributeNames: ["placeholder"],
                    htmlAttributeValues: null
                }]
        },
        "aria-valuemax": {
            conflict: [{
                    ariaAttributeValue: null,
                    htmlAttributeNames: ["max"],
                    htmlAttributeValues: null
                }]
            //overlap case covered in the role definition: Authors SHOULD NOT use aria-valuemax on any element which allows the max attribute. Use the max attribute instead. 
        },
        "aria-valuemin": {
            conflict: [{
                    ariaAttributeValue: null,
                    htmlAttributeNames: ["min"],
                    htmlAttributeValues: null
                }]
            ////overlap case covered in the role definition:Authors SHOULD NOT use aria-valuemin on any element which allows the min attribute. Use the min attribute instead.
        },
        "aria-readonly": {
            conflict: [{
                    ariaAttributeValue: "false",
                    htmlAttributeNames: ["readonly", "contenteditable", "iscontenteditable"],
                    htmlAttributeValues: [null, "false", "false"]
                }],
            overlapping: [{
                    ariaAttributeValue: "true",
                    htmlAttributeNames: ["readonly", "contenteditable", "iscontenteditable"],
                    htmlAttributeValues: [null, "true", "true"]
                }]
        },
        "aria-required": {
            conflict: [{
                    ariaAttributeValue: "false",
                    htmlAttributeNames: ["required"],
                    htmlAttributeValues: null
                }],
            overlapping: [{
                    ariaAttributeValue: "true",
                    htmlAttributeNames: ["required"],
                    htmlAttributeValues: null
                }]
        },
        "aria-colspan": {
            conflict: [{
                    // conflict occurs if both values are different
                    ariaAttributeValue: "VALUE",
                    htmlAttributeNames: ["colspan"],
                    htmlAttributeValues: ["VALUE"]
                }],
            overlapping: [{
                    // overlap occurs if both exists
                    ariaAttributeValue: null,
                    htmlAttributeNames: ["colspan"],
                    htmlAttributeValues: null
                }]
        },
        "aria-rowspan": {
            conflict: [{
                    // conflict occurs if both values are different
                    ariaAttributeValue: "VALUE",
                    htmlAttributeNames: ["rowspan"],
                    htmlAttributeValues: ["VALUE"]
                }],
            overlapping: [{
                    // overlap occurs if both exists 
                    ariaAttributeValue: null,
                    htmlAttributeNames: ["rowspan"],
                    htmlAttributeValues: null
                }]
        },
        /** "aria-autocomplete": {
            conflict: [{
                // conflict occurs if both exists, aria value is only for custom widget, rather than native
                ariaAttributeValue: null,
                htmlAttributeNames: ["autocomplete"],
                htmlAttributeValues: null
            }]
        } */
    };
    ARIADefinitions.containers = [];
    return ARIADefinitions;
}());
exports.ARIADefinitions = ARIADefinitions;
;
var containerArray = [];
for (var roleDesign in ARIADefinitions.designPatterns) {
    var containers = ARIADefinitions.designPatterns[roleDesign].container;
    if (containers !== null) {
        for (var _i = 0, containers_1 = containers; _i < containers_1.length; _i++) {
            var container = containers_1[_i];
            if (containerArray.indexOf(container) == -1) {
                containerArray.push(container);
            }
        }
    }
}
ARIADefinitions.containers = containerArray;


/***/ }),

/***/ 4944:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ARIAMapper = void 0;
var ARIADefinitions_1 = __webpack_require__(8235);
var CommonMapper_1 = __webpack_require__(1794);
var DOMUtil_1 = __webpack_require__(295);
var CommonUtil_1 = __webpack_require__(8137);
var AriaUtil_1 = __webpack_require__(490);
var fragment_1 = __webpack_require__(482);
var ARIAWalker_1 = __webpack_require__(8015);
var CacheUtil_1 = __webpack_require__(7788);
var DOMWalker_1 = __webpack_require__(7440);
var AccNameUtil_1 = __webpack_require__(1421);
var ARIAMapper = /** @class */ (function (_super) {
    __extends(ARIAMapper, _super);
    function ARIAMapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ARIAMapper.prototype.childrenCanHaveRole = function (node, role) {
        // if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
        //     const elem = node as Element;
        //     if (elem.getAttribute("aria-hidden") === "true") {
        //         return false;
        //     }
        // }
        return !(role in ARIADefinitions_1.ARIADefinitions.designPatterns && ARIADefinitions_1.ARIADefinitions.designPatterns[role].presentationalChildren);
    };
    ARIAMapper.prototype.getRole = function (node) {
        var role = ARIAMapper.nodeToRole(node);
        return role;
    };
    ARIAMapper.prototype.getNamespace = function () {
        return "aria";
    };
    ARIAMapper.prototype.getAttributes = function (node) {
        var retVal = {};
        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
            var elem_1 = node;
            for (var idx = 0; idx < elem_1.attributes.length; ++idx) {
                var attrInfo = elem_1.attributes[idx];
                var name_1 = attrInfo.name.toLowerCase();
                if (name_1.startsWith("aria-")) {
                    retVal[name_1.substring(5)] = attrInfo.nodeValue;
                }
            }
            var applyAttrRole = function (nodeName) {
                if (!(nodeName in ARIAMapper.elemAttrValueCalculators))
                    return;
                for (var attr in ARIAMapper.elemAttrValueCalculators[nodeName]) {
                    if (!(attr in retVal)) {
                        var value = ARIAMapper.elemAttrValueCalculators[nodeName][attr];
                        if (typeof value != "undefined" && value !== null) {
                            if (typeof value !== typeof "") {
                                value = value(elem_1);
                            }
                            retVal[attr] = value;
                        }
                    }
                }
            };
            applyAttrRole("global");
            applyAttrRole(node.nodeName.toLowerCase());
        }
        else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
            for (var attr in ARIAMapper.textAttrValueCalculators) {
                var val = ARIAMapper.textAttrValueCalculators[attr](node);
                if (typeof val != "undefined" && val !== null) {
                    retVal[attr] = val;
                }
            }
        }
        return retVal;
    };
    ARIAMapper.getAriaOwnedBy = function (elem) {
        var doc = fragment_1.FragmentUtil.getOwnerFragment(elem);
        if (!CacheUtil_1.CacheUtil.getCache(doc, "ARIAMapper::precalcOwned", false)) {
            var owners = doc.querySelectorAll("[aria-owns]");
            for (var iOwner = 0; iOwner < owners.length; ++iOwner) {
                var owner = owners[iOwner];
                var ownIds = owner.getAttribute("aria-owns").split(/ +/g);
                var _loop_1 = function (iId) {
                    var owned = doc.getElementById(ownIds[iId]);
                    //ignore if the aria-owns point to the element itself
                    //if (owned && !DOMUtil.sameNode(owner, owned)) {
                    //    CacheUtil.setCache(owned, "aria-owned", owner);
                    //}
                    /**
                     *  circular hierarchy check:
                     *  (1) the owned element is neither the same element with the owner nor any ascendant of the owner
                     *  (2) any child with aria-owns cannot point to the owner or any ascendant of the owner
                     */
                    if (owned && !DOMUtil_1.DOMUtil.sameNode(owner, owned)) {
                        // check if the owned with aria-owns that points to another element
                        var ownedNodes = [];
                        var sub_owners = owned.querySelectorAll("[aria-owns]");
                        for (var i = 0; i < sub_owners.length; ++i) {
                            var sub_owner = sub_owners[i];
                            var sub_ownIds = sub_owner.getAttribute("aria-owns").split(/ +/g);
                            for (var j = 0; j < sub_ownIds.length; ++j) {
                                var ownedNode = doc.getElementById(sub_ownIds[j]);
                                if (ownedNode)
                                    ownedNodes.push(ownedNode);
                            }
                        }
                        if (ownedNodes.length === 0) {
                            CacheUtil_1.CacheUtil.setCache(owned, "aria-owned", owner);
                            return "continue";
                        }
                        // check if any aria-owns points to the element itself or any of it's parent
                        var parent_1 = owner;
                        var circular = false;
                        while (parent_1 !== null) {
                            var found = ownedNodes.some(function (item) { return DOMUtil_1.DOMUtil.sameNode(parent_1, item); });
                            if (!found)
                                parent_1 = DOMWalker_1.DOMWalker.parentElement(parent_1);
                            else {
                                circular = true;
                                break;
                            }
                        }
                        if (!circular)
                            CacheUtil_1.CacheUtil.setCache(owned, "aria-owned", owner);
                    }
                };
                for (var iId = 0; iId < ownIds.length; ++iId) {
                    _loop_1(iId);
                }
            }
            CacheUtil_1.CacheUtil.setCache(doc, "ARIAMapper::precalcOwned", true);
        }
        return CacheUtil_1.CacheUtil.getCache(elem, "aria-owned", null);
    };
    ARIAMapper.prototype.getNodeHierarchy = function (node) {
        if (!node)
            return [];
        if (node.nodeType !== 1) {
            var parentHierarchy = this.getNodeHierarchy(DOMWalker_1.DOMWalker.parentElement(node));
            var parentInfo = parentHierarchy.length > 0 ? parentHierarchy[parentHierarchy.length - 1] : {
                role: "",
                rolePath: "",
                roleCount: {},
                childrenCanHaveRole: true
            };
            var nodeHierarchy = [];
            // Set hierarchy
            for (var _i = 0, parentHierarchy_1 = parentHierarchy; _i < parentHierarchy_1.length; _i++) {
                var item = parentHierarchy_1[_i];
                nodeHierarchy.push(item);
            }
            nodeHierarchy.push({
                attributes: {},
                bounds: this.getBounds(node),
                namespace: this.getNamespace(),
                node: node,
                role: this.getRole(node) || null,
                rolePath: parentInfo.rolePath + "/" + (this.getRole(node) || null),
                roleCount: {},
                childrenCanHaveRole: parentInfo.childrenCanHaveRole
            });
            return nodeHierarchy;
        }
        else {
            var elem = node;
            var nodeHierarchy = CacheUtil_1.CacheUtil.getCache(elem, "ARIAMapper::getNodeHierarchy", null);
            if (!nodeHierarchy) {
                // This element hasn't been processed yet - but ::reset processes them all in the right order
                // Get details about the correct parent first
                var parent_2 = ARIAMapper.getAriaOwnedBy(elem);
                if (!parent_2) {
                    parent_2 = DOMWalker_1.DOMWalker.parentElement(elem);
                }
                while (parent_2 && parent_2.nodeType !== 1) {
                    parent_2 = DOMWalker_1.DOMWalker.parentElement(elem);
                }
                var parentHierarchy = parent_2 ? this.getNodeHierarchy(parent_2) : [];
                var parentInfo = parentHierarchy.length > 0 ? parentHierarchy[parentHierarchy.length - 1] : {
                    role: "",
                    rolePath: "",
                    roleCount: {},
                    childrenCanHaveRole: true
                };
                while (parentInfo.role === null) {
                    parent_2 = ARIAMapper.getAriaOwnedBy(parent_2) || DOMWalker_1.DOMWalker.parentElement(parent_2);
                    parentHierarchy = parent_2 ? this.getNodeHierarchy(parent_2) : [];
                    parentInfo = parentHierarchy[parentHierarchy.length - 1];
                }
                // Set initial node info
                var nodeInfo = {
                    attributes: elem.nodeType === 1 ? this.getAttributes(elem) : {},
                    bounds: this.getBounds(elem),
                    namespace: this.getNamespace(),
                    node: elem,
                    role: this.getRole(elem) || null,
                    rolePath: "",
                    roleCount: {},
                    childrenCanHaveRole: true
                };
                // Adjust role if we're within a presentational container
                var presentationalContainer = !parentInfo.childrenCanHaveRole;
                if (presentationalContainer) {
                    nodeInfo.role = null;
                }
                else {
                    nodeInfo.childrenCanHaveRole = parentInfo.childrenCanHaveRole
                        && this.childrenCanHaveRole(elem, nodeInfo.role);
                }
                // Set the paths
                if (nodeInfo.role !== null) {
                    parentInfo.roleCount[nodeInfo.role] = (parentInfo.roleCount[nodeInfo.role] || 0) + 1;
                    nodeInfo.rolePath = parentInfo.rolePath + "/" + nodeInfo.role + "[" + parentInfo.roleCount[nodeInfo.role] + "]";
                }
                else {
                    nodeInfo.rolePath = parentInfo.rolePath;
                }
                // Set hierarchy
                nodeHierarchy = [];
                for (var _a = 0, parentHierarchy_2 = parentHierarchy; _a < parentHierarchy_2.length; _a++) {
                    var item = parentHierarchy_2[_a];
                    nodeHierarchy.push(item);
                }
                nodeHierarchy.push(nodeInfo);
                CacheUtil_1.CacheUtil.setCache(elem, "ARIAMapper::getNodeHierarchy", nodeHierarchy);
            }
            return nodeHierarchy;
        }
    };
    ARIAMapper.prototype.reset = function (node) {
        ARIAMapper.nameComputationId = 0;
        this.hierarchyRole = [];
        this.hierarchyResults = [];
        this.hierarchyPath = [{
                rolePath: "",
                roleCount: {}
            }];
        // Get to the topmost node
        var goodNode = node;
        var next;
        while (next = DOMWalker_1.DOMWalker.parentNode(goodNode)) {
            goodNode = next;
        }
        ;
        // Walk the tree and set the hierarchies in the right order
        var ariaWalker = new ARIAWalker_1.ARIAWalker(goodNode, false, goodNode);
        do {
            if (ariaWalker.node.nodeType === 1) {
                this.getNodeHierarchy(ariaWalker.node);
            }
        } while (ariaWalker.nextNode());
    };
    ARIAMapper.prototype.openScope = function (node) {
        if (this.hierarchyRole === null) {
            this.reset(node);
        }
        this.pushHierarchy(node);
        for (var idx = 0; idx < this.hierarchyResults.length; ++idx) {
            if (this.hierarchyResults[idx].role && this.hierarchyResults[idx].role[0] === "/") {
                this.hierarchyResults[idx].role = (this.hierarchyResults[idx].role ? this.hierarchyResults[idx].role.substring(1) : null);
            }
        }
        return this.hierarchyResults;
    };
    ARIAMapper.prototype.pushHierarchy = function (node) {
        // If we're not an element, no special handling
        var nodeHierarchy = [];
        // Determine our node info
        nodeHierarchy = this.getNodeHierarchy(node);
        var nodeInfo = nodeHierarchy[nodeHierarchy.length - 1];
        this.hierarchyRole.push(nodeInfo.role);
        if (nodeInfo.role !== null) {
            this.hierarchyPath.push(nodeInfo);
        }
        this.hierarchyResults = nodeHierarchy;
    };
    ARIAMapper.prototype.closeScope = function (node) {
        var retVal = [];
        for (var _i = 0, _a = this.hierarchyResults; _i < _a.length; _i++) {
            var res = _a[_i];
            // const temp = res.node;
            // res.node = null;
            // let cloned = JSON.parse(JSON.stringify(res));
            // cloned.node = res.node = temp; 
            // retVal.push(cloned);
            retVal.push(res);
        }
        if (retVal.length > 0) {
            retVal[retVal.length - 1].role = "/" + retVal[retVal.length - 1].role;
            var parent_3 = DOMWalker_1.DOMWalker.parentElement(node);
            this.hierarchyResults = parent_3 ? CacheUtil_1.CacheUtil.getCache(parent_3, "ARIAMapper::getNodeInfo", []) : [];
        }
        return retVal;
    };
    /**public static computeName(cur: Node) : string {
        ++ARIAMapper.nameComputationId;
        return ARIAMapper.computeNameHelp(ARIAMapper.nameComputationId, cur, false, false);
    }

    public static computeNameHelp(walkId: number, cur: Node, labelledbyTraverse: boolean, walkTraverse: boolean) : string {
        // 2g. None of the other content applies to text nodes, so just do this first
        if (cur.nodeType === 3 ) return cur.nodeValue;
        if (cur.nodeType === 11) return "";
        if (cur.nodeType !== 1 ) {
            if (walkTraverse || labelledbyTraverse) return "";
            throw new Error ("Can only compute name on Element and Text " + cur.nodeType);
        }

        const elem = cur as Element;
        // We've been here before - prevent recursion
        if (CacheUtil.getCache(elem, "data-namewalk", null) === ""+walkId) return "";
        CacheUtil.setCache(elem, "data-namewalk", ""+walkId);
        // See https://www.w3.org/TR/html-aam-1.0/#input-type-text-input-type-password-input-type-search-input-type-tel-input-type-url-and-textarea-element

        // 2a. Only show hidden content if it's referenced by a labelledby
        if (!labelledbyTraverse && !VisUtil.isNodeVisible(cur)) {
            return "";
        }

        // 2b. collect valid id references
        if (!labelledbyTraverse && elem.hasAttribute("aria-labelledby")) {
            let labelledby = elem.getAttribute("aria-labelledby").split(" ");
            let validElems = [];
            for (const ref of labelledby) {
                const refElem = FragmentUtil.getById(cur, ref);
                if (refElem && !DOMUtil.sameNode(elem, refElem)) {
                    validElems.push(refElem);
                }
            }
            if (validElems.length > 0) {
                let accumulated = "";
                for (const elem of validElems) {
                    accumulated += " " + this.computeNameHelp(walkId, elem, true, false);
                }
                return accumulated.trim();
            }
        }

        // Since nodeToRole calls back here for form and section, we need special casing here to handle those two cases
        if (["section", "form"].includes(cur.nodeName.toLowerCase())) {
            if (elem.hasAttribute("aria-label") && elem.getAttribute("aria-label").trim().length > 0) {
                // If I'm not an embedded control or I'm not recursing, return the aria-label
                if (!labelledbyTraverse && !walkTraverse) {
                    return elem.getAttribute("aria-label").trim();
                }
            }
            if (elem.hasAttribute("title")) {
                return elem.getAttribute("title");
            }
            return "";
        }

        // 2c. If label or walk, and this is a control, skip to the value, otherwise provide the label
        const role = ARIAMapper.nodeToRole(cur);
        let isEmbeddedControl = [
            "textbox", "button", "combobox", "listbox",
            "progressbar", "scrollbar", "slider", "spinbutton"
        ].includes(role);
        if (elem.hasAttribute("aria-label") && elem.getAttribute("aria-label").trim().length > 0) {
            // If I'm not an embedded control or I'm not recursing, return the aria-label
            if (!labelledbyTraverse && !walkTraverse || !isEmbeddedControl) {
                return elem.getAttribute("aria-label").trim();
            }
        }

        // 2d.
        if (role !== "presentation" && role !== "none") {
            if ((cur.nodeName.toLowerCase() === "img" || cur.nodeName.toLowerCase() === "area") && elem.hasAttribute("alt")) {
                return DOMUtil.cleanWhitespace(elem.getAttribute("alt")).trim();
            }

            if (cur.nodeName.toLowerCase() === "input" && elem.hasAttribute("id") && elem.getAttribute("id").length > 0) {
                let label = elem.ownerDocument.querySelector("label[for='"+elem.getAttribute("id")+"']");
                if (label) {
                    if (label.hasAttribute("aria-label") || (label.hasAttribute("aria-labelledby") && !CommonUtil.isIdReferToSelf(cur, label.getAttribute("aria-labelledby")))) {
                        return this.computeNameHelp(walkId, label, false, false);
                    } else {
                        return label.textContent;
                    }
                }
            }
            if (cur.nodeName.toLowerCase() === "fieldset") {
                if( (<Element>cur).querySelector("legend")){
                    let legend = (<Element>cur).querySelector("legend");
                    return legend.innerText;
                }else{
                    return this.computeNameHelp(walkId, cur, false, false);
                }
                            
            }
            
        }

        // 2e.
        if ((walkTraverse || labelledbyTraverse) && isEmbeddedControl) {
            // If the embedded control has role textbox, return its value.
            if (role === "textbox") {
                if (elem.nodeName.toLowerCase() === "input") {
                    if (elem.hasAttribute("value")) return elem.getAttribute("value");
                } else {
                    walkTraverse = false;
                }
            }

            // If the embedded control has role button, return the text alternative of the button.
            if (role === "button") {
                if (elem.nodeName.toLowerCase() === "input") {
                    let type = elem.getAttribute("type").toLowerCase();
                    if (["button", "submit", "reset"].includes(type)) {
                        if (elem.hasAttribute("value")) return elem.getAttribute("value");
                        if (type === "submit") return "Submit";
                        if (type === "reset") return "Reset";
                    }
                } else {
                    walkTraverse = false;
                }
            }

            // TODO: If the embedded control has role combobox or listbox, return the text alternative of the chosen option.
            if (role === "combobox") {
                if (elem.hasAttribute("aria-activedescendant")) {
                    let selected = FragmentUtil.getById(elem, "aria-activedescendant");
                    if (selected && !DOMUtil.sameNode(elem, selected)) {
                        return ARIAMapper.computeNameHelp(walkId, selected, false, false);
                    }
                }
            }

            // If the embedded control has role range (e.g., a spinbutton or slider):
            if (["progressbar", "scrollbar", "slider", "spinbutton"].includes(role)) {
                // If the aria-valuetext property is present, return its value,
                if (elem.hasAttribute("aria-valuetext")) return elem.getAttribute("aria-valuetext");
                // Otherwise, if the aria-valuenow property is present, return its value,
                if (elem.hasAttribute("aria-valuenow")) return elem.getAttribute("aria-valuenow");
                // TODO: Otherwise, use the value as specified by a host language attribute.
            }
        }

        // 2f. 2h.
        if (walkTraverse || ARIADefinitions.nameFromContent(role) || labelledbyTraverse) {
            // 2fi. Set the accumulated text to the empty string.
            let accumulated = "";
            // 2fii. Check for CSS generated textual content associated with the current node and
            // include it in the accumulated text. The CSS :before and :after pseudo elements [CSS2]
            // can provide textual content for elements that have a content model.
            //   For :before pseudo elements, User agents MUST prepend CSS textual content, without
            //     a space, to the textual content of the current node.
            //   For :after pseudo elements, User agents MUST append CSS textual content, without a
            //     space, to the textual content of the current node.
            let before = null;
            before = elem.ownerDocument.defaultView.getComputedStyle(elem,"before").content;

            if (before && before !== "none") {
                before = before.replace(/^"/,"").replace(/"$/,"");
                accumulated += before;
            }
            // 2fiii. For each child node of the current node:
            //   Set the current node to the child node.
            //   Compute the text alternative of the current node beginning with step 2. Set the result
            //     to that text alternative.
            //   Append the result to the accumulated text.
            if (elem.nodeName.toUpperCase() === "SLOT") {
                //if no assignedNode, check its own text
                if (!(elem as HTMLSlotElement).assignedNodes() || (elem as HTMLSlotElement).assignedNodes().length === 0) {
                    let innerText = CommonUtil.getInnerText(elem);
                    if (innerText && innerText !== null && innerText.trim().length > 0)
                        accumulated +=  " " + innerText;
                } else {
                    // check text from all assigned nodes
                    for (const slotChild of (elem as HTMLSlotElement).assignedNodes()) {
                        let nextChildContent = ARIAMapper.computeNameHelp(walkId, slotChild, labelledbyTraverse, true);
                        accumulated += " " + nextChildContent;
                    }
                }
            } else {
                let walkChild = elem.firstChild;
                while (walkChild) {
                    let nextChildContent = ARIAMapper.computeNameHelp(walkId, walkChild, labelledbyTraverse, true);
                    accumulated += " " + nextChildContent;
                    walkChild = walkChild.nextSibling;
                }
            }

            let after = null;
            try {
                after = elem.ownerDocument.defaultView.getComputedStyle(elem,"after").content;
            } catch (e) {}

            if (after && after !== "none") {
                after = after.replace(/^"/,"").replace(/"$/,"");
                accumulated += after;
            }
            // 2fiv. Return the accumulated text.
            accumulated = accumulated.replace(/\s+/g," ").trim();
            if (accumulated.trim().length > 0) {
                return accumulated;
            }
        }

        // 2i. Otherwise, if the current node has a Tooltip attribute, return its value.
        if (elem.hasAttribute("title")) {
            return elem.getAttribute("title");
        }
        if (elem.tagName.toLowerCase() === "svg") {
            let title = elem.querySelector("title");
            if (title) {
                return title.textContent || title.innerText;
            }
        }

        return "";
    }
    */
    /*        if (role in ARIADefinitions.designPatterns
                && ARIADefinitions.designPatterns[role].nameFrom
                && ARIADefinitions.designPatterns[role].nameFrom.includes("contents"))
            {
                name = elem.textContent;
            }
            if (elem.nodeName.toLowerCase() === "input" && elem.hasAttribute("id") && elem.getAttribute("id").trim().length > 0) {
                name = elem.ownerDocument.querySelector("label[for='"+elem.getAttribute("id").trim()+"']").textContent;
            }
            if (elem.hasAttribute("aria-label")) {
                name = elem.getAttribute("aria-label");
            }
            if (elem.hasAttribute("aria-labelledby")) {
                name = "";
                const ids = elem.getAttribute("aria-labelledby").split(" ");
                for (const id of ids) {
                    name += FragmentUtil.getById(elem, id).textContent + " ";
                }
                name = name.trim();
            }
            return name;
        }*/
    ARIAMapper.nodeToRole = function (node) {
        if (node.nodeType === 3 /* Node.TEXT_NODE */) {
            return "text";
        }
        else if (node.nodeType !== 1 /* Node.ELEMENT_NODE */) {
            return null;
        }
        var elem = node;
        if (!elem || elem.nodeType !== 1 /* Node.ELEMENT_NODE */) {
            return null;
        }
        // TO DO: use AriaUtil.getResolvedRole(elem) to replace the code following, which uses only the valid roles for the element based on the aria fallback rule
        //const role = AriaUtil.getResolvedRole(elem);
        //return role === "presentation" || role === "none" ? null : role;
        if (elem.hasAttribute("role") && elem.getAttribute("role").trim().length > 0) {
            var roleStr = elem.getAttribute("role").trim();
            var roles_2 = roleStr.split(" ");
            for (var _i = 0, roles_1 = roles_2; _i < roles_1.length; _i++) {
                var role_1 = roles_1[_i];
                if (role_1 === "presentation" || role_1 === "none") {
                    // If element is focusable, then presentation roles are to be ignored
                    if (!CommonUtil_1.CommonUtil.isFocusable(elem)) {
                        return null;
                    }
                }
                else if (role_1 in ARIADefinitions_1.ARIADefinitions.designPatterns) {
                    return role_1;
                }
            }
        }
        //return this.elemToImplicitRole(elem);
        var roles = AriaUtil_1.AriaUtil.getImplicitRole(elem);
        //console.log("node=" + node.nodeName +", role= " + (roles ? roles[0] : null) +", resolved=" + AriaUtil.getResolvedRole(elem));
        var role = !roles || roles.length === 0 ? null : roles[0];
        return role === "presentation" || role === "none" ? null : role;
        //return AriaUtil.getResolvedRole(elem);
    };
    ////////////////////////////////////////////////////////////////////////////
    // Helper functions
    ////
    // https://www.w3.org/TR/html-aam-1.0/#mapping-html-to-accessibility-apis
    ARIAMapper.elemAttrValueCalculators = {
        "global": {
            "name": AccNameUtil_1.AccNameUtil.computeAccessibleName //ARIAMapper.computeName
        },
        "datalist": {
            // set to "true" if the datalist's selection model allows multiple option elements to be
            // selected at a time, and "false" otherwise
            "multiselectable": function (elem) {
                var id = elem.getAttribute("id");
                if (id && id.length > 0) {
                    var input = elem.ownerDocument.querySelector("input[list='" + id + "']");
                    return "" + (elem.getAttribute("multiple")
                        && (elem.getAttribute("multiple") == "true" || elem.getAttribute("multiple") == ""));
                }
                return null;
            }
        },
        "h1": {
            "level": "1"
        },
        "h2": {
            "level": "2"
        },
        "h3": {
            "level": "3"
        },
        "h4": {
            "level": "4"
        },
        "h5": {
            "level": "5"
        },
        "h6": {
            "level": "6"
        },
        "input": {
            // - type="checkbox" state set to "mixed" if the element's indeterminate IDL attribute 
            // is true, or "true" if the element's checkedness is true, or "false" otherwise
            // - type="radio" state set to "true" if the element's checkedness is true, or "false" 
            // otherwise. 
            "checked": function (elem) {
                if (elem.getAttribute("type") === "checkbox" || elem.getAttribute("type") === "radio") {
                    return "" + elem.checked;
                }
                return null;
            }
            // - type="radio" and not in menu reflecting number of type=radio input elements 
            // within the radio button group
            ,
            "setsize": function (elem) { return null; throw new Error("NOT IMPLEMENTED"); }
            // - type="radio" and not in menu value reflecting the elements position 
            // within the radio button group."
            ,
            "posinset": function (elem) { return null; throw new Error("NOT IMPLEMENTED"); }
            // input (type attribute in the Text, Search, Telephone, URL, or E-mail states with a 
            // suggestions source element) combobox role, with the aria-owns property set to the same
            // value as the list attribute
            ,
            "owns": function (elem) { return null; throw new Error("NOT IMPLEMENTED"); }
        },
        "keygen": {
            "multiselectable": "false"
        },
        "li": {
            // Number of li elements within the ol, ul, menu
            "setsize": function (elem) {
                var parent = DOMUtil_1.DOMUtil.getAncestor(elem, ["ol", "ul", "menu"]);
                if (!parent)
                    return null;
                var lis = parent.querySelectorAll("li");
                var otherlis = parent.querySelectorAll("ol li, ul li, menu li");
                return "" + (lis.length - otherlis.length);
            }
            // Position of li element within the ol, ul, menu
            ,
            "posinset": function (elem) {
                var parent = DOMUtil_1.DOMUtil.getAncestor(elem, ["ol", "ul", "menu"]);
                if (!parent)
                    return null;
                var lis = parent.querySelectorAll("li");
                var num = 0;
                for (var idx = 0; idx < lis.length; ++idx) {
                    var li = lis[idx];
                    if (DOMUtil_1.DOMUtil.sameNode(parent, DOMUtil_1.DOMUtil.getAncestor(li, ["ol", "ul", "menu"]))) {
                        return "" + num;
                    }
                    ++num;
                }
                return null;
            }
        },
        "menuitem": {
            // type = checkbox or radio, set to "true" if the checked attribute 
            // is present, and "false" otherwise
            "checked": function (elem) { return "" + !!(elem.getAttribute("checked")
                && (elem.getAttribute("checked") == "true" || elem.getAttribute("checked") == "")); }
        },
        "option": {
            // set to "true" if the element's selectedness is true, or "false" otherwise.
            "selected": function (elem) { return "" + !!(elem.getAttribute("selected")
                && (elem.getAttribute("selected") == "true" || elem.getAttribute("selected") == "")); }
        },
        "progress": {
            "valuemax": function (elem) { return elem.getAttribute("max") || "1"; },
            "valuemin": function (elem) { return "0"; },
            "valuenow": function (elem) { return elem.getAttribute("value"); }
        }
    };
    ARIAMapper.textAttrValueCalculators = {
        "name": function (node) { return node.nodeValue; }
    };
    ARIAMapper.nameComputationId = 0;
    return ARIAMapper;
}(CommonMapper_1.CommonMapper));
exports.ARIAMapper = ARIAMapper;


/***/ }),

/***/ 8015:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ARIAWalker = void 0;
var fragment_1 = __webpack_require__(482);
var ARIAMapper_1 = __webpack_require__(4944);
var VisUtil_1 = __webpack_require__(8656);
var DOMWalker_1 = __webpack_require__(7440);
/**
 * Walks in an ARIA order
 *
 * See also ../dom/DOMWalker
 */
var ARIAWalker = /** @class */ (function () {
    function ARIAWalker(element, bEnd, root) {
        this.root = root || element;
        if (this.root.nodeType === 9) {
            this.root = this.root.documentElement;
        }
        this.node = element;
        // if (this.node.nodeType === 9) {
        //     this.node = (this.node as Document).documentElement
        // }
        this.bEndTag = (bEnd == undefined ? false : bEnd == true);
    }
    ARIAWalker.prototype.atRoot = function () {
        if (this.ownerElement)
            return false;
        if (this.root === this.node) {
            return true;
        }
        else if (this.root.isSameNode) {
            return this.root.isSameNode(this.node);
        }
        else if (this.root.compareDocumentPosition) {
            return this.root.compareDocumentPosition(this.node) === 0;
        }
        else {
            // Not supported in this environment - try our best
            return this.node.parentNode === null;
        }
    };
    ARIAWalker.prototype.nextNode = function () {
        var skipOwned = false;
        do {
            skipOwned = false;
            // console.log(this.node.nodeName, this.bEndTag?"END":"START", this.node.nodeType === 1 && (this.node as any).getAttribute("id"));
            if (!this.bEndTag) {
                var iframeNode = this.node;
                var elementNode = this.node;
                var slotElement = this.node;
                if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && this.node.nodeName.toUpperCase() === "IFRAME"
                    && VisUtil_1.VisUtil.isNodeVisible(iframeNode)
                    && iframeNode.contentDocument
                    && iframeNode.contentDocument.documentElement) {
                    var ownerElement = this.node;
                    this.node = iframeNode.contentDocument.documentElement;
                    this.node.ownerElement = ownerElement;
                }
                else if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && VisUtil_1.VisUtil.isNodeVisible(elementNode)
                    && elementNode.shadowRoot
                    && elementNode.shadowRoot.firstChild) {
                    var ownerElement = this.node;
                    this.node = elementNode.shadowRoot;
                    this.node.ownerElement = ownerElement;
                    DOMWalker_1.DOMWalker.assignSlots(this.node);
                }
                else if (this.node.nodeType === 1
                    && elementNode.nodeName.toLowerCase() === "slot"
                    && slotElement.assignedNodes().length > 0) {
                    this.node = slotElement.assignedNodes()[0];
                }
                else if ((this.node.nodeType === 1 /* Node.ELEMENT_NODE */ || this.node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */)
                    && DOMWalker_1.DOMWalker.firstChildNotOwnedBySlot(this.node)) {
                    this.node = DOMWalker_1.DOMWalker.firstChildNotOwnedBySlot(this.node);
                }
                else {
                    this.bEndTag = true;
                }
            }
            else {
                if (this.atRoot()) {
                    return false;
                }
                else if (this.node.slotOwner) {
                    var slotOwner = this.node.slotOwner;
                    var nextSlotIndex = this.node.slotIndex + 1;
                    // delete (this.node as any).slotOwner;
                    // delete (this.node as any).slotIndex;
                    if (nextSlotIndex < slotOwner.assignedNodes().length) {
                        this.node = slotOwner.assignedNodes()[nextSlotIndex];
                        this.bEndTag = false;
                    }
                    else {
                        this.node = slotOwner;
                        this.bEndTag = true;
                    }
                }
                else if (this.node.ownerElement) {
                    this.node = this.node.ownerElement;
                    this.bEndTag = true;
                }
                else if (DOMWalker_1.DOMWalker.nextSiblingNotOwnedBySlot(this.node)) {
                    this.node = DOMWalker_1.DOMWalker.nextSiblingNotOwnedBySlot(this.node);
                    this.bEndTag = false;
                    skipOwned = true;
                }
                else if (this.node.parentNode) {
                    if (this.node.parentNode.nodeType === 1 && this.node.parentNode.hasAttribute("aria-owns")) {
                        var ownIds = this.node.parentNode.getAttribute("aria-owns").split(/ +/g);
                        if (this.node.nodeType !== 1 || !this.node.hasAttribute("id")) {
                            this.node = fragment_1.FragmentUtil.getOwnerFragment(this.node).getElementById(ownIds[0]);
                            this.bEndTag = false;
                        }
                        else {
                            var idx = ownIds.indexOf(this.node.getAttribute("id"));
                            if (idx === ownIds.length - 1) {
                                // last one
                                this.node = this.node.parentNode;
                                this.bEndTag = true;
                            }
                            else {
                                // grab next
                                this.node = fragment_1.FragmentUtil.getOwnerFragment(this.node).getElementById(ownIds[idx + 1]);
                                this.bEndTag = false;
                            }
                        }
                    }
                    this.node = this.node.parentNode;
                    this.bEndTag = true;
                }
                else {
                    return false;
                }
            }
        } while ((this.node.nodeType !== 1 /* Node.ELEMENT_NODE */ && this.node.nodeType !== 11 && this.node.nodeType !== 3 /* Node.TEXT_NODE */)
            || (this.node.nodeType === 1 && this.node.getAttribute("aChecker") === "ACE")
            || (skipOwned && this.node.nodeType === 1 && !!ARIAMapper_1.ARIAMapper.getAriaOwnedBy(this.node)));
        return true;
    };
    ARIAWalker.prototype.prevNode = function () {
        var skipOwned = false;
        do {
            skipOwned = false;
            if (this.bEndTag) {
                var iframeNode = this.node;
                var elementNode = this.node;
                if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && this.node.nodeName.toUpperCase() === "IFRAME"
                    && VisUtil_1.VisUtil.isNodeVisible(iframeNode)
                    && iframeNode.contentDocument
                    && iframeNode.contentDocument.documentElement) {
                    var ownerElement = this.node;
                    this.node = iframeNode.contentDocument.documentElement;
                    this.node.ownerElement = ownerElement;
                }
                else if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && VisUtil_1.VisUtil.isNodeVisible(elementNode)
                    && elementNode.shadowRoot
                    && elementNode.shadowRoot.lastChild) {
                    var ownerElement = this.node;
                    this.node = elementNode.shadowRoot;
                    this.node.ownerElement = ownerElement;
                    DOMWalker_1.DOMWalker.assignSlots(this.node);
                }
                else if ((this.node.nodeType === 1 /* Node.ELEMENT_NODE */ || this.node.nodeType === 11)
                    && DOMWalker_1.DOMWalker.lastChildNotOwnedBySlot(this.node)) {
                    this.node = DOMWalker_1.DOMWalker.lastChildNotOwnedBySlot(this.node);
                }
                else {
                    this.bEndTag = false;
                }
            }
            else {
                if (this.atRoot()) {
                    return false;
                }
                else if (DOMWalker_1.DOMWalker.previousSiblingNotOwnedBySlot(this.node)) {
                    this.node = DOMWalker_1.DOMWalker.previousSiblingNotOwnedBySlot(this.node);
                    this.bEndTag = true;
                }
                else if (this.node.ownerElement) {
                    this.node = this.node.ownerElement;
                    this.bEndTag = false;
                    skipOwned = true;
                }
                else if (this.node.parentNode) {
                    if (this.node.parentNode.nodeType === 1 && this.node.parentNode.hasAttribute("aria-owns")) {
                        var ownIds = this.node.parentNode.getAttribute("aria-owns").split(/ +/g);
                        if (this.node.nodeType !== 1 || !this.node.hasAttribute("id")) {
                            this.node = fragment_1.FragmentUtil.getOwnerFragment(this.node).getElementById(ownIds[0]);
                            this.bEndTag = false;
                        }
                        else {
                            var idx = ownIds.indexOf(this.node.getAttribute("id"));
                            if (idx === ownIds.length - 1) {
                                // last one
                                this.node = this.node.parentNode;
                                this.bEndTag = true;
                            }
                            else {
                                // grab next
                                this.node = fragment_1.FragmentUtil.getOwnerFragment(this.node).getElementById(ownIds[idx + 1]);
                                this.bEndTag = false;
                            }
                        }
                    }
                    this.node = this.node.parentNode;
                    this.bEndTag = false;
                }
                else {
                    return false;
                }
            }
        } while ((this.node.nodeType !== 1 /* Node.ELEMENT_NODE */ && this.node.nodeType !== 11)
            || (this.node.nodeType === 1 && this.node.getAttribute("aChecker") === "ACE")
            || (skipOwned && this.node.nodeType === 1 && !!ARIAMapper_1.ARIAMapper.getAriaOwnedBy(this.node)));
        return true;
    };
    return ARIAWalker;
}());
exports.ARIAWalker = ARIAWalker;


/***/ }),

/***/ 9193:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AncestorUtil = void 0;
var AncestorUtil = /** @class */ (function () {
    function AncestorUtil() {
    }
    AncestorUtil.isPresentationFrame = function (contextHierarchy) {
        if (contextHierarchy && contextHierarchy.dom) {
            // Skip current node because we want ancestry
            for (var idx = contextHierarchy.dom.length - 2; idx >= 0; --idx) {
                var elem = contextHierarchy.dom[idx].node;
                if (elem.nodeType === 1
                    && elem.nodeName.toLowerCase() === "iframe"
                    && (elem.getAttribute("role") === "presentation" || elem.getAttribute("aria-hidden") === "true")) {
                    return true;
                }
            }
        }
        return false;
    };
    AncestorUtil.isFrame = function (contextHierarchy) {
        if (contextHierarchy && contextHierarchy.dom) {
            // Skip current node because we want ancestry
            for (var idx = contextHierarchy.dom.length - 2; idx >= 0; --idx) {
                var elem = contextHierarchy.dom[idx].node;
                if (elem.nodeType === 1 && elem.nodeName.toLowerCase() === "iframe") {
                    return true;
                }
            }
        }
        return false;
    };
    return AncestorUtil;
}());
exports.AncestorUtil = AncestorUtil;


/***/ }),

/***/ 482:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FragmentUtil = void 0;
var FragmentUtil = /** @class */ (function () {
    function FragmentUtil() {
    }
    FragmentUtil.getOwnerFragment = function (node) {
        var n = node;
        while (n.parentNode && (n = n.parentNode)) {
            if (n.nodeType === 11) {
                return n;
            }
        }
        return node.ownerDocument;
    };
    FragmentUtil.getById = function (node, id) {
        return this.getOwnerFragment(node).getElementById(id);
    };
    FragmentUtil.getAncestor = function (hierarchies, elemName) {
        var matches = hierarchies["dom"].filter(function (info) { return info.role === elemName; });
        return matches.length > 0 && matches[0].node || null;
    };
    FragmentUtil.getAncestorWithRole = function (hierarchies, role) {
        var matches = hierarchies["aria"].filter(function (info) { return info.role === role; });
        return matches.length > 0 && matches[0].node || null;
    };
    return FragmentUtil;
}());
exports.FragmentUtil = FragmentUtil;


/***/ }),

/***/ 2527:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2021- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LangUtil = void 0;
// From https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
var validPrimaryLangs = [
    ["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "aaa", "aab", "aac", "aad", "aae", "aaf", "aag", "aah", "aai", "aak", "aal", "aam", "aan", "aao", "aap", "aaq", "aas", "aat", "aau", "aav", "aaw", "aax", "aaz", "aba", "abb", "abc", "abd", "abe", "abf", "abg", "abh", "abi", "abj", "abl", "abm", "abn", "abo", "abp", "abq", "abr", "abs", "abt", "abu", "abv", "abw", "abx", "aby", "abz", "aca", "acb", "acd", "ace", "acf", "ach", "aci", "ack", "acl", "acm", "acn", "acp", "acq", "acr", "acs", "act", "acu", "acv", "acw", "acx", "acy", "acz", "ada", "adb", "add", "ade", "adf", "adg", "adh", "adi", "adj", "adl", "adn", "ado", "adp", "adq", "adr", "ads", "adt", "adu", "adw", "adx", "ady", "adz", "aea", "aeb", "aec", "aed", "aee", "aek", "ael", "aem", "aen", "aeq", "aer", "aes", "aeu", "aew", "aey", "aez", "afa", "afb", "afd", "afe", "afg", "afh", "afi", "afk", "afn", "afo", "afp", "afs", "aft", "afu", "afz", "aga", "agb", "agc", "agd", "age", "agf", "agg", "agh", "agi", "agj", "agk", "agl", "agm", "agn", "ago", "agp", "agq", "agr", "ags", "agt", "agu", "agv", "agw", "agx", "agy", "agz", "aha", "ahb", "ahg", "ahh", "ahi", "ahk", "ahl", "ahm", "ahn", "aho", "ahp", "ahr", "ahs", "aht", "aia", "aib", "aic", "aid", "aie", "aif", "aig", "aih", "aii", "aij", "aik", "ail", "aim", "ain", "aio", "aip", "aiq", "air", "ais", "ait", "aiw", "aix", "aiy", "aja", "ajg", "aji", "ajn", "ajp", "ajt", "aju", "ajw", "ajz", "akb", "akc", "akd", "ake", "akf", "akg", "akh", "aki", "akj", "akk", "akl", "akm", "ako", "akp", "akq", "akr", "aks", "akt", "aku", "akv", "akw", "akx", "aky", "akz", "ala", "alc", "ald", "ale", "alf", "alg", "alh", "ali", "alj", "alk", "all", "alm", "aln", "alo", "alp", "alq", "alr", "als", "alt", "alu", "alv", "alw", "alx", "aly", "alz", "ama", "amb", "amc", "ame", "amf", "amg", "ami", "amj", "amk", "aml", "amm", "amn", "amo", "amp", "amq", "amr", "ams", "amt", "amu", "amv", "amw", "amx", "amy", "amz", "ana", "anb", "anc", "and", "ane", "anf", "ang", "anh", "ani", "anj", "ank", "anl", "anm", "ann", "ano", "anp", "anq", "anr", "ans", "ant", "anu", "anv", "anw", "anx", "any", "anz", "aoa", "aob", "aoc", "aod", "aoe", "aof", "aog", "aoh", "aoi", "aoj", "aok", "aol", "aom", "aon", "aor", "aos", "aot", "aou", "aox", "aoz", "apa", "apb", "apc", "apd", "ape", "apf", "apg", "aph", "api", "apj", "apk", "apl", "apm", "apn", "apo", "app", "apq", "apr", "aps", "apt", "apu", "apv", "apw", "apx", "apy", "apz", "aqa", "aqc", "aqd", "aqg", "aqk", "aql", "aqm", "aqn", "aqp", "aqr", "aqt", "aqz", "arb", "arc", "ard", "are", "arh", "ari", "arj", "ark", "arl", "arn", "aro", "arp", "arq", "arr", "ars", "art", "aru", "arv", "arw", "arx", "ary", "arz", "asa", "asb", "asc", "asd", "ase", "asf", "asg", "ash", "asi", "asj", "ask", "asl", "asn", "aso", "asp", "asq", "asr", "ass", "ast", "asu", "asv", "asw", "asx", "asy", "asz", "ata", "atb", "atc", "atd", "ate", "atg", "ath", "ati", "atj", "atk", "atl", "atm", "atn", "ato", "atp", "atq", "atr", "ats", "att", "atu", "atv", "atw", "atx", "aty", "atz", "aua", "aub", "auc", "aud", "aue", "auf", "aug", "auh", "aui", "auj", "auk", "aul", "aum", "aun", "auo", "aup", "auq", "aur", "aus", "aut", "auu", "auw", "aux", "auy", "auz", "avb", "avd", "avi", "avk", "avl", "avm", "avn", "avo", "avs", "avt", "avu", "avv", "awa", "awb", "awc", "awd", "awe", "awg", "awh", "awi", "awk", "awm", "awn", "awo", "awr", "aws", "awt", "awu", "awv", "aww", "awx", "awy", "axb", "axe", "axg", "axk", "axl", "axm", "axx", "aya", "ayb", "ayc", "ayd", "aye", "ayg", "ayh", "ayi", "ayk", "ayl", "ayn", "ayo", "ayp", "ayq", "ayr", "ays", "ayt", "ayu", "ayx", "ayy", "ayz", "aza", "azb", "azc", "azd", "azg", "azj", "azm", "azn", "azo", "azt", "azz"],
    ["ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "baa", "bab", "bac", "bad", "bae", "baf", "bag", "bah", "bai", "baj", "bal", "ban", "bao", "bap", "bar", "bas", "bat", "bau", "bav", "baw", "bax", "bay", "baz", "bba", "bbb", "bbc", "bbd", "bbe", "bbf", "bbg", "bbh", "bbi", "bbj", "bbk", "bbl", "bbm", "bbn", "bbo", "bbp", "bbq", "bbr", "bbs", "bbt", "bbu", "bbv", "bbw", "bbx", "bby", "bbz", "bca", "bcb", "bcc", "bcd", "bce", "bcf", "bcg", "bch", "bci", "bcj", "bck", "bcl", "bcm", "bcn", "bco", "bcp", "bcq", "bcr", "bcs", "bct", "bcu", "bcv", "bcw", "bcy", "bcz", "bda", "bdb", "bdc", "bdd", "bde", "bdf", "bdg", "bdh", "bdi", "bdj", "bdk", "bdl", "bdm", "bdn", "bdo", "bdp", "bdq", "bdr", "bds", "bdt", "bdu", "bdv", "bdw", "bdx", "bdy", "bdz", "bea", "beb", "bec", "bed", "bee", "bef", "beg", "beh", "bei", "bej", "bek", "bem", "beo", "bep", "beq", "ber", "bes", "bet", "beu", "bev", "bew", "bex", "bey", "bez", "bfa", "bfb", "bfc", "bfd", "bfe", "bff", "bfg", "bfh", "bfi", "bfj", "bfk", "bfl", "bfm", "bfn", "bfo", "bfp", "bfq", "bfr", "bfs", "bft", "bfu", "bfw", "bfx", "bfy", "bfz", "bga", "bgb", "bgc", "bgd", "bge", "bgf", "bgg", "bgi", "bgj", "bgk", "bgl", "bgm", "bgn", "bgo", "bgp", "bgq", "bgr", "bgs", "bgt", "bgu", "bgv", "bgw", "bgx", "bgy", "bgz", "bha", "bhb", "bhc", "bhd", "bhe", "bhf", "bhg", "bhh", "bhi", "bhj", "bhk", "bhl", "bhm", "bhn", "bho", "bhp", "bhq", "bhr", "bhs", "bht", "bhu", "bhv", "bhw", "bhx", "bhy", "bhz", "bia", "bib", "bic", "bid", "bie", "bif", "big", "bij", "bik", "bil", "bim", "bin", "bio", "bip", "biq", "bir", "bit", "biu", "biv", "biw", "bix", "biy", "biz", "bja", "bjb", "bjc", "bjd", "bje", "bjf", "bjg", "bjh", "bji", "bjj", "bjk", "bjl", "bjm", "bjn", "bjo", "bjp", "bjq", "bjr", "bjs", "bjt", "bju", "bjv", "bjw", "bjx", "bjy", "bjz", "bka", "bkb", "bkc", "bkd", "bkf", "bkg", "bkh", "bki", "bkj", "bkk", "bkl", "bkm", "bkn", "bko", "bkp", "bkq", "bkr", "bks", "bkt", "bku", "bkv", "bkw", "bkx", "bky", "bkz", "bla", "blb", "blc", "bld", "ble", "blf", "blg", "blh", "bli", "blj", "blk", "bll", "blm", "bln", "blo", "blp", "blq", "blr", "bls", "blt", "blv", "blw", "blx", "bly", "blz", "bma", "bmb", "bmc", "bmd", "bme", "bmf", "bmg", "bmh", "bmi", "bmj", "bmk", "bml", "bmm", "bmn", "bmo", "bmp", "bmq", "bmr", "bms", "bmt", "bmu", "bmv", "bmw", "bmx", "bmy", "bmz", "bna", "bnb", "bnc", "bnd", "bne", "bnf", "bng", "bni", "bnj", "bnk", "bnl", "bnm", "bnn", "bno", "bnp", "bnq", "bnr", "bns", "bnt", "bnu", "bnv", "bnw", "bnx", "bny", "bnz", "boa", "bob", "boe", "bof", "bog", "boh", "boi", "boj", "bok", "bol", "bom", "bon", "boo", "bop", "boq", "bor", "bot", "bou", "bov", "bow", "box", "boy", "boz", "bpa", "bpb", "bpd", "bpe", "bpg", "bph", "bpi", "bpj", "bpk", "bpl", "bpm", "bpn", "bpo", "bpp", "bpq", "bpr", "bps", "bpt", "bpu", "bpv", "bpw", "bpx", "bpy", "bpz", "bqa", "bqb", "bqc", "bqd", "bqf", "bqg", "bqh", "bqi", "bqj", "bqk", "bql", "bqm", "bqn", "bqo", "bqp", "bqq", "bqr", "bqs", "bqt", "bqu", "bqv", "bqw", "bqx", "bqy", "bqz", "bra", "brb", "brc", "brd", "brf", "brg", "brh", "bri", "brj", "brk", "brl", "brm", "brn", "bro", "brp", "brq", "brr", "brs", "brt", "bru", "brv", "brw", "brx", "bry", "brz", "bsa", "bsb", "bsc", "bse", "bsf", "bsg", "bsh", "bsi", "bsj", "bsk", "bsl", "bsm", "bsn", "bso", "bsp", "bsq", "bsr", "bss", "bst", "bsu", "bsv", "bsw", "bsx", "bsy", "bta", "btb", "btc", "btd", "bte", "btf", "btg", "bth", "bti", "btj", "btk", "btl", "btm", "btn", "bto", "btp", "btq", "btr", "bts", "btt", "btu", "btv", "btw", "btx", "bty", "btz", "bua", "bub", "buc", "bud", "bue", "buf", "bug", "buh", "bui", "buj", "buk", "bum", "bun", "buo", "bup", "buq", "bus", "but", "buu", "buv", "buw", "bux", "buy", "buz", "bva", "bvb", "bvc", "bvd", "bve", "bvf", "bvg", "bvh", "bvi", "bvj", "bvk", "bvl", "bvm", "bvn", "bvo", "bvp", "bvq", "bvr", "bvt", "bvu", "bvv", "bvw", "bvx", "bvy", "bvz", "bwa", "bwb", "bwc", "bwd", "bwe", "bwf", "bwg", "bwh", "bwi", "bwj", "bwk", "bwl", "bwm", "bwn", "bwo", "bwp", "bwq", "bwr", "bws", "bwt", "bwu", "bww", "bwx", "bwy", "bwz", "bxa", "bxb", "bxc", "bxd", "bxe", "bxf", "bxg", "bxh", "bxi", "bxj", "bxk", "bxl", "bxm", "bxn", "bxo", "bxp", "bxq", "bxr", "bxs", "bxu", "bxv", "bxw", "bxx", "bxz", "bya", "byb", "byc", "byd", "bye", "byf", "byg", "byh", "byi", "byj", "byk", "byl", "bym", "byn", "byo", "byp", "byq", "byr", "bys", "byt", "byv", "byw", "byx", "byy", "byz", "bza", "bzb", "bzc", "bzd", "bze", "bzf", "bzg", "bzh", "bzi", "bzj", "bzk", "bzl", "bzm", "bzn", "bzo", "bzp", "bzq", "bzr", "bzs", "bzt", "bzu", "bzv", "bzw", "bzx", "bzy", "bzz"],
    ["ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "caa", "cab", "cac", "cad", "cae", "caf", "cag", "cah", "cai", "caj", "cak", "cal", "cam", "can", "cao", "cap", "caq", "car", "cas", "cau", "cav", "caw", "cax", "cay", "caz", "cba", "cbb", "cbc", "cbd", "cbe", "cbg", "cbh", "cbi", "cbj", "cbk", "cbl", "cbn", "cbo", "cbq", "cbr", "cbs", "cbt", "cbu", "cbv", "cbw", "cby", "cca", "ccc", "ccd", "cce", "ccg", "cch", "ccj", "ccl", "ccm", "ccn", "cco", "ccp", "ccq", "ccr", "ccs", "cda", "cdc", "cdd", "cde", "cdf", "cdg", "cdh", "cdi", "cdj", "cdm", "cdn", "cdo", "cdr", "cds", "cdy", "cdz", "cea", "ceb", "ceg", "cek", "cel", "cen", "cet", "cey", "cfa", "cfd", "cfg", "cfm", "cga", "cgc", "cgg", "cgk", "chb", "chc", "chd", "chf", "chg", "chh", "chj", "chk", "chl", "chm", "chn", "cho", "chp", "chq", "chr", "cht", "chw", "chx", "chy", "chz", "cia", "cib", "cic", "cid", "cie", "cih", "cik", "cim", "cin", "cip", "cir", "ciw", "ciy", "cja", "cje", "cjh", "cji", "cjk", "cjm", "cjn", "cjo", "cjp", "cjr", "cjs", "cjv", "cjy", "cka", "ckb", "ckh", "ckl", "ckm", "ckn", "cko", "ckq", "ckr", "cks", "ckt", "cku", "ckv", "ckx", "cky", "ckz", "cla", "clc", "cld", "cle", "clh", "cli", "clj", "clk", "cll", "clm", "clo", "clt", "clu", "clw", "cly", "cma", "cmc", "cme", "cmg", "cmi", "cmk", "cml", "cmm", "cmn", "cmo", "cmr", "cms", "cmt", "cna", "cnb", "cnc", "cng", "cnh", "cni", "cnk", "cnl", "cno", "cnp", "cnr", "cns", "cnt", "cnu", "cnw", "cnx", "coa", "cob", "coc", "cod", "coe", "cof", "cog", "coh", "coj", "cok", "col", "com", "con", "coo", "cop", "coq", "cot", "cou", "cov", "cow", "cox", "coy", "coz", "cpa", "cpb", "cpc", "cpe", "cpf", "cpg", "cpi", "cpn", "cpo", "cpp", "cps", "cpu", "cpx", "cpy", "cqd", "cqu", "cra", "crb", "crc", "crd", "crf", "crg", "crh", "cri", "crj", "crk", "crl", "crm", "crn", "cro", "crp", "crq", "crr", "crs", "crt", "crv", "crw", "crx", "cry", "crz", "csa", "csb", "csc", "csd", "cse", "csf", "csg", "csh", "csi", "csj", "csk", "csl", "csm", "csn", "cso", "csp", "csq", "csr", "css", "cst", "csu", "csv", "csw", "csx", "csy", "csz", "cta", "ctc", "ctd", "cte", "ctg", "cth", "ctl", "ctm", "ctn", "cto", "ctp", "cts", "ctt", "ctu", "cty", "ctz", "cua", "cub", "cuc", "cug", "cuh", "cui", "cuj", "cuk", "cul", "cum", "cuo", "cup", "cuq", "cur", "cus", "cut", "cuu", "cuv", "cuw", "cux", "cuy", "cvg", "cvn", "cwa", "cwb", "cwd", "cwe", "cwg", "cwt", "cya", "cyb", "cyo", "czh", "czk", "czn", "czo", "czt"],
    ["da", "de", "dv", "dz", "daa", "dac", "dad", "dae", "daf", "dag", "dah", "dai", "daj", "dak", "dal", "dam", "dao", "dap", "daq", "dar", "das", "dau", "dav", "daw", "dax", "day", "daz", "dba", "dbb", "dbd", "dbe", "dbf", "dbg", "dbi", "dbj", "dbl", "dbm", "dbn", "dbo", "dbp", "dbq", "dbr", "dbt", "dbu", "dbv", "dbw", "dby", "dcc", "dcr", "dda", "ddd", "dde", "ddg", "ddi", "ddj", "ddn", "ddo", "ddr", "dds", "ddw", "dec", "ded", "dee", "def", "deg", "deh", "dei", "dek", "del", "dem", "den", "dep", "deq", "der", "des", "dev", "dez", "dga", "dgb", "dgc", "dgd", "dge", "dgg", "dgh", "dgi", "dgk", "dgl", "dgn", "dgo", "dgr", "dgs", "dgt", "dgu", "dgw", "dgx", "dgz", "dha", "dhd", "dhg", "dhi", "dhl", "dhm", "dhn", "dho", "dhr", "dhs", "dhu", "dhv", "dhw", "dhx", "dia", "dib", "dic", "did", "dif", "dig", "dih", "dii", "dij", "dik", "dil", "dim", "din", "dio", "dip", "diq", "dir", "dis", "dit", "diu", "diw", "dix", "diy", "diz", "dja", "djb", "djc", "djd", "dje", "djf", "dji", "djj", "djk", "djl", "djm", "djn", "djo", "djr", "dju", "djw", "dka", "dkg", "dkk", "dkl", "dkr", "dks", "dkx", "dlg", "dlk", "dlm", "dln", "dma", "dmb", "dmc", "dmd", "dme", "dmf", "dmg", "dmk", "dml", "dmm", "dmn", "dmo", "dmr", "dms", "dmu", "dmv", "dmw", "dmx", "dmy", "dna", "dnd", "dne", "dng", "dni", "dnj", "dnk", "dnn", "dno", "dnr", "dnt", "dnu", "dnv", "dnw", "dny", "doa", "dob", "doc", "doe", "dof", "doh", "doi", "dok", "dol", "don", "doo", "dop", "doq", "dor", "dos", "dot", "dov", "dow", "dox", "doy", "doz", "dpp", "dra", "drb", "drc", "drd", "dre", "drg", "drh", "dri", "drl", "drn", "dro", "drq", "drr", "drs", "drt", "dru", "drw", "dry", "dsb", "dse", "dsh", "dsi", "dsl", "dsn", "dso", "dsq", "dta", "dtb", "dtd", "dth", "dti", "dtk", "dtm", "dtn", "dto", "dtp", "dtr", "dts", "dtt", "dtu", "dty", "dua", "dub", "duc", "dud", "due", "duf", "dug", "duh", "dui", "duj", "duk", "dul", "dum", "dun", "duo", "dup", "duq", "dur", "dus", "duu", "duv", "duw", "dux", "duy", "duz", "dva", "dwa", "dwk", "dwl", "dwr", "dws", "dwu", "dww", "dwy", "dwz", "dya", "dyb", "dyd", "dyg", "dyi", "dym", "dyn", "dyo", "dyu", "dyy", "dza", "dzd", "dze", "dzg", "dzl", "dzn"],
    ["ee", "el", "en", "eo", "es", "et", "eu", "eaa", "ebc", "ebg", "ebk", "ebo", "ebr", "ebu", "ecr", "ecs", "ecy", "eee", "efa", "efe", "efi", "ega", "egl", "ego", "egx", "egy", "ehs", "ehu", "eip", "eit", "eiv", "eja", "eka", "ekc", "eke", "ekg", "eki", "ekk", "ekl", "ekm", "eko", "ekp", "ekr", "eky", "ele", "elh", "eli", "elk", "elm", "elo", "elp", "elu", "elx", "ema", "emb", "eme", "emg", "emi", "emk", "emm", "emn", "emo", "emp", "emq", "ems", "emu", "emw", "emx", "emy", "emz", "ena", "enb", "enc", "end", "enf", "enh", "enl", "enm", "enn", "eno", "enq", "enr", "enu", "env", "enw", "enx", "eot", "epi", "era", "erg", "erh", "eri", "erk", "ero", "err", "ers", "ert", "erw", "ese", "esg", "esh", "esi", "esk", "esl", "esm", "esn", "eso", "esq", "ess", "esu", "esx", "esy", "etb", "etc", "eth", "etn", "eto", "etr", "ets", "ett", "etu", "etx", "etz", "euq", "eve", "evh", "evn", "ewo", "ext", "eya", "eyo", "eza", "eze"],
    ["fa", "ff", "fi", "fj", "fo", "fr", "fy", "faa", "fab", "fad", "faf", "fag", "fah", "fai", "faj", "fak", "fal", "fam", "fan", "fap", "far", "fat", "fau", "fax", "fay", "faz", "fbl", "fcs", "fer", "ffi", "ffm", "fgr", "fia", "fie", "fif", "fil", "fip", "fir", "fit", "fiu", "fiw", "fkk", "fkv", "fla", "flh", "fli", "fll", "fln", "flr", "fly", "fmp", "fmu", "fnb", "fng", "fni", "fod", "foi", "fom", "fon", "for", "fos", "fox", "fpe", "fqs", "frc", "frd", "frk", "frm", "fro", "frp", "frq", "frr", "frs", "frt", "fse", "fsl", "fss", "fub", "fuc", "fud", "fue", "fuf", "fuh", "fui", "fuj", "fum", "fun", "fuq", "fur", "fut", "fuu", "fuv", "fuy", "fvr", "fwa", "fwe"],
    ["ga", "gd", "gl", "gn", "gu", "gv", "gaa", "gab", "gac", "gad", "gae", "gaf", "gag", "gah", "gai", "gaj", "gak", "gal", "gam", "gan", "gao", "gap", "gaq", "gar", "gas", "gat", "gau", "gav", "gaw", "gax", "gay", "gaz", "gba", "gbb", "gbc", "gbd", "gbe", "gbf", "gbg", "gbh", "gbi", "gbj", "gbk", "gbl", "gbm", "gbn", "gbo", "gbp", "gbq", "gbr", "gbs", "gbu", "gbv", "gbw", "gbx", "gby", "gbz", "gcc", "gcd", "gce", "gcf", "gcl", "gcn", "gcr", "gct", "gda", "gdb", "gdc", "gdd", "gde", "gdf", "gdg", "gdh", "gdi", "gdj", "gdk", "gdl", "gdm", "gdn", "gdo", "gdq", "gdr", "gds", "gdt", "gdu", "gdx", "gea", "geb", "gec", "ged", "gef", "geg", "geh", "gei", "gej", "gek", "gel", "gem", "geq", "ges", "gev", "gew", "gex", "gey", "gez", "gfk", "gft", "gfx", "gga", "ggb", "ggd", "gge", "ggg", "ggk", "ggl", "ggn", "ggo", "ggr", "ggt", "ggu", "ggw", "gha", "ghc", "ghe", "ghh", "ghk", "ghl", "ghn", "gho", "ghr", "ghs", "ght", "gia", "gib", "gic", "gid", "gie", "gig", "gih", "gii", "gil", "gim", "gin", "gio", "gip", "giq", "gir", "gis", "git", "giu", "giw", "gix", "giy", "giz", "gji", "gjk", "gjm", "gjn", "gjr", "gju", "gka", "gkd", "gke", "gkn", "gko", "gkp", "gku", "glb", "glc", "gld", "glh", "gli", "glj", "glk", "gll", "glo", "glr", "glu", "glw", "gly", "gma", "gmb", "gmd", "gme", "gmg", "gmh", "gml", "gmm", "gmn", "gmq", "gmr", "gmu", "gmv", "gmw", "gmx", "gmy", "gmz", "gna", "gnb", "gnc", "gnd", "gne", "gng", "gnh", "gni", "gnj", "gnk", "gnl", "gnm", "gnn", "gno", "gnq", "gnr", "gnt", "gnu", "gnw", "gnz", "goa", "gob", "goc", "god", "goe", "gof", "gog", "goh", "goi", "goj", "gok", "gol", "gom", "gon", "goo", "gop", "goq", "gor", "gos", "got", "gou", "gow", "gox", "goy", "goz", "gpa", "gpe", "gpn", "gqa", "gqi", "gqn", "gqr", "gqu", "gra", "grb", "grc", "grd", "grg", "grh", "gri", "grj", "grk", "grm", "gro", "grq", "grr", "grs", "grt", "gru", "grv", "grw", "grx", "gry", "grz", "gse", "gsg", "gsl", "gsm", "gsn", "gso", "gsp", "gss", "gsw", "gta", "gti", "gtu", "gua", "gub", "guc", "gud", "gue", "guf", "gug", "guh", "gui", "guk", "gul", "gum", "gun", "guo", "gup", "guq", "gur", "gus", "gut", "guu", "guv", "guw", "gux", "guz", "gva", "gvc", "gve", "gvf", "gvj", "gvl", "gvm", "gvn", "gvo", "gvp", "gvr", "gvs", "gvy", "gwa", "gwb", "gwc", "gwd", "gwe", "gwf", "gwg", "gwi", "gwj", "gwm", "gwn", "gwr", "gwt", "gwu", "gww", "gwx", "gxx", "gya", "gyb", "gyd", "gye", "gyf", "gyg", "gyi", "gyl", "gym", "gyn", "gyo", "gyr", "gyy", "gyz", "gza", "gzi", "gzn"],
    ["ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "haa", "hab", "hac", "had", "hae", "haf", "hag", "hah", "hai", "haj", "hak", "hal", "ham", "han", "hao", "hap", "haq", "har", "has", "hav", "haw", "hax", "hay", "haz", "hba", "hbb", "hbn", "hbo", "hbu", "hca", "hch", "hdn", "hds", "hdy", "hea", "hed", "heg", "heh", "hei", "hem", "hgm", "hgw", "hhi", "hhr", "hhy", "hia", "hib", "hid", "hif", "hig", "hih", "hii", "hij", "hik", "hil", "him", "hio", "hir", "hit", "hiw", "hix", "hji", "hka", "hke", "hkh", "hkk", "hkn", "hks", "hla", "hlb", "hld", "hle", "hlt", "hlu", "hma", "hmb", "hmc", "hmd", "hme", "hmf", "hmg", "hmh", "hmi", "hmj", "hmk", "hml", "hmm", "hmn", "hmp", "hmq", "hmr", "hms", "hmt", "hmu", "hmv", "hmw", "hmx", "hmy", "hmz", "hna", "hnd", "hne", "hng", "hnh", "hni", "hnj", "hnn", "hno", "hns", "hnu", "hoa", "hob", "hoc", "hod", "hoe", "hoh", "hoi", "hoj", "hok", "hol", "hom", "hoo", "hop", "hor", "hos", "hot", "hov", "how", "hoy", "hoz", "hpo", "hps", "hra", "hrc", "hre", "hrk", "hrm", "hro", "hrp", "hrr", "hrt", "hru", "hrw", "hrx", "hrz", "hsb", "hsh", "hsl", "hsn", "hss", "hti", "hto", "hts", "htu", "htx", "hub", "huc", "hud", "hue", "huf", "hug", "huh", "hui", "huj", "huk", "hul", "hum", "huo", "hup", "huq", "hur", "hus", "hut", "huu", "huv", "huw", "hux", "huy", "huz", "hvc", "hve", "hvk", "hvn", "hvv", "hwa", "hwc", "hwo", "hya", "hyw", "hyx"],
    ["ia", "id", "ie", "ig", "ii", "ik", "in", "io", "is", "it", "iu", "iw", "iai", "ian", "iap", "iar", "iba", "ibb", "ibd", "ibe", "ibg", "ibh", "ibi", "ibl", "ibm", "ibn", "ibr", "ibu", "iby", "ica", "ich", "icl", "icr", "ida", "idb", "idc", "idd", "ide", "idi", "idr", "ids", "idt", "idu", "ifa", "ifb", "ife", "iff", "ifk", "ifm", "ifu", "ify", "igb", "ige", "igg", "igl", "igm", "ign", "igo", "igs", "igw", "ihb", "ihi", "ihp", "ihw", "iin", "iir", "ijc", "ije", "ijj", "ijn", "ijo", "ijs", "ike", "iki", "ikk", "ikl", "iko", "ikp", "ikr", "iks", "ikt", "ikv", "ikw", "ikx", "ikz", "ila", "ilb", "ilg", "ili", "ilk", "ill", "ilm", "ilo", "ilp", "ils", "ilu", "ilv", "ilw", "ima", "ime", "imi", "iml", "imn", "imo", "imr", "ims", "imy", "inb", "inc", "ine", "ing", "inh", "inj", "inl", "inm", "inn", "ino", "inp", "ins", "int", "inz", "ior", "iou", "iow", "ipi", "ipo", "iqu", "iqw", "ira", "ire", "irh", "iri", "irk", "irn", "iro", "irr", "iru", "irx", "iry", "isa", "isc", "isd", "ise", "isg", "ish", "isi", "isk", "ism", "isn", "iso", "isr", "ist", "isu", "itb", "itc", "itd", "ite", "iti", "itk", "itl", "itm", "ito", "itr", "its", "itt", "itv", "itw", "itx", "ity", "itz", "ium", "ivb", "ivv", "iwk", "iwm", "iwo", "iws", "ixc", "ixl", "iya", "iyo", "iyx", "izh", "izi", "izr", "izz"],
    ["ja", "ji", "jv", "jw", "jaa", "jab", "jac", "jad", "jae", "jaf", "jah", "jaj", "jak", "jal", "jam", "jan", "jao", "jaq", "jar", "jas", "jat", "jau", "jax", "jay", "jaz", "jbe", "jbi", "jbj", "jbk", "jbm", "jbn", "jbo", "jbr", "jbt", "jbu", "jbw", "jcs", "jct", "jda", "jdg", "jdt", "jeb", "jee", "jeg", "jeh", "jei", "jek", "jel", "jen", "jer", "jet", "jeu", "jgb", "jge", "jgk", "jgo", "jhi", "jhs", "jia", "jib", "jic", "jid", "jie", "jig", "jih", "jii", "jil", "jim", "jio", "jiq", "jit", "jiu", "jiv", "jiy", "jje", "jjr", "jka", "jkm", "jko", "jkp", "jkr", "jks", "jku", "jle", "jls", "jma", "jmb", "jmc", "jmd", "jmi", "jml", "jmn", "jmr", "jms", "jmw", "jmx", "jna", "jnd", "jng", "jni", "jnj", "jnl", "jns", "job", "jod", "jog", "jor", "jos", "jow", "jpa", "jpr", "jpx", "jqr", "jra", "jrb", "jrr", "jrt", "jru", "jsl", "jua", "jub", "juc", "jud", "juh", "jui", "juk", "jul", "jum", "jun", "juo", "jup", "jur", "jus", "jut", "juu", "juw", "juy", "jvd", "jvn", "jwi", "jya", "jye", "jyy"],
    ["ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "kaa", "kab", "kac", "kad", "kae", "kaf", "kag", "kah", "kai", "kaj", "kak", "kam", "kao", "kap", "kaq", "kar", "kav", "kaw", "kax", "kay", "kba", "kbb", "kbc", "kbd", "kbe", "kbf", "kbg", "kbh", "kbi", "kbj", "kbk", "kbl", "kbm", "kbn", "kbo", "kbp", "kbq", "kbr", "kbs", "kbt", "kbu", "kbv", "kbw", "kbx", "kby", "kbz", "kca", "kcb", "kcc", "kcd", "kce", "kcf", "kcg", "kch", "kci", "kcj", "kck", "kcl", "kcm", "kcn", "kco", "kcp", "kcq", "kcr", "kcs", "kct", "kcu", "kcv", "kcw", "kcx", "kcy", "kcz", "kda", "kdc", "kdd", "kde", "kdf", "kdg", "kdh", "kdi", "kdj", "kdk", "kdl", "kdm", "kdn", "kdo", "kdp", "kdq", "kdr", "kdt", "kdu", "kdv", "kdw", "kdx", "kdy", "kdz", "kea", "keb", "kec", "ked", "kee", "kef", "keg", "keh", "kei", "kej", "kek", "kel", "kem", "ken", "keo", "kep", "keq", "ker", "kes", "ket", "keu", "kev", "kew", "kex", "key", "kez", "kfa", "kfb", "kfc", "kfd", "kfe", "kff", "kfg", "kfh", "kfi", "kfj", "kfk", "kfl", "kfm", "kfn", "kfo", "kfp", "kfq", "kfr", "kfs", "kft", "kfu", "kfv", "kfw", "kfx", "kfy", "kfz", "kga", "kgb", "kgc", "kgd", "kge", "kgf", "kgg", "kgh", "kgi", "kgj", "kgk", "kgl", "kgm", "kgn", "kgo", "kgp", "kgq", "kgr", "kgs", "kgt", "kgu", "kgv", "kgw", "kgx", "kgy", "kha", "lyg", "khb", "khc", "khd", "khe", "khf", "khg", "khh", "khi", "khj", "khk", "khl", "khn", "kho", "khp", "khq", "khr", "khs", "kht", "khu", "khv", "khw", "khx", "khy", "khz", "kia", "kib", "kic", "kid", "kie", "kif", "kig", "kih", "kii", "kij", "kil", "kim", "kio", "kip", "kiq", "kis", "kit", "kiu", "kiv", "kiw", "kix", "kiy", "kiz", "kja", "kjb", "kjc", "kjd", "kje", "kjf", "kjg", "kjh", "kji", "kjj", "kjk", "kjl", "kjm", "kjn", "kjo", "kjp", "kjq", "kjr", "kjs", "kjt", "kju", "kjv", "kjx", "kjy", "kjz", "kka", "kkb", "kkc", "kkd", "kke", "kkf", "kkg", "kkh", "kki", "kkj", "kkk", "kkl", "kkm", "kkn", "kko", "kkp", "kkq", "kkr", "kks", "kkt", "kku", "kkv", "kkw", "kkx", "kky", "kkz", "kla", "klb", "klc", "kld", "kle", "klf", "klg", "klh", "kli", "klj", "klk", "kll", "klm", "kln", "klo", "klp", "klq", "klr", "kls", "klt", "klu", "klv", "klw", "klx", "kly", "klz", "kma", "kmb", "kmc", "kmd", "kme", "kmf", "kmg", "kmh", "kmi", "kmj", "kmk", "kml", "kmm", "kmn", "kmo", "kmp", "kmq", "kmr", "kms", "kmt", "kmu", "kmv", "kmw", "kmx", "kmy", "kmz", "kna", "knb", "knc", "knd", "kne", "knf", "kng", "kni", "knj", "knk", "knl", "knm", "knn", "kno", "knp", "knq", "knr", "kns", "knt", "knu", "knv", "knw", "knx", "kny", "knz", "koa", "koc", "kod", "koe", "kof", "kog", "koh", "koi", "koj", "kok", "kol", "koo", "kop", "koq", "kos", "kot", "kou", "kov", "kow", "kox", "koy", "koz", "kpa", "kpb", "kpc", "kpd", "kpe", "kpf", "kpg", "kph", "kpi", "kpj", "kpk", "kpl", "kpm", "kpn", "kpo", "kpp", "kpq", "kpr", "kps", "kpt", "kpu", "kpv", "kpw", "kpx", "kpy", "kpz", "kqa", "kqb", "kqc", "kqd", "kqe", "kqf", "kqg", "kqh", "kqi", "kqj", "kqk", "kql", "kqm", "kqn", "kqo", "kqp", "kqq", "kqr", "kqs", "kqt", "kqu", "kqv", "kqw", "kqx", "kqy", "kqz", "kra", "krb", "krc", "krd", "kre", "krf", "krh", "kri", "krj", "krk", "krl", "krm", "krn", "kro", "krp", "krr", "krs", "krt", "kru", "krv", "krw", "krx", "kry", "krz", "ksa", "ksb", "ksc", "ksd", "kse", "ksf", "ksg", "ksh", "ksi", "ksj", "ksk", "ksl", "ksm", "ksn", "kso", "ksp", "ksq", "ksr", "kss", "kst", "ksu", "ksv", "ksw", "ksx", "ksy", "ksz", "kta", "ktb", "ktc", "ktd", "kte", "ktf", "ktg", "kth", "kti", "ktj", "ktk", "ktl", "ktm", "ktn", "kto", "ktp", "ktq", "ktr", "kts", "ktt", "ktu", "ktv", "ktw", "ktx", "kty", "ktz", "kub", "kuc", "kud", "kue", "kuf", "kug", "kuh", "kui", "kuj", "kuk", "kul", "kum", "kun", "kuo", "kup", "kuq", "kus", "kut", "kuu", "kuv", "kuw", "kux", "kuy", "kuz", "kva", "kvb", "kvc", "kvd", "kve", "kvf", "kvg", "kvh", "kvi", "kvj", "kvk", "kvl", "kvm", "kvn", "kvo", "kvp", "kvq", "kvr", "kvs", "kvt", "kvu", "kvv", "kvw", "kvx", "kvy", "kvz", "kwa", "kwb", "kwc", "kwd", "kwe", "kwf", "kwg", "kwh", "kwi", "kwj", "kwk", "kwl", "kwm", "kwn", "kwo", "kwp", "kwq", "kwr", "kws", "kwt", "kwu", "kwv", "kww", "kwx", "kwy", "kwz", "kxa", "kxb", "kxc", "kxd", "kxe", "kxf", "kxh", "kxi", "kxj", "kxk", "kxl", "kxm", "kxn", "kxo", "kxp", "kxq", "kxr", "kxs", "kxt", "kxu", "kxv", "kxw", "kxx", "kxy", "kxz", "kya", "kyb", "kyc", "kyd", "kye", "kyf", "kyg", "kyh", "kyi", "kyj", "kyk", "kyl", "kym", "kyn", "kyo", "kyp", "kyq", "kyr", "kys", "kyt", "kyu", "kyv", "kyw", "kyx", "kyy", "kyz", "kza", "kzb", "kzc", "kzd", "kze", "kzf", "kzg", "kzh", "kzi", "kzj", "kzk", "kzl", "kzm", "kzn", "kzo", "kzp", "kzq", "kzr", "kzs", "kzt", "kzu", "kzv", "kzw", "kzx", "kzy", "kzz"],
    ["la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "laa", "lab", "lac", "lad", "lae", "laf", "lag", "lah", "lai", "laj", "lak", "lal", "lam", "lan", "lap", "laq", "lar", "las", "lau", "law", "lax", "lay", "laz", "lba", "lbb", "lbc", "lbe", "lbf", "lbg", "lbi", "lbj", "lbk", "lbl", "lbm", "lbn", "lbo", "lbq", "lbr", "lbs", "lbt", "lbu", "lbv", "lbw", "lbx", "lby", "lbz", "lcc", "lcd", "lce", "lcf", "lch", "lcl", "lcm", "lcp", "lcq", "lcs", "lda", "ldb", "ldd", "ldg", "ldh", "ldi", "ldj", "ldk", "ldl", "ldm", "ldn", "ldo", "ldp", "ldq", "lea", "leb", "lec", "led", "lee", "lef", "leg", "leh", "lei", "lej", "lek", "lel", "lem", "len", "leo", "lep", "leq", "ler", "les", "let", "leu", "lev", "lew", "lex", "ley", "lez", "lfa", "lfn", "lga", "lgb", "lgg", "lgh", "lgi", "lgk", "lgl", "lgm", "lgn", "lgq", "lgr", "lgt", "lgu", "lgz", "lha", "lhh", "lhi", "lhl", "lhm", "lhn", "lhp", "lhs", "lht", "lhu", "lia", "lib", "lic", "lid", "lie", "lif", "lig", "lih", "lii", "lij", "lik", "lil", "lio", "lip", "liq", "lir", "lis", "liu", "liv", "liw", "lix", "liy", "liz", "lja", "lje", "lji", "ljl", "ljp", "ljw", "ljx", "lka", "lkb", "lkc", "lkd", "lke", "lkh", "lki", "lkj", "lkl", "lkm", "lkn", "lko", "lkr", "lks", "lkt", "lku", "lky", "lla", "llb", "llc", "lld", "lle", "llf", "llg", "llh", "lli", "llj", "llk", "lll", "llm", "lln", "llo", "llp", "llq", "lls", "llu", "llx", "lma", "lmb", "lmc", "lmd", "lme", "lmf", "lmg", "lmh", "lmi", "lmj", "lmk", "lml", "lmm", "lmn", "lmo", "lmp", "lmq", "lmr", "lmu", "lmv", "lmw", "lmx", "lmy", "lmz", "lna", "lnb", "lnd", "lng", "lnh", "lni", "lnj", "lnl", "lnm", "lnn", "lno", "lns", "lnu", "lnw", "lnz", "loa", "lob", "loc", "loe", "lof", "log", "loh", "loi", "loj", "lok", "lol", "lom", "lon", "loo", "lop", "loq", "lor", "los", "lot", "lou", "lov", "low", "lox", "loy", "loz", "lpa", "lpe", "lpn", "lpo", "lpx", "lra", "lrc", "lre", "lrg", "lri", "lrk", "lrl", "lrm", "lrn", "lro", "lrr", "lrt", "lrv", "lrz", "lsa", "lsb", "lsd", "lse", "lsg", "lsh", "lsi", "lsl", "lsm", "lsn", "lso", "lsp", "lsr", "lss", "lst", "lsv", "lsy", "ltc", "ltg", "lth", "lti", "ltn", "lto", "lts", "ltu", "lua", "luc", "lud", "lue", "luf", "lui", "luj", "luk", "lul", "lum", "lun", "luo", "lup", "luq", "lur", "lus", "lut", "luu", "luv", "luw", "luy", "luz", "lva", "lvi", "lvk", "lvs", "lvu", "lwa", "lwe", "lwg", "lwh", "lwl", "lwm", "lwo", "lws", "lwt", "lwu", "lww", "lxm", "lya", "lyg", "lyn", "lzh", "lzl", "lzn", "lzz"],
    ["mg", "mh", "mi", "mk", "ml", "mn", "mo", "mr", "ms", "mt", "my", "maa", "mab", "mad", "mae", "maf", "mag", "mai", "maj", "mak", "mam", "man", "map", "maq", "mas", "mat", "mau", "mav", "maw", "max", "maz", "mba", "mbb", "mbc", "mbd", "mbe", "mbf", "mbh", "mbi", "mbj", "mbk", "mbl", "mbm", "mbn", "mbo", "mbp", "mbq", "mbr", "mbs", "mbt", "mbu", "mbv", "mbw", "mbx", "mby", "mbz", "mca", "mcb", "mcc", "mcd", "mce", "mcf", "mcg", "mch", "mci", "mcj", "mck", "mcl", "mcm", "mcn", "mco", "mcp", "mcq", "mcr", "mcs", "mct", "mcu", "mcv", "mcw", "mcx", "mcy", "mcz", "mda", "mdb", "mdc", "mdd", "mde", "mdf", "mdg", "mdh", "mdi", "mdj", "mdk", "mdl", "mdm", "mdn", "mdp", "mdq", "mdr", "mds", "mdt", "mdu", "mdv", "mdw", "mdx", "mdy", "mdz", "mea", "meb", "mec", "med", "mee", "mef", "meg", "meh", "mei", "mej", "mek", "mel", "mem", "men", "meo", "mep", "meq", "mer", "mes", "met", "meu", "mev", "mew", "mey", "mez", "mfa", "mfb", "mfc", "mfd", "mfe", "mff", "mfg", "mfh", "mfi", "mfj", "mfk", "mfl", "mfm", "mfn", "mfo", "mfp", "mfq", "mfr", "mfs", "mft", "mfu", "mfv", "mfw", "mfx", "mfy", "mfz", "mga", "mgb", "mgc", "mgd", "mge", "mgf", "mgg", "mgh", "mgi", "mgj", "mgk", "mgl", "mgm", "mgn", "mgo", "mgp", "mgq", "mgr", "mgs", "mgt", "mgu", "mgv", "mgw", "mgx", "mgy", "mgz", "mha", "mhb", "mhc", "mhd", "mhe", "mhf", "mhg", "mhh", "mhi", "mhj", "mhk", "mhl", "mhm", "mhn", "mho", "mhp", "mhq", "mhr", "mhs", "mht", "mhu", "mhw", "mhx", "mhy", "mhz", "mia", "mib", "mic", "mid", "mie", "mif", "mig", "mih", "mii", "mij", "mik", "mil", "mim", "min", "mio", "mip", "miq", "mir", "mis", "mit", "miu", "miw", "mix", "miy", "miz", "mja", "mjb", "mjc", "mjd", "mje", "mjg", "mjh", "mji", "mjj", "mjk", "mjl", "mjm", "mjn", "mjo", "mjp", "mjq", "mjr", "mjs", "mjt", "mju", "mjv", "mjw", "mjx", "mjy", "mjz", "mka", "mkb", "mkc", "mke", "mkf", "mkg", "mkh", "mki", "mkj", "mkk", "mkl", "mkm", "mkn", "mko", "mkp", "mkq", "mkr", "mks", "mkt", "mku", "mkv", "mkw", "mkx", "mky", "mkz", "mla", "mlb", "mlc", "mld", "mle", "mlf", "mlh", "mli", "mlj", "mlk", "mll", "mlm", "mln", "mlo", "mlp", "mlq", "mlr", "mls", "mlu", "mlv", "mlw", "mlx", "mlz", "mma", "mmb", "mmc", "mmd", "mme", "mmf", "mmg", "mmh", "mmi", "mmj", "mmk", "mml", "mmm", "mmn", "mmo", "mmp", "mmq", "mmr", "mmt", "mmu", "mmv", "mmw", "mmx", "mmy", "mmz", "mna", "mnb", "mnc", "mnd", "mne", "mnf", "mng", "mnh", "mni", "mnj", "mnk", "mnl", "mnm", "mnn", "mno", "mnp", "mnq", "mnr", "mns", "mnt", "mnu", "mnv", "mnw", "mnx", "mny", "mnz", "moa", "moc", "mod", "moe", "mof", "mog", "moh", "moi", "moj", "mok", "mom", "moo", "mop", "moq", "mor", "mos", "mot", "mou", "mov", "mow", "mox", "moy", "moz", "mpa", "mpb", "mpc", "mpd", "mpe", "mpg", "mph", "mpi", "mpj", "mpk", "mpl", "mpm", "mpn", "mpo", "mpp", "mpq", "mpr", "mps", "mpt", "mpu", "mpv", "mpw", "mpx", "mpy", "mpz", "mqa", "mqb", "mqc", "mqe", "mqf", "mqg", "mqh", "mqi", "mqj", "mqk", "mql", "mqm", "mqn", "mqo", "mqp", "mqq", "mqr", "mqs", "mqt", "mqu", "mqv", "mqw", "mqx", "mqy", "mqz", "mra", "mrb", "mrc", "mrd", "mre", "mrf", "mrg", "mrh", "mrj", "mrk", "mrl", "mrm", "mrn", "mro", "mrp", "mrq", "mrr", "mrs", "mrt", "mru", "mrv", "mrw", "mrx", "mry", "mrz", "msb", "msc", "msd", "mse", "msf", "msg", "msh", "msi", "msj", "msk", "msl", "msm", "msn", "mso", "msp", "msq", "msr", "mss", "mst", "msu", "msv", "msw", "msx", "msy", "msz", "mta", "mtb", "mtc", "mtd", "mte", "mtf", "mtg", "mth", "mti", "mtj", "mtk", "mtl", "mtm", "mtn", "mto", "mtp", "mtq", "mtr", "mts", "mtt", "mtu", "mtv", "mtw", "mtx", "mty", "mua", "mub", "muc", "mud", "mue", "mug", "muh", "mui", "muj", "muk", "mul", "mum", "mun", "muo", "mup", "muq", "mur", "mus", "mut", "muu", "muv", "mux", "muy", "muz", "mva", "mvb", "mvd", "mve", "mvf", "mvg", "mvh", "mvi", "mvk", "mvl", "mvm", "mvn", "mvo", "mvp", "mvq", "mvr", "mvs", "mvt", "mvu", "mvv", "mvw", "mvx", "mvy", "mvz", "mwa", "mwb", "mwc", "mwd", "mwe", "mwf", "mwg", "mwh", "mwi", "mwj", "mwk", "mwl", "mwm", "mwn", "mwo", "mwp", "mwq", "mwr", "mws", "mwt", "mwu", "mwv", "mww", "mwx", "mwy", "mwz", "mxa", "mxb", "mxc", "mxd", "mxe", "mxf", "mxg", "mxh", "mxi", "mxj", "mxk", "mxl", "mxm", "mxn", "mxo", "mxp", "mxq", "mxr", "mxs", "mxt", "mxu", "mxv", "mxw", "mxx", "mxy", "mxz", "myb", "myc", "myd", "mye", "myf", "myg", "myh", "myi", "myj", "myk", "myl", "mym", "myn", "myo", "myp", "myq", "myr", "mys", "myt", "myu", "myv", "myw", "myx", "myy", "myz", "mza", "mzb", "mzc", "mzd", "mze", "mzg", "mzh", "mzi", "mzj", "mzk", "mzl", "mzm", "mzn", "mzo", "mzp", "mzq", "mzr", "mzs", "mzt", "mzu", "mzv", "mzw", "mzx", "mzy", "mzz"],
    ["na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "naa", "nab", "nac", "nad", "nae", "naf", "nag", "nah", "nai", "naj", "nak", "nal", "nam", "nan", "nao", "nap", "naq", "nar", "nas", "nat", "naw", "nax", "nay", "naz", "nba", "nbb", "nbc", "nbd", "nbe", "nbf", "nbg", "nbh", "nbi", "nbj", "nbk", "nbm", "nbn", "nbo", "nbp", "nbq", "nbr", "nbs", "nbt", "nbu", "nbv", "nbw", "nbx", "nby", "nca", "ncb", "ncc", "ncd", "nce", "ncf", "ncg", "nch", "nci", "ncj", "nck", "ncl", "ncm", "ncn", "nco", "ncp", "ncq", "ncr", "ncs", "nct", "ncu", "ncx", "ncz", "nda", "ndb", "ndc", "ndd", "ndf", "ndg", "ndh", "ndi", "ndj", "ndk", "ndl", "ndm", "ndn", "ndp", "ndq", "ndr", "nds", "ndt", "ndu", "ndv", "ndw", "ndx", "ndy", "ndz", "nea", "neb", "nec", "ned", "nee", "nef", "neg", "neh", "nei", "nej", "nek", "nem", "nen", "neo", "neq", "ner", "nes", "net", "neu", "nev", "new", "nex", "ney", "nez", "nfa", "nfd", "nfl", "nfr", "nfu", "nga", "ngb", "ngc", "ngd", "nge", "ngf", "ngg", "ngh", "ngi", "ngj", "ngk", "ngl", "ngm", "ngn", "ngo", "ngp", "ngq", "ngr", "ngs", "ngt", "ngu", "ngv", "ngw", "ngx", "ngy", "ngz", "nha", "nhb", "nhc", "nhd", "nhe", "nhf", "nhg", "nhh", "nhi", "nhk", "nhm", "nhn", "nho", "nhp", "nhq", "nhr", "nht", "nhu", "nhv", "nhw", "nhx", "nhy", "nhz", "nia", "nib", "nic", "nid", "nie", "nif", "nig", "nih", "nii", "nij", "nik", "nil", "nim", "nin", "nio", "niq", "nir", "nis", "nit", "niu", "niv", "niw", "nix", "niy", "niz", "nja", "njb", "njd", "njh", "nji", "njj", "njl", "njm", "njn", "njo", "njr", "njs", "njt", "nju", "njx", "njy", "njz", "nka", "nkb", "nkc", "nkd", "nke", "nkf", "nkg", "nkh", "nki", "nkj", "nkk", "nkm", "nkn", "nko", "nkp", "nkq", "nkr", "nks", "nkt", "nku", "nkv", "nkw", "nkx", "nkz", "nla", "nlc", "nle", "nlg", "nli", "nlj", "nlk", "nll", "nlm", "nln", "nlo", "nlq", "nlr", "nlu", "nlv", "nlw", "nlx", "nly", "nlz", "nma", "nmb", "nmc", "nmd", "nme", "nmf", "nmg", "nmh", "nmi", "nmj", "nmk", "nml", "nmm", "nmn", "nmo", "nmp", "nmq", "nmr", "nms", "nmt", "nmu", "nmv", "nmw", "nmx", "nmy", "nmz", "nna", "nnb", "nnc", "nnd", "nne", "nnf", "nng", "nnh", "nni", "nnj", "nnk", "nnl", "nnm", "nnn", "nnp", "nnq", "nnr", "nns", "nnt", "nnu", "nnv", "nnw", "nnx", "nny", "nnz", "noa", "noc", "nod", "noe", "nof", "nog", "noh", "noi", "noj", "nok", "nol", "nom", "non", "noo", "nop", "noq", "nos", "not", "nou", "nov", "now", "noy", "noz", "npa", "npb", "npg", "nph", "npi", "npl", "npn", "npo", "nps", "npu", "npx", "npy", "nqg", "nqk", "nql", "nqm", "nqn", "nqo", "nqq", "nqt", "nqy", "nra", "nrb", "nrc", "nre", "nrf", "nrg", "nri", "nrk", "nrl", "nrm", "nrn", "nrp", "nrr", "nrt", "nru", "nrx", "nrz", "nsa", "nsb", "nsc", "nsd", "nse", "nsf", "nsg", "nsh", "nsi", "nsk", "nsl", "nsm", "nsn", "nso", "nsp", "nsq", "nsr", "nss", "nst", "nsu", "nsv", "nsw", "nsx", "nsy", "nsz", "ntd", "nte", "ntg", "nti", "ntj", "ntk", "ntm", "nto", "ntp", "ntr", "nts", "ntu", "ntw", "ntx", "nty", "ntz", "nua", "nub", "nuc", "nud", "nue", "nuf", "nug", "nuh", "nui", "nuj", "nuk", "nul", "num", "nun", "nuo", "nup", "nuq", "nur", "nus", "nut", "nuu", "nuv", "nuw", "nux", "nuy", "nuz", "nvh", "nvm", "nvo", "nwa", "nwb", "nwc", "nwe", "nwg", "nwi", "nwm", "nwo", "nwr", "nwx", "nwy", "nxa", "nxd", "nxe", "nxg", "nxi", "nxk", "nxl", "nxm", "nxn", "nxo", "nxq", "nxr", "nxu", "nxx", "nyb", "nyc", "nyd", "nye", "nyf", "nyg", "nyh", "nyi", "nyj", "nyk", "nyl", "nym", "nyn", "nyo", "nyp", "nyq", "nyr", "nys", "nyt", "nyu", "nyv", "nyw", "nyx", "nyy", "nza", "nzb", "nzd", "nzi", "nzk", "nzm", "nzs", "nzu", "nzy", "nzz"],
    ["oc", "oj", "om", "or", "os", "oaa", "oac", "oar", "oav", "obi", "obk", "obl", "obm", "obo", "obr", "obt", "obu", "oca", "och", "ocm", "oco", "ocu", "oda", "odk", "odt", "odu", "ofo", "ofs", "ofu", "ogb", "ogc", "oge", "ogg", "ogo", "ogu", "oht", "ohu", "oia", "oin", "ojb", "ojc", "ojg", "ojp", "ojs", "ojv", "ojw", "oka", "okb", "okc", "okd", "oke", "okg", "okh", "oki", "okj", "okk", "okl", "okm", "okn", "oko", "okr", "oks", "oku", "okv", "okx", "okz", "ola", "old", "ole", "olk", "olm", "olo", "olr", "olt", "olu", "oma", "omb", "omc", "ome", "omg", "omi", "omk", "oml", "omn", "omo", "omp", "omq", "omr", "omt", "omu", "omv", "omw", "omx", "omy", "ona", "onb", "one", "ong", "oni", "onj", "onk", "onn", "ono", "onp", "onr", "ons", "ont", "onu", "onw", "onx", "ood", "oog", "oon", "oor", "oos", "opa", "opk", "opm", "opo", "opt", "opy", "ora", "orc", "ore", "org", "orh", "orn", "oro", "orr", "ors", "ort", "oru", "orv", "orw", "orx", "ory", "orz", "osa", "osc", "osi", "osn", "oso", "osp", "ost", "osu", "osx", "ota", "otb", "otd", "ote", "oti", "otk", "otl", "otm", "otn", "oto", "otq", "otr", "ots", "ott", "otu", "otw", "otx", "oty", "otz", "oua", "oub", "oue", "oui", "oum", "oun", "ovd", "owi", "owl", "oyb", "oyd", "oym", "oyy", "ozm"],
    ["pa", "pi", "pl", "ps", "pt", "paa", "pab", "pac", "pad", "pae", "paf", "pag", "pah", "pai", "pak", "pal", "pam", "pao", "pap", "paq", "par", "pas", "pat", "pau", "pav", "paw", "pax", "pay", "paz", "pbb", "pbc", "pbe", "pbf", "pbg", "pbh", "pbi", "pbl", "pbm", "pbn", "pbo", "pbp", "pbr", "pbs", "pbt", "pbu", "pbv", "pby", "pbz", "pca", "pcb", "pcc", "pcd", "pce", "pcf", "pcg", "pch", "pci", "pcj", "pck", "pcl", "pcm", "pcn", "pcp", "pcr", "pcw", "pda", "pdc", "pdi", "pdn", "pdo", "pdt", "pdu", "pea", "peb", "ped", "pee", "pef", "peg", "peh", "pei", "pej", "pek", "pel", "pem", "peo", "pep", "peq", "pes", "pev", "pex", "pey", "pez", "pfa", "pfe", "pfl", "pga", "pgd", "pgg", "pgi", "pgk", "pgl", "pgn", "pgs", "pgu", "pgy", "pgz", "pha", "phd", "phg", "phh", "phi", "phk", "phl", "phm", "phn", "pho", "phq", "phr", "pht", "phu", "phv", "phw", "pia", "pib", "pic", "pid", "pie", "pif", "pig", "pih", "pii", "pij", "pil", "pim", "pin", "pio", "pip", "pir", "pis", "pit", "piu", "piv", "piw", "pix", "piy", "piz", "pjt", "pka", "pkb", "pkc", "pkg", "pkh", "pkn", "pko", "pkp", "pkr", "pks", "pkt", "pku", "pla", "plb", "plc", "pld", "ple", "plf", "plg", "plh", "plj", "plk", "pll", "pln", "plo", "plp", "plq", "plr", "pls", "plt", "plu", "plv", "plw", "ply", "plz", "pma", "pmb", "pmc", "pmd", "pme", "pmf", "pmh", "pmi", "pmj", "pmk", "pml", "pmm", "pmn", "pmo", "pmq", "pmr", "pms", "pmt", "pmu", "pmw", "pmx", "pmy", "pmz", "pna", "pnb", "pnc", "pnd", "pne", "png", "pnh", "pni", "pnj", "pnk", "pnl", "pnm", "pnn", "pno", "pnp", "pnq", "pnr", "pns", "pnt", "pnu", "pnv", "pnw", "pnx", "pny", "pnz", "poc", "pod", "poe", "pof", "pog", "poh", "poi", "pok", "pom", "pon", "poo", "pop", "poq", "pos", "pot", "pov", "pow", "pox", "poy", "poz", "ppa", "ppe", "ppi", "ppk", "ppl", "ppm", "ppn", "ppo", "ppp", "ppq", "ppr", "pps", "ppt", "ppu", "pqa", "pqe", "pqm", "pqw", "pra", "prb", "prc", "prd", "pre", "prf", "prg", "prh", "pri", "prk", "prl", "prm", "prn", "pro", "prp", "prq", "prr", "prs", "prt", "pru", "prw", "prx", "pry", "prz", "psa", "psc", "psd", "pse", "psg", "psh", "psi", "psl", "psm", "psn", "pso", "psp", "psq", "psr", "pss", "pst", "psu", "psw", "psy", "pta", "pth", "pti", "ptn", "pto", "ptp", "ptq", "ptr", "ptt", "ptu", "ptv", "ptw", "pty", "pua", "pub", "puc", "pud", "pue", "puf", "pug", "pui", "puj", "puk", "pum", "puo", "pup", "puq", "pur", "put", "puu", "puw", "pux", "puy", "puz", "pwa", "pwb", "pwg", "pwi", "pwm", "pwn", "pwo", "pwr", "pww", "pxm", "pye", "pym", "pyn", "pys", "pyu", "pyx", "pyy", "pzn"],
    ["qu", "qua", "qub", "quc", "qud", "quf", "qug", "quh", "qui", "quk", "qul", "qum", "qun", "qup", "quq", "qur", "qus", "quv", "quw", "qux", "quy", "quz", "qva", "qvc", "qve", "qvh", "qvi", "qvj", "qvl", "qvm", "qvn", "qvo", "qvp", "qvs", "qvw", "qvy", "qvz", "qwa", "qwc", "qwe", "qwh", "qwm", "qws", "qwt", "qxa", "qxc", "qxh", "qxl", "qxn", "qxo", "qxp", "qxq", "qxr", "qxs", "qxt", "qxu", "qxw", "qya", "qyp"],
    ["rm", "rn", "ro", "ru", "rw", "raa", "rab", "rac", "rad", "raf", "rag", "rah", "rai", "raj", "rak", "ral", "ram", "ran", "rao", "rap", "raq", "rar", "ras", "rat", "rau", "rav", "raw", "rax", "ray", "raz", "rbb", "rbk", "rbl", "rbp", "rcf", "rdb", "rea", "reb", "ree", "reg", "rei", "rej", "rel", "rem", "ren", "rer", "res", "ret", "rey", "rga", "rge", "rgk", "rgn", "rgr", "rgs", "rgu", "rhg", "rhp", "ria", "rie", "rif", "ril", "rim", "rin", "rir", "rit", "riu", "rjg", "rji", "rjs", "rka", "rkb", "rkh", "rki", "rkm", "rkt", "rkw", "rma", "rmb", "rmc", "rmd", "rme", "rmf", "rmg", "rmh", "rmi", "rmk", "rml", "rmm", "rmn", "rmo", "rmp", "rmq", "rmr", "rms", "rmt", "rmu", "rmv", "rmw", "rmx", "rmy", "rmz", "rna", "rnd", "rng", "rnl", "rnn", "rnp", "rnr", "rnw", "roa", "rob", "roc", "rod", "roe", "rof", "rog", "rol", "rom", "roo", "rop", "ror", "rou", "row", "rpn", "rpt", "rri", "rro", "rrt", "rsb", "rsi", "rsl", "rsm", "rtc", "rth", "rtm", "rts", "rtw", "rub", "ruc", "rue", "ruf", "rug", "ruh", "rui", "ruk", "ruo", "rup", "ruq", "rut", "ruu", "ruy", "ruz", "rwa", "rwk", "rwl", "rwm", "rwo", "rwr", "rxd", "rxw", "ryn", "rys", "ryu", "rzh"],
    ["sa", "sc", "sd", "se", "sg", "sh", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "saa", "sab", "sac", "sad", "sae", "saf", "sah", "sai", "saj", "sak", "sal", "sam", "sao", "sap", "saq", "sar", "sas", "sat", "sau", "sav", "saw", "sax", "say", "saz", "sba", "sbb", "sbc", "sbd", "sbe", "sbf", "sbg", "sbh", "sbi", "sbj", "sbk", "sbl", "sbm", "sbn", "sbo", "sbp", "sbq", "sbr", "sbs", "sbt", "sbu", "sbv", "sbw", "sbx", "sby", "sbz", "sca", "scb", "sce", "scf", "scg", "sch", "sci", "sck", "scl", "scn", "sco", "scp", "scq", "scs", "sct", "scu", "scv", "scw", "scx", "sda", "sdb", "sdc", "sde", "sdf", "sdg", "sdh", "sdj", "sdk", "sdl", "sdm", "sdn", "sdo", "sdp", "sdq", "sdr", "sds", "sdt", "sdu", "sdv", "sdx", "sdz", "sea", "seb", "sec", "sed", "see", "sef", "seg", "seh", "sei", "sej", "sek", "sel", "sem", "sen", "seo", "sep", "seq", "ser", "ses", "set", "seu", "sev", "sew", "sey", "sez", "sfb", "sfe", "sfm", "sfs", "sfw", "sga", "sgb", "sgc", "sgd", "sge", "sgg", "sgh", "sgi", "sgj", "sgk", "sgl", "sgm", "sgn", "sgo", "sgp", "sgr", "sgs", "sgt", "sgu", "sgw", "sgx", "sgy", "sgz", "sha", "shb", "shc", "shd", "she", "shg", "shh", "shi", "shj", "shk", "shl", "shm", "shn", "sho", "shp", "shq", "shr", "shs", "sht", "shu", "shv", "shw", "shx", "shy", "shz", "sia", "sib", "sid", "sie", "sif", "sig", "sih", "sii", "sij", "sik", "sil", "sim", "sio", "sip", "siq", "sir", "sis", "sit", "siu", "siv", "siw", "six", "siy", "siz", "sja", "sjb", "sjd", "sje", "sjg", "sjk", "sjl", "sjm", "sjn", "sjo", "sjp", "sjr", "sjs", "sjt", "sju", "sjw", "ska", "skb", "skc", "skd", "ske", "skf", "skg", "skh", "ski", "skj", "skk", "skm", "skn", "sko", "skp", "skq", "skr", "sks", "skt", "sku", "skv", "skw", "skx", "sky", "skz", "sla", "slc", "sld", "sle", "slf", "slg", "slh", "sli", "slj", "sll", "slm", "sln", "slp", "slq", "slr", "sls", "slt", "slu", "slw", "slx", "sly", "slz", "sma", "smb", "smc", "smd", "smf", "smg", "smh", "smi", "smj", "smk", "sml", "smm", "smn", "smp", "smq", "smr", "sms", "smt", "smu", "smv", "smw", "smx", "smy", "smz", "snb", "snc", "sne", "snf", "sng", "snh", "sni", "snj", "snk", "snl", "snm", "snn", "sno", "snp", "snq", "snr", "sns", "snu", "snv", "snw", "snx", "sny", "snz", "soa", "sob", "soc", "sod", "soe", "sog", "soh", "soi", "soj", "sok", "sol", "son", "soo", "sop", "soq", "sor", "sos", "sou", "sov", "sow", "sox", "soy", "soz", "spb", "spc", "spd", "spe", "spg", "spi", "spk", "spl", "spm", "spn", "spo", "spp", "spq", "spr", "sps", "spt", "spu", "spv", "spx", "spy", "sqa", "sqh", "sqj", "sqk", "sqm", "sqn", "sqo", "sqq", "sqr", "sqs", "sqt", "squ", "sqx", "sra", "srb", "src", "sre", "srf", "srg", "srh", "sri", "srk", "srl", "srm", "srn", "sro", "srq", "srr", "srs", "srt", "sru", "srv", "srw", "srx", "sry", "srz", "ssa", "ssb", "ssc", "ssd", "sse", "ssf", "ssg", "ssh", "ssi", "ssj", "ssk", "ssl", "ssm", "ssn", "sso", "ssp", "ssq", "ssr", "sss", "sst", "ssu", "ssv", "ssx", "ssy", "ssz", "sta", "stb", "std", "ste", "stf", "stg", "sth", "sti", "stj", "stk", "stl", "stm", "stn", "sto", "stp", "stq", "str", "sts", "stt", "stu", "stv", "stw", "sty", "sua", "sub", "suc", "sue", "sug", "sui", "suj", "suk", "sul", "sum", "suo", "suq", "sur", "sus", "sut", "suv", "suw", "sux", "suy", "suz", "sva", "svb", "svc", "sve", "svk", "svm", "svr", "svs", "svx", "swb", "swc", "swf", "swg", "swh", "swi", "swj", "swk", "swl", "swm", "swn", "swo", "swp", "swq", "swr", "sws", "swt", "swu", "swv", "sww", "swx", "swy", "sxb", "sxc", "sxe", "sxg", "sxk", "sxl", "sxm", "sxn", "sxo", "sxr", "sxs", "sxu", "sxw", "sya", "syb", "syc", "syd", "syi", "syk", "syl", "sym", "syn", "syo", "syr", "sys", "syw", "syx", "syy", "sza", "szb", "szc", "szd", "sze", "szg", "szl", "szn", "szp", "szs", "szv", "szw", "szy"],
    ["ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "taa", "tab", "tac", "tad", "tae", "taf", "tag", "tai", "taj", "tak", "tal", "tan", "tao", "tap", "taq", "tar", "tas", "tau", "tav", "taw", "tax", "tay", "taz", "tba", "tbb", "tbc", "tbd", "tbe", "tbf", "tbg", "tbh", "tbi", "tbj", "tbk", "tbl", "tbm", "tbn", "tbo", "tbp", "tbq", "tbr", "tbs", "tbt", "tbu", "tbv", "tbw", "tbx", "tby", "tbz", "tca", "tcb", "tcc", "tcd", "tce", "tcf", "tcg", "tch", "tci", "tck", "tcl", "tcm", "tcn", "tco", "tcp", "tcq", "tcs", "tct", "tcu", "tcw", "tcx", "tcy", "tcz", "tda", "tdb", "tdc", "tdd", "tde", "tdf", "tdg", "tdh", "tdi", "tdj", "tdk", "tdl", "tdm", "tdn", "tdo", "tdq", "tdr", "tds", "tdt", "tdu", "tdv", "tdx", "tdy", "tea", "teb", "tec", "ted", "tee", "tef", "teg", "teh", "tei", "tek", "tem", "ten", "teo", "tep", "teq", "ter", "tes", "tet", "teu", "tev", "tew", "tex", "tey", "tez", "tfi", "tfn", "tfo", "tfr", "tft", "tga", "tgb", "tgc", "tgd", "tge", "tgf", "tgg", "tgh", "tgi", "tgj", "tgn", "tgo", "tgp", "tgq", "tgr", "tgs", "tgt", "tgu", "tgv", "tgw", "tgx", "tgy", "tgz", "thc", "thd", "the", "thf", "thh", "thi", "thk", "thl", "thm", "thn", "thp", "thq", "thr", "ths", "tht", "thu", "thv", "thw", "thx", "thy", "thz", "tia", "tic", "tid", "tie", "tif", "tig", "tih", "tii", "tij", "tik", "til", "tim", "tin", "tio", "tip", "tiq", "tis", "tit", "tiu", "tiv", "tiw", "tix", "tiy", "tiz", "tja", "tjg", "tji", "tjj", "tjl", "tjm", "tjn", "tjo", "tjp", "tjs", "tju", "tjw", "tka", "tkb", "tkd", "tke", "tkf", "tkg", "tkk", "tkl", "tkm", "tkn", "tkp", "tkq", "tkr", "tks", "tkt", "tku", "tkv", "tkw", "tkx", "tkz", "tla", "tlb", "tlc", "tld", "tlf", "tlg", "tlh", "tli", "tlj", "tlk", "tll", "tlm", "tln", "tlo", "tlp", "tlq", "tlr", "tls", "tlt", "tlu", "tlv", "tlw", "tlx", "tly", "tma", "tmb", "tmc", "tmd", "tme", "tmf", "tmg", "tmh", "tmi", "tmj", "tmk", "tml", "tmm", "tmn", "tmo", "tmp", "tmq", "tmr", "tms", "tmt", "tmu", "tmv", "tmw", "tmy", "tmz", "tna", "tnb", "tnc", "tnd", "tne", "tnf", "tng", "tnh", "tni", "tnk", "tnl", "tnm", "tnn", "tno", "tnp", "tnq", "tnr", "tns", "tnt", "tnu", "tnv", "tnw", "tnx", "tny", "tnz", "tob", "toc", "tod", "toe", "tof", "tog", "toh", "toi", "toj", "tol", "tom", "too", "top", "toq", "tor", "tos", "tou", "tov", "tow", "tox", "toy", "toz", "tpa", "tpc", "tpe", "tpf", "tpg", "tpi", "tpj", "tpk", "tpl", "tpm", "tpn", "tpo", "tpp", "tpq", "tpr", "tpt", "tpu", "tpv", "tpw", "tpx", "tpy", "tpz", "tqb", "tql", "tqm", "tqn", "tqo", "tqp", "tqq", "tqr", "tqt", "tqu", "tqw", "tra", "trb", "trc", "trd", "tre", "trf", "trg", "trh", "tri", "trj", "trk", "trl", "trm", "trn", "tro", "trp", "trq", "trr", "trs", "trt", "tru", "trv", "trw", "trx", "try", "trz", "tsa", "tsb", "tsc", "tsd", "tse", "tsf", "tsg", "tsh", "tsi", "tsj", "tsk", "tsl", "tsm", "tsp", "tsq", "tsr", "tss", "tst", "tsu", "tsv", "tsw", "tsx", "tsy", "tsz", "tta", "ttb", "ttc", "ttd", "tte", "ttf", "ttg", "tth", "tti", "ttj", "ttk", "ttl", "ttm", "ttn", "tto", "ttp", "ttq", "ttr", "tts", "ttt", "ttu", "ttv", "ttw", "tty", "ttz", "tua", "tub", "tuc", "tud", "tue", "tuf", "tug", "tuh", "tui", "tuj", "tul", "tum", "tun", "tuo", "tup", "tuq", "tus", "tut", "tuu", "tuv", "tuw", "tux", "tuy", "tuz", "tva", "tvd", "tve", "tvk", "tvl", "tvm", "tvn", "tvo", "tvs", "tvt", "tvu", "tvw", "tvx", "tvy", "twa", "twb", "twc", "twd", "twe", "twf", "twg", "twh", "twl", "twm", "twn", "two", "twp", "twq", "twr", "twt", "twu", "tww", "twx", "twy", "txa", "txb", "txc", "txe", "txg", "txh", "txi", "txj", "txm", "txn", "txo", "txq", "txr", "txs", "txt", "txu", "txx", "txy", "tya", "tye", "tyh", "tyi", "tyj", "tyl", "tyn", "typ", "tyr", "tys", "tyt", "tyu", "tyv", "tyx", "tyy", "tyz", "tza", "tzh", "tzj", "tzl", "tzm", "tzn", "tzo", "tzx"],
    ["ug", "uk", "ur", "uz", "uam", "uan", "uar", "uba", "ubi", "ubl", "ubr", "ubu", "uby", "uda", "ude", "udg", "udi", "udj", "udl", "udm", "udu", "ues", "ufi", "uga", "ugb", "uge", "ugn", "ugo", "ugy", "uha", "uhn", "uis", "uiv", "uji", "uka", "ukg", "ukh", "uki", "ukk", "ukl", "ukp", "ukq", "uks", "uku", "ukv", "ukw", "uky", "ula", "ulb", "ulc", "ule", "ulf", "uli", "ulk", "ull", "ulm", "uln", "ulu", "ulw", "uma", "umb", "umc", "umd", "umg", "umi", "umm", "umn", "umo", "ump", "umr", "ums", "umu", "una", "und", "une", "ung", "uni", "unk", "unm", "unn", "unp", "unr", "unu", "unx", "unz", "uok", "upi", "upv", "ura", "urb", "urc", "ure", "urf", "urg", "urh", "uri", "urj", "urk", "url", "urm", "urn", "uro", "urp", "urr", "urt", "uru", "urv", "urw", "urx", "ury", "urz", "usa", "ush", "usi", "usk", "usp", "uss", "usu", "uta", "ute", "uth", "utp", "utr", "utu", "uum", "uun", "uur", "uuu", "uve", "uvh", "uvl", "uwa", "uya", "uzn", "uzs"],
    ["ve", "vi", "vo", "vaa", "vae", "vaf", "vag", "vah", "vai", "vaj", "val", "vam", "van", "vao", "vap", "var", "vas", "vau", "vav", "vay", "vbb", "vbk", "vec", "ved", "vel", "vem", "veo", "vep", "ver", "vgr", "vgt", "vic", "vid", "vif", "vig", "vil", "vin", "vis", "vit", "viv", "vka", "vki", "vkj", "vkk", "vkl", "vkm", "vkn", "vko", "vkp", "vkt", "vku", "vkz", "vlp", "vls", "vma", "vmb", "vmc", "vmd", "vme", "vmf", "vmg", "vmh", "vmi", "vmj", "vmk", "vml", "vmm", "vmp", "vmq", "vmr", "vms", "vmu", "vmv", "vmw", "vmx", "vmy", "vmz", "vnk", "vnm", "vnp", "vor", "vot", "vra", "vro", "vrs", "vrt", "vsi", "vsl", "vsv", "vto", "vum", "vun", "vut", "vwa"],
    ["wa", "wo", "waa", "wab", "wac", "wad", "wae", "waf", "wag", "wah", "wai", "waj", "wak", "wal", "wam", "wan", "wao", "wap", "waq", "war", "was", "wat", "wau", "wav", "waw", "wax", "way", "waz", "wba", "wbb", "wbe", "wbf", "wbh", "wbi", "wbj", "wbk", "wbl", "wbm", "wbp", "wbq", "wbr", "wbs", "wbt", "wbv", "wbw", "wca", "wci", "wdd", "wdg", "wdj", "wdk", "wdu", "wdy", "wea", "wec", "wed", "weg", "weh", "wei", "wem", "wen", "weo", "wep", "wer", "wes", "wet", "weu", "wew", "wfg", "wga", "wgb", "wgg", "wgi", "wgo", "wgu", "wgw", "wgy", "wha", "whg", "whk", "whu", "wib", "wic", "wie", "wif", "wig", "wih", "wii", "wij", "wik", "wil", "wim", "win", "wir", "wit", "wiu", "wiv", "wiw", "wiy", "wja", "wji", "wka", "wkb", "wkd", "wkl", "wkr", "wku", "wkw", "wky", "wla", "wlc", "wle", "wlg", "wlh", "wli", "wlk", "wll", "wlm", "wlo", "wlr", "wls", "wlu", "wlv", "wlw", "wlx", "wly", "wma", "wmb", "wmc", "wmd", "wme", "wmg", "wmh", "wmi", "wmm", "wmn", "wmo", "wms", "wmt", "wmw", "wmx", "wnb", "wnc", "wnd", "wne", "wng", "wni", "wnk", "wnm", "wnn", "wno", "wnp", "wnu", "wnw", "wny", "woa", "wob", "woc", "wod", "woe", "wof", "wog", "woi", "wok", "wom", "won", "woo", "wor", "wos", "wow", "woy", "wpc", "wra", "wrb", "wrd", "wrg", "wrh", "wri", "wrk", "wrl", "wrm", "wrn", "wro", "wrp", "wrr", "wrs", "wru", "wrv", "wrw", "wrx", "wry", "wrz", "wsa", "wsg", "wsi", "wsk", "wsr", "wss", "wsu", "wsv", "wtf", "wth", "wti", "wtk", "wtm", "wtw", "wua", "wub", "wud", "wuh", "wul", "wum", "wun", "wur", "wut", "wuu", "wuv", "wux", "wuy", "wwa", "wwb", "wwo", "wwr", "www", "wxa", "wxw", "wya", "wyb", "wyi", "wym", "wyr", "wyy"],
    ["xh", "xaa", "xab", "xac", "xad", "xae", "xag", "xai", "xaj", "xak", "xal", "xam", "xan", "xao", "xap", "xaq", "xar", "xas", "xat", "xau", "xav", "xaw", "xay", "xba", "xbb", "xbc", "xbd", "xbe", "xbg", "xbi", "xbj", "xbm", "xbn", "xbo", "xbp", "xbr", "xbw", "xbx", "xby", "xcb", "xcc", "xce", "xcg", "xch", "xcl", "xcm", "xcn", "xco", "xcr", "xct", "xcu", "xcv", "xcw", "xcy", "xda", "xdc", "xdk", "xdm", "xdo", "xdy", "xeb", "xed", "xeg", "xel", "xem", "xep", "xer", "xes", "xet", "xeu", "xfa", "xga", "xgb", "xgd", "xgf", "xgg", "xgi", "xgl", "xgm", "xgn", "xgr", "xgu", "xgw", "xha", "xhc", "xhd", "xhe", "xhr", "xht", "xhu", "xhv", "xia", "xib", "xii", "xil", "xin", "xip", "xir", "xis", "xiv", "xiy", "xjb", "xjt", "xka", "xkb", "xkc", "xkd", "xke", "xkf", "xkg", "xkh", "xki", "xkj", "xkk", "xkl", "xkn", "xko", "xkp", "xkq", "xkr", "xks", "xkt", "xku", "xkv", "xkw", "xkx", "xky", "xkz", "xla", "xlb", "xlc", "xld", "xle", "xlg", "xli", "xln", "xlo", "xlp", "xls", "xlu", "xly", "xma", "xmb", "xmc", "xmd", "xme", "xmf", "xmg", "xmh", "xmj", "xmk", "xml", "xmm", "xmn", "xmo", "xmp", "xmq", "xmr", "xms", "xmt", "xmu", "xmv", "xmw", "xmx", "xmy", "xmz", "xna", "xnb", "xnd", "xng", "xnh", "xni", "xnj", "xnk", "xnm", "xnn", "xno", "xnq", "xnr", "xns", "xnt", "xnu", "xny", "xnz", "xoc", "xod", "xog", "xoi", "xok", "xom", "xon", "xoo", "xop", "xor", "xow", "xpa", "xpb", "xpc", "xpd", "xpe", "xpf", "xpg", "xph", "xpi", "xpj", "xpk", "xpl", "xpm", "xpn", "xpo", "xpp", "xpq", "xpr", "xps", "xpt", "xpu", "xpv", "xpw", "xpx", "xpy", "xpz", "xqa", "xqt", "xra", "xrb", "xrd", "xre", "xrg", "xri", "xrm", "xrn", "xrq", "xrr", "xrt", "xru", "xrw", "xsa", "xsb", "xsc", "xsd", "xse", "xsh", "xsi", "xsj", "xsl", "xsm", "xsn", "xso", "xsp", "xsq", "xsr", "xss", "xsu", "xsv", "xsy", "xta", "xtb", "xtc", "xtd", "xte", "xtg", "xth", "xti", "xtj", "xtl", "xtm", "xtn", "xto", "xtp", "xtq", "xtr", "xts", "xtt", "xtu", "xtv", "xtw", "xty", "xtz", "xua", "xub", "xud", "xug", "xuj", "xul", "xum", "xun", "xuo", "xup", "xur", "xut", "xuu", "xve", "xvi", "xvn", "xvo", "xvs", "xwa", "xwc", "xwd", "xwe", "xwg", "xwj", "xwk", "xwl", "xwo", "xwr", "xwt", "xww", "xxb", "xxk", "xxm", "xxr", "xxt", "xya", "xyb", "xyj", "xyk", "xyl", "xyt", "xyy", "xzh", "xzm", "xzp"],
    ["yi", "yo", "yaa", "yab", "yac", "yad", "yae", "yaf", "yag", "yah", "yai", "yaj", "yak", "yal", "yam", "yan", "yao", "yap", "yaq", "yar", "yas", "yat", "yau", "yav", "yaw", "yax", "yay", "yaz", "yba", "ybb", "ybd", "ybe", "ybh", "ybi", "ybj", "ybk", "ybl", "ybm", "ybn", "ybo", "ybx", "yby", "ych", "ycl", "ycn", "ycp", "yda", "ydd", "yde", "ydg", "ydk", "yds", "yea", "yec", "yee", "yei", "yej", "yel", "yen", "yer", "yes", "yet", "yeu", "yev", "yey", "yga", "ygi", "ygl", "ygm", "ygp", "ygr", "ygs", "ygu", "ygw", "yha", "yhd", "yhl", "yhs", "yia", "yif", "yig", "yih", "yii", "yij", "yik", "yil", "yim", "yin", "yip", "yiq", "yir", "yis", "yit", "yiu", "yiv", "yix", "yiy", "yiz", "yka", "ykg", "yki", "ykk", "ykl", "ykm", "ykn", "yko", "ykr", "ykt", "yku", "yky", "yla", "ylb", "yle", "ylg", "yli", "yll", "ylm", "yln", "ylo", "ylr", "ylu", "yly", "yma", "ymb", "ymc", "ymd", "yme", "ymg", "ymh", "ymi", "ymk", "yml", "ymm", "ymn", "ymo", "ymp", "ymq", "ymr", "yms", "ymt", "ymx", "ymz", "yna", "ynd", "yne", "yng", "ynh", "ynk", "ynl", "ynn", "yno", "ynq", "yns", "ynu", "yob", "yog", "yoi", "yok", "yol", "yom", "yon", "yos", "yot", "yox", "yoy", "ypa", "ypb", "ypg", "yph", "ypk", "ypm", "ypn", "ypo", "ypp", "ypz", "yra", "yrb", "yre", "yri", "yrk", "yrl", "yrm", "yrn", "yro", "yrs", "yrw", "yry", "ysc", "ysd", "ysg", "ysl", "ysm", "ysn", "yso", "ysp", "ysr", "yss", "ysy", "yta", "ytl", "ytp", "ytw", "yty", "yua", "yub", "yuc", "yud", "yue", "yuf", "yug", "yui", "yuj", "yuk", "yul", "yum", "yun", "yup", "yuq", "yur", "yut", "yuu", "yuw", "yux", "yuy", "yuz", "yva", "yvt", "ywa", "ywg", "ywl", "ywn", "ywq", "ywr", "ywt", "ywu", "yww", "yxa", "yxg", "yxl", "yxm", "yxu", "yxy", "yyr", "yyu", "yyz", "yzg", "yzk"],
    ["za", "zh", "zu", "zaa", "zab", "zac", "zad", "zae", "zaf", "zag", "zah", "zai", "zaj", "zak", "zal", "zam", "zao", "zap", "zaq", "zar", "zas", "zat", "zau", "zav", "zaw", "zax", "zay", "zaz", "zba", "zbc", "zbe", "zbl", "zbt", "zbu", "zbw", "zca", "zch", "zdj", "zea", "zeg", "zeh", "zen", "zga", "zgb", "zgh", "zgm", "zgn", "zgr", "zhb", "zhd", "zhi", "zhn", "zhw", "zhx", "zia", "zib", "zik", "zil", "zim", "zin", "zir", "ziw", "ziz", "zka", "zkb", "zkd", "zkg", "zkh", "zkk", "zkn", "zko", "zkp", "zkr", "zkt", "zku", "zkv", "zkz", "zla", "zle", "zlj", "zlm", "zln", "zlq", "zls", "zlw", "zma", "zmb", "zmc", "zmd", "zme", "zmf", "zmg", "zmh", "zmi", "zmj", "zmk", "zml", "zmm", "zmn", "zmo", "zmp", "zmq", "zmr", "zms", "zmt", "zmu", "zmv", "zmw", "zmx", "zmy", "zmz", "zna", "znd", "zne", "zng", "znk", "zns", "zoc", "zoh", "zom", "zoo", "zoq", "zor", "zos", "zpa", "zpb", "zpc", "zpd", "zpe", "zpf", "zpg", "zph", "zpi", "zpj", "zpk", "zpl", "zpm", "zpn", "zpo", "zpp", "zpq", "zpr", "zps", "zpt", "zpu", "zpv", "zpw", "zpx", "zpy", "zpz", "zqe", "zra", "zrg", "zrn", "zro", "zrp", "zrs", "zsa", "zsk", "zsl", "zsm", "zsr", "zsu", "zte", "ztg", "ztl", "ztm", "ztn", "ztp", "ztq", "zts", "ztt", "ztu", "ztx", "zty", "zua", "zuh", "zum", "zun", "zuy", "zwa", "zxx", "zyb", "zyg", "zyj", "zyn", "zyp", "zza", "zzj"]
];
var LangUtil = /** @class */ (function () {
    function LangUtil() {
    }
    /* Determine if given string is a valid BCP 47 string */
    LangUtil.isBcp47 = function (langStr) {
        return /^(([a-zA-Z]{2,3}(-[a-zA-Z](-[a-zA-Z]{3}){0,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-([0-9a-zA-Z]{5,8}|[0-9][a-zA-Z]{3}))*(-[0-9a-wy-zA-WY-Z](-[a-zA-Z0-9]{2,8})+)*(-x(-[a-zA-Z0-9]{1,8})+)?|x(-[a-zA-Z0-9]{1,8})+|(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE|art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))$/.test(langStr);
    };
    LangUtil.validPrimaryLang = function (langStr) {
        var primary = langStr.toLowerCase();
        if (primary.includes("-")) {
            primary = primary.split("-")[0];
        }
        if (!primary.match(/[a-z]{2,3}/))
            return false;
        // qaa..qtz
        if (primary.length === 3
            && primary.charAt(0) === "q"
            && primary.charCodeAt(1) >= 97 && primary.charCodeAt(1) <= 116
            && primary.charCodeAt(2) >= 97 && primary.charCodeAt(2) <= 122) {
        }
        return validPrimaryLangs[primary.charCodeAt(0) - 97].includes(primary);
    };
    LangUtil.matchPrimaryLang = function (lang1, lang2) {
        var primary1 = lang1;
        if (primary1.includes("-")) {
            primary1 = primary1.split("-")[0];
        }
        var primary2 = lang2;
        if (primary2.includes("-")) {
            primary2 = primary2.split("-")[0];
        }
        return primary1.toLowerCase() === primary2.toLowerCase();
    };
    return LangUtil;
}());
exports.LangUtil = LangUtil;


/***/ }),

/***/ 1794:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonMapper = void 0;
var DOMWalker_1 = __webpack_require__(7440);
var CommonMapper = /** @class */ (function () {
    function CommonMapper() {
        this.hierarchyRole = null;
        this.hierarchyPath = null;
        this.hierarchyResults = null;
    }
    CommonMapper.prototype.getBounds = function (node) {
        return null;
    };
    CommonMapper.prototype.reset = function (node) {
        this.hierarchyRole = [];
        this.hierarchyResults = [];
        this.hierarchyPath = [{
                rolePath: "",
                roleCount: {}
            }];
        var ancestors = [];
        var parent = DOMWalker_1.DOMWalker.parentNode(node);
        while (parent && parent.nodeType != 9 /* Node.DOCUMENT_NODE */) {
            ancestors.push(parent);
            parent = DOMWalker_1.DOMWalker.parentNode(parent);
        }
        ancestors = ancestors.reverse();
        for (var _i = 0, ancestors_1 = ancestors; _i < ancestors_1.length; _i++) {
            var ancestor = ancestors_1[_i];
            var siblings = [];
            var sibling = ancestor.previousSibling;
            while (sibling) {
                siblings.push(sibling);
                sibling = sibling.previousSibling;
            }
            siblings = siblings.reverse();
            for (var _a = 0, siblings_1 = siblings; _a < siblings_1.length; _a++) {
                var sibling_1 = siblings_1[_a];
                this.pushHierarchy(sibling_1);
                this.popHierarchy();
            }
            this.pushHierarchy(ancestor);
        }
    };
    CommonMapper.prototype.pushHierarchy = function (node) {
        var role = this.getRole(node) || null;
        this.hierarchyRole.push(role);
        if (role !== null) {
            var parentPathInfo = this.hierarchyPath[this.hierarchyPath.length - 1];
            parentPathInfo.roleCount[role] = (parentPathInfo.roleCount[role] || 0) + 1;
            this.hierarchyPath.push({
                "rolePath": parentPathInfo.rolePath + "/" + role + "[" + parentPathInfo.roleCount[role] + "]",
                "roleCount": {}
            });
        }
        var attr = {};
        if (node.nodeType === 1) {
            attr = this.getAttributes(node);
        }
        this.hierarchyResults.push({
            node: node,
            namespace: this.getNamespace(),
            role: role,
            attributes: attr,
            rolePath: this.hierarchyPath[this.hierarchyPath.length - 1].rolePath,
            bounds: this.getBounds(node)
        });
    };
    CommonMapper.prototype.popHierarchy = function () {
        var role = this.hierarchyRole.pop();
        if (role !== null) {
            this.hierarchyPath.pop();
        }
        this.hierarchyResults.pop();
    };
    CommonMapper.prototype.openScope = function (node) {
        if (this.hierarchyRole === null) {
            this.reset(node);
        }
        this.pushHierarchy(node);
        return this.hierarchyResults;
    };
    CommonMapper.prototype.closeScope = function (node) {
        var retVal = [];
        for (var _i = 0, _a = this.hierarchyResults; _i < _a.length; _i++) {
            var res = _a[_i];
            // const temp = res.node;
            // res.node = null;
            // let cloned = JSON.parse(JSON.stringify(res));
            // cloned.node = res.node = temp; 
            // retVal.push(cloned);
            retVal.push(res);
        }
        retVal[retVal.length - 1].role = "/" + retVal[retVal.length - 1].role;
        this.popHierarchy();
        return retVal;
    };
    return CommonMapper;
}());
exports.CommonMapper = CommonMapper;


/***/ }),

/***/ 2306:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = exports.PartInfo = exports.AttrInfo = void 0;
// Context that will cause this rule to execute. 
// Context syntax:
//   Triggers:
//     aria:role - Triggers on element with ARIA role role
//     aria:role[attribute] - Triggers on elements with the equivalent logical 
//       aria- attribute (e.g., button[disabled] will trigger on 
//       <button disabled> or <div role="button" aria-disabled="true">)
//     role[attribute=value] - Similar to above, with case-sensitive match
//       to value
//     role[attribute~value] - Similar to above, with case-insensitive match
//     dom:element - Triggers on an element with the specified name
//     dom:element[attribute] - Triggers on a dom element with the specified attribute
//     dom:*[attribute] - Triggers on all elements with the specified attribute
//   Combining triggers:
//     trigger1 trigger2 - Triggers on elements with trigger2 within an 
//       element with trigger1
//     !trigger1 trigger2 - Triggers on elements with trigger2 not within
//       element with trigger1
//     trigger1>trigger2 - Triggers on elements with trigger2 with an
//       an immediate parent with trigger1
//     trigger1+trigger2 - Triggers on elements with trigger2 with an
//       immediate previous sibling with trigger1
//     trigger1~trigger2 - Triggers on elements with trigger2 with an
//       some earlier sibling with trigger1
//     context,context - Triggers on elements with either context
var AttrInfo = /** @class */ (function () {
    function AttrInfo(inclusive, attr, eq, value) {
        this.inclusive = inclusive;
        this.attr = attr;
        this.eq = eq;
        this.value = value;
        if (!inclusive
            && ((typeof eq) !== "undefined" && eq.length > 0)) {
            throw new Error("Cannot have !attr" + eq + " context");
        }
        if (inclusive && (typeof eq) !== "undefined" && eq.length > 0 && ((typeof value) === "undefined" || value.length === 0)) {
            throw new Error("Cannot have equivalence check without a value");
        }
    }
    AttrInfo.prototype.matches = function (context) {
        var ruleAttrPart = this;
        var elemAttrs = context.attributes;
        if (!(ruleAttrPart.attr in elemAttrs)) {
            return !ruleAttrPart.inclusive;
        }
        else if (!ruleAttrPart.inclusive) {
            return false;
        }
        else if (!ruleAttrPart.eq) {
            // inclusive match and I have that attribute and no equivalence defined
            return true;
        }
        else {
            // inclusive match and I have that attribute and equivalence defined
            var attrValue = elemAttrs[ruleAttrPart.attr];
            if (ruleAttrPart.eq === "=") {
                return ruleAttrPart.value === attrValue;
            }
            else if (ruleAttrPart.eq === "!=") {
                return ruleAttrPart.value !== attrValue;
            }
            else if (ruleAttrPart.eq === "~") {
                return ruleAttrPart.value === attrValue;
            }
            else if (ruleAttrPart.eq === "!~") {
                return ruleAttrPart.value !== attrValue;
            }
            else {
                throw new Error("Context equivalence operator not supported");
            }
        }
    };
    return AttrInfo;
}());
exports.AttrInfo = AttrInfo;
var PartInfo = /** @class */ (function () {
    function PartInfo(inclusive, namespace, role, attrs, connector) {
        this.inclusive = inclusive;
        this.namespace = namespace;
        this.role = role;
        this.attrs = attrs;
        this.connector = connector;
        if (role === "*" && !inclusive) {
            throw new Error("!* context not supported");
        }
    }
    PartInfo.prototype.matches = function (contextHier, hierLevel) {
        var rulePart = this;
        var ruleRoleMatch = (rulePart.namespace in contextHier) && contextHier[rulePart.namespace][hierLevel]
            && (contextHier[rulePart.namespace][hierLevel].role === rulePart.role
                || contextHier[rulePart.namespace][hierLevel].role !== "none" && rulePart.role === "*");
        if (ruleRoleMatch
            && rulePart.role === "*"
            && rulePart.namespace === "dom"
            && (contextHier[rulePart.namespace][hierLevel].role === "#text"
                || contextHier[rulePart.namespace][hierLevel].role === "/#text")) {
            ruleRoleMatch = false;
        }
        if (rulePart.inclusive && !ruleRoleMatch)
            return false;
        if (!rulePart.inclusive && !ruleRoleMatch)
            return true;
        // Match the attributes
        var ruleAttrs = rulePart.attrs;
        var elemContext = contextHier[rulePart.namespace][hierLevel];
        var match = true;
        for (var _i = 0, ruleAttrs_1 = ruleAttrs; _i < ruleAttrs_1.length; _i++) {
            var ruleAttrPart = ruleAttrs_1[_i];
            match = match && ruleAttrPart.matches(elemContext);
        }
        if (!rulePart.inclusive)
            match = !match;
        return match;
    };
    return PartInfo;
}());
exports.PartInfo = PartInfo;
var Context = /** @class */ (function () {
    function Context(context) {
        this.contextInfo = [];
        var contextHierMatches = context.match(/!?[/a-zA-Z:0-9*\-_]+(\[[^\]]+\])*[ >+~]?/g);
        var results = [];
        for (var _i = 0, contextHierMatches_1 = contextHierMatches; _i < contextHierMatches_1.length; _i++) {
            var part = contextHierMatches_1[_i];
            var parts = part.match(/(!?)([/a-zA-Z:0-9*\-_]+)((\[[^\]]+\])*)([ >+~]?)/);
            var attrInfo = [];
            for (var _a = 0, _b = parts[3].match(/\[([^\]]+)\]/g) || []; _a < _b.length; _a++) {
                var attrPart = _b[_a];
                var attrParts = attrPart.match(/\[(!?)([a-z:A-Z*\-_]+)(!?[=~])?([^\]]+)?\]/);
                attrInfo.push(new AttrInfo(attrParts[1] !== "!", attrParts[2].toLowerCase(), attrParts[3], attrParts[4]));
            }
            parts[2] = parts[2].toLowerCase();
            var nsParts = parts[2].split(":");
            var incl = parts[1] !== "!";
            var ns = nsParts.shift();
            var role = nsParts.join(":");
            var partInfo = new PartInfo(incl, ns, role, attrInfo, parts[parts.length - 1]);
            results.push(partInfo);
        }
        this.contextInfo = results;
    }
    Context.cleanContext = function (context) {
        context = context.toLowerCase().trim();
        context = context.replace(/ +!/g, " !");
        context = context.replace(/ +([>+~,])/g, "$1");
        context = context.replace(/([>+~,]) +/g, "$1");
        context = context.replace(/ +/g, " ");
        return context.trim();
    };
    Context.parse = function (context) {
        var contexts = Context.splitMultiple(Context.cleanContext(context));
        var retVal = [];
        for (var i = 0; i < contexts.length; ++i) {
            var ctx = new Context(contexts[i]);
            retVal.push(ctx);
        }
        return retVal;
    };
    /**
     * Handles initial processing of splitting on comma - context,context
     * @param context
     */
    Context.splitMultiple = function (context) {
        var contexts = [];
        if (context) {
            if (context.indexOf(",") === -1) {
                contexts.push(context);
            }
            else {
                for (var _i = 0, _a = context.split(","); _i < _a.length; _i++) {
                    var c = _a[_i];
                    contexts.push(c);
                }
            }
        }
        return contexts;
    };
    return Context;
}());
exports.Context = Context;


/***/ }),

/***/ 9324:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Engine = void 0;
var DOMWalker_1 = __webpack_require__(7440);
var Context_1 = __webpack_require__(2306);
var Config_1 = __webpack_require__(3962);
var DOMMapper_1 = __webpack_require__(5697);
var DOMUtil_1 = __webpack_require__(295);
var CacheUtil_1 = __webpack_require__(7788);
var IRule_1 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
var WrappedRule = /** @class */ (function () {
    function WrappedRule(rule, parsedInfo) {
        this.rule = rule;
        this.parsedInfo = parsedInfo;
        this.ns = this.parsedInfo.contextInfo[this.parsedInfo.contextInfo.length - 1].namespace;
        Config_1.Config.DEBUG && console.log("Added Rule:", rule.id, JSON.stringify(this.parsedInfo));
    }
    /**
     * This function is responsible converting the node into a snippet which can be added to report.
     *
     * Note: This function will take the node and extract the node name and the attributes and build the snippet based on this.
     *
     * TODO: Future, maybe we can extract more then just single line, add more info or even add closing tags etc...
     *
     * @param {HTMLElement} node - The html element to convert into element snippet with node name and attributes only.
     *
     * @return {String} nodeSnippet - return the element snippet of the element that was provided which only contains,
     *                                nodename and attributes. i.e. <table id=\"layout_table1\" role=\"presentation\">
     *
     * @memberOf this
     */
    WrappedRule.convertNodeToSnippet = function (node) {
        // Variable Decleration
        var nodeSnippet = '';
        // Extract the node name and add it to the node snippet
        nodeSnippet += '<' + node.nodeName.toLowerCase();
        // Extract all the node attributes as an array
        var nodeAttributes = node.attributes;
        // In the case there are attributes on this node
        if (nodeAttributes !== null && typeof nodeAttributes !== 'undefined') {
            // Loop over all theses attributes and add the name and value to the nodeSnippet which will be returned
            for (var i = nodeAttributes.length - 1; i >= 0; i--) {
                if (nodeAttributes[i].name === "data-namewalk")
                    continue;
                // Add the attribute name and value.
                nodeSnippet += ' ' + nodeAttributes[i].name + '="' + nodeAttributes[i].value + '"';
            }
        }
        // Close the node
        nodeSnippet += '>';
        // Return the node snippet
        return nodeSnippet;
    };
    WrappedRule.prototype.run = function (engine, context, options, contextHierarchies) {
        var startTime = new Date().getTime();
        var results;
        try {
            results = this.rule.run(context, options, contextHierarchies);
        }
        catch (e) {
            var err = e;
            console.error("RULE EXCEPTION:", this.rule.id, context.dom.rolePath, err.stack);
            throw e;
        }
        var endTime = new Date().getTime();
        if (!results)
            results = [];
        if (!(results instanceof Array)) {
            results = [results];
        }
        var retVal = [];
        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
            var result = results_1[_i];
            var message = engine.getMessage(this.rule.id, result.reasonId, result.messageArgs);
            var path = {};
            for (var ns in context) {
                path[ns] = context[ns].rolePath;
            }
            var ruleId = this.rule.id.replace(/^(.*)\$\$\d+$/, "$1");
            retVal.push({
                ruleId: ruleId,
                value: result.value,
                node: context["dom"].node,
                path: path,
                ruleTime: endTime - startTime,
                reasonId: result.reasonId,
                message: message,
                messageArgs: result.messageArgs,
                apiArgs: result.apiArgs,
                bounds: context["dom"].bounds,
                snippet: WrappedRule.convertNodeToSnippet(context["dom"].node)
            });
        }
        return retVal;
    };
    return WrappedRule;
}());
var Engine = /** @class */ (function () {
    function Engine() {
        this.mappers = {};
        this.ruleMap = {};
        this.wrappedRuleMap = {};
        this.nlsMap = {};
        this.helpMap = {};
        this.inclRules = {};
        this.exclRules = {};
        // Need a DOM Mapper as a minimum
        this.addMapper(new DOMMapper_1.DOMMapper());
    }
    Engine.getLanguages = function () {
        var env = typeof process !== "undefined" && typeof process.nodeType === "undefined" && process.env;
        // If all else fails, default to US English
        var nodeLang = "en-US";
        if (env) {
            nodeLang = env.LANG || env.LANGUAGE || env.LC_ALL || env.LC_MESSAGES;
            if (nodeLang && nodeLang.length > 0) {
                nodeLang = nodeLang.split(".")[0].replace(/_/g, "-");
            }
            else {
                nodeLang = "en-US";
            }
        }
        return typeof navigator !== "undefined" && navigator.languages || [nodeLang];
    };
    Engine.prototype.run = function (root, options) {
        if (root === null) {
            return Promise.reject("null document");
        }
        if (root.nodeType === 9 /* Node.DOCUMENT_NODE */) {
            root = root.documentElement;
        }
        root.ownerDocument && (root.ownerDocument.PT_CHECK_HIDDEN_CONTENT = false);
        CacheUtil_1.CacheUtil.clearCaches(root);
        var walker = new DOMWalker_1.DOMWalker(root, false, root, true);
        var retVal = {
            results: [],
            numExecuted: 0,
            ruleTime: 0,
            totalTime: 0
        };
        var start = new Date().getTime();
        // Reset the role mappers
        for (var namespace in this.mappers) {
            this.mappers[namespace].reset(root);
        }
        // Initialize the context detector
        do {
            // Get the context information from the rule mappers
            var contextHierarchies = {};
            for (var namespace in this.mappers) {
                if (!walker.bEndTag) {
                    contextHierarchies[namespace] = this.mappers[namespace].openScope(walker.node);
                    // if (namespace === "dom" && walker.node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                    // const elem = walker.node as Element;
                    // let id;
                    // if (elem.hasAttribute("id") && (id = elem.getAttribute("id").trim()).length > 0) {
                    // if (root.ownerDocument.getElementById(id) === elem) {
                    // contextHierarchies["dom"][contextHierarchies["dom"].length-1].rolePath = "//*[@id='"+id+"']";
                    // }
                    // }
                    // }
                }
                else {
                    contextHierarchies[namespace] = this.mappers[namespace].closeScope(walker.node);
                }
            }
            if (walker.node.nodeType !== 11
                && (VisUtil_1.VisUtil.isNodeVisible(walker.node)
                    // || walker.node.nodeName.toLowerCase() === "head"
                    || walker.node.nodeName.toLowerCase() === "meta"
                    || walker.node.nodeName.toLowerCase() === "style"
                    || walker.node.nodeName.toLowerCase() === "datalist"
                    || walker.node.nodeName.toLowerCase() === "param"
                    || !DOMUtil_1.DOMUtil.getAncestor(walker.node, ["body"]))) {
                var context = {};
                for (var ns in contextHierarchies) {
                    var nsHier = contextHierarchies[ns];
                    var lastHier = nsHier[nsHier.length - 1];
                    context[ns] = lastHier;
                }
                var matchingRules = this.getMatchingRules(contextHierarchies);
                var depMatch = {};
                for (var _i = 0, matchingRules_1 = matchingRules; _i < matchingRules_1.length; _i++) {
                    var matchingRule = matchingRules_1[_i];
                    var fulfillsDependencies = true;
                    for (var _a = 0, _b = matchingRule.rule.dependencies || []; _a < _b.length; _a++) {
                        var dep = _b[_a];
                        if (!depMatch[dep])
                            fulfillsDependencies = false;
                    }
                    if (fulfillsDependencies) {
                        var results = [];
                        try {
                            results = matchingRule.run(this, context, options, contextHierarchies);
                        }
                        catch (err) {
                            // Wrapper shows error in console. Skip this rule as N/A
                            // We don't want to kill the engine
                        }
                        // If out of scope, it fulfills the dependency
                        if (results.length === 0) {
                            depMatch[matchingRule.rule.id] = true;
                        }
                        for (var _c = 0, results_2 = results; _c < results_2.length; _c++) {
                            var result = results_2[_c];
                            retVal.results.push(result);
                            retVal.ruleTime += result.ruleTime;
                            retVal.numExecuted++;
                            if (result.value[1] === IRule_1.eRuleConfidence.PASS) {
                                depMatch[result.ruleId] = true;
                            }
                        }
                    }
                }
            }
        } while (walker.nextNode());
        CacheUtil_1.CacheUtil.clearCaches(root);
        retVal.totalTime = new Date().getTime() - start;
        return Promise.resolve(retVal);
    };
    Engine.prototype.enableRules = function (ruleIds) {
        for (var ruleId in this.ruleMap) {
            this.ruleMap[ruleId].enabled = false;
        }
        for (var _i = 0, _a = ruleIds || []; _i < _a.length; _i++) {
            var ruleId = _a[_i];
            if (!(ruleId in this.ruleMap)) {
                console.warn("WARNING: Rule Id", ruleId, "could not be enabled.");
            }
            else {
                this.ruleMap[ruleId].enabled = true;
            }
        }
    };
    Engine.prototype.getRule = function (ruleId) {
        return this.ruleMap[ruleId];
    };
    Engine.prototype.getRulesIds = function () {
        var retVal = [];
        for (var ruleId in this.ruleMap) {
            retVal.push(ruleId);
        }
        return retVal;
    };
    Engine.prototype.addRules = function (rules) {
        for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {
            var rule = rules_1[_i];
            this.addRule(rule, true);
        }
        this._sortRules();
    };
    Engine.prototype.addRule = function (rule, skipSort) {
        var ctxs = Context_1.Context.parse(rule.context);
        var idx = 0;
        var ruleId = rule.id;
        if (ruleId in this.ruleMap) {
            console.log("WARNING: Rule", ruleId, "already added to engine. Ignoring...");
            return;
        }
        this.ruleMap[ruleId] = rule;
        for (var _i = 0, ctxs_1 = ctxs; _i < ctxs_1.length; _i++) {
            var ctx = ctxs_1[_i];
            var wrapId = ruleId;
            if (idx >= 1) {
                wrapId = ruleId + "$$" + idx;
            }
            ++idx;
            var wrappedRule = new WrappedRule(rule, ctx);
            this.wrappedRuleMap[wrapId] = wrappedRule;
            var parts = wrappedRule.parsedInfo.contextInfo;
            var lastPart = parts[parts.length - 1];
            var triggerRole = lastPart.namespace + ":" + lastPart.role;
            if (lastPart.inclusive) {
                this.inclRules[triggerRole] = this.inclRules[triggerRole] || [];
                this.inclRules[triggerRole].push(wrappedRule);
            }
            else {
                this.exclRules[triggerRole] = this.exclRules[triggerRole] || [];
                this.exclRules[triggerRole].push(wrappedRule);
            }
        }
        if (!skipSort) {
            this._sortRules();
        }
    };
    Engine.prototype._sortRules = function () {
        for (var role in this.inclRules) {
            this.inclRules[role].sort(function (ruleA, ruleB) {
                var hasDepA = ruleA.rule.dependencies && ruleA.rule.dependencies.length > 0;
                var hasDepB = ruleB.rule.dependencies && ruleB.rule.dependencies.length > 0;
                // If B depends on A, sort A before B
                if (hasDepB && ruleB.rule.dependencies.includes(ruleA.rule.id))
                    return -1;
                // If A depends on B, sort B before A
                if (hasDepA && ruleA.rule.dependencies.includes(ruleB.rule.id))
                    return 1;
                // Otherwise, doesn't matter
                return 0;
            });
        }
        for (var role in this.exclRules) {
            this.exclRules[role].sort(function (ruleA, ruleB) {
                var hasDepA = ruleA.rule.dependencies && ruleA.rule.dependencies.length > 0;
                var hasDepB = ruleB.rule.dependencies && ruleB.rule.dependencies.length > 0;
                // If B depends on A, sort A before B
                if (hasDepB && ruleB.rule.dependencies.includes(ruleA.rule.id))
                    return -1;
                // If A depends on B, sort B before A
                if (hasDepA && ruleA.rule.dependencies.includes(ruleB.rule.id))
                    return 1;
                // Otherwise, doesn't matter
                return 0;
            });
        }
    };
    Engine.prototype.addNlsMap = function (map) {
        for (var key in map) {
            this.nlsMap[key] = map[key];
        }
    };
    Engine.prototype.addHelpMap = function (map) {
        for (var key in map) {
            this.helpMap[key] = map[key];
        }
    };
    Engine.prototype.getMessage = function (ruleId, ruleIdx, msgArgs) {
        var splitter = ruleId.indexOf("$$");
        if (splitter >= 0) {
            ruleId = ruleId.substring(0, splitter);
        }
        if (!(ruleId in this.nlsMap))
            return ruleId;
        var messageTemplate = this.nlsMap[ruleId][ruleIdx || 0];
        if (!messageTemplate)
            return ruleId + "_" + ruleIdx;
        return messageTemplate.replace(/\{(\d+)\}/g, function (matchedStr, matchedNum, matchedIndex) { return msgArgs[matchedNum]; });
    };
    Engine.prototype.getHelp = function (ruleId, reasonId, archiveId) {
        if (!archiveId) {
            // Set to the latest
            archiveId = "latest";
        }
        return "".concat(Config_1.Config.helpRoot, "/").concat(archiveId, "/doc").concat(this.getHelpRel(ruleId, reasonId));
    };
    Engine.prototype.getHelpRel = function (ruleId, ruleIdx) {
        var splitter = ruleId.indexOf("$$");
        if (splitter >= 0) {
            ruleId = ruleId.substring(0, splitter);
        }
        if (!(ruleId in this.helpMap))
            return ruleId;
        ruleIdx = ruleIdx || 0;
        var helpStr = null;
        if (ruleIdx in this.helpMap[ruleId]) {
            helpStr = this.helpMap[ruleId][ruleIdx || 0];
        }
        else {
            helpStr = this.helpMap[ruleId][0];
        }
        if (!helpStr)
            return ruleId + "_" + ruleIdx;
        return helpStr;
    };
    Engine.prototype.addMapper = function (mapper) {
        this.mappers[mapper.getNamespace()] = mapper;
    };
    Engine.match = function (rule, contextHier) {
        var ruleParts = rule.parsedInfo.contextInfo;
        var partIdx = ruleParts.length - 1;
        var curNS = ruleParts[partIdx].namespace;
        var curHier = contextHier[curNS][contextHier[curNS].length - 1];
        var contextNode = curHier.node;
        // If the end of the rule part doesn't match the end of the hierarchy, we don't have a match
        if (!ruleParts[partIdx].matches(contextHier, contextHier[curNS].length - 1)) {
            return false;
        }
        // If there was only one part, we have a match
        if (ruleParts.length === 1) {
            return true;
        }
        // Need to deal with parent parts. To walk the hierarchy, these need to be
        // all in the same namespace. Confirm that is true.
        curNS = ruleParts[0].namespace;
        curHier = contextHier[curNS][contextHier[curNS].length - 1];
        --partIdx;
        if (ruleParts.slice(0, ruleParts.length - 1).some(function (part) { return part.namespace !== curNS; })) {
            console.error("[ERROR] Rule ".concat(rule.rule.id, " has inconsitent parent namespaces"));
            return false;
        }
        // If the target node matches the end of the hierarchy, move up past it, otherwise, start at the end
        var hierIdx = contextHier[curNS].length - (curHier.node.isSameNode(contextNode) ? 2 : 1);
        while (hierIdx >= 0 && partIdx >= 0) {
            var part = ruleParts[partIdx];
            var matchesPart = ruleParts[partIdx].matches(contextHier, hierIdx);
            if (part.connector === ">") {
                if (!matchesPart) {
                    // Direct parent check and doesn't match
                    return false;
                }
                else {
                    // Direct parent check and does match
                    --partIdx;
                    --hierIdx;
                }
            }
            else if (part.connector === " ") {
                if (part.inclusive) {
                    // inclusive ancestor match
                    if (matchesPart) {
                        --partIdx;
                    }
                    // If doesn't match, just move up the role hierarchy
                    --hierIdx;
                }
                else if (!matchesPart) {
                    // exclusive ancestor match and current matches
                    return false;
                }
                else {
                    // exclusive ancestor match and current doesn't match - check for other ancestors
                    var parentMatch = false;
                    for (var searchIdx = hierIdx - 1; !parentMatch && searchIdx >= 0; --searchIdx) {
                        parentMatch = !ruleParts[partIdx].matches(contextHier, searchIdx);
                    }
                    if (parentMatch)
                        return false;
                    else
                        --partIdx;
                }
            }
            else {
                throw new Error("Context connector " + part.connector + " is not supported");
            }
        }
        return partIdx === -1;
    };
    Engine.prototype.getMatchingRules = function (ctxHier) {
        var matches = [];
        function addMatches(rules) {
            for (var _i = 0, rules_2 = rules; _i < rules_2.length; _i++) {
                var rule = rules_2[_i];
                if (rule.rule.enabled && Engine.match(rule, ctxHier)) {
                    matches.push(rule);
                }
            }
        }
        for (var ns in ctxHier) {
            var role = ns + ":" + (ctxHier[ns].length > 0 ? ctxHier[ns][ctxHier[ns].length - 1].role : "none");
            if (role in this.inclRules) {
                addMatches(this.inclRules[role]);
            }
            for (var xRole in this.exclRules) {
                if (xRole !== role) {
                    addMatches(this.exclRules[xRole]);
                }
            }
            if (role !== ns + ":none") {
                if (role.startsWith(ns + ":/")) {
                    if (ns + ":/*" in this.inclRules) {
                        addMatches(this.inclRules[ns + ":/*"]);
                    }
                }
                else {
                    if (ns + ":*" in this.inclRules) {
                        addMatches(this.inclRules[ns + ":*"]);
                    }
                }
            }
        }
        return this.sortDeps(matches);
    };
    /**
     * Sorts the rules in order to execute dependencies in the correct order
     * @param inRules List of wrapped rules to sort
     * @returns Sorted list of wrapped rules
     */
    Engine.prototype.sortDeps = function (inRules) {
        var depRules = [];
        for (var _i = 0, inRules_1 = inRules; _i < inRules_1.length; _i++) {
            var rule = inRules_1[_i];
            depRules.push(rule);
        }
        var retVal = [];
        var idToRule = {};
        // Iterate through the rules. If that rule's dependencies can be met by rules already in the list, add it to the list
        // Repeat until no changes are made to the satisfied list
        // If a rule cannot be satisfied, it will never execute, so it can be dropped.
        var change = false;
        do {
            change = false;
            for (var idx = 0; idx < depRules.length; ++idx) {
                var depRule = depRules[idx];
                if (depRule.rule.id in idToRule)
                    continue;
                var allMatch = true;
                if (depRule.rule.dependencies && depRule.rule.dependencies.length > 0) {
                    for (var _a = 0, _b = depRule.rule.dependencies; _a < _b.length; _a++) {
                        var depId = _b[_a];
                        if (!(depId in idToRule)) {
                            allMatch = false;
                        }
                    }
                }
                // if (depRule.rule.prereqs && depRule.rule.prereqs.length > 0) {
                //     for (const depId of depRule.rule.prereqs) {
                //         if (!(depId in idToRule)) {
                //             allMatch = false;
                //         }                        
                //     }
                // }
                if (allMatch) {
                    change = true;
                    retVal.push(depRule);
                    idToRule[depRule.rule.id] = true;
                    depRules.splice(idx--, 1);
                }
            }
        } while (change);
        return retVal;
    };
    return Engine;
}());
exports.Engine = Engine;


/***/ }),

/***/ 3962:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Config = void 0;
var Config = /** @class */ (function () {
    function Config() {
    }
    Config.DEBUG = false;
    Config.helpRoot = "https://able.ibm.com/rules/archives";
    return Config;
}());
exports.Config = Config;


/***/ }),

/***/ 5697:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DOMMapper = void 0;
var CommonMapper_1 = __webpack_require__(1794);
var CacheUtil_1 = __webpack_require__(7788);
var DOMMapper = /** @class */ (function (_super) {
    __extends(DOMMapper, _super);
    function DOMMapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DOMMapper.prototype.getRole = function (node) {
        return node.nodeName.toLowerCase();
    };
    DOMMapper.prototype.getNamespace = function () {
        return "dom";
    };
    DOMMapper.prototype.getAttributes = function (node) {
        var retVal = {};
        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
            var elem = node;
            for (var idx = 0; idx < elem.attributes.length; ++idx) {
                var attrInfo = elem.attributes[idx];
                retVal[attrInfo.name.toLowerCase()] = attrInfo.nodeValue;
            }
        }
        return retVal;
    };
    /**
     * get scaled bounds for screenshot etc. adjusted for devicePixelRatio and scroll
     * @param node
     * @returns
     */
    DOMMapper.prototype.getBounds = function (node) {
        if (node.nodeType !== 1 /*Node.ELEMENT_NODE*/)
            return null;
        var bunds = CacheUtil_1.CacheUtil.getCache(node, "DOMMapper_Bounds", undefined);
        if (bunds === undefined) {
            var adjustment = 1;
            if (node.ownerDocument && node.ownerDocument.defaultView && node.ownerDocument.defaultView.devicePixelRatio) {
                adjustment = node.ownerDocument.defaultView.devicePixelRatio;
            }
            var bounds = node.getBoundingClientRect();
            // Do a check whether bounds has value as we use different tool (htmlUnit, browser) to call this function
            if (bounds) {
                var scrollX_1 = node && node.ownerDocument && node.ownerDocument.defaultView && node.ownerDocument.defaultView.scrollX || 0;
                var scrollY_1 = node && node.ownerDocument && node.ownerDocument.defaultView && node.ownerDocument.defaultView.scrollY || 0;
                var ret = {
                    "left": Math.ceil((bounds.left + scrollX_1) * adjustment),
                    "top": Math.ceil((bounds.top + scrollY_1) * adjustment),
                    "height": Math.ceil(bounds.height * adjustment),
                    "width": Math.ceil(bounds.width * adjustment)
                };
                CacheUtil_1.CacheUtil.setCache(node, "DOMMapper_Bounds", ret);
                return ret;
            }
            return null;
        }
        return bunds;
    };
    /**
     * get real CSS bounds in css pixels, adjusted for scroll only
     * @param node
     * @returns
     */
    DOMMapper.prototype.getUnadjustedBounds = function (node) {
        if (node.nodeType !== 1 /*Node.ELEMENT_NODE*/)
            return null;
        var bunds = CacheUtil_1.CacheUtil.getCache(node, "DOMMapper_UnadjustedBounds", undefined);
        if (bunds === undefined) {
            var bounds = node.getBoundingClientRect();
            // adjusted for scroll if any
            if (bounds) {
                var scrollX_2 = node && node.ownerDocument && node.ownerDocument.defaultView && node.ownerDocument.defaultView.scrollX || 0;
                var scrollY_2 = node && node.ownerDocument && node.ownerDocument.defaultView && node.ownerDocument.defaultView.scrollY || 0;
                var ret = {
                    "left": Math.ceil(bounds.left + scrollX_2),
                    "top": Math.ceil(bounds.top + scrollY_2),
                    "height": Math.ceil(bounds.height),
                    "width": Math.ceil(bounds.width)
                };
                CacheUtil_1.CacheUtil.setCache(node, "DOMMapper_UnadjustedBounds", ret);
                return ret;
            }
            return null;
        }
        return bunds;
    };
    return DOMMapper;
}(CommonMapper_1.CommonMapper));
exports.DOMMapper = DOMMapper;


/***/ }),

/***/ 295:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DOMUtil = void 0;
var DOMWalker_1 = __webpack_require__(7440);
var DOMUtil = /** @class */ (function () {
    function DOMUtil() {
    }
    DOMUtil.hasParent = function (node, names) {
        var p = DOMWalker_1.DOMWalker.parentElement(node);
        while (p && !names.includes(p.nodeName)) {
            p = DOMWalker_1.DOMWalker.parentElement(p);
        }
        return !!p;
    };
    DOMUtil.getAncestor = function (node, names) {
        var p = DOMWalker_1.DOMWalker.parentElement(node);
        while (p && !names.includes(p.nodeName.toLowerCase())) {
            p = DOMWalker_1.DOMWalker.parentElement(p);
        }
        return p;
    };
    DOMUtil.sameNode = function (a, b) {
        if (a === b) {
            return true;
        }
        else if (a.isSameNode) {
            return a.isSameNode(b);
        }
        else if (a.compareDocumentPosition) {
            return a.compareDocumentPosition(b) === 0;
        }
        else {
            // Not supported in this environment - try our best
            return true;
        }
    };
    DOMUtil.cleanWhitespace = function (s) {
        var retVal = s.replace(/[ \t\r\n]/g, " ").replace(/ +/g, " ");
        return retVal;
    };
    DOMUtil.cleanSpace = function (s) {
        var retVal = s.replace(/ +/g, " ");
        return retVal;
    };
    // return true if element1 and element2 (cells) are in the same table
    DOMUtil.isInSameTable = function (element1, element2) {
        if (element1 && element2) {
            var parentName = ['table'];
            var parent1 = DOMUtil.getAncestor(element1, parentName);
            var parent2 = DOMUtil.getAncestor(element2, parentName);
            if (parent1 !== null && parent2 != null && DOMUtil.sameNode(parent1, parent2))
                return true;
        }
        return false;
    };
    DOMUtil.shadowRootNode = function (node) {
        var nd = node;
        while (nd != null && nd.nodeType !== 11 /* Node.DOCUMENT_FRAGMENT_NODE */)
            nd = nd.parentNode;
        return nd;
    };
    /**
     * Copies objects, but retains Node attributes as references
     * @param rhs
     */
    DOMUtil.objectCopyWithNodeRefs = function (rhs) {
        if (!rhs)
            return rhs;
        if (typeof rhs !== "object") {
            if (typeof rhs === "function") {
                return rhs;
            }
            else {
                return JSON.parse(JSON.stringify(rhs));
            }
        }
        else if (rhs instanceof Node || !!rhs.nodeType) {
            return rhs;
        }
        else {
            var retVal = void 0;
            if (rhs.constructor.name === "Array") {
                retVal = [];
                for (var _i = 0, rhs_1 = rhs; _i < rhs_1.length; _i++) {
                    var item = rhs_1[_i];
                    retVal.push(this.objectCopyWithNodeRefs(item));
                }
            }
            else {
                retVal = {};
                for (var key in rhs) {
                    retVal[key] = this.objectCopyWithNodeRefs(rhs[key]);
                }
            }
            return retVal;
        }
    };
    DOMUtil.getAncestorWithAttribute = function (element, attrName, attrValue) {
        var walkNode = DOMWalker_1.DOMWalker.parentNode(element);
        while (walkNode !== null) {
            if (walkNode.nodeType === 1 /* Node.ELEMENT_NODE */ && walkNode.getAttribute(attrName) === attrValue)
                return walkNode;
            walkNode = DOMWalker_1.DOMWalker.parentNode(walkNode);
        }
        return null;
    };
    return DOMUtil;
}());
exports.DOMUtil = DOMUtil;


/***/ }),

/***/ 7440:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DOMWalker = void 0;
var VisUtil_1 = __webpack_require__(8656);
/**
 * Walks in a DOM order
 *
 * Assumption that nodes of shadow DOMs call assignSlots on the shadow root before
 * doing other processing in that tree. If you walk into a shadow root, the DOMWalker
 * will do it automatically.
 *
 * See also ../aria/ARIAWalker
 */
var DOMWalker = /** @class */ (function () {
    function DOMWalker(element, bEnd, root, considerHidden, DEBUG) {
        this.DEBUGIDX = 0;
        this.indent = 0;
        this.DEBUG = !!DEBUG;
        this.root = root || ((element && element.ownerDocument) ? element.ownerDocument.documentElement : element);
        if (this.root.nodeType === 9) {
            this.root = this.root.documentElement;
        }
        this.node = element;
        if (this.node.nodeType === 9) {
            this.node = this.node.documentElement;
        }
        this.bEndTag = (bEnd == undefined ? false : bEnd == true);
        this.considerHidden = considerHidden || false;
    }
    DOMWalker.prototype.elem = function () {
        return this.node.nodeType === 1 && this.node || null;
    };
    DOMWalker.parentNode = function (node) {
        if (node === null)
            return null;
        var p = node.parentNode;
        if (node.slotOwner) {
            p = node.slotOwner;
        }
        else if (node.ownerElement) {
            p = node.ownerElement;
        }
        else if (p && p.nodeType === 11) {
            if (p.host) {
                p = p.host;
            }
            else {
                p = null;
            }
        }
        return p;
    };
    DOMWalker.parentElement = function (node) {
        var elem = node;
        do {
            elem = DOMWalker.parentNode(elem);
        } while (elem && elem.nodeType !== 1);
        return elem;
    };
    DOMWalker.assignSlots = function (root) {
        var slots = root.querySelectorAll("slot");
        for (var iSlot = 0; iSlot < slots.length; ++iSlot) {
            var processSlot = slots[iSlot];
            var assignedNodes = processSlot.assignedNodes();
            for (var iAssigned = 0; iAssigned < assignedNodes.length; ++iAssigned) {
                assignedNodes[iAssigned].slotOwner = processSlot;
                assignedNodes[iAssigned].slotIndex = iAssigned;
            }
        }
    };
    DOMWalker.firstChildNotOwnedBySlot = function (node) {
        var retVal = node.firstChild;
        while (retVal && retVal.slotOwner) {
            retVal = retVal.nextSibling;
        }
        return retVal;
    };
    DOMWalker.lastChildNotOwnedBySlot = function (node) {
        var retVal = node.lastChild;
        while (retVal && retVal.slotOwner) {
            retVal = retVal.previousSibling;
        }
        return retVal;
    };
    DOMWalker.nextSiblingNotOwnedBySlot = function (node) {
        var retVal = node.nextSibling;
        while (retVal && retVal.slotOwner) {
            retVal = retVal.nextSibling;
        }
        return retVal;
    };
    DOMWalker.previousSiblingNotOwnedBySlot = function (node) {
        var retVal = node.previousSibling;
        while (retVal && retVal.slotOwner) {
            retVal = retVal.previousSibling;
        }
        return retVal;
    };
    DOMWalker.prototype.atRoot = function () {
        if (this.ownerElement)
            return false;
        if (this.root === this.node) {
            return true;
        }
        else if (this.root.isSameNode) {
            return this.root.isSameNode(this.node);
        }
        else if (this.root.compareDocumentPosition) {
            return this.root.compareDocumentPosition(this.node) === 0;
        }
        else {
            // Not supported in this environment - try our best
            return this.node.parentNode === null;
        }
    };
    DOMWalker.prototype.nextNode = function () {
        var _this = this;
        var indent = function () {
            var s = "";
            for (var idx = 0; idx < _this.indent; ++idx) {
                s += " ";
            }
            return s;
        };
        var DBG = false; //this.DEBUGIDX >= 7 && this.DEBUGIDX <= 10;
        var startName = this.node.nodeName;
        if (!this.node) {
            this.bEndTag = false;
            return false;
        }
        do {
            //console.log(this.node.nodeName, this.bEndTag?"END":"START", this.node.nodeType === 1 && (this.node as any).getAttribute("id"));
            if (!this.bEndTag) {
                var iframeNode = this.node;
                var elementNode = this.node;
                var slotElement = this.node;
                if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && this.node.nodeName.toUpperCase() === "IFRAME"
                    && (this.considerHidden ? VisUtil_1.VisUtil.isNodeVisible(iframeNode) : true)
                    && iframeNode.contentDocument
                    && iframeNode.contentDocument.documentElement) {
                    DBG && console.log("!!!Into Frame");
                    var ownerElement = this.node;
                    this.node = iframeNode.contentDocument.documentElement;
                    this.node.ownerElement = ownerElement;
                }
                else if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && (this.considerHidden ? VisUtil_1.VisUtil.isNodeVisible(elementNode) : true)
                    && elementNode.shadowRoot
                    && elementNode.shadowRoot.firstChild) {
                    DBG && console.log("!!!Into shadow root");
                    var ownerElement = this.node;
                    this.node = elementNode.shadowRoot;
                    this.node.ownerElement = ownerElement;
                    DOMWalker.assignSlots(this.node);
                }
                else if (this.node.nodeType === 1
                    && elementNode.nodeName.toLowerCase() === "slot"
                    && slotElement.assignedNodes().length > 0) {
                    DBG && console.log("!!!Into slot");
                    this.node = slotElement.assignedNodes()[0];
                }
                else if ((this.node.nodeType === 1 /* Node.ELEMENT_NODE */ || this.node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */)
                    && DOMWalker.firstChildNotOwnedBySlot(this.node)) {
                    DBG && console.log("!!!First child");
                    this.node = DOMWalker.firstChildNotOwnedBySlot(this.node);
                }
                else {
                    DBG && console.log("!!!Flip to end tag");
                    this.bEndTag = true;
                }
            }
            else {
                DBG && console.log("!!!1");
                if (this.atRoot()) {
                    DBG && console.log("!!!Done at root");
                    return false;
                }
                else if (this.node.slotOwner) {
                    var slotOwner = this.node.slotOwner;
                    var nextSlotIndex = this.node.slotIndex + 1;
                    // delete (this.node as any).slotOwner;
                    // delete (this.node as any).slotIndex;
                    if (nextSlotIndex < slotOwner.assignedNodes().length) {
                        DBG && console.log("!!!Next slot child");
                        this.node = slotOwner.assignedNodes()[nextSlotIndex];
                        this.bEndTag = false;
                    }
                    else {
                        DBG && console.log("!!!Back up to slot owner");
                        this.node = slotOwner;
                        this.bEndTag = true;
                    }
                }
                else if (this.node.ownerElement) {
                    DBG && console.log("!!!Up to frame owner");
                    this.node = this.node.ownerElement;
                    this.bEndTag = true;
                }
                else if (DOMWalker.nextSiblingNotOwnedBySlot(this.node)) {
                    DBG && console.log("!!!Next sibling");
                    this.node = DOMWalker.nextSiblingNotOwnedBySlot(this.node);
                    this.bEndTag = false;
                }
                else if (this.node.parentNode) {
                    DBG && console.log("!!!Parent");
                    this.node = this.node.parentNode;
                    this.bEndTag = true;
                }
                else {
                    DBG && console.log("!!!Done with walk");
                    return false;
                }
            }
            if (DBG && ((this.node.nodeType !== 1 && this.node.nodeType !== 11 && this.node.nodeType !== 3)
                || (this.node.nodeType === 1 && this.node.getAttribute("aChecker") === "ACE"))) {
                this.DEBUG && console.log(indent() + "<".concat(this.bEndTag ? "/" : "").concat(this.node.nodeName, "> (from ").concat(startName, ") ").concat(this.DEBUGIDX++, " SKIPPED"));
            }
        } while ((this.node.nodeType !== 1 && this.node.nodeType !== 11 && this.node.nodeType !== 3)
            || (this.node.nodeType === 1 && this.node.getAttribute("aChecker") === "ACE"));
        if (this.bEndTag)
            this.indent -= 2;
        this.DEBUG && console.log(indent() + "<".concat(this.bEndTag ? "/" : "").concat(this.node.nodeName, "> (from ").concat(startName, ") ").concat(this.DEBUGIDX++));
        this.DEBUG && this.node.slotOwner && console.log(indent() + "slotOwner: ".concat(this.node.slotOwner.nodeName));
        this.DEBUG && this.node.slotIndex && console.log(indent() + "slotIndex: ".concat(this.node.slotIndex));
        this.DEBUG && this.node.ownerElement && console.log(indent() + "ownerElement: ".concat(this.node.ownerElement.nodeName));
        if (!this.bEndTag)
            this.indent += 2;
        return true;
    };
    DOMWalker.prototype.prevNode = function () {
        do {
            if (this.bEndTag) {
                var iframeNode = this.node;
                var elementNode = this.node;
                if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && this.node.nodeName.toUpperCase() === "IFRAME"
                    && (this.considerHidden ? VisUtil_1.VisUtil.isNodeVisible(iframeNode) : true)
                    && iframeNode.contentDocument
                    && iframeNode.contentDocument.documentElement) {
                    var ownerElement = this.node;
                    this.node = iframeNode.contentDocument.documentElement;
                    this.node.ownerElement = ownerElement;
                }
                else if (this.node.nodeType === 1 /* Node.ELEMENT_NODE */
                    && (this.considerHidden ? VisUtil_1.VisUtil.isNodeVisible(elementNode) : true)
                    && elementNode.shadowRoot
                    && elementNode.shadowRoot.lastChild) {
                    var ownerElement = this.node;
                    this.node = elementNode.shadowRoot;
                    this.node.ownerElement = ownerElement;
                    DOMWalker.assignSlots(this.node);
                }
                else if ((this.node.nodeType === 1 /* Node.ELEMENT_NODE */ || this.node.nodeType === 11)
                    && DOMWalker.lastChildNotOwnedBySlot(this.node)) {
                    this.node = DOMWalker.lastChildNotOwnedBySlot(this.node);
                }
                else {
                    this.bEndTag = false;
                }
            }
            else {
                if (this.atRoot()) {
                    return false;
                }
                else if (DOMWalker.previousSiblingNotOwnedBySlot(this.node)) {
                    this.node = DOMWalker.previousSiblingNotOwnedBySlot(this.node);
                    this.bEndTag = true;
                }
                else if (this.node.ownerElement) {
                    this.node = this.node.ownerElement;
                    this.bEndTag = false;
                }
                else if (this.node.parentNode) {
                    this.node = this.node.parentNode;
                    this.bEndTag = false;
                }
                else {
                    return false;
                }
            }
        } while ((this.node.nodeType !== 1 /* Node.ELEMENT_NODE */ && this.node.nodeType !== 11 && this.node.nodeType !== 3)
            || (this.node.nodeType === 1 && this.node.getAttribute("aChecker") === "ACE"));
        return true;
    };
    return DOMWalker;
}());
exports.DOMWalker = DOMWalker;


/***/ }),

/***/ 1970:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StyleMapper = void 0;
var CommonMapper_1 = __webpack_require__(1794);
var StyleMapper = /** @class */ (function (_super) {
    __extends(StyleMapper, _super);
    function StyleMapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StyleMapper.prototype.getRole = function (node) {
        return "computed";
    };
    StyleMapper.prototype.getNamespace = function () {
        return "css";
    };
    StyleMapper.prototype.getAttributes = function (node) {
        var retVal = {};
        if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
            var elem = node;
            var style = elem.ownerDocument.defaultView.getComputedStyle(elem);
            for (var idx = 0; idx < style.length; ++idx) {
                var name_1 = style[idx].toLowerCase();
                retVal[name_1] = style[name_1];
            }
        }
        return retVal;
    };
    return StyleMapper;
}(CommonMapper_1.CommonMapper));
exports.StyleMapper = StyleMapper;


/***/ }),

/***/ 3005:
/***/ ((__unused_webpack_module, exports) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.eGuidelineType = exports.eGuidelineCategory = exports.eToolkitLevel = void 0;
var eToolkitLevel;
(function (eToolkitLevel) {
    eToolkitLevel["LEVEL_ONE"] = "1";
    eToolkitLevel["LEVEL_TWO"] = "2";
    eToolkitLevel["LEVEL_THREE"] = "3";
    eToolkitLevel["LEVEL_FOUR"] = "4";
})(eToolkitLevel = exports.eToolkitLevel || (exports.eToolkitLevel = {}));
var eGuidelineCategory;
(function (eGuidelineCategory) {
    eGuidelineCategory["ACCESSIBILITY"] = "Accessibility";
    eGuidelineCategory["DESIGN"] = "Design";
    eGuidelineCategory["OTHER"] = "Other";
})(eGuidelineCategory = exports.eGuidelineCategory || (exports.eGuidelineCategory = {}));
var eGuidelineType;
(function (eGuidelineType) {
    eGuidelineType["DEFAULT"] = "default";
    eGuidelineType["EXTENSION"] = "extension";
})(eGuidelineType = exports.eGuidelineType || (exports.eGuidelineType = {}));


/***/ }),

/***/ 4377:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.eRulesetType = exports.eRuleCategory = exports.eToolkitLevel = exports.RuleManual = exports.RulePotential = exports.RuleFail = exports.RuleRender = exports.RulePass = exports.eRulePolicy = exports.eRuleConfidence = void 0;
var eRuleConfidence;
(function (eRuleConfidence) {
    eRuleConfidence["PASS"] = "PASS";
    eRuleConfidence["FAIL"] = "FAIL";
    eRuleConfidence["POTENTIAL"] = "POTENTIAL";
    eRuleConfidence["MANUAL"] = "MANUAL";
})(eRuleConfidence = exports.eRuleConfidence || (exports.eRuleConfidence = {}));
var eRulePolicy;
(function (eRulePolicy) {
    eRulePolicy["VIOLATION"] = "VIOLATION";
    eRulePolicy["RECOMMENDATION"] = "RECOMMENDATION";
    eRulePolicy["INFORMATION"] = "INFORMATION";
})(eRulePolicy = exports.eRulePolicy || (exports.eRulePolicy = {}));
function RulePass(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.PASS],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RulePass = RulePass;
function RuleRender(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.PASS],
        reasonId: 0,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RuleRender = RuleRender;
function RuleFail(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.FAIL],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RuleFail = RuleFail;
function RulePotential(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.POTENTIAL],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RulePotential = RulePotential;
function RuleManual(reasonId, messageArgs, apiArgs) {
    if (typeof reasonId === "undefined" || reasonId === null)
        throw new Error("Reason ID must be defined");
    return {
        value: [eRulePolicy.INFORMATION, eRuleConfidence.MANUAL],
        reasonId: reasonId,
        messageArgs: messageArgs || [],
        apiArgs: apiArgs || []
    };
}
exports.RuleManual = RuleManual;
/**
 * @deprecated See ./IGuideline
 */
var IGuideline_1 = __webpack_require__(3005);
Object.defineProperty(exports, "eToolkitLevel", ({ enumerable: true, get: function () { return IGuideline_1.eToolkitLevel; } }));
/**
 * @deprecated See ./IGuideline:eGuidelineCategory
 */
var IGuideline_2 = __webpack_require__(3005);
Object.defineProperty(exports, "eRuleCategory", ({ enumerable: true, get: function () { return IGuideline_2.eGuidelineCategory; } }));
/**
 * @deprecated See ./IGuideline:eGuidelineType
 */
var IGuideline_3 = __webpack_require__(3005);
Object.defineProperty(exports, "eRulesetType", ({ enumerable: true, get: function () { return IGuideline_3.eGuidelineType; } }));


/***/ }),

/***/ 7884:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Checker = void 0;
var IRule_1 = __webpack_require__(4377);
var Engine_1 = __webpack_require__(9324);
var ARIAMapper_1 = __webpack_require__(4944);
var StyleMapper_1 = __webpack_require__(1970);
var rulesets_1 = __webpack_require__(1070);
var checkRulesV4 = __webpack_require__(8081);
var IGuideline_1 = __webpack_require__(3005);
var checkRules = [];
var checkNls = {};
var checkHelp = {};
function _initialize() {
    var langs = JSON.parse(JSON.stringify(Engine_1.Engine.getLanguages()));
    // Default lang to en-US if nothing else specified is found
    langs.push("en-US");
    // Process V4 rules into the V2 format
    for (var rulename in checkRulesV4) {
        // Convert rule
        var v4Rule = checkRulesV4[rulename];
        checkRules.push(v4Rule);
        // Go backwards because the first lang is the preferred, so
        // earlier languages will override later languages
        for (var idx = langs.length - 1; idx >= 0; --idx) {
            var langId = langs[idx];
            if (langId in v4Rule.messages) {
                checkNls[v4Rule.id] = v4Rule.messages[langId];
                checkNls[v4Rule.id][0] = checkNls[v4Rule.id].group;
            }
            if (langId in v4Rule.help) {
                checkHelp[v4Rule.id] = {};
                for (var reasonId in v4Rule.help[langId]) {
                    checkHelp[v4Rule.id][reasonId] = "/".concat(langId, "/").concat(v4Rule.help[langId][reasonId]);
                }
                checkNls[v4Rule.id][0] = checkNls[v4Rule.id].group;
            }
        }
        // Convert RS
        for (var _i = 0, _a = v4Rule.rulesets; _i < _a.length; _i++) {
            var rsSection = _a[_i];
            for (var _b = 0, _c = rulesets_1.a11yRulesets; _b < _c.length; _b++) {
                var rs = _c[_b];
                var checkRsIds = typeof rsSection.id === "string" ? [rsSection.id] : rsSection.id;
                if (checkRsIds.includes(rs.id)) {
                    for (var _d = 0, _e = rs.checkpoints; _d < _e.length; _d++) {
                        var cp = _e[_d];
                        var checkCPIds = typeof rsSection.num === "string" ? [rsSection.num] : rsSection.num;
                        if (checkCPIds.includes(cp.num)) {
                            cp.rules = cp.rules || [];
                            cp.rules.push({
                                id: v4Rule.id,
                                reasonCodes: rsSection.reasonCodes,
                                level: rsSection.level,
                                toolkitLevel: rsSection.toolkitLevel
                            });
                        }
                    }
                }
            }
        }
    }
}
_initialize();
var Checker = /** @class */ (function () {
    function Checker() {
        this.guidelines = [];
        /**
         * @deprecated Use getGuidelines().
         */
        this.rulesets = this.guidelines;
        /**
         * @deprecated Use getGuidelineIds().
         */
        this.rulesetIds = [];
        this.rulesetRules = {};
        this.ruleLevels = {};
        this.ruleReasonLevels = {};
        this.ruleCategory = {};
        var engine = this.engine = new Engine_1.Engine();
        engine.addMapper(new ARIAMapper_1.ARIAMapper());
        engine.addMapper(new StyleMapper_1.StyleMapper());
        engine.addRules(checkRules);
        engine.addNlsMap(checkNls);
        engine.addHelpMap(checkHelp);
        for (var _i = 0, a11yRulesets_1 = rulesets_1.a11yRulesets; _i < a11yRulesets_1.length; _i++) {
            var rs = a11yRulesets_1[_i];
            this.addRuleset(rs);
        }
    }
    /**
     * Adds a guideline to the engine. If the id already exists, the previous guideline will be replaced.
     * @param guideline
     */
    Checker.prototype.addGuideline = function (guideline) {
        if (guideline.id in this.rulesetRules) {
            this.removeGuideline(guideline.id);
        }
        this.guidelines.push(guideline);
        this.rulesetIds.push(guideline.id);
        var ruleIds = [];
        for (var _i = 0, _a = guideline.checkpoints; _i < _a.length; _i++) {
            var cp = _a[_i];
            cp.rules = cp.rules || [];
            for (var _b = 0, _c = cp.rules; _b < _c.length; _b++) {
                var rule = _c[_b];
                if (rule.enabled !== false) {
                    ruleIds.push(rule.id);
                    //this.ruleLevels[rule.id] = this.ruleLevels[rule.id] || {};
                    //this.ruleLevels[rule.id][guideline.id] = rule.level;
                    this.ruleReasonLevels[rule.id] = this.ruleReasonLevels[rule.id] || {};
                    this.ruleReasonLevels[rule.id][guideline.id] = this.ruleReasonLevels[rule.id][guideline.id] || {};
                    var code = rule.reasonCodes ? rule.reasonCodes.join('--') : "None";
                    this.ruleReasonLevels[rule.id][guideline.id][code] = rule.level;
                    this.ruleCategory[rule.id] = this.ruleCategory[rule.id] || {};
                    this.ruleCategory[rule.id][guideline.id] = guideline.category;
                }
            }
        }
        this.rulesetRules[guideline.id] = ruleIds;
    };
    /**
     * Enable a rule for all guidelines
     * @param ruleId
     */
    Checker.prototype.enableRule = function (ruleId) {
        for (var _i = 0, _a = this.getGuidelines(); _i < _a.length; _i++) {
            var guideline = _a[_i];
            var updated = false;
            for (var _b = 0, _c = guideline.checkpoints; _b < _c.length; _b++) {
                var cp = _c[_b];
                for (var _d = 0, _e = cp.rules; _d < _e.length; _d++) {
                    var rule = _e[_d];
                    if (rule.enabled === false) {
                        updated = true;
                        delete rule.enabled;
                    }
                }
            }
            if (updated) {
                this.addGuideline(guideline);
            }
        }
    };
    /**
     * Disable a rule for all guidelines
     * @param ruleId
     */
    Checker.prototype.disableRule = function (ruleId) {
        for (var _i = 0, _a = this.getGuidelines(); _i < _a.length; _i++) {
            var guideline = _a[_i];
            var updated = false;
            for (var _b = 0, _c = guideline.checkpoints; _b < _c.length; _b++) {
                var cp = _c[_b];
                for (var _d = 0, _e = cp.rules; _d < _e.length; _d++) {
                    var rule = _e[_d];
                    if (rule.enabled !== false) {
                        updated = true;
                        rule.enabled = false;
                    }
                }
            }
            if (updated) {
                this.addGuideline(guideline);
            }
        }
    };
    /**
     * Remove a guideline from the engine
     *
     * Generally, there isn't a good reason to do this. Users should just not select the guideline as an option in check
     * @param guidelineId
     */
    Checker.prototype.removeGuideline = function (guidelineId) {
        if (guidelineId in this.rulesetRules) {
            delete this.rulesetRules[guidelineId];
            this.rulesets = this.guidelines = this.guidelines.filter(function (guideline) { return guideline.id !== guidelineId; });
            this.rulesetIds = this.getGuidelineIds();
        }
    };
    /**
     * Get the guidelines available in the engine
     * @returns
     */
    Checker.prototype.getGuidelines = function () {
        return JSON.parse(JSON.stringify(this.guidelines));
    };
    /**
     * Get the ids of the guidelines available in the engine
     * @returns
     */
    Checker.prototype.getGuidelineIds = function () {
        return this.guidelines.map(function (guideline) { return guideline.id; });
    };
    /**
     *
     * @deprecated See addGuideline
     */
    Checker.prototype.addRuleset = function (rs) {
        this.addGuideline(rs);
    };
    /**
     * Perform a check of the specified node/document
     * @param node DOMNode or Document on which to run the check
     * @param guidelineIds Guideline ids to check with to specify which rules to run
     * @returns
     */
    Checker.prototype.check = function (node, guidelineIds) {
        // Determine which rules to run
        var ruleIds = [];
        // Fix the input
        if (!guidelineIds) {
            ruleIds = this.engine.getRulesIds();
        }
        else {
            if (typeof guidelineIds === "string") {
                guidelineIds = [guidelineIds];
            }
            for (var _i = 0, guidelineIds_1 = guidelineIds; _i < guidelineIds_1.length; _i++) {
                var rsId = guidelineIds_1[_i];
                if (rsId in this.rulesetRules) {
                    ruleIds = ruleIds.concat(this.rulesetRules[rsId]);
                }
            }
        }
        this.engine.enableRules(ruleIds);
        // Add the report levels
        var myThis = this;
        return this.engine.run(node)
            .then(function (report) {
            report.nls = {};
            for (var _i = 0, _a = report.results; _i < _a.length; _i++) {
                var result = _a[_i];
                if (result.ruleId in checkNls) {
                    report.nls[result.ruleId] = report.nls[result.ruleId] || {
                        0: checkNls[result.ruleId][0]
                    };
                    if (result.reasonId in checkNls[result.ruleId]) {
                        report.nls[result.ruleId][result.reasonId] = checkNls[result.ruleId][result.reasonId];
                    }
                }
                //result.value[0] = myThis.getLevel(guidelineIds as string[], result.ruleId);
                var code = result.reasonId ? result.reasonId : "None";
                result.value[0] = myThis.getReasonLevel(guidelineIds, result.ruleId, code);
                result.category = myThis.getCategory(guidelineIds, result.ruleId);
                delete result.path.css;
            }
            return report;
        });
    };
    Checker.prototype.getLevel = function (rsIds, ruleId) {
        if (!rsIds)
            return IRule_1.eRulePolicy.INFORMATION;
        var rsInfo = this.ruleLevels[ruleId];
        var retVal = null;
        if (rsIds) {
            if (!(ruleId in this.ruleLevels)) {
                throw new Error("Rule triggered for which we have no rule level information: " + ruleId);
            }
            for (var _i = 0, rsIds_1 = rsIds; _i < rsIds_1.length; _i++) {
                var rsId = rsIds_1[_i];
                if (rsId in rsInfo) {
                    if (rsInfo[rsId] === IRule_1.eRulePolicy.VIOLATION) {
                        retVal = IRule_1.eRulePolicy.VIOLATION;
                    }
                    else if (rsInfo[rsId] === IRule_1.eRulePolicy.RECOMMENDATION && retVal === null) {
                        retVal = IRule_1.eRulePolicy.RECOMMENDATION;
                    }
                    else if (retVal === null) {
                        retVal = IRule_1.eRulePolicy.INFORMATION;
                    }
                }
            }
        }
        if (retVal === null) {
            throw new Error("Rule triggered for which we have no rule level information: " + ruleId);
        }
        return retVal;
    };
    Checker.prototype.getReasonLevel = function (rsIds, ruleId, reasonCode) {
        if (!rsIds)
            return IRule_1.eRulePolicy.INFORMATION;
        var rsInfo = this.ruleReasonLevels[ruleId];
        var retVal = null;
        if (rsIds) {
            if (!(ruleId in this.ruleReasonLevels)) {
                throw new Error("Rule triggered for which we have no rule level information " + ruleId);
            }
            var _loop_1 = function (rsId) {
                if (rsId in rsInfo) {
                    var reCode_1 = new RegExp("(^|--)".concat(reasonCode, "($|--)"));
                    Object.keys(rsInfo[rsId]).forEach(function (code) {
                        var level = null;
                        if (code === 'None')
                            level = rsInfo[rsId]["None"];
                        else if (reCode_1.test(code))
                            level = rsInfo[rsId][code];
                        if (level !== null) {
                            if (level === IRule_1.eRulePolicy.VIOLATION) {
                                retVal = IRule_1.eRulePolicy.VIOLATION;
                            }
                            else if (level === IRule_1.eRulePolicy.RECOMMENDATION && retVal === null) {
                                retVal = IRule_1.eRulePolicy.RECOMMENDATION;
                            }
                            else if (retVal === null) {
                                retVal = IRule_1.eRulePolicy.INFORMATION;
                            }
                        }
                    });
                    if (retVal === null) {
                        retVal = IRule_1.eRulePolicy.INFORMATION;
                    }
                }
            };
            for (var _i = 0, rsIds_2 = rsIds; _i < rsIds_2.length; _i++) {
                var rsId = rsIds_2[_i];
                _loop_1(rsId);
            }
        }
        if (retVal === null) {
            throw new Error("Rule triggered for which we have no rule level information: " + ruleId);
        }
        return retVal;
    };
    Checker.prototype.getCategory = function (rsIds, ruleId) {
        var rsInfo = this.ruleCategory[ruleId];
        var retVal = "";
        if (!(ruleId in this.ruleCategory)) {
            return IGuideline_1.eGuidelineCategory.OTHER;
        }
        if (!rsIds) {
            rsIds = this.getGuidelineIds();
        }
        for (var _i = 0, rsIds_3 = rsIds; _i < rsIds_3.length; _i++) {
            var rsId = rsIds_3[_i];
            if (rsId in rsInfo) {
                return rsInfo[rsId];
            }
        }
        return IGuideline_1.eGuidelineCategory.OTHER;
    };
    return Checker;
}());
exports.Checker = Checker;


/***/ }),

/***/ 8980:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.a_target_warning = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.a_target_warning = {
    id: "a_target_warning",
    context: "dom:a[target],dom:area[target],dom:base[target]",
    refactor: {
        "WCAG20_A_TargetAndText": {
            "Pass_0": "pass",
            "Potential_1": "potential_warn"
        }
    },
    help: {
        "en-US": {
            "group": "a_target_warning.html",
            "pass": "a_target_warning.html",
            "potential_warn": "a_target_warning.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Users should be warned in advance if their input action will open a new window",
            "pass": "The user is warned in advance that the input action opens a new window",
            "potential_warn": "Inform the user when their input action will open a new window"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "3.2.2",
            level: IRule_2.eRulePolicy.RECOMMENDATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // skip the rule if it's AT hidden and not tabbable
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) && !CommonUtil_1.CommonUtil.isTabbable(ruleContext))
            return null;
        var params = {
            paramWinText: {
                value: ["new window", "new tab"],
                type: "array"
            }
        };
        var tStr = ruleContext.getAttribute("target");
        var passed = tStr == "_parent" || tStr == "_self" || tStr == "_top" || CommonUtil_1.CommonUtil.getFrameByName(ruleContext, tStr) != null;
        if (!passed) {
            // Name is not part of this frameset  must have potential to create new window?
            // See if a new window is mentioned
            var textStr = CommonUtil_1.CommonUtil.getInnerText(ruleContext);
            if (ruleContext.hasAttribute("title"))
                textStr += " " + ruleContext.getAttribute("title");
            for (var i = 0; !passed && i < params.paramWinText.value.length; ++i)
                if (textStr.indexOf(params.paramWinText.value[i]) != -1)
                    passed = true;
        }
        return passed ? (0, IRule_1.RulePass)("pass") : (0, IRule_1.RulePotential)("potential_warn");
    }
};


/***/ }),

/***/ 3961:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.a_text_purpose = void 0;
var IRule_1 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
var IRule_2 = __webpack_require__(4377);
var AccNameUtil_1 = __webpack_require__(1421);
exports.a_text_purpose = {
    id: "a_text_purpose",
    // doc-biblioref is a link
    context: "aria:link,aria:doc-biblioref",
    refactor: {
        "WCAG20_A_HasText": {
            "Pass_0": "pass",
            "Fail_1": "fail_acc_name"
        }
    },
    help: {
        "en-US": {
            "group": "a_text_purpose.html",
            "pass": "a_text_purpose.html",
            "fail_acc_name": "a_text_purpose.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Hyperlinks must have an accessible name for their purpose",
            "pass": "Hyperlink has a description of its purpose",
            "fail_acc_name": "Hyperlink has no link text, label or image with a text alternative"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: ["2.4.4", "4.1.2"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: "c487ae",
    run: function (context, options) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext)) {
            return null;
        }
        // Rule only passes if an element has inner content,
        // in the case that there is only hidden content under the the element it is a violation
        var accName_pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(ruleContext);
        var passed = (accName_pair && accName_pair.name && accName_pair.name.trim().length > 0)
            /**ARIAMapper.computeName(ruleContext).trim().length > 0*/
            || CommonUtil_1.CommonUtil.nonTabableChildCheck(ruleContext);
        if (!passed) {
            return (0, IRule_1.RuleFail)("fail_acc_name");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 1445:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.applet_alt_exists = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.applet_alt_exists = {
    id: "applet_alt_exists",
    context: "dom:applet",
    refactor: {
        "WCAG20_Applet_HasAlt": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
        }
    },
    help: {
        "en-US": {
            "group": "applet_alt_exists.html",
            "Pass_0": "applet_alt_exists.html",
            "Fail_1": "applet_alt_exists.html",
            "Fail_2": "applet_alt_exists.html",
            "Fail_3": "applet_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "<applet> elements must provide an 'alt' attribute and an alternative description",
            "Pass_0": "Rule Passed",
            "Fail_1": "An <applet> element does not have an 'alt' attribute that provides a short text alternative",
            "Fail_2": "The 'alt' attribute value for an <applet> element duplicates the 'code' attribute",
            "Fail_3": "An <applet> element provides alternative text, but does not provide inner content"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "1.1.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        // JCH - NO OUT OF SCOPE hidden in context
        if (!CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "alt")) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            var alt = ruleContext.getAttribute("alt").trim();
            if (ruleContext.hasAttribute("code") && alt == ruleContext.getAttribute("code").trim()) {
                return (0, IRule_1.RuleFail)("Fail_2");
            }
            else if (!CommonUtil_1.CommonUtil.hasInnerContentHidden(ruleContext)) {
                return (0, IRule_1.RuleFail)("Fail_3");
            }
            else {
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
    }
};


/***/ }),

/***/ 876:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.application_content_accessible = void 0;
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.application_content_accessible = {
    id: "application_content_accessible",
    context: "aria:application",
    refactor: {
        "HAAC_Application_Role_Text": {
            0: "HAAC_Application_Role_Text.html",
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            0: "application_content_accessible.html",
            "Pass_0": "application_content_accessible.html",
            "Potential_1": "application_content_accessible.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Non-decorative static text and image content within an element with \"application\" role must be accessible",
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that the non-decorative static text and image content within an element with \"application\" role are accessible"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: ["1.1.1", "2.1.1"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = true;
        var children = ruleContext.childNodes;
        for (var i = 0; passed && i < children.length; i++) {
            if (children[i].nodeType === 1) {
                if (VisUtil_1.VisUtil.isNodeVisible(children[i])) {
                    passed = AriaUtil_1.AriaUtil.hasRoleInSemantics(children[i], "document") || AriaUtil_1.AriaUtil.hasRoleInSemantics(children[i], "article");
                }
            }
            else if (children[i].nodeType === 3) {
                passed = children[i].nodeValue.trim().length === 0;
            }
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 2768:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.area_alt_exists = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.area_alt_exists = {
    id: "area_alt_exists",
    context: "dom:area",
    refactor: {
        "WCAG20_Area_HasAlt": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "area_alt_exists.html",
            "Pass_0": "area_alt_exists.html",
            "Fail_1": "area_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "<area> elements in an image map must have a text alternative",
            "Pass_0": "Rule Passed",
            "Fail_1": "<area> element in an image map has no text alternative"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "1.1.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        // JCH - NO OUT OF SCOPE hidden in context
        if (CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "alt")) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
    }
};


/***/ }),

/***/ 2533:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_accessiblename_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
var AccNameUtil_1 = __webpack_require__(1421);
var ARIADefinitions_1 = __webpack_require__(8235);
exports.aria_accessiblename_exists = {
    id: "aria_accessiblename_exists",
    context: "aria:columnheader, aria:heading, aria:rowheader, aria:graphics-document,aria:graphics-symbol, aria:img,aria:image, doc-backlink, doc-biblioentry, doc-biblioref, doc-glossref, doc-noteref, doc-pagebreak, doc-example",
    help: {
        "en-US": {
            "pass": "aria_accessiblename_exists.html",
            "fail_no_accessible_name": "aria_accessiblename_exists.html",
            "fail_no_accessible_name_image": "aria_accessiblename_exists.html",
            "group": "aria_accessiblename_exists.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "An accessible name is provided for the element",
            "fail_no_accessible_name": "Element <{0}> with \"{1}\" role has no accessible name",
            "fail_no_accessible_name_image": "Element <{0}> with \"{1}\" role has no accessible name",
            "group": "Elements with certain roles should have accessible names"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE,
            reasonCodes: ["fail_no_accessible_name"]
        },
        {
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["ARIA"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE,
            reasonCodes: ["fail_no_accessible_name_image"]
        }],
    act: [{ "23a2a8": { "fail_no_accessible_name_image": "fail" } }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var nodeName = ruleContext.nodeName.toLocaleLowerCase();
        // svg element is handled in svg_graphics_labbelled rule and image rules
        if (nodeName === 'svg' || nodeName === 'img')
            return;
        // when table element with a caption as first child
        if (nodeName === 'table'
            && ruleContext.firstElementChild && ruleContext.firstElementChild.nodeName.toLowerCase() === 'caption'
            && ruleContext.firstElementChild.textContent && ruleContext.firstElementChild.textContent.trim().length > 0)
            return (0, IRule_1.RulePass)("pass");
        var invalidRoles = AriaUtil_1.AriaUtil.getRolesUndefinedByAria(ruleContext);
        if (invalidRoles && invalidRoles.length > 0)
            return null;
        var deprecatedRoles = AriaUtil_1.AriaUtil.getDeprecatedAriaRoles(ruleContext);
        if (deprecatedRoles && deprecatedRoles.length > 0)
            return null;
        var deprecatedAttributes = AriaUtil_1.AriaUtil.getDeprecatedAriaAttributes(ruleContext);
        if (deprecatedAttributes && deprecatedAttributes.length > 0)
            return null;
        var role = AriaUtil_1.AriaUtil.getResolvedRole(ruleContext);
        if (!role || !ARIADefinitions_1.ARIADefinitions.designPatterns[role] || !ARIADefinitions_1.ARIADefinitions.designPatterns[role].nameRequired)
            return null;
        var name_pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(ruleContext);
        if (!name_pair || !name_pair.name || name_pair.name.trim().length === 0) {
            if (role === 'img' || role === 'image')
                return (0, IRule_1.RuleFail)("fail_no_accessible_name_image", [ruleContext.nodeName.toLowerCase(), role]);
            return (0, IRule_1.RuleFail)("fail_no_accessible_name", [ruleContext.nodeName.toLowerCase(), role]);
        }
        return (0, IRule_1.RulePass)("pass");
    }
};


/***/ }),

/***/ 7178:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_activedescendant_tabindex_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.aria_activedescendant_tabindex_valid = {
    id: "aria_activedescendant_tabindex_valid",
    context: "dom:*[aria-activedescendant]",
    refactor: {
        "Rpt_Aria_InvalidTabindexForActivedescendant": {
            "pass": "pass",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_activedescendant_tabindex_valid.html",
            "Fail_1": "aria_activedescendant_tabindex_valid.html",
            "group": "aria_activedescendant_tabindex_valid.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "Fail_1": "The <{0}> element using 'aria-activedescendant' set to \"{1}\" is not tabbable",
            "group": "Element using 'aria-activedescendant' property should be tabbable"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = false;
        var nodeName = ruleContext.nodeName.toLowerCase();
        // Rule not supported on mobile
        if (ruleContext.hasAttribute("class") && ruleContext.getAttribute("class").substring(0, 3) == "mbl") {
            return null;
        }
        // Handle the case where the element is hidden by a disabled HTML5 attribute or aria-disabled:
        //  1. In the case that this element has a disabled attribute and the element supports it, we mark this rule as passed.
        //  2. In the case that this element has an aria-disabled attribute then, we mark this rule as passed.
        // For both of the cases above we do not need to perform any further checks, as the element is disabled in some form or another.
        if (CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext)) {
            return null;
        }
        //ignore if the attribute 'aria-activedescendant' is blank
        if (ruleContext.getAttribute("aria-activedescendant").trim().length === 0)
            return;
        // If the tabindex attribute is provided then verify that it is 0 or -1
        passed = CommonUtil_1.CommonUtil.isTabbable(ruleContext);
        // pass if one of the children is tabbable. in this case, the tab will stop on the first tabbable element
        if (!passed)
            passed = CommonUtil_1.CommonUtil.getTabbableChildren(ruleContext) > 0;
        // Build array for node token
        var retToken1 = new Array();
        retToken1.push(nodeName);
        // Build array for id referenced by aria-activedescendant
        var retToken2 = new Array();
        retToken2.push(ruleContext.getAttribute("aria-activedescendant").split(" ").join(", "));
        //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [retToken1, retToken2]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [retToken1.toString(), retToken2.toString()]);
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 9745:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_activedescendant_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var fragment_1 = __webpack_require__(482);
var VisUtil_1 = __webpack_require__(8656);
var DOMUtil_1 = __webpack_require__(295);
exports.aria_activedescendant_valid = {
    id: "aria_activedescendant_valid",
    context: "dom:*[aria-activedescendant]",
    refactor: {
        "HAAC_ActiveDescendantCheck": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
            // "Fail_4": "Fail_4"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_activedescendant_valid.html",
            "Fail_1": "aria_activedescendant_valid.html",
            "Fail_2": "aria_activedescendant_valid.html",
            "Fail_3": "aria_activedescendant_valid.html",
            // "Fail_4": "aria_activedescendant_valid.html",
            "group": "aria_activedescendant_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The 'aria-activedescendant' property is empty",
            "Fail_2": "The 'aria-activedescendant' property references a hidden node",
            "Fail_3": "Element is not a combobox, and the referenced active-descendant element is not a valid descendant",
            // "Fail_4": "Element is a combobox, and the referenced active-descendant element is not controlled by this component",
            "group": "The 'aria-activedescendant' property must reference the 'id' of a non-empty, non-hidden active child element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // combobox active descendants handled by 'combobox_active_descendant'
        if (AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, "combobox")) {
            return null;
        }
        var descendant_id = AriaUtil_1.AriaUtil.getAriaAttribute(ruleContext, "aria-activedescendant");
        // POF1: The attribute is empty
        if (!descendant_id || descendant_id.trim() === "") {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        var descendant = fragment_1.FragmentUtil.getById(ruleContext, descendant_id.trim());
        if (!descendant || DOMUtil_1.DOMUtil.sameNode(descendant_id, ruleContext)) {
            // The referenced element doesn't exist. We let 1077 to trigger the error
            return null;
        }
        if (!VisUtil_1.VisUtil.isNodeVisible(descendant)) {
            // POF2: aria-activedescendant references a hidden node
            return (0, IRule_1.RuleFail)("Fail_2");
        }
        // 1. The value of aria-activedescendant refers to an element that is either a descendant of 
        // the element with DOM focus
        if (ruleContext.contains(descendant)) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        var pofId = 2;
        // or is a logical descendant as indicated by the aria-owns attribute.
        if (ruleContext.hasAttribute("aria-owns")) {
            var owned_ids = CommonUtil_1.CommonUtil.normalizeSpacing(ruleContext.getAttribute("aria-owns").trim()).split(" ");
            for (var i = 0; i < owned_ids.length; i++) {
                var owned_ele = fragment_1.FragmentUtil.getById(ruleContext, owned_ids[i]);
                if (owned_ele && !DOMUtil_1.DOMUtil.sameNode(owned_ele, ruleContext) && owned_ele.contains(descendant)) {
                    return (0, IRule_1.RulePass)("Pass_0");
                }
            }
        }
        // 2. The element with DOM focus is a textbox with aria-controls referring to an element that 
        //  supports aria-activedescendant, and the value of aria-activedescendant specified for the 
        //  textbox refers to either a descendant of the element controlled by the textbox or is a logical 
        //  descendant of that controlled element as indicated by the aria-owns attribute.
        //
        if (AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, "textbox") && ruleContext.hasAttribute("aria-controls")) {
            pofId = 3;
            var controlled_ids = CommonUtil_1.CommonUtil.normalizeSpacing(ruleContext.getAttribute("aria-controls").trim()).split(" ");
            for (var i = 0; i < controlled_ids.length; i++) {
                var controlled_ele = fragment_1.FragmentUtil.getById(ruleContext, controlled_ids[i]);
                if (controlled_ele && !DOMUtil_1.DOMUtil.sameNode(controlled_ele, ruleContext) && controlled_ele.contains(descendant)) {
                    return (0, IRule_1.RulePass)("Pass_0");
                }
                if (controlled_ele.hasAttribute("aria-owns")) {
                    var owns_ids = CommonUtil_1.CommonUtil.normalizeSpacing(controlled_ele.getAttribute("aria-owns").trim()).split(" ");
                    for (var j = 0; j < owns_ids.length; j++) {
                        var owned_ele = fragment_1.FragmentUtil.getById(ruleContext, owns_ids[j]);
                        if (owned_ele && !DOMUtil_1.DOMUtil.sameNode(owned_ele, ruleContext) && owned_ele.contains(descendant)) {
                            return (0, IRule_1.RulePass)("Pass_0");
                        }
                    }
                }
            }
        }
        // POF3: I'm not a combobox, and the referenced active-descendant is not a descendant and not owned by the element 
        // that referenced it.
        if (pofId == 3) {
            return (0, IRule_1.RuleFail)("Fail_3");
        }
        return null;
    }
};


/***/ }),

/***/ 8019:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_application_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_application_label_unique = {
    id: "aria_application_label_unique",
    context: "aria:application",
    refactor: {
        "Rpt_Aria_MultipleApplicationLandmarks": {
            "Pass_0": "pass",
            "Fail_1": "fail_label_not_unique"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_application_label_unique.html",
            "fail_label_not_unique": "aria_application_label_unique.html",
            "group": "aria_application_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element with \"application\" role has a unique label that describes its purpose",
            "fail_label_not_unique": "Multiple elements with \"application\" role do not have unique labels",
            "group": "Each element with \"application\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var dupped = AriaUtil_1.AriaUtil.isLandmarkNameUnique(ruleContext, "application");
        if (dupped == null)
            return null;
        if (dupped) {
            return (0, IRule_1.RuleFail)("fail_label_not_unique");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 6505:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_application_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AccNameUtil_1 = __webpack_require__(1421);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_application_labelled = {
    id: "aria_application_labelled",
    context: "aria:application",
    refactor: {
        "Rpt_Aria_ApplicationLandmarkLabel": {
            "Pass_0": "pass",
            "Fail_1": "fail_no_label"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_application_labelled.html",
            "fail_no_label": "aria_application_labelled.html",
            "group": "aria_application_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element with \"application\" role has a label that describes its purpose",
            "fail_no_label": "Element with \"application\" role does not have a label",
            "group": "Each element with \"application\" role must have a label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(ruleContext);
        if (!pair) {
            return (0, IRule_1.RuleFail)("fail_no_label");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 8910:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_article_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
var AriaUtil_1 = __webpack_require__(490);
exports.aria_article_label_unique = {
    id: "aria_article_label_unique",
    context: "aria:article",
    refactor: {
        "Rpt_Aria_MultipleArticleRoles_Implicit": {
            "Pass_0": "pass",
            "Fail_1": "fail_label_not_unique"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_article_label_unique.html",
            "fail_label_not_unique": "aria_article_label_unique.html",
            "group": "aria_article_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element with \"article\" role has a unique label that describes its purpose",
            "fail_label_not_unique": "Multiple elements with \"article\" role do not have unique labels",
            "group": "Each element with \"article\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var dupped = AriaUtil_1.AriaUtil.isLandmarkNameUnique(ruleContext, "article");
        if (dupped == null)
            return null;
        if (dupped) {
            return (0, IRule_1.RuleFail)("fail_label_not_unique");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 3492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_allowed = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var ARIADefinitions_1 = __webpack_require__(8235);
var AriaUtil_1 = __webpack_require__(490);
exports.aria_attribute_allowed = {
    id: "aria_attribute_allowed",
    context: "dom:*",
    refactor: {
        "Rpt_Aria_ValidProperty": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_attribute_allowed.html",
            "Pass_0": "aria_attribute_allowed.html",
            "Fail_1": "aria_attribute_allowed.html"
        }
    },
    messages: {
        "en-US": {
            "group": "ARIA attributes must be valid for the element's role",
            "Pass_0": "Rule Passed",
            "Fail_1": "The attribute(s) '{0}' referenced by the element <{1}> is not a valid ARIA state or property"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "4.1.2",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "5f99a7",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var contextAttributes = ruleContext.attributes;
        // This gets all elements with attributes so we still have some
        // Out of Scope since not all attributes are aria 
        if (contextAttributes) {
            var propertyDataTypes = ARIADefinitions_1.ARIADefinitions.propertyDataTypes;
            var failedProperties = "";
            var testedProperties = 0;
            for (var i = 0, length_1 = contextAttributes.length; i < length_1; i++) {
                var attrName = contextAttributes[i].name;
                if (AriaUtil_1.AriaUtil.isDefinedAriaAttribute(ruleContext, attrName)) {
                    testedProperties++;
                    // Now we just have aria attributes which can
                    // pass or fail based on whether there property is valid
                    var dataTypes = propertyDataTypes[attrName];
                    if (!dataTypes) { // if property is not in valid property list
                        // create failedProperties comma sep list
                        if (failedProperties.length == 0) {
                            failedProperties = attrName;
                        }
                        else {
                            failedProperties = failedProperties + ", " + attrName;
                        }
                    }
                }
            }
            if (testedProperties == 0) {
                return null;
            }
            else if (failedProperties.length != 0) {
                return (0, IRule_1.RuleFail)("Fail_1", [failedProperties, ruleContext.nodeName.toLowerCase()]);
            }
            else {
                //return RulePass(1);
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
        else {
            return null;
        }
        // JCH - passing is based on all attributes not just aria attributes
        //       leading to OVER COUNTING so moved pass up
        //return RulePass(1);
    }
};


/***/ }),

/***/ 5316:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_conflict = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
exports.aria_attribute_conflict = {
    id: "aria_attribute_conflict",
    context: "dom:*[aria-required], dom:*[aria-autocomplete], dom:*[aria-readonly], dom:*[aria-disabled], dom:*[aria-placeholder]"
        + ", dom:*[aria-checked], dom:*[aria-hidden], dom:*[aria-valuemax], dom:*[aria-valuemin], dom:*[aria-colspan]"
        + ", dom:*[aria-rowspan]",
    help: {
        "en-US": {
            // "pass": "aria_attribute_conflict.html",
            "fail_conflict": "aria_attribute_conflict.html",
            "group": "aria_attribute_conflict.html"
        }
    },
    messages: {
        "en-US": {
            // "pass": "The ARIA attribute is not conflict with the corresponding HTML attribute",
            "fail_conflict": "The ARIA attribute \"{0}\" is in conflict with the corresponding HTML attribute \"{1}\"",
            "group": "An ARIA attribute must not conflict with the corresponding HTML attribute"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // dependency check: if the ARIA attribute is completely invalid, skip this check
        var invalidAttributes = AriaUtil_1.AriaUtil.getInvalidAriaAttributes(ruleContext);
        if (invalidAttributes && invalidAttributes.length > 0)
            return null;
        var ret = [];
        var ariaAttributes = AriaUtil_1.AriaUtil.getUserDefinedAriaAttributes(ruleContext);
        if (!ariaAttributes || ariaAttributes.length === 0)
            return null;
        var conflictAttributes = AriaUtil_1.AriaUtil.getConflictAriaAndHtmlAttributes(ruleContext);
        for (var i = 0; i < conflictAttributes.length; i++) {
            ret.push((0, IRule_1.RuleFail)("fail_conflict", [conflictAttributes[i]['ariaAttr'], conflictAttributes[i]['htmlAttr']]));
            if (ariaAttributes.includes(conflictAttributes[i]['ariaAttr']))
                CommonUtil_1.CommonUtil.reduceArrayItemList([conflictAttributes[i]['ariaAttr']], ariaAttributes);
        }
        if (ret.length > 0)
            return ret;
        return null;
    }
};


/***/ }),

/***/ 8412:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_deprecated = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
exports.aria_attribute_deprecated = {
    id: "aria_attribute_deprecated",
    context: "dom:*",
    help: {
        "en-US": {
            // "pass": "aria_attribute_deprecated.html",
            "fail_aria_role": "aria_attribute_deprecated.html",
            "fail_aria_attr": "aria_attribute_deprecated.html",
            "fail_role_attr": "aria_attribute_deprecated.html",
            "group": "aria_attribute_deprecated.html"
        }
    },
    messages: {
        "en-US": {
            // "pass": "The ARIA roles and attribute are used per specification",
            "fail_aria_role": "The ARIA role \"{0}\" is deprecated in the ARIA specification",
            "fail_aria_attr": "The ARIA attributes \"{0}\" are deprecated in the ARIA specification",
            "fail_role_attr": "The ARIA attributes \"{0}\" are deprecated for the role \"{1}\" in the ARIA specification",
            "group": "No deprecated ARIA role or attribute should be used"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next"],
            "num": ["ARIA"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var ret = [];
        var deprecatedRoles = AriaUtil_1.AriaUtil.getDeprecatedAriaRoles(ruleContext);
        if (deprecatedRoles && deprecatedRoles.length > 0) {
            for (var i = 0; i < deprecatedRoles.length; i++)
                ret.push((0, IRule_1.RuleFail)('fail_aria_role', [deprecatedRoles[i]]));
        }
        var deprecatedAttributes = AriaUtil_1.AriaUtil.getDeprecatedAriaAttributes(ruleContext);
        if (deprecatedAttributes && deprecatedAttributes.length > 0) {
            for (var i = 0; i < deprecatedAttributes.length; i++) {
                // "role":"any", "attribute":ariaAttrs[i]}
                if (deprecatedAttributes[i].role === 'any')
                    ret.push((0, IRule_1.RuleFail)('fail_aria_attr', [deprecatedAttributes[i].attribute]));
                else
                    ret.push((0, IRule_1.RuleFail)('fail_role_attr', [deprecatedAttributes[i].attribute, deprecatedAttributes[i].role]));
            }
        }
        if (ret.length > 0)
            return ret;
        return null;
    }
};


/***/ }),

/***/ 172:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var ARIADefinitions_1 = __webpack_require__(8235);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_attribute_exists = {
    id: "aria_attribute_exists",
    context: "dom:*[role]",
    dependencies: ["aria_role_allowed"],
    refactor: {
        "Rpt_Aria_EmptyPropertyValue": {
            "pass": "pass",
            "fail_empty_attribute": "fail_empty_attribute"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_attribute_exists.html",
            "fail_empty_attribute": "aria_attribute_exists.html",
            "group": "aria_attribute_exists.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "fail_empty_attribute": "The element attribute(s): '{0}' value is empty",
            "group": "When specifying a required ARIA attribute, the value must not be empty"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: ["6a7281"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return;
        var attrNameArr = new Array();
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        var hasAttribute = CommonUtil_1.CommonUtil.hasAttribute;
        var testedProperties = 0;
        var role = AriaUtil_1.AriaUtil.getResolvedRole(ruleContext);
        if (!role)
            return;
        if (designPatterns[role] && AriaUtil_1.AriaUtil.getRoleRequiredProperties(role, ruleContext) != null) {
            var requiredRoleProps = AriaUtil_1.AriaUtil.getRoleRequiredProperties(role, ruleContext);
            for (var i = 0, length_1 = requiredRoleProps.length; i < length_1; i++) {
                var attribute = requiredRoleProps[i];
                if (hasAttribute(ruleContext, attribute)) {
                    testedProperties++;
                    var nodeValue = CommonUtil_1.CommonUtil.normalizeSpacing(ruleContext.getAttribute(requiredRoleProps[i]));
                    if (nodeValue.length == 0)
                        attrNameArr.push(requiredRoleProps[i]);
                }
                else if (requiredRoleProps[i] == "aria-labelledby") {
                    if ((role == "radiogroup") && (hasAttribute(ruleContext, "aria-label"))) {
                        testedProperties++;
                        var nodeValue = CommonUtil_1.CommonUtil.normalizeSpacing(ruleContext.getAttribute("aria-label"));
                        if (nodeValue.length == 0)
                            attrNameArr.push("aria-label");
                    }
                }
                else if (requiredRoleProps[i] == "aria-valuenow") {
                    if ((role == "progressbar") && (hasAttribute(ruleContext, "aria-valuetext"))) {
                        testedProperties++;
                        var nodeValue = CommonUtil_1.CommonUtil.normalizeSpacing(ruleContext.getAttribute("aria-valuetext"));
                        if (nodeValue.length == 0)
                            attrNameArr.push("aria-valuetext");
                    }
                }
            }
        }
        if (designPatterns[role]) {
            var tagProperty = AriaUtil_1.AriaUtil.getElementAriaProperty(ruleContext);
            var permittedRoles = [];
            permittedRoles.push(role);
            var allowedAttributes = AriaUtil_1.AriaUtil.getAllowedAriaAttributes(ruleContext, permittedRoles, tagProperty);
            for (var i = 0, length_2 = allowedAttributes.length; i < length_2; i++) {
                var attribute = allowedAttributes[i];
                if (attribute == "aria-checked" || attribute == "aria-selected" ||
                    attribute == "aria-expanded" || attribute == "aria-orientation" ||
                    attribute == "aria-level") {
                    if (hasAttribute(ruleContext, attribute)) {
                        testedProperties++;
                        var nodeValue = CommonUtil_1.CommonUtil.normalizeSpacing(ruleContext.getAttribute(attribute));
                        if (nodeValue.length == 0 && !attrNameArr.includes(attribute)) {
                            attrNameArr.push(attribute);
                        }
                    }
                }
            }
        }
        var retMsg = new Array();
        var passed = attrNameArr.length == 0;
        retMsg.push(attrNameArr.join(", "));
        //return new ValidationResult(passed, [ruleContext], attrNameArr, '', retMsg);
        if (testedProperties == 0) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("fail_empty_attribute", retMsg);
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 9844:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_redundant = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
exports.aria_attribute_redundant = {
    id: "aria_attribute_redundant",
    context: "dom:*[aria-required], dom:*[aria-autocomplete], dom:*[aria-readonly], dom:*[aria-disabled], dom:*[aria-placeholder]"
        + ", dom:*[aria-checked], dom:*[aria-hidden], dom:*[aria-valuemax], dom:*[aria-valuemin], dom:*[aria-colspan]"
        + ", dom:*[aria-rowspan]",
    help: {
        "en-US": {
            "pass": "aria_attribute_redundant.html",
            "fail_redundant": "aria_attribute_redundant.html",
            "group": "aria_attribute_redundant.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The ARIA attribute is not redundant with a corresponding HTML attribute",
            "fail_redundant": "The ARIA attribute \"{0}\" is redundant with the HTML attribute \"{1}\"",
            "group": "An ARIA attribute should not be redundant with a corresponding HTML attribute"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // dependency check: if the ARIA attribute is completely invalid, skip this check
        var invalidAttributes = AriaUtil_1.AriaUtil.getInvalidAriaAttributes(ruleContext);
        if (invalidAttributes && invalidAttributes.length > 0)
            return null;
        // if conflict already reported, ignore reporting overlap
        var conflictAttributes = AriaUtil_1.AriaUtil.getConflictAriaAndHtmlAttributes(ruleContext);
        if (conflictAttributes && conflictAttributes.length > 0)
            return null;
        var domAttributes = ruleContext.attributes;
        var ariaAttrs = [];
        var htmlAttrs = [];
        if (domAttributes) {
            for (var i = 0; i < domAttributes.length; i++) {
                var attrName = domAttributes[i].name.trim().toLowerCase();
                var attrValue = ruleContext.getAttribute(attrName);
                if (attrValue === '')
                    attrValue = null;
                if (attrName.substring(0, 5) === 'aria-')
                    ariaAttrs.push({ name: attrName, value: attrValue });
                else
                    htmlAttrs.push({ name: attrName, value: attrValue });
            }
        }
        var ret = [];
        var _loop_1 = function (i) {
            var examinedHtmlAtrNames = AriaUtil_1.AriaUtil.getConflictOrOverlappingHtmlAttribute(ariaAttrs[i], htmlAttrs, 'overlapping');
            if (examinedHtmlAtrNames === null)
                return "continue";
            examinedHtmlAtrNames.forEach(function (item) {
                if (item['result'] === 'Pass') { //pass
                    ret.push((0, IRule_1.RulePass)("pass"));
                }
                else if (item['result'] === 'Failed') { //failed
                    ret.push((0, IRule_1.RuleFail)("fail_redundant", [ariaAttrs[i]['name'], item['attr']]));
                }
            });
        };
        for (var i = 0; i < ariaAttrs.length; i++) {
            _loop_1(i);
        }
        if (ret.length > 0)
            return ret;
        return null;
    }
};


/***/ }),

/***/ 9695:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_required = void 0;
var ARIADefinitions_1 = __webpack_require__(8235);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.aria_attribute_required = {
    id: "aria_attribute_required",
    context: "dom:*[role]",
    dependencies: ["aria_role_allowed"],
    refactor: {
        "Rpt_Aria_RequiredProperties": {
            "Pass_0": "pass",
            "Fail_1": "fail_missing"
        }
    },
    help: {
        "en-US": {
            "group": "aria_attribute_required.html",
            "pass": "aria_attribute_required.html",
            "fail_missing": "aria_attribute_required.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The required attributes for the element with a role must be defined",
            "pass": "The required attributes for the element with the role are defined",
            "fail_missing": "Element with '{0}' role does not have the required ARIA attribute(s): '{1}'"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "4.1.2",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "4e8ab6",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var attrNameArr = new Array();
        var roleNameArr = new Array();
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        //let implicitRole = ARIAMapper.elemToImplicitRole(ruleContext);
        //let implicitRole = AriaUtil.getImplicitRole(ruleContext);
        var hasAttribute = CommonUtil_1.CommonUtil.hasAttribute;
        var testedRoles = 0;
        var tagProperty = AriaUtil_1.AriaUtil.getElementAriaProperty(ruleContext);
        var role = AriaUtil_1.AriaUtil.getResolvedRole(ruleContext);
        if (!role)
            return;
        var requiredRoleProps = AriaUtil_1.AriaUtil.getRoleRequiredProperties(role, ruleContext);
        if (designPatterns[role] && requiredRoleProps !== null) {
            var allowedRoleProps = AriaUtil_1.AriaUtil.getAllowedAriaAttributes(ruleContext, role, tagProperty);
            var roleMissingReqProp = false;
            for (var i = 0, propertiesLength = requiredRoleProps.length; i < propertiesLength; i++) {
                if (!allowedRoleProps.includes(requiredRoleProps[i]))
                    continue;
                if (!hasAttribute(ruleContext, requiredRoleProps[i])) {
                    // If an aria-labelledby isn't present, an aria-label will meet the requirement.
                    if (requiredRoleProps[i] == "aria-labelledby") {
                        if ((!hasAttribute(ruleContext, "aria-label")) || (role != "radiogroup")) {
                            attrNameArr.push(requiredRoleProps[i]);
                            roleMissingReqProp = true;
                        }
                    }
                    else if (requiredRoleProps[i] == "aria-valuenow") {
                        if ((!hasAttribute(ruleContext, "aria-valuetext")) || (role != "progressbar")) {
                            attrNameArr.push(requiredRoleProps[i]);
                            roleMissingReqProp = true;
                        }
                    }
                    else if (requiredRoleProps[i] == "aria-controls" && role == "combobox") {
                        // Skip this check since aria-controls in the textbox of a combobox is already handled in rule HAAC_Combobox_Must_have_Text_Input
                    }
                    else {
                        attrNameArr.push(requiredRoleProps[i]);
                        roleMissingReqProp = true;
                    }
                }
            }
            if (roleMissingReqProp == true) {
                roleNameArr.push(role);
            }
        }
        var passed = roleNameArr.length == 0 || attrNameArr.length == 0; // only aria attributes so NO OUT OF SCOPE
        if (!passed) {
            var retToken = new Array();
            retToken.push(roleNameArr.join(", "));
            retToken.push(attrNameArr.join(", "));
            return (0, IRule_1.RuleFail)("fail_missing", retToken);
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 1699:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_value_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var ARIADefinitions_1 = __webpack_require__(8235);
exports.aria_attribute_value_valid = {
    id: "aria_attribute_value_valid",
    context: "dom:*",
    dependencies: ["aria_attribute_allowed"],
    refactor: {
        "Rpt_Aria_ValidPropertyValue": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_attribute_value_valid.html",
            "Pass_0": "aria_attribute_value_valid.html",
            "Fail_1": "aria_attribute_value_valid.html"
        }
    },
    messages: {
        "en-US": {
            "group": "ARIA property values must be valid",
            "Pass_0": "Rule Passed",
            "Fail_1": "The value \"{0}\" specified for attribute '{1}' on element <{2}> is not valid"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "6a7281",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var valueArr = new Array();
        var attrNameArr = new Array();
        var dataTypeArr = new Array();
        var propertyDataTypes = ARIADefinitions_1.ARIADefinitions.propertyDataTypes;
        var contextAttributes = ruleContext.attributes;
        var testedPropertyValues = 0;
        if (contextAttributes) {
            for (var i = 0, length_1 = contextAttributes.length; i < length_1; i++) {
                var attrName = contextAttributes[i].name;
                if (AriaUtil_1.AriaUtil.isDefinedAriaAttribute(ruleContext, attrName)) {
                    var dataTypes = propertyDataTypes[attrName];
                    var nodeValue = CommonUtil_1.CommonUtil.normalizeSpacing(contextAttributes[i].nodeValue);
                    testedPropertyValues++;
                    if (dataTypes && dataTypes.values) {
                        if (dataTypes.values.indexOf(nodeValue) == -1) {
                            if (dataTypes.values.indexOf('undefined') != -1 && nodeValue.length == 0) {
                                //translate 'undefined' to mean ''
                            }
                            else {
                                // aria-relevant is represented as a space delimited list of the following values: 
                                // additions, removals, text; or a single catch-all value all.
                                if (dataTypes.type === "http://www.w3.org/2001/XMLSchema#nmtokens") {
                                    var attrValues = contextAttributes[i].nodeValue.trim().split(" ");
                                    // if the value all is specified, it cannot have any other value
                                    if (attrValues.length > 1 && attrValues.includes("all")) {
                                        valueArr.push(contextAttributes[i].nodeValue.split(" "));
                                        attrNameArr.push(attrName);
                                        dataTypeArr.push(dataTypes.values.toString());
                                    }
                                    else {
                                        var hash = {};
                                        for (var j = 0; j < attrValues.length; j++) {
                                            // if the individual value is not in the list of allowed values
                                            if (attrValues[j] != "" && !dataTypes.values.includes(attrValues[j])) {
                                                if (!hash.hasOwnProperty(attrName)) {
                                                    hash[attrName] = true;
                                                    attrNameArr.push(attrName);
                                                }
                                                valueArr.push(attrValues[j]);
                                                dataTypeArr.push(dataTypes.values.toString());
                                            }
                                        }
                                    }
                                }
                                else {
                                    valueArr.push(contextAttributes[i].nodeValue.split(" "));
                                    attrNameArr.push(attrName);
                                    dataTypeArr.push(dataTypes.values.toString());
                                }
                            }
                        }
                    }
                    else if (dataTypes && dataTypes.type && dataTypes.type === "http://www.w3.org/2001/XMLSchema#int") {
                        var iVal = parseInt(nodeValue);
                        if (isNaN(iVal) || ("" + iVal !== nodeValue)) {
                            valueArr.push(nodeValue);
                            attrNameArr.push(attrName);
                        }
                    }
                    else if (dataTypes && dataTypes.type && dataTypes.type == "http://www.w3.org/2001/XMLSchema#decimal") {
                        var fVal = parseFloat(nodeValue);
                        if (isNaN(fVal)) {
                            valueArr.push(nodeValue);
                            attrNameArr.push(attrName);
                        }
                    }
                    else if (dataTypes && dataTypes.type && (dataTypes.type == "http://www.w3.org/2001/XMLSchema#boolean")) {
                        var tmpV = nodeValue.trim().toLowerCase();
                        if (tmpV !== "true" && tmpV !== "false") {
                            valueArr.push(nodeValue);
                            attrNameArr.push(attrName);
                        }
                    }
                    else if (dataTypes && dataTypes.type && (dataTypes.type == "http://www.w3.org/2001/XMLSchema#string")) {
                    }
                    else {
                        testedPropertyValues--;
                    }
                }
            }
        }
        var retMsg = new Array();
        var passed = attrNameArr.length == 0;
        retMsg.push(valueArr.join(", "));
        retMsg.push(attrNameArr.join(", "));
        retMsg.push(ruleContext.nodeName.toLowerCase());
        // retMsg.push (dataTypeArr.join(", "));
        //return new ValidationResult(passed, [ruleContext], attrNameArr, '', retMsg);
        if (testedPropertyValues == 0) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", retMsg);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4974:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_banner_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_banner_label_unique = {
    id: "aria_banner_label_unique",
    context: "aria:banner",
    refactor: {
        "Rpt_Aria_MultipleBannerLandmarks_Implicit": {
            "Pass_0": "pass",
            "Fail_1": "fail_label_not_unique"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_banner_label_unique.html",
            "fail_label_not_unique": "aria_banner_label_unique.html",
            "group": "aria_banner_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element with \"banner\" role has a unique label that describes its purpose",
            "fail_label_not_unique": "Multiple elements with \"banner\" role do not have unique labels",
            "group": "Each element with \"banner\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var dupped = AriaUtil_1.AriaUtil.isLandmarkNameUnique(ruleContext, "banner", true);
        if (dupped == null)
            return null;
        if (dupped) {
            return (0, IRule_1.RuleFail)("fail_label_not_unique");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 3054:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_banner_single = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_banner_single = {
    id: "aria_banner_single",
    context: "dom:*[role], dom:header",
    refactor: {
        "Rpt_Aria_OneBannerInSiblingSet_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_banner_single.html",
            "Fail_1": "aria_banner_single.html",
            "group": "aria_banner_single.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"banner\" role found on the page",
            "group": "A page, document, or application should only have one element with \"banner\" role"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        if (!AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, "banner")) {
            return null;
        }
        var passed = AriaUtil_1.AriaUtil.getSiblingWithRoleHidden(ruleContext, "banner", true, true) === null;
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
    }
};


/***/ }),

/***/ 4649:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_child_tabbable = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var ARIADefinitions_1 = __webpack_require__(8235);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_child_tabbable = {
    id: "aria_child_tabbable",
    context: "dom:*[role]",
    dependencies: ["aria_role_allowed"],
    refactor: {
        "Rpt_Aria_MissingFocusableChild": {
            "pass": "pass",
            "fail_missing_child": "fail_missing_child"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_child_tabbable.html",
            "fail_missing_child": "aria_child_tabbable.html",
            "group": "aria_child_tabbable.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "fail_missing_child": "None of the descendent elements with \"{1}\" role is tabbable",
            "group": "UI component must have at least one tabbable descendant for keyboard access"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return;
        //skip the check if the element requires presentational children only
        if (AriaUtil_1.AriaUtil.containsPresentationalChildrenOnly(ruleContext) || AriaUtil_1.AriaUtil.shouldBePresentationalChild(ruleContext))
            return;
        // An ARIA list is not interactive
        if (AriaUtil_1.AriaUtil.hasRole(ruleContext, { "list": true, "row": true, "rowgroup": true, "table": true, "grid": true })) {
            return null;
        }
        // Not a valid message for mobile because all elements are focusable in iOS when VoiceOver is enabled.
        if (ruleContext.hasAttribute("class") && ruleContext.getAttribute("class").substring(0, 3) == "mbl") {
            return null;
        }
        //ignore datalist element check since it will be part of a input element or hidden by default
        if (ruleContext.nodeName.toLowerCase() === 'datalist')
            return null;
        // ignore if the element's navigation is controlled by another element, such as combobox
        if (AriaUtil_1.AriaUtil.isNavigationOwnedOrControlled(ruleContext))
            return null;
        var role = AriaUtil_1.AriaUtil.getResolvedRole(ruleContext);
        var passed = true;
        var doc = ruleContext.ownerDocument;
        var hasAttribute = CommonUtil_1.CommonUtil.hasAttribute;
        var roleNameArr = new Array();
        var nodeName = "";
        var inScope = false;
        if (ARIADefinitions_1.ARIADefinitions.containers.includes(role)) {
            var disabled = hasAttribute(ruleContext, 'aria-disabled') ? ruleContext.getAttribute("aria-disabled") : '';
            if (disabled != 'true' && !hasAttribute(ruleContext, 'aria-activedescendant') && !CommonUtil_1.CommonUtil.isTabbable(ruleContext)) {
                var reqChildren = ARIADefinitions_1.ARIADefinitions.designPatterns[role].reqChildren;
                if (reqChildren) {
                    inScope = true;
                    passed = false;
                    var xp = "descendant::*[";
                    for (var i = 0; i < reqChildren.length; i++) {
                        xp += "@role='" + reqChildren[i] + "' or ";
                    }
                    xp = xp.substring(0, xp.length - 4) + ']';
                    var xpathResult = doc.evaluate(xp, ruleContext, CommonUtil_1.CommonUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                    var r = xpathResult.iterateNext();
                    while (r && !passed) {
                        // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                        // or not.
                        //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                        //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                        //     add it to the roleToElems hash at all or even do any checking for it at all.
                        //
                        // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                        //       so on and so forth.
                        if (CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(r)) {
                            r = xpathResult.iterateNext();
                            continue;
                        }
                        passed = CommonUtil_1.CommonUtil.isTabbable(r);
                        // Required child is not focusable via tabindex. See if there is a grandchild that is focusable by default or by tabindex.
                        if (!passed) {
                            var xp2 = "descendant::*";
                            var xpathResult2 = doc.evaluate(xp2, r, CommonUtil_1.CommonUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                            var r2 = xpathResult2.iterateNext();
                            while (r2 && !passed) {
                                // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                                // or not.
                                //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                                //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                                //     add it to the roleToElems hash at all or even do any checking for it at all.
                                //
                                // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                                //       so on and so forth.
                                if (CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(r2)) {
                                    r2 = xpathResult2.iterateNext();
                                    continue;
                                }
                                passed = CommonUtil_1.CommonUtil.isTabbable(r);
                                r2 = xpathResult2.iterateNext();
                            }
                        }
                        if (!passed) {
                            roleNameArr = r.getAttribute("role").trim().split(" ");
                            nodeName = r.nodeName.toLowerCase();
                        }
                        r = xpathResult.iterateNext();
                    }
                }
            }
        }
        // Variable Decleration
        var retToken1 = new Array();
        var retToken2 = new Array();
        // In the case the arrays/strings are empty, that means that there is no violation so we can reset it back to passed, the reason for this
        // is that we are setting passed=false while we perform a loop which causes violation to trigger even if there is no issues. Instead of
        // updating the whole rule to switch from using passed in that way simply do the check at this point.
        if (nodeName.length > 0 && roleNameArr.length > 0) {
            retToken1.push(nodeName);
            retToken2.push(roleNameArr.join(", "));
        }
        else {
            passed = true;
        }
        //return new ValidationResult(passed, [ruleContext], 'role', '', passed == true ? [] : [retToken1, retToken2]);
        if (!inScope) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("fail_missing_child", [retToken1.toString(), retToken2.toString()]);
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 4193:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_child_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_child_valid = {
    id: "aria_child_valid",
    //context: "dom:*[role]",
    //dependencies: ["Rpt_Aria_ValidRole"],
    context: "dom:*",
    dependencies: ["aria_role_valid", "aria_descendant_valid"],
    help: {
        "en-US": {
            "group": "aria_child_valid.html",
            "Pass": "aria_child_valid.html",
            "Fail_no_child": "aria_child_valid.html",
            "Fail_invalid_child": "aria_child_valid.html"
        }
    },
    messages: {
        "en-US": {
            "group": "An element with an ARIA role must own a required child",
            "Pass": "An element with an ARIA role owns a required child",
            "Fail_no_child": "The element with role \"{0}\" does not own any child element with any of the following role(s): \"{1}\"",
            "Fail_invalid_child": "The element with role \"{0}\" owns the child element with the role \"{1}\" that is not one of the allowed role(s): \"{2}\""
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    // TODO: ACT: Verify mapping
    act: ["bc4a75"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return;
        //skip the check if the element requires presentational children only
        if (AriaUtil_1.AriaUtil.containsPresentationalChildrenOnly(ruleContext))
            return;
        var roles = AriaUtil_1.AriaUtil.getRoles(ruleContext, false);
        // if explicit role doesn't exist, get the implicit one
        if (!roles || roles.length === 0)
            roles = AriaUtil_1.AriaUtil.getImplicitRole(ruleContext);
        //ignore if the element doesn't have any explicit or implicit role, shouldn't happen
        if (!roles || roles.length === 0)
            return null;
        // ignore if the element contains none or presentation role
        var presentationRoles = ["none", "presentation"];
        var found = roles.some(function (r) { return presentationRoles.includes(r); });
        if (found)
            return null;
        //  For combobox, we have g1193 ... g1199 to check the values etc.
        //  We don't want to trigger 1152 again. So, we bypass it here.
        if (roles.includes("combobox"))
            return null;
        var requiredChildRoles = AriaUtil_1.AriaUtil.getRequiredChildRoles(ruleContext, true);
        // a 'group' role is allowed but not required for some elements so remove it if exists
        if (requiredChildRoles.includes('group')) {
            var index = requiredChildRoles.indexOf('group');
            if (index > -1)
                requiredChildRoles.splice(index, 1);
        }
        /**
         * ignore if a role doesn't require a child with any specific role
         * the reverse might be not true - parent will be checked in Rpt_Aria_RequiredParent_Native_Host_Sematics rule
        */
        if (requiredChildRoles.length == 0)
            return null;
        // get all the children from accessibility tree, 
        // including ones with aria-owns    
        var directATChildren = AriaUtil_1.AriaUtil.getDirectATChildren(ruleContext);
        if (!directATChildren || directATChildren.length == 0) {
            // the element with at least one required role dosen't contain any accessible child
            /**
             * When a widget is missing required owned elements due to script execution or loading,
             * authors MUST mark a containing element with 'aria-busy' equal to true.
             */
            var busy = ruleContext.getAttribute("aria-busy");
            if (!busy || busy !== 'true') {
                var retToken = new Array();
                retToken.push(roles.join(", "));
                retToken.push(requiredChildRoles.join(", "));
                return (0, IRule_1.RuleFail)("Fail_no_child", retToken);
            }
            // it's 'busy' loading, ignore it 
            return null;
        }
        var violateElemRoles = new Array();
        for (var j = 0; j < directATChildren.length; j++) {
            var childRoles = AriaUtil_1.AriaUtil.getRoles(directATChildren[j], false);
            // if explicit role doesn't exist, get the implicit one
            if (!childRoles || childRoles.length == 0)
                childRoles = AriaUtil_1.AriaUtil.getImplicitRole(directATChildren[j]);
            if (childRoles && childRoles.length > 0) {
                /**
                 * when multiple roles are specified as required owned elements for a role, at least one instance of one required owned element is expected.
                 * the specification does not require an instance of each of the listed owned roles.
                 * therefore, the requirement is met if it has any one of the required roles.
                 */
                var found_1 = childRoles.some(function (r) { return requiredChildRoles.includes(r); });
                if (!found_1)
                    violateElemRoles.push(childRoles.join(", "));
            }
            else {
                // ignore the element since it's not semantic, shouldn't happen 
            }
        }
        if (violateElemRoles.length > 0) {
            var retValues = [];
            for (var i = 0; i < violateElemRoles.length; i++) {
                var retToken = new Array();
                retToken.push(roles.join(", "));
                retToken.push(violateElemRoles[i]);
                retToken.push(requiredChildRoles.join(", "));
                retValues.push((0, IRule_1.RuleFail)("Fail_invalid_child", retToken));
            }
            return retValues;
        }
        return (0, IRule_1.RulePass)("Pass");
    }
};


/***/ }),

/***/ 3188:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_complementary_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_complementary_label_unique = {
    id: "aria_complementary_label_unique",
    context: "aria:complementary",
    refactor: {
        "Rpt_Aria_MultipleComplementaryLandmarks_Implicit": {
            "Pass_0": "pass",
            "Fail_1": "fail_label_not_unique"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_complementary_label_unique.html",
            "fail_label_not_unique": "aria_complementary_label_unique.html",
            "group": "aria_complementary_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element with \"complementary\" role has a unique label that describes its purpose",
            "fail_label_not_unique": "Multiple elements with \"complementary\" role do not have unique labels",
            "group": "Each element with \"complementary\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var dupped = AriaUtil_1.AriaUtil.isLandmarkNameUnique(ruleContext, "complementary");
        if (dupped == null)
            return null;
        if (dupped) {
            return (0, IRule_1.RuleFail)("fail_label_not_unique");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 4176:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_complementary_label_visible = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_complementary_label_visible = {
    id: "aria_complementary_label_visible",
    context: "dom:*[role], dom:aside",
    dependencies: ["aria_complementary_labelled"],
    refactor: {
        "Rpt_Aria_ComplementaryLandmarkLabel_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_complementary_label_visible.html",
            "Fail_1": "aria_complementary_label_visible.html",
            "group": "aria_complementary_label_visible.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Element with \"complementary\" role does not have a visible label",
            "group": "Each element with \"complementary\" role should have a visible label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        if (!AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, "complementary")) {
            return null;
        }
        var passed = CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "aria-labelledby");
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
    }
};


/***/ }),

/***/ 7964:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_complementary_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AccNameUtil_1 = __webpack_require__(1421);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_complementary_labelled = {
    id: "aria_complementary_labelled",
    context: "aria:complementary",
    refactor: {
        "Rpt_Aria_ComplementaryRequiredLabel_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_complementary_labelled.html",
            "Fail_1": "aria_complementary_labelled.html",
            "group": "aria_complementary_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Element with \"complementary\" role does not have a label",
            "group": "Each element with \"complementary\" role must have a label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(ruleContext);
        if (pair) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
    }
};


/***/ }),

/***/ 2554:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_content_in_landmark = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var CacheUtil_1 = __webpack_require__(7788);
var DOMWalker_1 = __webpack_require__(7440);
var VisUtil_1 = __webpack_require__(8656);
var TableUtil_1 = __webpack_require__(5755);
exports.aria_content_in_landmark = {
    id: "aria_content_in_landmark",
    context: "dom:*",
    refactor: {
        "Rpt_Aria_OrphanedContent_Native_Host_Sematics": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_content_in_landmark.html",
            "Fail_1": "aria_content_in_landmark.html",
            "group": "aria_content_in_landmark.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Content is not within a landmark element",
            "group": "All content must reside within an element with a landmark role"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        },
        {
            "id": ["WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var params = CacheUtil_1.CacheUtil.getCache(context.dom.node.ownerDocument, "aria_content_in_landmark", null);
        if (!params) {
            params = {
                landmarks: {
                    value: ["banner", "complementary", "contentinfo", "form", "main", "navigation", "region", "search"],
                    type: "array"
                },
                possibleOrphanedWidgets: {
                    value: ["button", "combobox", "checkbox", "grid", "heading", "link", "list",
                        "listbox", "menu", "menubar", "progressbar", "radio", "tablist", "textbox", "toolbar", "tree",
                        "treegrid"
                    ],
                    type: "array"
                },
                possibleOrphanedElements: {
                    value: ["p", "table", "input", "textarea", "select", "button", "a", "ol", "ul", "dl", "h1", "h2", "h3", "h4", "h5",
                        "h6", "embed", "object", "area"
                    ],
                    type: "array"
                },
                noLandmarkedRoles: {
                    // These roles don't require landmarks
                    value: ["alert", "alertdialog", "dialog", "tooltip"],
                    type: "array"
                },
                mapLandmarks: {},
                mapPossibleOrphanedWidgets: {},
                mapPossibleOrphanedElements: {},
                mapNoLandmarkedRoles: {}
            };
            // Convert arrays to maps
            params.mapLandmarks = {};
            for (var i = 0; i < params.landmarks.value.length; ++i) {
                params.mapLandmarks[params.landmarks.value[i]] = true;
            }
            params.mapPossibleOrphanedWidgets = {};
            for (var i = 0; i < params.possibleOrphanedWidgets.value.length; ++i) {
                params.mapPossibleOrphanedWidgets[params.possibleOrphanedWidgets.value[i]] = true;
            }
            params.mapPossibleOrphanedElements = {};
            for (var i = 0; i < params.possibleOrphanedElements.value.length; ++i) {
                params.mapPossibleOrphanedElements[params.possibleOrphanedElements.value[i]] = true;
            }
            params.mapNoLandmarkedRoles = {};
            for (var i = 0; i < params.noLandmarkedRoles.value.length; ++i) {
                params.mapNoLandmarkedRoles[params.noLandmarkedRoles.value[i]] = true;
            }
            CacheUtil_1.CacheUtil.setCache(context.dom.node.ownerDocument, "aria_content_in_landmark", params);
        }
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) || // avoid diagnosing g1157 for non-visible nodes
            (VisUtil_1.VisUtil.hiddenByDefaultElements != null &&
                VisUtil_1.VisUtil.hiddenByDefaultElements != undefined &&
                VisUtil_1.VisUtil.hiddenByDefaultElements.indexOf(nodeName) > -1)) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        var elemsWithoutContent = ["area", "input", "embed", "button", "textarea", "select"];
        if (!CommonUtil_1.CommonUtil.hasInnerContentHidden(ruleContext) && //only trigger the rule on elements that have content
            elemsWithoutContent.indexOf(nodeName) === -1) { // a few elems wihout content should not be skipped
            return (0, IRule_1.RulePass)("Pass_0");
        }
        // Short circuit for layout tables
        if (nodeName == "table" && TableUtil_1.TableUtil.isLayoutTable(ruleContext)) {
            return null;
        }
        // Check if it is a possible orphan
        var passed = true;
        var isPossibleOrphanedWidget = AriaUtil_1.AriaUtil.hasRole(ruleContext, params.mapPossibleOrphanedWidgets, true);
        //exclude <link rel="stylesheet" href="xyz.css"> in the <head> and <body>(#608)
        //having link in the head could cause lot of violaions                    
        if (nodeName === 'link') {
            isPossibleOrphanedWidget = false;
        }
        var isPossibleOrphanedElement = nodeName in params.mapPossibleOrphanedElements;
        if (isPossibleOrphanedWidget || isPossibleOrphanedElement) {
            // See if ancestor has landmark roles or implicit land mark roles
            var parentRoles = contextHierarchies["aria"].map(function (info) { return info.role; });
            passed = parentRoles.filter(function (role) { return role in params.mapLandmarks; }).length > 0;
            if (!passed) {
                // Don't fail elements when a parent or sibling has failed - causes too many messages.
                var walkElement = DOMWalker_1.DOMWalker.parentElement(ruleContext);
                while (!passed && walkElement != null) {
                    passed = CacheUtil_1.CacheUtil.getCache(walkElement, "Rpt_Aria_OrphanedContent", false);
                    walkElement = DOMWalker_1.DOMWalker.parentElement(walkElement);
                }
                walkElement = ruleContext.nextElementSibling;
                while (!passed && walkElement != null) {
                    passed = CacheUtil_1.CacheUtil.getCache(walkElement, "Rpt_Aria_OrphanedContent", false);
                    walkElement = walkElement.nextElementSibling;
                }
                walkElement = ruleContext.previousElementSibling;
                while (!passed && walkElement != null) {
                    passed = CacheUtil_1.CacheUtil.getCache(walkElement, "Rpt_Aria_OrphanedContent", false);
                    walkElement = walkElement.previousElementSibling;
                }
                if (!passed) {
                    CacheUtil_1.CacheUtil.setCache(ruleContext, "Rpt_Aria_OrphanedContent", true);
                    // Don't trigger rule if element is a stand-alone widget
                    passed = CacheUtil_1.CacheUtil.getCache(ruleContext, "Rpt_Aria_OrphanedContent_NoTrigger", false) ||
                        AriaUtil_1.AriaUtil.hasRole(ruleContext, params.mapNoLandmarkedRoles, true) ||
                        AriaUtil_1.AriaUtil.getAncestorWithRole(ruleContext, params.mapNoLandmarkedRoles, true);
                    if (passed) {
                        CacheUtil_1.CacheUtil.setCache(ruleContext, "Rpt_Aria_OrphanedContent_NoTrigger", true);
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
        }
        else {
            return null;
        }
        //return new ValidationResult(passed, [ruleContext], '', '', []);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 1229:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_contentinfo_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_contentinfo_label_unique = {
    id: "aria_contentinfo_label_unique",
    context: "aria:contentinfo",
    refactor: {
        "Rpt_Aria_MultipleContentinfoLandmarks_Implicit": {
            "Pass_0": "pass",
            "Fail_1": "fail_label_not_unique"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_contentinfo_label_unique.html",
            "fail_label_not_unique": "aria_contentinfo_label_unique.html",
            "group": "aria_contentinfo_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element with \"contentinfo\" role has a unique label that describes its purpose",
            "fail_label_not_unique": "Multiple elements with \"contentinfo\" role do not have unique labels",
            "group": "Each element with \"contentinfo\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var dupped = AriaUtil_1.AriaUtil.isLandmarkNameUnique(ruleContext, "contentinfo", true);
        if (dupped == null)
            return null;
        if (dupped) {
            return (0, IRule_1.RuleFail)("fail_label_not_unique");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 8523:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_contentinfo_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_contentinfo_misuse = {
    id: "aria_contentinfo_misuse",
    context: "dom:*[role], dom:footer, dom:address",
    refactor: {
        "Rpt_Aria_ContentinfoWithNoMain_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_contentinfo_misuse.html",
            "Fail_1": "aria_contentinfo_misuse.html",
            "group": "aria_contentinfo_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Element with \"contentinfo\" role is present without an element with \"main\" role",
            "group": "Each element with \"contentinfo\" role is only permitted with an element with \"main\" role"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        //consider implicit role
        if (!AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, "contentinfo")) {
            return null;
        }
        // Consider the Check Hidden Content setting that is set by the rules
        var passed = CommonUtil_1.CommonUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "main", true, true).length > 0;
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 3781:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_contentinfo_single = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_contentinfo_single = {
    id: "aria_contentinfo_single",
    context: "dom:*[role], dom:footer, dom:address",
    refactor: {
        "Rpt_Aria_MultipleContentinfoInSiblingSet_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_contentinfo_single.html",
            "Fail_1": "aria_contentinfo_single.html",
            "group": "aria_contentinfo_single.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"contentinfo\" role found on the page",
            "group": "A page, document, or application should only have one element with \"contentinfo\" role"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        //find out if <footer> element has siblings as <footer> has implicit contentinfo role
        if (!AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, "contentinfo")) {
            return null;
        }
        var passed = !AriaUtil_1.AriaUtil.getSiblingWithRoleHidden(ruleContext, "contentinfo", true, true);
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 8509:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_descendant_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_descendant_valid = {
    id: "aria_descendant_valid",
    context: "dom:*",
    dependencies: ["aria_role_valid"],
    help: {
        "en-US": {
            "group": "aria_descendant_valid.html",
            "pass": "aria_descendant_valid.html",
            "potential_child_implicit_role": "aria_descendant_valid.html",
            "fail_child_explicit_role": "aria_descendant_valid.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Browsers ignore the explicit and implicit ARIA roles of the descendants of certain elements",
            "pass": "The element contains valid descendants",
            "potential_child_implicit_role": "The element with role \"{0}\" contains descendants with implicit roles \"{1}\" which are ignored by browsers",
            "fail_child_explicit_role": "The element with role \"{0}\" contains descendants with roles \"{1}\" which are ignored by browsers"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    // TODO: ACT: Verify mapping
    act: ["307n5z"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return;
        //skip the check if the element doesn't require presentational children only
        if (!AriaUtil_1.AriaUtil.containsPresentationalChildrenOnly(ruleContext))
            return;
        var roles = AriaUtil_1.AriaUtil.getRoles(ruleContext, false);
        // if explicit role doesn't exist, get the implicit one
        if (!roles || roles.length === 0)
            roles = AriaUtil_1.AriaUtil.getImplicitRole(ruleContext);
        //ignore if the element doesn't have any explicit or implicit role, shouldn't happen
        if (!roles || roles.length === 0)
            return null;
        var tagName = ruleContext.tagName.toLowerCase();
        // get all the children from accessibility tree, 
        // including ones with aria-owns    
        var directATChildren = AriaUtil_1.AriaUtil.getDirectATChildren(ruleContext);
        if (directATChildren && directATChildren.length > 0) {
            // the element with at least one non-presentational children
            var explicitRoles = new Array();
            var implicitRoles = new Array();
            for (var j = 0; j < directATChildren.length; j++) {
                // ignore <img> and <svg>
                var tag = directATChildren[j].nodeName.toLowerCase();
                if (tag === 'img' || tag === 'svg')
                    continue;
                // get explicit role if exists
                var childRoles = AriaUtil_1.AriaUtil.getRoles(directATChildren[j], false);
                if (childRoles && childRoles.length > 0) {
                    explicitRoles.push(childRoles.join(", "));
                }
                else {
                    // get implicit role if exists
                    childRoles = AriaUtil_1.AriaUtil.getImplicitRole(directATChildren[j]);
                    if (childRoles && childRoles.length > 0)
                        implicitRoles.push(childRoles.join(", "));
                }
            }
            if (explicitRoles.length > 0) {
                var retValues = [];
                for (var i = 0; i < explicitRoles.length; i++) {
                    var retToken = new Array();
                    retToken.push(roles.join(", "));
                    retToken.push(explicitRoles[i]);
                    retValues.push((0, IRule_1.RuleFail)("fail_child_explicit_role", retToken));
                }
                return retValues;
            }
            if (implicitRoles.length > 0) {
                var retValues = [];
                for (var i = 0; i < implicitRoles.length; i++) {
                    var retToken = new Array();
                    retToken.push(roles.join(", "));
                    retToken.push(implicitRoles[i]);
                    retValues.push((0, IRule_1.RulePotential)("potential_child_implicit_role", retToken));
                }
                return retValues;
            }
        }
        else
            return (0, IRule_1.RulePass)("pass");
    }
};


/***/ }),

/***/ 3234:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_document_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_document_label_unique = {
    id: "aria_document_label_unique",
    context: "aria:document",
    refactor: {
        "Rpt_Aria_MultipleDocumentRoles": {
            "Pass_0": "pass",
            "Fail_1": "fail_label_not_unique"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_document_label_unique.html",
            "fail_label_not_unique": "aria_document_label_unique.html",
            "group": "aria_document_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element with \"document\" role has a unique label that describes its purpose",
            "fail_label_not_unique": "Multiple elements with \"document\" roles do not have unique labels",
            "group": "Each element with \"document\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var dupped = AriaUtil_1.AriaUtil.isLandmarkNameUnique(ruleContext, "document", true);
        if (dupped == null)
            return null;
        if (dupped) {
            return (0, IRule_1.RuleFail)("fail_label_not_unique");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 5217:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_eventhandler_role_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
exports.aria_eventhandler_role_valid = {
    id: "aria_eventhandler_role_valid",
    context: "dom:*[onclick],dom:*[onblur], dom:*[ondblclick], dom:*[onfocus], dom:*[onkeydown],dom:*[onkeypress], dom:*[onkeyup], dom:*[onmousedown], dom:*[onmouseup], dom:*[onmousemove], dom:*[onmouseout], dom:*[onmouseover], dom:*[onresize], dom:*[onchange]",
    refactor: {
        "Rpt_Aria_EventHandlerMissingRole_Native_Host_Sematics": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_eventhandler_role_valid.html",
            "Fail_1": "aria_eventhandler_role_valid.html",
            "group": "aria_eventhandler_role_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The <{0}> element with '{1}' does not have a valid ARIA role specified",
            "group": "Elements with event handlers must have a valid ARIA role"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Don't trigger this for SVG element for now until a determination is made (by Rich)
        // to support SVG at a point when the SVG a11y spec is ready.
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, "svg")) {
            return null;
        }
        //this rule is passed if a element has attribut role 
        //also, passed of element has any implicit roles. 
        if (AriaUtil_1.AriaUtil.hasAnyRole(ruleContext, true)) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        //pass if this element is received focus by default
        if (CommonUtil_1.CommonUtil.isfocusableByDefault(ruleContext)) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        //validate if this element has any of the given event handler's
        var retToken1 = new Array();
        retToken1.push(ruleContext.nodeName.toLowerCase());
        var eventArr = new Array();
        // From WCAG20_Script_UseW3CDomFunctions
        //let events = ["onblur", "onfocus", "onchange", "onclick", "oncontextmenu", "ondblclick", "onkeydown",
        //              "onkeypress", "onkeyup", "onload", "onmousedown", "onmouseup", "onmousemove", "onmouseout",
        //              "onmouseover", "onmousewheel", "onreset", "onpaste", "onresize", "onscroll",
        //              "onselect", "onsubmit", "onactivate", "ondeactivate", "onmouseenter", "onmouseleave"];
        var events = ["onblur", "onfocus", "onchange", "onclick", "ondblclick", "onkeydown",
            "onkeypress", "onkeyup", "onmousedown", "onmouseup", "onmousemove", "onmouseout",
            "onmouseover", "onresize"
        ];
        for (var i = 0; i < events.length; ++i) {
            if (ruleContext.hasAttribute(events[i]))
                eventArr.push(events[i]);
        }
        var retToken2 = new Array();
        retToken2.push(eventArr.join(", "));
        //return new ValidationResult(false, [ruleContext], '', '', [retToken1, retToken2]);
        return (0, IRule_1.RuleFail)("Fail_1", [retToken1.toString(), retToken2.toString()]);
    }
};


/***/ }),

/***/ 4050:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_form_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_form_label_unique = {
    id: "aria_form_label_unique",
    context: "aria:form",
    refactor: {
        "Rpt_Aria_MultipleFormLandmarks_Implicit": {
            "Pass_0": "pass",
            "Fail_1": "fail_label_not_unique"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_form_label_unique.html",
            "fail_label_not_unique": "aria_form_label_unique.html",
            "group": "aria_form_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element with \"form\" role has a unique label that describes its purpose",
            "fail_label_not_unique": "Multiple elements with \"form\" role do not have unique labels",
            "group": "Each element with \"form\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var dupped = AriaUtil_1.AriaUtil.isLandmarkNameUnique(ruleContext, "form", true);
        if (dupped == null)
            return null;
        if (dupped) {
            return (0, IRule_1.RuleFail)("fail_label_not_unique");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 4275:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_graphic_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_graphic_labelled = {
    id: "aria_graphic_labelled",
    context: "aria:graphics-document,aria:graphics-symbol",
    refactor: {
        "HAAC_Aria_SvgAlt": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
        }
    },
    help: {
        "en-US": {
            "group": "aria_graphic_labelled.html",
            "Pass_0": "aria_graphic_labelled.html",
            "Fail_1": "aria_graphic_labelled.html",
            "Fail_2": "aria_graphic_labelled.html",
            "Fail_3": "aria_graphic_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "group": "An element with a graphics role must have a non-empty label",
            "Pass_0": "Rule Passed",
            "Fail_1": "Element with \"{0}\" graphics role has no label",
            "Fail_2": "Element with \"{0}\" graphics role has no label or an empty label",
            "Fail_3": "Element with \"{0}\" graphics role missing non-empty 'aria-label' or 'aria-labelledby'"
        }
    },
    rulesets: [],
    act: [{
            "7d6734": {
                "Pass_0": "pass",
                "Fail_1": "inapplicable",
                "Fail_2": "fail",
                "Fail_3": "inapplicable"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        if (!ruleContext.hasAttribute("role") || !ruleContext.getAttribute("role").includes("graphics-"))
            return null;
        /* removed the role check role= presentation since if an element has role=img, then there needs to be a check for alt attribute regardless of the presecne of role=presentation
        if (RPTUtil.hasRole(ruleContext, "presentation") || RPTUtil.hasRole(ruleContext, "none")){
                return RulePass(1);
        }*/
        // If role === img, you must use an aria label
        //check attributes aria-label and aria-labelledby for other tags (e.g., <div>, <span>, etc)
        var passed = AriaUtil_1.AriaUtil.getAriaLabel(ruleContext).length > 0;
        if (!passed && ruleContext.nodeName.toLowerCase() === "svg") {
            var svgTitle = ruleContext.querySelector("title");
            passed = svgTitle && CommonUtil_1.CommonUtil.hasInnerContent(svgTitle);
        }
        if (!passed) {
            //check title attribute
            passed = CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "title");
            // We should guide people to use alt or label - this is just a secondary approach to silence the rule.
            // So, we should keep the POF from above.
            // if (!passed) POF = "Fail_3";
        }
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_2", [ruleContext.getAttribute("role")]);
        }
    }
};


/***/ }),

/***/ 1465:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_hidden_nontabbable = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.aria_hidden_nontabbable = {
    id: "aria_hidden_nontabbable",
    context: "dom:*[aria-hidden=true], dom:*[aria-hidden=true] dom:*",
    refactor: {
        "aria_hidden_focus_misuse": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_hidden_nontabbable.html",
            "Pass_0": "aria_hidden_nontabbable.html",
            "Fail_1": "aria_hidden_nontabbable.html"
        }
    },
    messages: {
        "en-US": {
            "group": "A hidden element should not contain any tabbable elements",
            "Pass_0": "Rule Passed",
            "Fail_1": "Element \"{0}\" should not be focusable within the subtree of an element with an 'aria-hidden' attribute with value 'true'"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: ["1.3.1", "4.1.2"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    // TODO: ACT: Handle testcase with focus jumping away
    act: "6cfa84",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (CommonUtil_1.CommonUtil.isTabbable(ruleContext)) {
            return (0, IRule_1.RuleFail)("Fail_1", [nodeName]);
        }
        return (0, IRule_1.RulePass)("Pass_0");
    }
};


/***/ }),

/***/ 405:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_id_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var fragment_1 = __webpack_require__(482);
var ARIADefinitions_1 = __webpack_require__(8235);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_id_unique = {
    id: "aria_id_unique",
    context: "dom:*",
    refactor: {
        "Rpt_Aria_ValidIdRef": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_id_unique.html",
            "Fail_1": "aria_id_unique.html",
            "group": "aria_id_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The 'id' \"{0}\" specified for the ARIA property '{1}' value is not valid",
            "group": "The ARIA property must reference a non-empty unique id of an existing element that is visible"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    // TODO: ACT: 6a7281 - Need a separate reason code when the property is not required. ACT says it's okay to be
    // invalid when not required. I think we should still fail, but flag it as a different reason so that we can have a subset
    // aligns with ACT.
    act: ["59796f", "6a7281"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var pass = true;
        var attrNameArr = new Array();
        var nonExistantIDs = new Array();
        var ownerDocument = fragment_1.FragmentUtil.getOwnerFragment(ruleContext);
        var contextAttributes = ruleContext.attributes;
        var idTokens = new Array();
        var testedReferences = 0;
        if (contextAttributes) {
            for (var i = 0, attrLength = contextAttributes.length; i < attrLength; i++) {
                pass = true;
                var attrName = contextAttributes[i].name;
                if (AriaUtil_1.AriaUtil.isDefinedAriaAttribute(ruleContext, attrName)) {
                    var dataTypes = ARIADefinitions_1.ARIADefinitions.propertyDataTypes[attrName];
                    if (dataTypes && dataTypes.type) {
                        var supportsOneIDRef = (dataTypes.type == "http://www.w3.org/2001/XMLSchema#idref") ? true : false;
                        //If the data type supports one or more id refs do error checking
                        if (supportsOneIDRef || (dataTypes.type == "http://www.w3.org/2001/XMLSchema#idrefs")) {
                            testedReferences++;
                            var nodeValueLength = CommonUtil_1.CommonUtil.normalizeSpacing(contextAttributes[i].nodeValue).length;
                            var idArray = contextAttributes[i].nodeValue.split(" ");
                            // Check for an empty ID Ref
                            if (nodeValueLength < 1) {
                                pass = false;
                                idTokens.push("\"" + contextAttributes[i].nodeValue + "\"");
                            }
                            // check to see if too many IDRefs
                            else if (supportsOneIDRef) {
                                //If has too many IDRefs it is an error
                                if (nodeValueLength >= 1) {
                                    if (idArray.length > 1) {
                                        pass = false;
                                        // Need to capture all the IDRefs for idTokens
                                        for (var z = 0, length_1 = idArray.length; z < length_1; ++z) {
                                            if (idArray[z] != "") {
                                                idTokens.push(idArray[z]);
                                            }
                                        }
                                    }
                                }
                            }
                            // check to see if id refs are invalid
                            if (pass && nodeValueLength >= 1) {
                                for (var j = 0, length_2 = idArray.length; j < length_2; ++j) {
                                    if (idArray[j].length > 0) { // it is an empty string if spaces are one after the other
                                        // Get the element by Id
                                        var elementById = ownerDocument.getElementById(idArray[j]);
                                        // Pass if the element exists
                                        pass = elementById != null;
                                        // If the element exists and this is an aria attribute that doesn't support hidden ID reference
                                        // then perform a isNodeVisible check, in the case the node is not visible then we return
                                        // false and true otherwise.
                                        if (pass && !dataTypes.hiddenIDRefSupported) {
                                            pass = VisUtil_1.VisUtil.isNodeVisible(elementById);
                                        }
                                        if (!pass) {
                                            if (idArray[j] != "") {
                                                idTokens.push(idArray[j]);
                                            }
                                        }
                                        // Only one of the id references need to be valid to mark the rule as passed.
                                        // Therefore if we find a single visible element then stop checking and mark as
                                        // passed.
                                        else {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (!pass)
                        attrNameArr.push(attrName);
                }
            }
        }
        var passed = attrNameArr.length == 0;
        var retToken1 = new Array();
        var retToken2 = new Array();
        var retToken3 = new Array();
        if (!passed) {
            retToken2.push(attrNameArr.join(", "));
            retToken3.push(ruleContext.nodeName.toLowerCase());
            if (idTokens.length > 0) {
                retToken1.push(idTokens.join(", "));
            }
        }
        //return new ValidationResult(passed, [ruleContext], attrNameArr, '', passed == true ? [] : [retToken1, retToken2, retToken3]);
        if (testedReferences == 0) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [retToken1.toString(), retToken2.toString(), retToken3.toString()]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 9136:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_img_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_img_labelled = {
    id: "aria_img_labelled",
    context: "aria:img, aria:image",
    refactor: {
        "HAAC_Aria_ImgAlt": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
        }
    },
    help: {
        "en-US": {
            "group": "aria_img_labelled.html",
            "Pass_0": "aria_img_labelled.html",
            "Fail_1": "aria_img_labelled.html",
            "Fail_2": "aria_img_labelled.html",
            "Fail_3": "aria_img_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "group": "An element with \"img\" role must have a non-empty label",
            "Pass_0": "Rule Passed",
            "Fail_1": "Element with \"img\" role has no label",
            "Fail_2": "Element with \"img\" role has no label or an empty label",
            "Fail_3": "Element with \"img\" role missing non-empty 'aria-label' or 'aria-labelledby'"
        }
    },
    rulesets: [],
    act: ["23a2a8", {
            "7d6734": {
                "Pass_0": "pass",
                "Fail_1": "inapplicable",
                "Fail_2": "fail",
                "Fail_3": "inapplicable"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        if (!ruleContext.hasAttribute("role")) {
            // If no role, this is implicit, and covered by WCAG20_Img_HasAlt
            return null;
        }
        var nodeName = ruleContext.nodeName.toLocaleLowerCase();
        // svg and img elements are handled in svg_graphics_labbelled and img_alt_valid rules
        if (nodeName === 'svg' || nodeName === 'img')
            return;
        /* removed the role check role= presentation since if an element has role=img, then there needs to be a check for alt attribute regardless of the presecne of role=presentation
        if (RPTUtil.hasRole(ruleContext, "presentation") || RPTUtil.hasRole(ruleContext, "none")){
                return RulePass(1);
        }*/
        /* JCH - Points of failure
         *    0. Missing alt attr with value
         *    1. Missing aria-label or aria-labelledby
         *    2. Missing title attr with value
         */
        // If role === img, you must use an aria label
        //check attributes aria-label and aria-labelledby for other tags (e.g., <div>, <span>, etc)
        var passed = AriaUtil_1.AriaUtil.getAriaLabel(ruleContext).length > 0;
        if (!passed && ruleContext.nodeName.toLowerCase() === "svg") {
            var svgTitle = ruleContext.querySelector("title");
            passed = svgTitle && CommonUtil_1.CommonUtil.hasInnerContent(svgTitle);
        }
        if (!passed) {
            //check title attribute
            passed = CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "title");
            // We should guide people to use alt or label - this is just a secondary approach to silence the rule.
            // So, we should keep the POF from above.
            // if (!passed) POF = "Fail_3";
        }
        //return new ValidationResult(passed, [ruleContext], 'role', '', []);
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_2");
        }
    }
};


/***/ }),

/***/ 5117:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_keyboard_handler_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var ARIADefinitions_1 = __webpack_require__(8235);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_keyboard_handler_exists = {
    id: "aria_keyboard_handler_exists",
    context: "dom:*[role]",
    dependencies: ["aria_role_allowed"],
    refactor: {
        "Rpt_Aria_MissingKeyboardHandler": {
            "pass": "pass",
            "potential_no_keyboard_access": "potential_no_keyboard_access"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_keyboard_handler_exists.html",
            "potential_no_keyboard_access": "aria_keyboard_handler_exists.html",
            "group": "aria_keyboard_handler_exists.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "potential_no_keyboard_access": "Verify the <{0}> element with \"{1}\" role has keyboard access",
            "group": "Interactive WAI_ARIA UI components must provide keyboard access"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return;
        var passed = true;
        var savedPassed = passed;
        var doc = ruleContext.ownerDocument;
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        //let roles = ruleContext.getAttribute("role").trim().toLowerCase().split(/\s+/);
        //only consider user specified role(s), rather than native containers
        var roles = AriaUtil_1.AriaUtil.getRoles(ruleContext, false);
        var nodeName = ruleContext.nodeName.toLowerCase();
        //if an explicit role is specified, the 'aria_role_redundant' rule should be triggered and addressed first,
        // and the current rule should be ignored
        if (nodeName === 'datalist' && roles && roles.includes("listbox"))
            return null;
        // Composite user interface widget roles. They act as containers that manage other, contained widgets.
        var roleContainers = ["combobox", "grid", "listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"];
        for (var _i = 0, roleContainers_1 = roleContainers; _i < roleContainers_1.length; _i++) {
            var role = roleContainers_1[_i];
            if (AriaUtil_1.AriaUtil.getAncestorWithRole(ruleContext, role, true) != null)
                // it's a descendant of a composite widget already examined
                return null;
        }
        var hasAttribute = CommonUtil_1.CommonUtil.hasAttribute;
        var roleNameArr = new Array();
        for (var j = 0; j < roles.length; ++j) {
            var pattern = designPatterns[roles[j]];
            if (roleContainers.indexOf(roles[j]) >= 0) {
                var disabled = hasAttribute(ruleContext, 'aria-disabled') ? ruleContext.getAttribute("aria-disabled") : '';
                if (!disabled) {
                    // See if there is a keyboard event handler on the parent element.
                    passed = (ruleContext.hasAttribute("onkeydown") || ruleContext.hasAttribute("onkeypress") || ruleContext.hasAttribute("onkeyup"));
                    // No keyboard event handler found on parent. See if keyboard event handlers are on required child elements.
                    if (!passed) {
                        if (!hasAttribute(ruleContext, 'aria-activedescendant')) {
                            var reqChildren = ARIADefinitions_1.ARIADefinitions.designPatterns[roles[j]].reqChildren;
                            if (reqChildren) { /* SMF TODO menubar does not have any reqChildren */
                                for (var i = 0, requiredChildrenLength = reqChildren.length; i < requiredChildrenLength; i++) {
                                    var xp = "*[contains(@role,'" + reqChildren[i] + "')]";
                                    var xpathResult = doc.evaluate(xp, ruleContext, CommonUtil_1.CommonUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                                    var r = xpathResult.iterateNext();
                                    while (r) {
                                        passed = (r.hasAttribute("onkeydown") || r.hasAttribute("onkeypress"));
                                        if (!passed) {
                                            // Child did not have a key handler. See if any of the grandchildren do.
                                            var xp2 = "descendant::*";
                                            var xpathResult2 = doc.evaluate(xp2, r, CommonUtil_1.CommonUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                                            var r2 = xpathResult2.iterateNext();
                                            while (r2 && !passed) {
                                                // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                                                // or not.
                                                //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                                                //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                                                //     add it to the roleToElems hash at all or even do any checking for it at all.
                                                //
                                                // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                                                //       so on and so forth.
                                                if (CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(r2)) {
                                                    r2 = xpathResult2.iterateNext();
                                                    continue;
                                                }
                                                passed = CommonUtil_1.CommonUtil.isTabbable(r2) &&
                                                    (r2.hasAttribute("onkeydown") || r2.hasAttribute("onkeypress"));
                                                if (!passed) {
                                                    // Is this an action link?
                                                    if (r2.nodeName.toLowerCase() == "a" && r2.hasAttribute("href")) {
                                                        var href = r2.getAttribute("href");
                                                        // Action link must start with "javascript:", must not contain a "void" and
                                                        // must have a function name following "javascript:" (i.e., href.length > 11)
                                                        passed = (href.startsWith("javascript:") && href.indexOf("void") == -1 && href.length > 11);
                                                    }
                                                }
                                                r2 = xpathResult2.iterateNext();
                                            }
                                        }
                                        if (!passed) {
                                            // All the required children (or any descendants of the required children) must have keypress/keydown
                                            // If not, it is a failure, no need to keep checking any more.
                                            break;
                                        }
                                        r = xpathResult.iterateNext();
                                    }
                                }
                            }
                            else {
                                // The current element failed the keydown/keypress, and it does not have required children, such as menubar.
                                // Let's check its descendants.
                                var xp2 = "descendant::*";
                                var xpathResult2 = doc.evaluate(xp2, ruleContext, CommonUtil_1.CommonUtil.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
                                var r2 = xpathResult2.iterateNext();
                                while (r2 && !passed) {
                                    // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                                    // or not.
                                    //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                                    //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                                    //     add it to the roleToElems hash at all or even do any checking for it at all.
                                    //
                                    // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                                    //       so on and so forth.
                                    if (CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(r2)) {
                                        r2 = xpathResult2.iterateNext();
                                        continue;
                                    }
                                    passed = CommonUtil_1.CommonUtil.isTabbable(r2) &&
                                        (r2.hasAttribute("onkeydown") || r2.hasAttribute("onkeypress"));
                                    if (!passed) {
                                        // Is this an action link?
                                        if (r2.nodeName.toLowerCase() == "a" && r2.hasAttribute("href")) {
                                            var href = r2.getAttribute("href");
                                            // Action link must start with "javascript:", must not contain a "void" and
                                            // must have a function name following "javascript:" (i.e., href.length > 11)
                                            passed = (href.startsWith("javascript:") && href.indexOf("void") == -1 && href.length > 11);
                                        }
                                    }
                                    r2 = xpathResult2.iterateNext();
                                }
                            }
                        }
                        else {
                            // Attribute 'aria-activedescendant' is specified.
                            passed = true;
                        }
                    }
                }
            }
            if (!passed) {
                roleNameArr.push(roles[j]);
            }
            if (!passed && savedPassed) {
                savedPassed = passed;
            }
        }
        var retToken1 = new Array();
        retToken1.push(ruleContext.nodeName.toLowerCase());
        var retToken2 = new Array();
        retToken2.push(roleNameArr.join(", "));
        // Determine if this is referenced by a combobox. If so, leave it to the combobox rules to check
        var id = ruleContext.getAttribute("id");
        if (id && id.trim().length > 0) {
            if (ruleContext.ownerDocument.querySelector("*[aria-controls='".concat(id, "'][role='combobox']"))) {
                return null;
            }
        }
        return savedPassed ? (0, IRule_1.RulePass)("pass") : (0, IRule_1.RulePotential)("potential_no_keyboard_access", [retToken1.toString(), retToken2.toString()]);
    }
};


/***/ }),

/***/ 9062:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_landmark_name_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var ARIAMapper_1 = __webpack_require__(4944);
var DOMUtil_1 = __webpack_require__(295);
var fragment_1 = __webpack_require__(482);
var CacheUtil_1 = __webpack_require__(7788);
var AccNameUtil_1 = __webpack_require__(1421);
var VisUtil_1 = __webpack_require__(8656);
var CommonUtil_1 = __webpack_require__(8137);
var AriaUtil_1 = __webpack_require__(490);
exports.aria_landmark_name_unique = {
    id: "aria_landmark_name_unique",
    context: "aria:complementary, aria:banner, aria:contentinfo, aria:main, aria:navigation, aria:region, aria:search, aria:form",
    refactor: {
        "landmark_name_unique": {
            "Pass_0": "pass",
            "Fail_0": "fail_label_not_unique"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_landmark_name_unique.html",
            "fail_label_not_unique": "aria_landmark_name_unique.html",
            "group": "aria_landmark_name_unique.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Multiple elements with \"{0}\" landmarks within the same parent region are distinguished by unique 'aria-label' or 'aria-labelledby'",
            "fail_label_not_unique": "Multiple elements with \"{0}\" landmarks within the same parent region are not distinguished from one another because they have the same \"{1}\" label",
            "group": "Each landmark should have a unique 'aria-labelledby' or 'aria-label' or be nested in a different parent region"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        },
        {
            "id": ["WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        // TODO do I need to fiter out bad contentinfo nodes: The footer element is not a contentinfo landmark when it is a descendant of the following HTML5 sectioning elements: https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/landmarks/HTML5.html
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        // Checking if this landmark is inside a dialog element. If it is we are going to skip checking it. 
        /**var copyOfRuleContext = ruleContext;
        var parnetNodesOfRuleContext = [];
        while (copyOfRuleContext) {
            parnetNodesOfRuleContext.unshift(copyOfRuleContext);
            copyOfRuleContext = copyOfRuleContext.parentElement;
        }
        parnetNodesOfRuleContext.forEach(elem => {
            if (elem !== null) {
                if (elem.tagName == "DIALOG" || elem.getAttribute('role') == "dialog") {
                    return null // Skipping checking landmarks that happen to be inside dialog elements
                }
            }
        })
        */
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["DIALOG"]) !== null || AriaUtil_1.AriaUtil.getAncestorWithRole(ruleContext, "dialog", true) !== null)
            return null;
        // Begining formCache work
        var ownerDocument = fragment_1.FragmentUtil.getOwnerFragment(ruleContext);
        var formCache = CacheUtil_1.CacheUtil.getCache(ruleContext.ownerDocument, "aria_landmark_name_unique", null);
        if (!formCache) {
            // console.log("---------ENTERING FORM CACHE")
            formCache = {
                navigationNodes: [],
                navigationNodesComputedLabels: [],
                navigationNodesParents: [],
                navigationNodesMatchFound: []
            };
            var navigationNodesTemp = ownerDocument.querySelectorAll('aside,[role="complementary"], footer,[role="contentinfo"], header,[role="banner"], main,[role="main"], nav,[role="navigation"], form,[role="form"], section,[role="region"],[role="search"]');
            var navigationNodes = Array.from(navigationNodesTemp);
            var navigationNodesParents = [];
            var navigationNodesMatchFound = [];
            // This block of code filters out any nav elements that are under a dialog. As those are not ones we want to test against as we consider dialogs are separate locations from the rest of the main page.
            var navigationNodesWithoutDialogs = [];
            for (var i = 0; i < navigationNodes.length; i++) {
                /**let a = navigationNodes[i];
                
                let dialogNodeFoundFlag = false;
                while (a) {
                    a = a.parentElement;
                    if (a !== null) {
                        if (a.tagName == "DIALOG" || a.getAttribute('role') == "dialog") {
                            dialogNodeFoundFlag = true;
                        }
                    }
                }
                if (!dialogNodeFoundFlag) {
                    navigationNodesWithoutDialogs.push(navigationNodes[i])
                }*/
                // ignore node that is AT hidden or in a dialog
                if (VisUtil_1.VisUtil.isNodeHiddenFromAT(navigationNodes[i]) || CommonUtil_1.CommonUtil.getAncestor(navigationNodes[i], ["DIALOG"]) !== null || AriaUtil_1.AriaUtil.getAncestorWithRole(navigationNodes[i], "dialog", true) !== null)
                    continue;
                navigationNodesWithoutDialogs.push(navigationNodes[i]);
            }
            navigationNodes = navigationNodesWithoutDialogs;
            for (var i = 0; i < navigationNodes.length; i++) {
                // Loop over all the landmark nodes
                var els = [];
                var a = navigationNodes[i].parentElement;
                while (a) {
                    els.push(a);
                    a = a.parentElement;
                }
                for (var j = 0; j < els.length; j++) {
                    // Loop over all the parents of the landmark nodes
                    // Find nearest landmark parent based on the tagName or the role attribute
                    var tagNameTrigger = [
                        "ASIDE",
                        "FOOTER",
                        "FORM",
                        "HEADER",
                        "MAIN",
                        "NAV",
                        "SECTION",
                    ].includes(els[j].tagName);
                    var roleNameTrigger = false;
                    if (els[j].hasAttribute("role")) {
                        roleNameTrigger = [
                            "complementary",
                            "contentinfo",
                            "form",
                            "banner",
                            "main",
                            "navigation",
                            "region",
                            "search",
                        ].includes(els[j].getAttribute("role")); // TODO we are not covering the case where a elemenent with multiple roles. e.g., role = "form banner". This is a improvment we might want to add in the future.
                    }
                    if (tagNameTrigger || roleNameTrigger) {
                        // Nearest parent-landmark found
                        navigationNodesParents.push(els[j]);
                        break;
                    }
                    if (j === els.length - 1) {
                        // This node is at the head of the file so it does not have a parent
                        navigationNodesParents.push(null);
                        break;
                    }
                }
            }
            var navigationNodesComputedLabels = [];
            for (var i = 0; i < navigationNodes.length; i++) {
                var pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(navigationNodes[i]);
                // Loop over all the landmark nodes
                navigationNodesComputedLabels.push(
                /**ARIAMapper.computeName(navigationNodes[i])*/
                pair && pair.name && pair.name.trim().length > 0 ? pair.name.trim() : "");
            }
            for (var i = 0; i < navigationNodesParents.length; i++) {
                // Loop over all the parents of the landmark nodes to find duplicates
                var matchFound = false;
                var pass_0_flag = false;
                for (var j = 0; j < navigationNodesParents.length; j++) {
                    if (j === i) {
                        // We do not want to compare against ourselfs
                        continue;
                    }
                    // This if statement focus on the case where the parent landmark is null
                    if (navigationNodesParents[i] === null &&
                        navigationNodesParents[j] === null) {
                        // We are looking at two root nodes, so we should compare them.
                        if (ARIAMapper_1.ARIAMapper.nodeToRole(navigationNodes[i]) ===
                            ARIAMapper_1.ARIAMapper.nodeToRole(navigationNodes[j])) {
                            // Both nodes have the same role AND
                            if (navigationNodesComputedLabels[i] ===
                                navigationNodesComputedLabels[j]) {
                                // both have the same (computed) aria-label/aria-labelledby
                                // if (navigationNodesComputedLabels[i] === "") {
                                navigationNodesMatchFound.push("fail_label_not_unique"); // Fail 0
                                matchFound = true;
                                break;
                                // }
                            }
                            else {
                                // Same parents && same node roles BUT different computed aria-label/aria-labelledby
                                // We have at least a Pass_0. But we need to check all nodes to see if another one fails. So set a flag.
                                pass_0_flag = true;
                            }
                        }
                        else {
                            // Same parents but different node roles // Not applicable
                        }
                    }
                    else if (navigationNodesParents[i] === null ||
                        navigationNodesParents[j] === null) {
                        // We are looking at a single root node
                        continue;
                    }
                    // This if statement focus on the case where the parent landmark is NOT null
                    if (DOMUtil_1.DOMUtil.sameNode(navigationNodesParents[i], navigationNodesParents[j])) {
                        // We have the same parent-landmark AND
                        if (ARIAMapper_1.ARIAMapper.nodeToRole(navigationNodes[i]) ===
                            ARIAMapper_1.ARIAMapper.nodeToRole(navigationNodes[j])) {
                            // Both nodes have the same role AND
                            if (navigationNodesComputedLabels[i] ===
                                navigationNodesComputedLabels[j]) {
                                // both have the same (computed) aria-label/aria-labelledby
                                // if (navigationNodesComputedLabels[i] === "") {
                                navigationNodesMatchFound.push("fail_label_not_unique"); // Fail 0
                                matchFound = true;
                                break;
                                // }
                            }
                            else {
                                // Same parents && same node roles BUT different computed aria-label/aria-labelledby
                                // We have at least a Pass_0. But we need to check all nodes to see if another one fails. So set a flag.
                                pass_0_flag = true;
                            }
                        }
                        else {
                            // Same parents but different node roles // Not applicable
                        }
                    }
                    else {
                        // Different parents // Not applicable
                    }
                }
                if (!matchFound) {
                    if (pass_0_flag) {
                        navigationNodesMatchFound.push("pass");
                    }
                    else {
                        navigationNodesMatchFound.push("null"); // This is not the keyword null on purpose. It is a spaceholder in the array so indexes match up.
                    }
                }
            }
            formCache.navigationNodesComputedLabels =
                navigationNodesComputedLabels;
            formCache.navigationNodes = navigationNodes;
            formCache.navigationNodesParents = navigationNodesParents;
            formCache.navigationNodesMatchFound = navigationNodesMatchFound;
            CacheUtil_1.CacheUtil.setCache(ruleContext.ownerDocument, "aria_landmark_name_unique", formCache);
            // TODO Add validation that all 3 arrays are the same length
            // console.log("-------------End formCache")
        } // End formCache
        var indexToCheck = -1;
        for (var i = 0; i < formCache.navigationNodes.length; i++) {
            if (ruleContext.isSameNode(formCache.navigationNodes[i])) {
                indexToCheck = i;
            }
        }
        if (indexToCheck === -1) {
            return null;
        }
        if (formCache.navigationNodesMatchFound[indexToCheck] === "pass") {
            return (0, IRule_1.RulePass)("pass", [
                ARIAMapper_1.ARIAMapper.nodeToRole(formCache.navigationNodes[indexToCheck]),
            ]);
        }
        else if (formCache.navigationNodesMatchFound[indexToCheck] === "fail_label_not_unique") {
            return (0, IRule_1.RuleFail)("fail_label_not_unique", [
                ARIAMapper_1.ARIAMapper.nodeToRole(formCache.navigationNodes[indexToCheck]),
                formCache.navigationNodesComputedLabels[indexToCheck],
            ]);
        }
        else {
            return null;
        }
    }
};


/***/ }),

/***/ 5746:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_main_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_main_label_unique = {
    id: "aria_main_label_unique",
    context: "aria:main",
    refactor: {
        "Rpt_Aria_MultipleMainsRequireLabel_Implicit_2": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_main_label_unique.html",
            "Fail_1": "aria_main_label_unique.html",
            "group": "aria_main_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"main\" role do not have unique labels",
            "group": "Each element with \"main\" role must have unique label that describes its purposes"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var contextLabel = AriaUtil_1.AriaUtil.getAriaLabel(ruleContext);
        var parentDocRole = AriaUtil_1.AriaUtil.getAncestorWithRole(ruleContext, "document", true);
        var mains = CommonUtil_1.CommonUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "main", true, true);
        var result = null;
        for (var i = 0; i < mains.length; ++i) {
            if (mains[i] === ruleContext)
                continue;
            result = (0, IRule_1.RulePass)("Pass_0");
            var thisParentDocRole = AriaUtil_1.AriaUtil.getAncestorWithRole(mains[i], "document", true);
            if (thisParentDocRole === parentDocRole) {
                if (AriaUtil_1.AriaUtil.getAriaLabel(mains[i]) === contextLabel) {
                    result = (0, IRule_1.RuleFail)("Fail_1");
                    break;
                }
            }
        }
        return result;
    }
};


/***/ }),

/***/ 8685:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_main_label_visible = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_main_label_visible = {
    id: "aria_main_label_visible",
    context: "dom:body",
    refactor: {
        "Rpt_Aria_MultipleMainsVisibleLabel_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_main_label_visible.html",
            "Fail_1": "aria_main_label_visible.html",
            "group": "aria_main_label_visible.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"main\" role do not have unique visible labels",
            "group": "Each element with \"main\" role should have a unique visible label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        // Consider the Check Hidden Content setting that is set by the rules
        //call getElementsByRoleHidden with considerImplicit flag as true
        //so that the method returs <main> elements
        var landmarks = CommonUtil_1.CommonUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "main", true, true);
        if (landmarks.length === 0 || landmarks.length === 1) {
            return null;
        }
        var passed = AriaUtil_1.AriaUtil.hasUniqueAriaLabelledby(landmarks);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 2678:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_navigation_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_navigation_label_unique = {
    id: "aria_navigation_label_unique",
    context: "aria:navigation",
    refactor: {
        "Rpt_Aria_MultipleNavigationLandmarks_Implicit": {
            "Pass_0": "pass",
            "Fail_1": "fail_label_not_unique"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_navigation_label_unique.html",
            "fail_label_not_unique": "aria_navigation_label_unique.html",
            "group": "aria_navigation_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element with \"navigation\" role has a unique label that describes its purpose",
            "fail_label_not_unique": "Multiple elements with \"navigation\" role do not have unique labels",
            "group": "Each element with \"navigation\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var dupped = AriaUtil_1.AriaUtil.isLandmarkNameUnique(ruleContext, "navigation", true);
        if (dupped == null)
            return null;
        if (dupped) {
            return (0, IRule_1.RuleFail)("fail_label_not_unique");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 971:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_parent_required = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var ARIADefinitions_1 = __webpack_require__(8235);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_parent_required = {
    id: "aria_parent_required",
    context: "dom:*[role]",
    dependencies: ["aria_role_allowed"],
    refactor: {
        "Rpt_Aria_RequiredParent_Native_Host_Sematics": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_parent_required.html",
            "Pass_0": "aria_parent_required.html",
            "Fail_1": "aria_parent_required.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Each element with an implicit or explicit role must be contained within a valid element",
            "Pass_0": "Rule Passed",
            "Fail_1": "Element with \"{0}\" role is not contained in or owned by an element with one of the following roles: \"{1}\""
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    // TODO: ACT: Check Fail 3
    act: "ff89c9",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return;
        //skip the check if the element should be a presentational child of an element
        if (AriaUtil_1.AriaUtil.shouldBePresentationalChild(ruleContext) || VisUtil_1.VisUtil.isNodePresentational(ruleContext))
            return;
        var passed = true;
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        var roleNameArr = new Array();
        var containerRoles = new Array();
        var testedContainer = 0;
        var ancestorRoles = contextHierarchies["aria"].map(function (info) { return info.role; });
        var parentRole = ancestorRoles[ancestorRoles.length - 2];
        var count = 2;
        while (parentRole === 'none') {
            count++;
            parentRole = ancestorRoles[ancestorRoles.length - count];
        }
        /**for (let j = 0, length = roles.length; j < length; ++j) {
            if (designPatterns[roles[j]] && designPatterns[roles[j]].container != null) {
                testedContainer++;
                passed = false;
                containerRoles = designPatterns[roles[j]].container;
                for (let i = 0, containersLength = containerRoles.length; !passed && i < containersLength; i++) {
                    passed = parentRole === containerRoles[i];
                    if (passed) break;
                }
                if (passed == false) {
                    roleNameArr.push(roles[j]);
                }
            }
        }
        */
        var role = AriaUtil_1.AriaUtil.getResolvedRole(ruleContext);
        if (designPatterns[role] && designPatterns[role].container != null) {
            testedContainer++;
            passed = false;
            containerRoles = designPatterns[role].container;
            for (var i = 0, containersLength = containerRoles.length; !passed && i < containersLength; i++) {
                passed = parentRole === containerRoles[i];
                if (passed)
                    break;
            }
            if (passed == false) {
                roleNameArr.push(role);
            }
        }
        var retToken1 = new Array();
        retToken1.push(roleNameArr.join(", "));
        var retToken2 = new Array();
        retToken2.push(containerRoles.join(", "));
        //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [retToken1, retToken2]);
        if (testedContainer == 0) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [retToken1.toString(), retToken2.toString()]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 3709:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_region_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_region_label_unique = {
    id: "aria_region_label_unique",
    context: "aria:region",
    refactor: {
        "Rpt_Aria_MultipleRegionsUniqueLabel_Implicit": {
            "Pass_0": "pass",
            "Fail_1": "fail_label_not_unique"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_region_label_unique.html",
            "fail_label_not_unique": "aria_region_label_unique.html",
            "group": "aria_region_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element with \"region\" role has a unique label that describes its purpose",
            "fail_label_not_unique": "Multiple elements with \"region\" role do not have unique labels",
            "group": "Each element with \"region\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var dupped = AriaUtil_1.AriaUtil.isLandmarkNameUnique(ruleContext, "region");
        if (dupped == null)
            return null;
        if (dupped) {
            return (0, IRule_1.RuleFail)("fail_label_not_unique");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 6486:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_region_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_region_labelled = {
    id: "aria_region_labelled",
    context: "aria:region",
    refactor: {
        "Rpt_Aria_RegionLabel_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
            // "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_region_labelled.html",
            "Fail_1": "aria_region_labelled.html",
            // "Fail_2": "aria_region_labelled.html",
            "group": "aria_region_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Element with \"region\" role does not have a label",
            // "Fail_2": "Element with \"region\" role is not labeled with 'aria-label' or 'aria-labelledby'",
            "group": "Each element with \"region\" role must have a label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = AriaUtil_1.AriaUtil.hasAriaLabel(ruleContext) || CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "title");
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
    }
};


/***/ }),

/***/ 4151:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_role_allowed = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
exports.aria_role_allowed = {
    id: "aria_role_allowed",
    context: "dom:*[role]",
    refactor: {
        "Rpt_Aria_ValidRole": {
            "Pass_0": "Pass_0",
            "Fail_2": "Fail_2",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_role_allowed.html",
            "Pass_0": "aria_role_allowed.html",
            "Fail_2": "aria_role_allowed.html",
            "Potential_1": "aria_role_allowed.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Elements must have a valid 'role' per ARIA specification",
            "Pass_0": "Rule Passed",
            "Fail_2": "The role '{0}' defined on the element is not valid per ARIA specification",
            "Potential_1": "Some of the roles, '{0}', defined on the element are not valid per ARIA specification"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "4.1.2",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    // TODO: ACT: Recheck
    act: "674b10",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var roleStr = ruleContext.getAttribute("role").trim().toLowerCase();
        if (roleStr.length === 0) {
            return null;
        }
        if (ruleContext.hasAttribute("aria-hidden") && ruleContext.getAttribute("aria-hidden").toLowerCase() === "true") {
            return null;
        }
        var invalidRoles = AriaUtil_1.AriaUtil.getRolesUndefinedByAria(ruleContext);
        if (!invalidRoles || invalidRoles.length === 0)
            return (0, IRule_1.RulePass)("Pass_0");
        else {
            var roles = roleStr.split(/\s+/);
            if (invalidRoles.length === roles.length) {
                return (0, IRule_1.RuleFail)("Fail_2", [invalidRoles.join(",")]);
            }
            else if (invalidRoles.length > 0) {
                return (0, IRule_1.RulePotential)("Potential_1", [invalidRoles.join(",")]);
            }
        }
    }
};


/***/ }),

/***/ 8545:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_role_redundant = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var TableUtil_1 = __webpack_require__(5755);
exports.aria_role_redundant = {
    id: "aria_role_redundant",
    context: "dom:*[role]",
    help: {
        "en-US": {
            "pass": "aria_role_redundant.html",
            "fail_redundant": "aria_role_redundant.html",
            "group": "aria_role_redundant.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "An explicitly-assigned ARIA role is not redundant with the implicit role of the element",
            "fail_redundant": "The explicitly-assigned ARIA role \"{0}\" is redundant with the implicit role of the element <{1}>",
            "group": "An explicitly-assigned ARIA role should not be redundant with the implicit role of the element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next"],
            "num": ["ARIA"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var elemName = ruleContext.tagName.toLowerCase();
        var ariaRoles = AriaUtil_1.AriaUtil.getRoles(ruleContext, false);
        if (!ariaRoles || ariaRoles.length === 0)
            return;
        // the invalid role case: handled by Rpt_Aria_ValidRole. Ignore to avoid duplicated report
        var role_defined = AriaUtil_1.AriaUtil.areRolesDefined(ariaRoles);
        if (!role_defined)
            return null;
        // dependency check: if it's already failed in the parent relation, then skip this check
        if (["td", "th", "tr"].includes(elemName)) {
            var parentRole = TableUtil_1.TableUtil.isTableDescendant(contextHierarchies);
            if (parentRole !== null && parentRole.length > 0)
                return null;
        }
        var implicitRoles = AriaUtil_1.AriaUtil.getImplicitRole(ruleContext);
        if (!implicitRoles || implicitRoles.length === 0)
            return (0, IRule_1.RulePass)("pass");
        var ret = [];
        for (var i = 0; i < ariaRoles.length; i++) {
            if (!implicitRoles.includes(ariaRoles[i]))
                ret.push((0, IRule_1.RulePass)("pass"));
            else
                ret.push((0, IRule_1.RuleFail)("fail_redundant", [ariaRoles[i], elemName]));
        }
        if (ret.length > 0)
            return ret;
        return null;
    }
};


/***/ }),

/***/ 8538:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_search_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
exports.aria_search_label_unique = {
    id: "aria_search_label_unique",
    context: "aria:search",
    refactor: {
        "Rpt_Aria_MultipleSearchLandmarks": {
            "Pass_0": "pass",
            "Fail_1": "fail_label_not_unique"
        }
    },
    help: {
        "en-US": {
            "pass": "aria_search_label_unique.html",
            "fail_label_not_unique": "aria_search_label_unique.html",
            "group": "aria_search_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element with \"search\" role has a unique label that describes its purpose",
            "fail_label_not_unique": "Multiple elements with \"search\" role do not have unique labels",
            "group": "Each element with \"search\" role must have a unique label that describes its purpose"
        }
    },
    /**
     * deprecated the rule on 01/27/2025
     * rulesets: [{
        "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
        "num": ["2.4.1"],
        "level": eRulePolicy.VIOLATION,
        "toolkitLevel": eToolkitLevel.LEVEL_THREE
    }],*/
    rulesets: [{
            "id": [],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var dupped = AriaUtil_1.AriaUtil.isLandmarkNameUnique(ruleContext, "search", true);
        if (dupped == null)
            return null;
        if (dupped) {
            return (0, IRule_1.RuleFail)("fail_label_not_unique");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 1908:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_attribute_valid = exports.aria_role_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
exports.aria_role_valid = {
    id: "aria_role_valid",
    context: "dom:*",
    dependencies: ["aria_attribute_allowed"],
    refactor: {
        "aria_semantics_role": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_role_valid.html",
            "Fail_1": "aria_role_valid.html",
            "Fail_2": "aria_role_valid.html",
            "group": "aria_role_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The ARIA role '{0}' is not valid for the element <{1}>",
            "Fail_2": "The ARIA role '{0}' is not valid for the element <{1}> and may be ignored by the browser since the element is focusable",
            "group": "ARIA roles must be valid for the element to which they are assigned"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var tagName = ruleContext.tagName.toLowerCase();
        // only chek element (1) and fragment nodes (11)
        if (ruleContext.nodeType !== 1 /* Node.ELEMENT_NODE */)
            return null;
        //skip the rule
        // the invalid role case: handled by aria_role_allowed. Ignore to avoid duplicated report
        var undefinedRoles = AriaUtil_1.AriaUtil.getRolesUndefinedByAria(ruleContext);
        if (undefinedRoles && undefinedRoles.length > 0)
            return null;
        var deprecatedRoles = AriaUtil_1.AriaUtil.getDeprecatedAriaRoles(ruleContext);
        if (deprecatedRoles && deprecatedRoles.length > 0)
            return null;
        var deprecatedAttributes = AriaUtil_1.AriaUtil.getDeprecatedAriaAttributes(ruleContext);
        if (deprecatedAttributes && deprecatedAttributes.length > 0)
            return null;
        // dependency check: if it's already failed, then skip
        if (["td", "th", "tr"].includes(tagName)) {
            var parentRole = CommonUtil_1.CommonUtil.isTableDescendant(contextHierarchies);
            if (parentRole !== null && parentRole.length > 0)
                return null;
        }
        var domRoles = AriaUtil_1.AriaUtil.getUserDefinedRoles(ruleContext);
        if (!domRoles || domRoles.length === 0)
            return null;
        // check the 'generic' role first
        if (domRoles.includes('generic'))
            return (0, IRule_1.RuleFail)("Fail_1", ["generic", tagName]);
        var invalidRoles = AriaUtil_1.AriaUtil.getInvalidRoles(ruleContext);
        if (invalidRoles === null || invalidRoles.length === 0)
            return (0, IRule_1.RulePass)("Pass_0", [domRoles.join(", "), tagName]);
        if (invalidRoles.includes("presentation") || invalidRoles.includes("none") && CommonUtil_1.CommonUtil.isTabbable(ruleContext))
            return (0, IRule_1.RuleFail)("Fail_2", [invalidRoles.join(", "), tagName]);
        if (invalidRoles.length > 0)
            return (0, IRule_1.RuleFail)("Fail_1", [invalidRoles.join(", "), tagName]);
        if (domRoles.length > 0)
            return (0, IRule_1.RulePass)("Pass_0", [domRoles.join(", "), tagName]);
        return null;
    }
};
// This rule is in the same file because there is a dependency that aria_role_valid runs first,
// and the info is passed by cache, but there isn't a dependency in the Fail_2 scenario, so regular
// dependency cannot be used
exports.aria_attribute_valid = {
    id: "aria_attribute_valid",
    context: "dom:*",
    // The the ARIA role is completely invalid, skip this check
    dependencies: ["aria_attribute_deprecated", "aria_role_valid"],
    refactor: {
        "aria_attribute_allowed": {
            "Pass": "Pass",
            "Fail_invalid_role_attr": "Fail_invalid_role_attr",
            "Fail_invalid_implicit_role_attr": "Fail_invalid_implicit_role_attr"
        }
    },
    help: {
        "en-US": {
            "group": "aria_attribute_valid.html",
            "Pass": "aria_attribute_valid.html",
            "Fail_invalid_role_attr": "aria_attribute_valid.html",
            "Fail_invalid_implicit_role_attr": "aria_attribute_valid.html"
        }
    },
    messages: {
        "en-US": {
            "group": "ARIA attributes should be valid for the element and ARIA role to which they are assigned",
            "Pass": "ARIA attributes are valid for the element and ARIA role",
            "Fail_invalid_role_attr": "The ARIA attributes \"{0}\" are not valid for the element <{1}> with ARIA role \"{2}\"",
            "Fail_invalid_implicit_role_attr": "The ARIA attributes \"{0}\" are not valid for the element <{1}> with implicit ARIA role \"{2}\""
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["ARIA"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: ["5c01ea", { "46ca7f": { "Pass": "pass", "Fail_invalid_role_attr": "fail", "Fail_invalid_implicit_role_attr": "fail" } }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // only chek element (1)
        if (ruleContext.nodeType !== 1 /* Node.ELEMENT_NODE */)
            return null;
        // ignore if no aria attribute
        var ariaAttributes = AriaUtil_1.AriaUtil.getUserDefinedAriaAttributes(ruleContext);
        if (ariaAttributes === null || ariaAttributes.length === 0)
            return null;
        var roles = AriaUtil_1.AriaUtil.getUserDefinedRoles(ruleContext);
        var explicit = true;
        if (roles && roles.length > 0) {
            // the invalid role case: handled by Rpt_Aria_ValidRole. Ignore to avoid duplicated report
            if (!AriaUtil_1.AriaUtil.areRolesDefined(roles))
                return null;
        }
        else {
            //no explicit role defined
            roles = AriaUtil_1.AriaUtil.getImplicitRole(ruleContext);
            explicit = false;
        }
        var tagName = ruleContext.tagName.toLowerCase();
        var failedAttributes = AriaUtil_1.AriaUtil.getInvalidAriaAttributes(ruleContext);
        if (!failedAttributes || failedAttributes.length === 0)
            return (0, IRule_1.RulePass)("Pass", [ariaAttributes.join(", "), tagName, roles.join(", ")]);
        if (roles.length > 0) {
            if (explicit)
                return (0, IRule_1.RuleFail)("Fail_invalid_role_attr", [failedAttributes.join(", "), tagName, roles.join(", ")]);
            else
                return (0, IRule_1.RuleFail)("Fail_invalid_implicit_role_attr", [failedAttributes.join(", "), tagName, roles.join(", ")]);
        }
        return (0, IRule_1.RuleFail)("Fail_invalid_role_attr", [failedAttributes.join(", "), tagName, "none"]);
    }
};


/***/ }),

/***/ 6360:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_toolbar_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var CacheUtil_1 = __webpack_require__(7788);
exports.aria_toolbar_label_unique = {
    id: "aria_toolbar_label_unique",
    context: "aria:toolbar",
    refactor: {
        "Rpt_Aria_MultipleToolbarUniqueLabel": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "aria_toolbar_label_unique.html",
            "Fail_1": "aria_toolbar_label_unique.html",
            "group": "aria_toolbar_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Multiple elements with \"toolbar\" roles do not have unique labels",
            "group": "Each element with \"toolbar\" role must have a unique label that describes its purpose"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Consider the Check Hidden Content setting that is set by the rules
        // Also, consider Implicit role checking.
        var landmarks = CommonUtil_1.CommonUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "toolbar", true, true);
        if (landmarks.length === 0 || landmarks.length === 1) {
            return null;
        }
        var dupes = CacheUtil_1.CacheUtil.getCache(ruleContext.ownerDocument, "aria_toolbar_label_unique", null);
        if (!dupes) {
            dupes = AriaUtil_1.AriaUtil.findAriaLabelDupes(landmarks);
            CacheUtil_1.CacheUtil.setCache(ruleContext.ownerDocument, "aria_toolbar_label_unique", dupes);
        }
        var myLabel = AriaUtil_1.AriaUtil.getAriaLabel(ruleContext);
        var passed = myLabel !== "" && (!(myLabel in dupes) || dupes[myLabel] <= 1);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [myLabel]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 5386:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aria_widget_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var ARIAMapper_1 = __webpack_require__(4944);
var fragment_1 = __webpack_require__(482);
var ARIADefinitions_1 = __webpack_require__(8235);
var DOMUtil_1 = __webpack_require__(295);
exports.aria_widget_labelled = {
    id: "aria_widget_labelled",
    context: "dom:*",
    refactor: {
        "Rpt_Aria_WidgetLabels_Implicit": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "aria_widget_labelled.html",
            "Pass_0": "aria_widget_labelled.html",
            "Fail_1": "aria_widget_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Interactive component must have a programmatically associated name",
            "Pass_0": "Rule Passed",
            "Fail_1": "Interactive component with ARIA role '{0}' does not have a programmatically associated name"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "m6b1q3",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        /* removed the role check role= presentation and role=none since these 2 roles are not in the list of widget type roles */
        if ((ruleContext.hasAttribute("type") &&
            ruleContext.getAttribute("type") === "hidden") ||
            (AriaUtil_1.AriaUtil.getAncestorWithRole(ruleContext, "combobox") &&
                !(AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, "textbox") ||
                    AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, "searchbox")))) {
            // we need to diagnose that a combobox input textbox has a label(github issue #1104)
            return null;
        }
        var elemRole = ARIAMapper_1.ARIAMapper.nodeToRole(ruleContext);
        var tagName = ruleContext.nodeName.toLowerCase();
        // Handled by input_label_exists
        var skipRoles = [
            "button",
            "checkbox",
            "combobox",
            "listbox",
            "menuitemcheckbox",
            "menuitemradio",
            "radio",
            "searchbox",
            "slider",
            "spinbutton",
            "switch",
            "textbox",
            "progressbar",
            "link",
        ];
        if (skipRoles.includes(elemRole))
            return null;
        if (tagName === "output" ||
            (tagName === "input" &&
                ruleContext.getAttribute("type") === "file")) {
        }
        if (!ruleContext.hasAttribute("role")) {
            // Form/input elements are checked by G41, we skip them from this rule. Github issue 449
            var skipElements = [
                "input",
                "textarea",
                "select",
                "button",
                "datalist",
                "optgroup",
                "option",
                "keygen",
                "output",
                "progress",
                "meter",
            ];
            if (skipElements.indexOf(ruleContext.nodeName.toLowerCase()) !=
                -1) {
                return null;
            }
        }
        // avoid diagnosing the popup list of a combobox.
        var rolesToCheck = ["listbox", "tree", "grid", "dialog"];
        for (var j = 0; j < rolesToCheck.length; j++) {
            if (AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, rolesToCheck[j])) {
                var comboboxes = CommonUtil_1.CommonUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "combobox", true, true);
                for (var k = 0; k < comboboxes.length; k++) {
                    var combobox = comboboxes[k];
                    var aria_owns = CommonUtil_1.CommonUtil.getElementAttribute(combobox, "aria-owns");
                    if (aria_owns) {
                        var owns = CommonUtil_1.CommonUtil.normalizeSpacing(aria_owns.trim()).split(" ");
                        for (var i = 0; i < owns.length; i++) {
                            var owned = fragment_1.FragmentUtil.getById(ruleContext, owns[i]);
                            if (owned === ruleContext) {
                                return null;
                            }
                        }
                    }
                }
            }
        }
        var passed = true;
        var prohibited = false;
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        //get attribute roles as well as implicit roles.
        var roles = AriaUtil_1.AriaUtil.getRoles(ruleContext, true);
        var numWidgetsTested = 0;
        var interactiveRoleTypes = ["widget", "liveRegion", "window"];
        for (var i = 0, length_1 = roles.length; passed && i < length_1; ++i) {
            var pattern = designPatterns[roles[i]];
            if (pattern &&
                pattern.nameRequired &&
                pattern.roleType &&
                interactiveRoleTypes.includes(pattern.roleType)) {
                ++numWidgetsTested;
                // All widgets may have an author supplied accessible name.
                // Title is legal, but don't advertise its use in documentation.
                // Encourage use of aria-label, aria-labelledby or html label element.
                passed =
                    AriaUtil_1.AriaUtil.hasAriaLabel(ruleContext) ||
                        CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "title") ||
                        CommonUtil_1.CommonUtil.getLabelForElementHidden(ruleContext, true);
                if (!passed &&
                    pattern.nameFrom &&
                    pattern.nameFrom.indexOf("contents") >= 0) {
                    // See if widget's accessible name is supplied by element's inner text
                    // nameFrom: ["author", "contents"]
                    passed = CommonUtil_1.CommonUtil.hasInnerContentOrAlt(ruleContext);
                }
                if (!passed) {
                    // check if it has implicit label, like <label><input ....>abc </label>
                    passed = CommonUtil_1.CommonUtil.hasImplicitLabel(ruleContext);
                }
                if (!passed &&
                    ruleContext.tagName.toLowerCase() === "img" &&
                    !ruleContext.hasAttribute("role") &&
                    ruleContext.hasAttribute("alt")) {
                    passed =
                        DOMUtil_1.DOMUtil.cleanWhitespace(ruleContext.getAttribute("alt")).trim().length > 0;
                }
                if (pattern.nameFrom.indexOf("prohibited") >= 0) {
                    prohibited = true;
                }
            }
        }
        if (numWidgetsTested === 0) {
            return null;
        }
        else if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", [elemRole]);
        }
        else {
            //TODO
            //                if (prohibited) {
            //                    return RuleFail("Fail_2");
            //                } else {
            return (0, IRule_1.RulePass)("Pass_0");
            //                }
        }
    }
};


/***/ }),

/***/ 8752:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asciiart_alt_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.asciiart_alt_exists = {
    id: "asciiart_alt_exists",
    context: "dom:pre, dom:listing, dom:xmp, dom:plaintext",
    refactor: {
        "RPT_Pre_ASCIIArt": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "asciiart_alt_exists.html",
            "Potential_1": "asciiart_alt_exists.html",
            "group": "asciiart_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that ASCII art has a text alternative",
            "group": "ASCII art must have a text alternative"
        }
    },
    /**
     * Decision in planning 9/7/23 that this rule causes more reviews that we see actual problems in content, so turn these rules off
    rulesets: [{
        "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
        "num": ["1.1.1"],
        "level": eRulePolicy.VIOLATION,
        "toolkitLevel": eToolkitLevel.LEVEL_ONE
    }],
    */
    rulesets: [],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Fix for IDWB writers. Don't trigger if content is in a code element.  The code element is searched for
        // in various places because of the weird way various browsers render <code><pre></pre></code.  Firefox,
        // HtmlUnit and Chrome all render differently.  Firefox: <code></code><pre></pre>  HtmlUnit: </code><pre><code></code></pre>
        // See unit test CodeElementAbovePreElement.html.  Don't know how RPT renders, so cover all the bases.
        if (ruleContext.nodeName.toLowerCase() == "pre") {
            if ((ruleContext.previousSibling && ruleContext.previousSibling.nodeName.toLowerCase() == "code") ||
                ruleContext.getElementsByTagName("code").length > 0 ||
                CommonUtil_1.CommonUtil.getAncestor(ruleContext, "code")) {
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
        var passed = true;
        var txtValue = CommonUtil_1.CommonUtil.getInnerText(ruleContext);
        var nonAlphaNumericNorSpaceCount = 0;
        var alphNumSameCharacterCount = 0;
        var lastCharacter = "";
        // Iterate through the text content
        for (var idx = 0; passed && (idx < txtValue.length); ++idx) {
            var chStr = txtValue.substr(idx, 1);
            // Check if it is alphanumeric or punctuation
            if (/[\w!@#$%&\*().,?\[\]{}<>=":\/\\-]/.test(chStr)) {
                // Detect same character sequence
                if (lastCharacter == chStr) {
                    alphNumSameCharacterCount = alphNumSameCharacterCount + 1;
                    ;
                }
                else {
                    alphNumSameCharacterCount = 0;
                }
            }
            else if (/\s/.test(chStr)) {
                alphNumSameCharacterCount = 0;
            }
            else {
                nonAlphaNumericNorSpaceCount = nonAlphaNumericNorSpaceCount + 1;
                alphNumSameCharacterCount = 0;
            }
            lastCharacter = chStr;
            // Make the decision
            if (nonAlphaNumericNorSpaceCount >= 5 || alphNumSameCharacterCount >= 4) {
                passed = false;
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 4392:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.blink_css_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.blink_css_review = {
    id: "blink_css_review",
    context: "dom:style, dom:*[style]",
    refactor: {
        "RPT_Blink_CSSTrigger1": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "blink_css_review.html",
            "Pass_0": "blink_css_review.html",
            "Potential_1": "blink_css_review.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Do not use the \"blink\" value of the 'text-decoration' property for longer than five seconds",
            "Pass_0": "Rule Passed",
            "Potential_1": "Check the \"blink\" value of the CSS 'text-decoration' property is not used for more than than five seconds"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "2.2.2",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var textValue = CommonUtil_1.CommonUtil.getInnerText(ruleContext);
        if (ruleContext.hasAttribute('style')) {
            textValue = ruleContext.getAttribute('style');
        }
        var passed = textValue.toLowerCase().indexOf("text-decoration:blink") == -1;
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 932:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.blink_elem_deprecated = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.blink_elem_deprecated = {
    id: "blink_elem_deprecated",
    context: "dom:blink",
    refactor: {
        "WCAG20_Blink_AlwaysTrigger": {
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "blink_elem_deprecated.html",
            "Fail_1": "blink_elem_deprecated.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Content that blinks persistently must not be used",
            "Fail_1": "Content found that blinks persistently"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "2.2.2",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        // const ruleContext = context["dom"].node as Element;
        return (0, IRule_1.RuleFail)("Fail_1");
    }
};


/***/ }),

/***/ 6255:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.blockquote_cite_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.blockquote_cite_exists = {
    id: "blockquote_cite_exists",
    context: "dom:blockquote",
    refactor: {
        "RPT_Blockquote_HasCite": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "blockquote_cite_exists.html",
            "Potential_1": "blockquote_cite_exists.html",
            "group": "blockquote_cite_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that <blockquote> should have a 'cite' attribute and not be used for indentation only",
            "group": "Use <blockquote> only for quotations, not indentation"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "cite");
        if (!passed) {
            var citeElems = CommonUtil_1.CommonUtil.getDocElementsByTag(ruleContext, "cite");
            passed = citeElems != null && citeElems.length > 0;
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5743:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.canvas_content_described = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
exports.canvas_content_described = {
    id: "canvas_content_described",
    context: "dom:canvas",
    refactor: {
        "HAAC_Canvas": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "canvas_content_described.html",
            "Manual_1": "canvas_content_described.html",
            "group": "canvas_content_described.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Verify accessibility of the <canvas> element",
            "group": "The <canvas> element may not be accessible"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1", "2.1.1", "4.1.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = ruleContext.innerHTML.trim().length > 0;
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 2671:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.caption_track_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.caption_track_exists = {
    id: "caption_track_exists",
    context: "dom:video",
    refactor: {
        "HAAC_Video_HasNoTrack": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "caption_track_exists.html",
            "Potential_1": "caption_track_exists.html",
            "group": "caption_track_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that captions are available for any meaningful audio or provide a caption track for the <video> element",
            "group": "A <video> element must have a text alternative for any meaningful audio content"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.2.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = false;
        // ignore decorative video if user uses aria-hidden
        if (ruleContext.getAttribute("aria-hidden") === "true") {
            return null;
        }
        var tracks = ruleContext.getElementsByTagName("track");
        for (var i = 0; i < tracks.length; ++i) {
            passed = passed || tracks[i].getAttribute("kind") === 'captions';
        }
        // checks for addition of dynamic tracks
        if (ruleContext.textTracks && ruleContext.textTracks.length > 0) {
            for (var i = 0; i < ruleContext.textTracks.length; i++) {
                passed = passed || ruleContext.textTracks[i].kind === 'captions';
            }
        }
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RulePotential)("Potential_1");
        }
    }
};


/***/ }),

/***/ 3974:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combobox_active_descendant = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var fragment_1 = __webpack_require__(482);
var DOMWalker_1 = __webpack_require__(7440);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8656);
exports.combobox_active_descendant = {
    id: "combobox_active_descendant",
    context: "aria:combobox",
    dependencies: ["combobox_popup_reference"],
    help: {
        "en-US": {
            "Pass": "combobox_active_descendant.html",
            "Fail_missing": "combobox_active_descendant.html",
            "Fail_not_in_popup": "combobox_active_descendant.html",
            "Fail_active_role_invalid": "combobox_active_descendant.html",
            "Fail_active_not_selected": "combobox_active_descendant.html",
            "group": "combobox_active_descendant.html"
        }
    },
    messages: {
        "en-US": {
            "Pass": "'aria-activedescendant' is used appropriately for this combobox",
            "Fail_missing": "The element referenced by 'aria-activedescendant' \"{0}\" does not exist",
            "Fail_not_in_popup": "The element referenced by 'aria-activedescendant' \"{0}\" does not exist within the popup referenced by 'id' \"{1}\"",
            "Fail_active_role_invalid": "The 'aria-activedescendant' \"{0}\" references an element with the roles \"{1}\", which does not have a valid ARIA role of 'option', 'gridcell', 'row', or 'treeitem'",
            "Fail_active_not_selected": "The 'aria-activedescendant' \"{0}\" references an element that does not have 'aria-selected' set to true",
            "group": "'aria-activedescendant' must be used to define focus within the combobox popup, except when using a dialog popup"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var cache = CacheUtil_1.CacheUtil.getCache(ruleContext.ownerDocument, "combobox", {});
        if (!cache)
            return null;
        var cachedElem = cache[context["dom"].rolePath];
        if (!cachedElem)
            return null;
        var popupElement = cachedElem.popupElement, popupId = cachedElem.popupId;
        // If this isn't defined, the combobox is probably collapsed. A reference error is
        // detected in combobox_popup_reference
        if (!popupElement)
            return null;
        // This rule only applies if the activedescendant is specified
        var activeId = ruleContext.getAttribute("aria-activedescendant");
        if (!activeId || activeId.trim().length === 0) {
            return null;
        }
        var activeElem = fragment_1.FragmentUtil.getById(ruleContext, activeId);
        if (!activeElem) {
            return (0, IRule_1.RuleFail)("Fail_missing", [activeId]);
        }
        var found = false;
        // examine the children
        if (popupElement) {
            //let nw = new NodeWalker(popupElement);
            var nw = new DOMWalker_1.DOMWalker(popupElement);
            while (!found && nw.nextNode() && nw.node != popupElement && nw.node != popupElement.nextSibling) {
                if (nw.node.nodeType === 1 && VisUtil_1.VisUtil.isNodeVisible(nw.node)) {
                    found = nw.elem().getAttribute("id") === activeId;
                }
            }
        }
        var retVal = [];
        if (!found) {
            retVal.push((0, IRule_1.RulePass)("Fail_not_in_popup", [activeId, popupId]));
        }
        var activeRoles = AriaUtil_1.AriaUtil.getRoles(activeElem, true);
        var validRoles = ["option", "gridcell", "row", "treeitem"].filter(function (validRole) { return activeRoles.includes(validRole); });
        if (validRoles.length === 0) {
            retVal.push((0, IRule_1.RuleFail)("Fail_active_role_invalid", [activeId, activeRoles.join(",")]));
        }
        if (activeElem.getAttribute("aria-selected") !== "true") {
            retVal.push((0, IRule_1.RuleFail)("Fail_active_not_selected", [activeId]));
        }
        if (retVal.length === 0) {
            return (0, IRule_1.RulePass)("Pass");
        }
        else {
            return retVal;
        }
    }
};


/***/ }),

/***/ 9881:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combobox_autocomplete_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var DOMWalker_1 = __webpack_require__(7440);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8656);
exports.combobox_autocomplete_valid = {
    id: "combobox_autocomplete_valid",
    context: "aria:combobox",
    dependencies: ["combobox_popup_reference"],
    refactor: {
        "combobox_autocomplete": {
            "Pass": "Pass",
            "Fail_1": "Fail_1",
            "Fail_inline": "Fail_inline"
        }
    },
    help: {
        "en-US": {
            "Pass": "combobox_autocomplete_valid.html",
            "Fail_1": "combobox_autocomplete_valid.html",
            "Fail_inline": "combobox_autocomplete_valid.html",
            "group": "combobox_autocomplete_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass": "The combobox does not use 'aria-autocomplete' value '\"inline\"' nor does it have 'aria-autocomplete' defined within the popup",
            "Fail_1": "The combobox has the 'aria-autocomplete' attribute incorrectly set on an element within the popup referenced by \"{0}\"",
            "Fail_inline": "The combobox does not support an 'aria-autocomplete' attribute value set to '\"inline\"' ",
            "group": "A combobox that supports autocompletion behavior must have the 'aria-autocomplete' attribute only on its text input element with a valid value; a value of '\"inline\"' is not supported"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var cache = CacheUtil_1.CacheUtil.getCache(ruleContext.ownerDocument, "combobox", {});
        if (!cache)
            return null;
        var cachedElem = cache[context["dom"].rolePath];
        if (!cachedElem)
            return null;
        var popupId = cachedElem.popupId, popupElement = cachedElem.popupElement;
        var retVal = [];
        if (ruleContext.getAttribute("aria-autocomplete") === "inline") {
            retVal.push((0, IRule_1.RuleFail)("Fail_inline"));
        }
        var passed = true;
        // examine the children
        if (popupElement && VisUtil_1.VisUtil.isNodeVisible(popupElement)) {
            // if popupElement itself has "aria-autocomplete"
            passed = !popupElement.hasAttribute("aria-autocomplete");
            // if any child of popupElement has "aria-autocomplete"
            if (passed && popupElement.children && popupElement.children.length > 0) {
                //let nw = new NodeWalker(popupElement);
                var nw = new DOMWalker_1.DOMWalker(popupElement);
                while (passed && nw.nextNode()) {
                    if (nw.node.nodeType === 1 && VisUtil_1.VisUtil.isNodeVisible(nw.node)) {
                        passed = !nw.elem().hasAttribute("aria-autocomplete");
                        if (nw.bEndTag && nw.node === popupElement.lastElementChild)
                            break;
                    }
                }
            }
        }
        if (!passed) {
            retVal.push((0, IRule_1.RuleFail)("Fail_1", [popupId]));
        }
        if (retVal.length > 0) {
            return retVal;
        }
        else {
            return (0, IRule_1.RulePass)("Pass");
        }
    }
};


/***/ }),

/***/ 1226:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combobox_design_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
var CacheUtil_1 = __webpack_require__(7788);
function patternDetect(elem) {
    // check 'explicit' role combobox and that it is not <select>. 
    if (elem.tagName.toLowerCase() === "select" && elem.getAttribute("role") !== "combobox") {
        return "implicit";
    }
    else if (elem.nodeName.toLowerCase() === "input"
        && (!elem.hasAttribute("type") || elem.getAttribute("type") === "text")
        && elem.hasAttribute("aria-owns") && !elem.hasAttribute("aria-controls")) {
        // Looks like this is an ARIA 1.0 pattern, which the ARIA 1.2 spec says to continue to allow
        return "1.0";
    }
    else if (elem.nodeName.toLowerCase() !== "input"
        && elem.hasAttribute("aria-owns") && !elem.hasAttribute("aria-controls")) {
        // Looks like this is an ARIA 1.1 pattern, which the ARIA 1.2 spec says is now invalid
        return "1.1";
    }
    // Assume they're trying to do the latest, 1.2 pattern
    return "1.2";
}
exports.combobox_design_valid = {
    id: "combobox_design_valid",
    context: "aria:combobox",
    refactor: {
        "combobox_version": {
            "Pass_1.0": "Pass_1.0",
            "Fail_1.1": "Fail_1.1",
            "Pass_1.2": "Pass_1.2"
        }
    },
    help: {
        "en-US": {
            "Pass_1.0": "combobox_design_valid.html",
            "Fail_1.1": "combobox_design_valid.html",
            "Pass_1.2": "combobox_design_valid.html",
            "group": "combobox_design_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_1.0": "The combobox design pattern is detected as ARIA 1.0, which is allowed by ARIA 1.2",
            "Fail_1.1": "The combobox design pattern is detected as ARIA 1.1, which is not allowed by ARIA 1.2",
            "Pass_1.2": "The combobox design pattern is detected as ARIA 1.2",
            "group": "The combobox design pattern must be valid for ARIA 1.2"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext)) {
            return null;
        }
        var pattern = patternDetect(ruleContext);
        // We don't assess native select elements here
        if (pattern === "implicit") {
            return null;
        }
        var tagName = ruleContext.tagName.toLowerCase();
        var expanded = (AriaUtil_1.AriaUtil.getAriaAttribute(ruleContext, "aria-expanded") || "").trim().toLowerCase() === "true";
        var editable = tagName === "input" && (!ruleContext.hasAttribute("type") || ruleContext.getAttribute("type").toLowerCase() === "text");
        var key = context["dom"].rolePath;
        if (key) {
            var cache = CacheUtil_1.CacheUtil.getCache(ruleContext.ownerDocument, "combobox", {});
            if (!cache)
                return null;
            cache[key] = {
                "inputElement": editable ? ruleContext : null,
                "pattern": pattern,
                "expanded": expanded
            };
            CacheUtil_1.CacheUtil.setCache(ruleContext.ownerDocument, "combobox", cache);
        }
        else {
            // No xpath?
            return null;
        }
        if (pattern === "1.0") {
            return (0, IRule_1.RulePass)("Pass_1.0");
        }
        else if (pattern === "1.1") {
            return (0, IRule_1.RuleFail)("Fail_1.1");
        }
        else if (pattern === "1.2") {
            return (0, IRule_1.RulePass)("Pass_1.2");
        }
    }
};


/***/ }),

/***/ 7369:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combobox_focusable_elements = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var DOMWalker_1 = __webpack_require__(7440);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8656);
exports.combobox_focusable_elements = {
    id: "combobox_focusable_elements",
    context: "aria:combobox",
    dependencies: ["combobox_popup_reference"],
    help: {
        "en-US": {
            "Pass": "combobox_focusable_elements.html",
            "Fail_not_tabbable": "combobox_focusable_elements.html",
            "Fail_tabbable_child": "combobox_focusable_elements.html",
            "group": "combobox_focusable_elements.html"
        }
    },
    messages: {
        "en-US": {
            "Pass": "DOM focus is allowed only on the combobox element as required",
            "Fail_not_tabbable": "The combobox element does not allow DOM focus as required",
            "Fail_tabbable_child": "The popup of the combobox has DOM focus or has 'aria-activedescendant' defined, which is not allowed",
            "group": "Tabbable focus for the combobox must be allowed only on the text input, except when using a dialog popup"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var cache = CacheUtil_1.CacheUtil.getCache(ruleContext.ownerDocument, "combobox", {});
        if (!cache)
            return null;
        var cachedElem = cache[context["dom"].rolePath];
        if (!cachedElem)
            return null;
        var popupElement = cachedElem.popupElement, expanded = cachedElem.expanded;
        // If this isn't defined, the combobox is probably collapsed. A reference error is
        // detected in combobox_popup_reference
        if (!popupElement)
            return null;
        var popupRole = AriaUtil_1.AriaUtil.getRoles(popupElement, true)[0];
        var retVal = [];
        if (!CommonUtil_1.CommonUtil.isTabbable(ruleContext)) {
            retVal.push((0, IRule_1.RuleFail)("Fail_not_tabbable"));
        }
        // Only makes sense to check the popup when expanded
        // this does not apply to dialogs, return pass since the main element was focusable above
        if (expanded === false || popupRole === "dialog") {
            return (0, IRule_1.RulePass)("Pass");
        }
        var passed = true;
        // examine the children
        if (popupElement && VisUtil_1.VisUtil.isNodeVisible(popupElement)) {
            // if popupElement itself has "aria-activedescendant"
            passed = !CommonUtil_1.CommonUtil.isTabbable(popupElement) && !AriaUtil_1.AriaUtil.getAriaAttribute(popupElement, "aria-activedescendant");
            ;
            // if any child of popupElement has "aria-autocomplete"
            if (passed && popupElement.children && popupElement.children.length > 0) {
                //let nw = new NodeWalker(popupElement);
                var nw = new DOMWalker_1.DOMWalker(popupElement);
                while (passed && nw.nextNode()) {
                    if (nw.node.nodeType === 1 && VisUtil_1.VisUtil.isNodeVisible(nw.node)) {
                        passed = !CommonUtil_1.CommonUtil.isTabbable(nw.node) &&
                            !AriaUtil_1.AriaUtil.getAriaAttribute(nw.node, "aria-activedescendant");
                        if (nw.bEndTag && nw.node === popupElement.lastElementChild)
                            break;
                    }
                }
            }
        }
        if (!passed) {
            retVal.push((0, IRule_1.RuleFail)("Fail_tabbable_child"));
        }
        if (retVal.length === 0) {
            return (0, IRule_1.RulePass)("Pass");
        }
        else {
            return retVal;
        }
    }
};


/***/ }),

/***/ 2633:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combobox_haspopup_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CacheUtil_1 = __webpack_require__(7788);
exports.combobox_haspopup_valid = {
    id: "combobox_haspopup_valid",
    context: "aria:combobox",
    dependencies: ["combobox_popup_reference"],
    refactor: {
        "combobox_haspopup": {
            "Pass": "Pass",
            "Fail_popup_role_invalid": "Fail_popup_role_invalid",
            "Fail_combobox_popup_role_mismatch": "Fail_combobox_popup_role_mismatch"
        }
    },
    help: {
        "en-US": {
            "Pass": "combobox_haspopup_valid.html",
            "Fail_popup_role_invalid": "combobox_haspopup_valid.html",
            "Fail_combobox_popup_role_mismatch": "combobox_haspopup_valid.html",
            "group": "combobox_haspopup_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass": "The 'aria-controls' (ARIA 1.2) or 'aria-owns' (ARIA 1.0) appropriately references a valid popup 'id' value",
            "Fail_popup_role_invalid": "The 'role' value \"{0}\" of the popup element \"{1}\" should be one of \"listbox\", \"grid\", \"tree\" or \"dialog\"",
            "Fail_combobox_popup_role_mismatch": "The value of the combobox 'aria-haspopup' attribute \"{0}\" does not match the 'role' value of the popup element \"{1}\"",
            "group": "The combobox attribute 'aria-haspopup' value must be appropriate for the role of the element referenced by 'aria-controls' (ARIA 1.2) or 'aria-owns' (ARIA 1.0)"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var cache = CacheUtil_1.CacheUtil.getCache(ruleContext.ownerDocument, "combobox", {});
        if (!cache)
            return null;
        var cacheKey = context["dom"].rolePath;
        var cachedElem = cache[cacheKey];
        if (!cachedElem)
            return null;
        var popupElement = cachedElem.popupElement, popupId = cachedElem.popupId;
        // If this isn't defined, the combobox is probably collapsed. A reference error is
        // detected in combobox_popup_reference
        if (!popupElement)
            return null;
        // Check that popup role is listbox, grid, tree, or dialog and that it matches the combobox
        var popupRoles = AriaUtil_1.AriaUtil.getRoles(popupElement, true);
        var validRoles = ["listbox", "grid", "tree", "dialog"].filter(function (validRole) { return popupRoles.includes(validRole); });
        if (validRoles.length === 0) {
            return (0, IRule_1.RuleFail)("Fail_popup_role_invalid", [popupRoles.join(","), popupId]);
        }
        else {
            var popupRole = validRoles[0];
            var haspopupVal = ruleContext.getAttribute("aria-haspopup") || "listbox";
            // Popup role must match aria-haspopup unless popupRole is listbox, then aria-haspopup should not be defined                
            if (haspopupVal !== popupRole) {
                if (popupRole !== "listbox" || ruleContext.hasAttribute("aria-haspopup")) {
                    return (0, IRule_1.RuleFail)("Fail_combobox_popup_role_mismatch", [haspopupVal, popupRole]);
                }
            }
        }
        return (0, IRule_1.RulePass)("Pass");
    }
};


/***/ }),

/***/ 2429:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.combobox_popup_reference = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var fragment_1 = __webpack_require__(482);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8656);
exports.combobox_popup_reference = {
    id: "combobox_popup_reference",
    context: "aria:combobox",
    dependencies: ["combobox_design_valid"],
    help: {
        "en-US": {
            "group": "combobox_popup_reference.html",
            "Pass_1.0_expanded": "combobox_popup_reference.html",
            "Pass_1.0_collapsed": "combobox_popup_reference.html",
            "Pass_1.2_expanded": "combobox_popup_reference.html",
            "Pass_1.2_collapsed": "combobox_popup_reference.html",
            "Fail_1.0_missing_owns": "combobox_popup_reference.html",
            "Fail_1.2_missing_controls": "combobox_popup_reference.html",
            "Fail_1.0_popup_reference_missing": "combobox_popup_reference.html",
            "Fail_1.2_popup_reference_missing": "combobox_popup_reference.html",
            "Fail_combobox_expanded_hidden": "combobox_popup_reference.html",
            "Fail_combobox_collapsed_visible": "combobox_popup_reference.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The 'aria-controls' (for ARIA 1.2) or the 'aria-owns' (for ARIA 1.0) attribute of the expanded combobox must reference a valid popup 'id' value",
            "Pass_1.0_expanded": "The combobox popup referenced by 'aria-owns' (ARIA 1.0) exists and is visible",
            "Pass_1.0_collapsed": "The combobox popup in its collapsed state does not reference any visible popup as required",
            "Pass_1.2_expanded": "The combobox popup referenced by 'aria-controls' (ARIA 1.2) exists and is visible",
            "Pass_1.2_collapsed": "The combobox popup in its collapsed state does not reference any visible popup as required",
            "Fail_1.0_missing_owns": "The 'aria-owns' attribute of the expanded combobox is missing",
            "Fail_1.2_missing_controls": "The 'aria-controls' attribute of the expanded combobox is missing",
            "Fail_1.0_popup_reference_missing": "The 'aria-owns' attribute \"{0}\" of the expanded combobox does not reference a valid popup 'id' value",
            "Fail_1.2_popup_reference_missing": "The 'aria-controls' attribute \"{0}\" of the expanded combobox does not reference a valid popup 'id' value",
            "Fail_combobox_expanded_hidden": "The combobox 'aria-expanded' attribute is true, but the combobox popup is not visible",
            "Fail_combobox_collapsed_visible": "The combobox 'aria-expanded' attribute is false, but the combobox popup is visible"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [{
            "4e8ab6": {
                "Pass_1.0_expanded": "fail",
                "Pass_1.0_collapsed": "fail",
                "Pass_1.2_expanded": "pass",
                "Pass_1.2_collapsed": "pass",
                "Fail_1.0_missing_owns": "inapplicable",
                "Fail_1.2_missing_controls": "fail",
                "Fail_1.0_popup_reference_missing": "inapplicable",
                "Fail_1.2_popup_reference_missing": "fail",
                "Fail_combobox_expanded_hidden": "inapplicable",
                "Fail_combobox_collapsed_visible": "inapplicable"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var cache = CacheUtil_1.CacheUtil.getCache(ruleContext.ownerDocument, "combobox", {});
        if (!cache)
            return null;
        var cacheKey = context["dom"].rolePath;
        var cachedElem = cache[cacheKey];
        if (!cachedElem)
            return null;
        var pattern = cachedElem.pattern, expanded = cachedElem.expanded;
        var popupId;
        var popupElement;
        if (pattern === "1.0") {
            if (!ruleContext.hasAttribute("aria-owns")) {
                // If the combobox isn't expanded, this attribute isn't required
                return !expanded ? null : (0, IRule_1.RuleFail)("Fail_1.0_missing_owns");
            }
            popupId = ruleContext.getAttribute("aria-owns");
            popupElement = fragment_1.FragmentUtil.getById(ruleContext, popupId);
            if (!popupElement) {
                // If the combobox isn't expanded, this attribute isn't required
                return !expanded ? null : (0, IRule_1.RuleFail)("Fail_1.0_popup_reference_missing", [popupId]);
            }
        }
        else if (pattern === "1.2") {
            if (!ruleContext.hasAttribute("aria-controls")) {
                // If the combobox isn't expanded, this attribute isn't required
                return !expanded ? null : (0, IRule_1.RuleFail)("Fail_1.2_missing_controls");
            }
            popupId = ruleContext.getAttribute("aria-controls");
            popupElement = fragment_1.FragmentUtil.getById(ruleContext, popupId);
            if (!popupElement) {
                // If the combobox isn't expanded, this attribute isn't required
                return !expanded ? null : (0, IRule_1.RuleFail)("Fail_1.2_popup_reference_missing", [popupId]);
            }
        }
        else {
            return null;
        }
        // We have an element, stick it in the cache and then check its role
        cachedElem.popupId = popupId;
        cachedElem.popupElement = popupElement;
        if (expanded && !VisUtil_1.VisUtil.isNodeVisible(popupElement)) {
            return (0, IRule_1.RuleFail)("Fail_combobox_expanded_hidden");
        }
        else if (!expanded && VisUtil_1.VisUtil.isNodeVisible(popupElement)) {
            return (0, IRule_1.RuleFail)("Fail_combobox_collapsed_visible");
        }
        if (pattern === "1.0") {
            if (expanded) {
                return (0, IRule_1.RulePass)("Pass_1.0_expanded");
            }
            else {
                return (0, IRule_1.RulePass)("Pass_1.0_collapsed");
            }
        }
        else {
            if (expanded) {
                return (0, IRule_1.RulePass)("Pass_1.2_expanded");
            }
            else {
                return (0, IRule_1.RulePass)("Pass_1.2_collapsed");
            }
        }
    }
};


/***/ }),

/***/ 7874:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debug_paths = void 0;
var IRule_1 = __webpack_require__(4377);
exports.debug_paths = {
    id: "debug_paths",
    context: "dom:*",
    help: {
        "en-US": {
            "group": "",
            "Pass_0": ""
        }
    },
    messages: {
        "en-US": {
            "group": "",
            "Pass_0": ""
        }
    },
    rulesets: [{
            id: ["DEBUG"],
            num: "1",
            level: IRule_1.eRulePolicy.INFORMATION,
            toolkitLevel: IRule_1.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        ruleContext.setAttribute("domPath", context["dom"].rolePath);
        ruleContext.setAttribute("ariaPath", context["aria"].rolePath);
        return null;
    }
};


/***/ }),

/***/ 3334:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.detector_tabbable = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.detector_tabbable = {
    id: "detector_tabbable",
    context: "dom:*",
    help: {
        "en-US": {
            "group": "",
            "Pass_0": ""
        }
    },
    messages: {
        "en-US": {
            "group": "",
            "Pass_0": ""
        }
    },
    rulesets: [{
            id: ["EXTENSIONS"],
            num: "1",
            level: IRule_2.eRulePolicy.INFORMATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!CommonUtil_1.CommonUtil.isTabbable(ruleContext)) {
            return null;
        }
        var hierContext = contextHierarchies.aria[contextHierarchies.aria.length - 1];
        return (0, IRule_1.RulePass)("Pass_0", [], [{
                name: hierContext.attributes.name,
                role: hierContext.role,
                tabindex: parseInt(ruleContext.getAttribute("tabindex") || "0")
            }]);
    }
};


/***/ }),

/***/ 4298:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dir_attribute_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.dir_attribute_valid = {
    id: "dir_attribute_valid",
    context: "dom:*[dir]",
    refactor: {
        "Valerie_Elem_DirValid": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "dir_attribute_valid.html",
            "Fail_1": "dir_attribute_valid.html",
            "group": "dir_attribute_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Invalid value used for the 'dir' attribute",
            "group": "'dir' attribute value must be \"ltr\", \"rtl\", or \"auto\""
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var dirStr = ruleContext.getAttribute("dir").toLowerCase();
        var passed = dirStr == "ltr" || dirStr == "rtl" || dirStr == "auto";
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4435:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.download_keyboard_controllable = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.download_keyboard_controllable = {
    id: "download_keyboard_controllable",
    context: "dom:a[href],dom:area[href]",
    refactor: {
        "HAAC_Media_DocumentTrigger2": {
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Manual_1": "download_keyboard_controllable.html",
            "group": "download_keyboard_controllable.html"
        }
    },
    messages: {
        "en-US": {
            "Manual_1": "Verify that the file download mechanism does not cause a keyboard trap",
            "group": "File download mechanisms should be keyboard-operable and preserve page focus location"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.1.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var href = ruleContext.getAttribute("href");
        var ext = CommonUtil_1.CommonUtil.getFileExt(href);
        var passed = ![".docx", ".doc", ".pdf", ".odt"].includes(ext);
        if (passed)
            return null;
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 1685:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.draggable_alternative_exists = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
exports.draggable_alternative_exists = {
    id: "draggable_alternative_exists",
    context: "dom:*[draggable]",
    dependencies: [],
    help: {
        "en-US": {
            "group": "draggable_alternative_exists.html",
            // "pass_alternative": "draggable_alternative_exists.html",
            "pass_undraggable": "draggable_alternative_exists.html",
            "potential_alternative": "draggable_alternative_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "A draggable element must have a \"single pointer\" alternative",
            // "pass_alternative": "The draggable element \"{0}\" has a \"single pointer\" alternative",
            "pass_undraggable": "The element \"{0}\" is not draggable",
            "potential_alternative": "Ensure the draggable element \"{0}\" has a \"single pointer\" alternative"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_2"],
            num: ["2.5.7"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext))
            return null;
        var nodeName = ruleContext.nodeName.toLocaleLowerCase();
        //ignore certain elements
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["pre", "code", "script", "meta"]) !== null
            || nodeName === "body" || nodeName === "html")
            return null;
        if (ruleContext.getAttribute("draggable") === 'true')
            return (0, IRule_1.RulePotential)("potential_alternative", [nodeName]);
        else if (ruleContext.getAttribute("draggable") === 'false')
            return (0, IRule_1.RulePass)("pass_undraggable", [nodeName]);
        else
            return null;
    }
};


/***/ }),

/***/ 6313:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_accesskey_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
var ARIADefinitions_1 = __webpack_require__(8235);
var AccNameUtil_1 = __webpack_require__(1421);
exports.element_accesskey_labelled = {
    id: "element_accesskey_labelled",
    context: "dom:*[accesskey]",
    refactor: {
        "HAAC_Accesskey_NeedLabel": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "element_accesskey_labelled.html",
            "Potential_1": "element_accesskey_labelled.html",
            "group": "element_accesskey_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "The element with an assigned 'accesskey' attribute does not have an associated label",
            "group": "An element with an assigned 'accesskey' attribute must have an associated label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["3.3.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return;
        //skip if the element is tabbable, it's covered by other rules
        if (CommonUtil_1.CommonUtil.isTabbable(ruleContext))
            return;
        var roles = AriaUtil_1.AriaUtil.getRoles(ruleContext, true);
        //skip the native element, mostly text elements
        if (!roles || roles.length === 0)
            return;
        var patterns = ARIADefinitions_1.ARIADefinitions.designPatterns[roles[0]];
        if (!patterns || !patterns.nameFrom)
            return;
        // ignore if accessble name is required (checked in other rules) or prohibited (text element)    
        if (patterns.nameRequired || !patterns.nameFrom || patterns.nameFrom.includes("prohibited"))
            return;
        //special case: legend, as a child of a fieldset, delegate the accesskey command to the field of the fieldset which is covered by other rules 
        if (ruleContext.parentElement && ruleContext.parentElement.nodeName.toLowerCase() === 'fieldset')
            return;
        // check if accessible name exists
        var pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(ruleContext);
        if (pair && pair.name && pair.name.trim().length > 0)
            //if (ARIAMapper.computeName(ruleContext).trim().length > 0)
            return (0, IRule_1.RulePass)("Pass_0");
        return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9109:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_accesskey_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CacheUtil_1 = __webpack_require__(7788);
exports.element_accesskey_unique = {
    id: "element_accesskey_unique",
    context: "dom:*[accesskey]",
    refactor: {
        "WCAG20_Elem_UniqueAccessKey": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "element_accesskey_unique.html",
            "Fail_1": "element_accesskey_unique.html",
            "group": "element_accesskey_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "'accesskey' attribute value on the element is not unique",
            "group": "'accesskey' attribute values on each element must be unique for the page"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next"],
            "num": ["HTML"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var map = CacheUtil_1.CacheUtil.getCache(ruleContext.ownerDocument, "element_accesskey_unique", {});
        var key = ruleContext.getAttribute("accesskey");
        var passed = !(key in map);
        map[key] = true;
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 9918:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_attribute_deprecated = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var DEPRECATED_ELEMENTS = [
    /** original */
    "applet", "basefont", "center", "dir", "font", "isindex", "listing",
    "plaintext", "spacer", "s", "strike", "u", "xmp",
    /** added from https://dev.w3.org/html5/pf-summary/obsolete.html */
    "acronym", "frame", "frameset", "noframes", "noembed", "big", "blink", "marquee", "tt",
];
var DEPRECATED_HTML_GLOBAL_ATTRIBUTES = [
    /** original */
    "align", "link", "archive", "background", "bgcolor", "clear", "code", "color",
    "compact", "face", "hspace", "language", "link", "noshade", "nowrap", "object",
    "prompt", "start", "text", "version", "vlink", "vspace"
];
var DEPRECATED_ELEMENT_ATTRIBUTES = {
    /** original */
    "td": ["height", "width", "abbr", "axis", "char", "charoff", "height", "nowrap", "valign", "width", "align", "bgcolor"],
    "th": ["height", "width", "abbr", "axis", "charoff", "height", "bgcolor", "align", "nowrap", "char", "valign", "width"],
    "li": ["type", "value", "type"],
    "ul": ["type", "compact"],
    "pre": ["width"],
    /** added from https://dev.w3.org/html5/pf-summary/obsolete.html */
    "meta": ["http-equiv"],
    "a": ["charset", "coords", "shape", "rev", "scheme"],
    "link": ["rev", "charset", "target"],
    "img": ["name", "longdesc", "align", "hspace", "vspace", "border"],
    "area": ["nohref"],
    "head": ["profile"],
    "html": ["version"],
    "iframe": ["longdesc", "align", "frameborder", "marginheight", "marginwidth", "scrolling"],
    "object": ["archive", "code", "codebase", "codetype", "declare", "standby", "align", "hspace", "vspace", "border"],
    "param": ["type", "valuetype"],
    "script": ["language"],
    "body": ["alink", "background", "bgcolor", "link", "text", "vlink"],
    "br": ["clear"],
    "caption": ["align"],
    "col": ["align", "char", "charoff", "valign", "width"],
    "div": ["align"],
    "dl": ["compact"],
    "hr": ["align", "noshade", "size", "width", "align"],
    "h2": ["align"],
    "h3": ["align"],
    "h4": ["align"],
    "h5": ["align"],
    "h6": ["align"],
    "input": ["align", "usemap"],
    "legend": ["align"],
    "menu": ["compact"],
    "ol": ["compact", "type", "type"],
    "p": ["align"],
    "table": ["bgcolor", "cellpadding", "cellspacing", "frame", "rules", "width", "align"],
    "tbody": ["align", "char", "valign", "charoff"],
    "tfoot": ["align", "charoff", "char", "valign"],
    "thead": ["char", "charoff", "valign", "align"],
    "tr": ["align", "bgcolor", "char", "charoff", "valign"]
};
function arrayToContextStr(obj, type) {
    var str = "";
    for (var _i = 0, obj_1 = obj; _i < obj_1.length; _i++) {
        var prop = obj_1[_i];
        if (str !== '' && !str.endsWith(', '))
            str += ", ";
        if (type === 'HTML_ELEMENTS')
            str += 'dom:' + prop;
        else if (type === 'HTML_ATTRIBUTES')
            str += 'dom:*[' + prop + "]";
    }
    return str;
}
function objToContextStr(obj, type) {
    var str = "";
    for (var prop in obj) {
        if (str !== '' && !str.endsWith(', '))
            str += ", ";
        if (type === 'HTML_ELEMENT_ATTRIBUTES') {
            for (var _i = 0, _a = obj[prop]; _i < _a.length; _i++) {
                var item = _a[_i];
                if (str !== '' && !str.endsWith(", "))
                    str += ", ";
                str += 'dom:' + prop + '[' + item + ']';
            }
        }
    }
    return str;
}
exports.element_attribute_deprecated = {
    id: "element_attribute_deprecated",
    context: "dom:applet, dom:basefont, dom:center, dom:dir, dom:font, dom:isindex, dom:listing, dom:menu, dom:plaintext, dom:spacer, dom:s, dom:strike, dom:u, dom:xmp, dom:acronym, dom:frame, dom:frameset, dom:noframes, dom:noembed, dom:big, dom:blink, dom:marquee, dom:ttNaNdom:*[align], dom:*[link], dom:*[archive], dom:*[background], dom:*[bgcolor], dom:*[clear], dom:*[code], dom:*[color], dom:*[compact], dom:*[face], dom:*[hspace], dom:*[language], dom:*[link], dom:*[noshade], dom:*[nowrap], dom:*[object], dom:*[prompt], dom:*[start], dom:*[text], dom:*[version], dom:*[vlink], dom:*[vspace]NaNdom:td[height], dom:td[width], dom:td[abbr], dom:td[axis], dom:td[char], dom:td[charoff], dom:td[height], dom:td[nowrap], dom:td[valign], dom:td[width], dom:td[align], dom:td[bgcolor], dom:th[height], dom:th[width], dom:th[abbr], dom:th[axis], dom:th[charoff], dom:th[height], dom:th[bgcolor], dom:th[align], dom:th[nowrap], dom:th[char], dom:th[valign], dom:th[width], dom:li[type], dom:li[value], dom:li[type], dom:ul[type], dom:ul[compact], dom:pre[width], dom:meta[http-equiv], dom:a[charset], dom:a[coords], dom:a[shape], dom:a[rev], dom:a[scheme], dom:link[rev], dom:link[charset], dom:link[target], dom:img[name], dom:img[longdesc], dom:img[align], dom:img[hspace], dom:img[vspace], dom:img[border], dom:area[nohref], dom:head[profile], dom:html[version], dom:iframe[longdesc], dom:iframe[align], dom:iframe[frameborder], dom:iframe[marginheight], dom:iframe[marginwidth], dom:iframe[scrolling], dom:object[archive], dom:object[code], dom:object[codebase], dom:object[codetype], dom:object[declare], dom:object[standby], dom:object[align], dom:object[hspace], dom:object[vspace], dom:object[border], dom:param[type], dom:param[valuetype], dom:script[language], dom:body[alink], dom:body[background], dom:body[bgcolor], dom:body[link], dom:body[text], dom:body[vlink], dom:br[clear], dom:caption[align], dom:col[align], dom:col[char], dom:col[charoff], dom:col[valign], dom:col[width], dom:div[align], dom:dl[compact], dom:hr[align], dom:hr[noshade], dom:hr[size], dom:hr[width], dom:hr[align], dom:h2[align], dom:h3[align], dom:h4[align], dom:h5[align], dom:h6[align], dom:input[align], dom:input[usemap], dom:legend[align], dom:menu[compact], dom:ol[compact], dom:ol[type], dom:ol[type], dom:p[align], dom:table[bgcolor], dom:table[cellpadding], dom:table[cellspacing], dom:table[frame], dom:table[rules], dom:table[width], dom:table[align], dom:tbody[align], dom:tbody[char], dom:tbody[valign], dom:tbody[charoff], dom:tfoot[align], dom:tfoot[charoff], dom:tfoot[char], dom:tfoot[valign], dom:thead[char], dom:thead[charoff], dom:thead[valign], dom:thead[align], dom:tr[align], dom:tr[bgcolor], dom:tr[char], dom:tr[charoff], dom:tr[valign]",
    help: {
        "en-US": {
            "pass": "element_attribute_deprecated.html",
            "fail_elem": "element_attribute_deprecated.html",
            "fail_attr": "element_attribute_deprecated.html",
            "fail_elem_attr": "element_attribute_deprecated.html",
            "group": "element_attribute_deprecated.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "fail_elem": "The <{0}> element is deprecated in HTML 5",
            "fail_attr": "The HTML attribute(s) \"{0}\" is deprecated in HTML 5",
            "fail_elem_attr": "The HTML attribute(s) \"{0}\" is deprecated for the <{1}> element in HTML 5",
            "group": "Avoid use of obsolete features if possible"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next"],
            "num": ["HTML"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // HTMLUnit auto adds a tbody[align=left] to tables if tbody is missing!
        if (ruleContext.nodeName.toLowerCase() === "tbody" && ruleContext.hasAttribute("align")) {
            return (0, IRule_1.RulePass)("pass");
        }
        if (ruleContext.nodeName.includes("-")) {
            // This is a webcomponent element, HTML doesn't define what's deprecated
            return null;
        }
        var nodeName = ruleContext.nodeName.toLowerCase();
        var ret = [];
        // check if it's a deprecated element
        if (DEPRECATED_ELEMENTS.includes(nodeName)) {
            return (0, IRule_1.RuleFail)("fail_elem", [nodeName]);
        }
        // check if it's a deprecated HTML global attribute
        var attrs = ruleContext.getAttributeNames();
        var violations = '';
        for (var _i = 0, attrs_1 = attrs; _i < attrs_1.length; _i++) {
            var attr = attrs_1[_i];
            if (DEPRECATED_HTML_GLOBAL_ATTRIBUTES.includes(attr)) {
                if (violations !== '')
                    violations += ', ';
                violations += attr;
            }
        }
        if (violations !== '') {
            return (0, IRule_1.RuleFail)("fail_attr", [violations]);
        }
        // check if it's a deprecated HTML element & attribute
        violations = '';
        if (nodeName in DEPRECATED_ELEMENT_ATTRIBUTES) {
            for (var _a = 0, attrs_2 = attrs; _a < attrs_2.length; _a++) {
                var attr = attrs_2[_a];
                if (DEPRECATED_ELEMENT_ATTRIBUTES[nodeName] && DEPRECATED_ELEMENT_ATTRIBUTES[nodeName].includes(attr)) {
                    if (violations !== '')
                        violations += ', ';
                    violations += attr;
                }
            }
            if (violations !== '') {
                return (0, IRule_1.RuleFail)("fail_elem_attr", [violations, nodeName]);
            }
        }
        return (0, IRule_1.RulePass)("pass");
    }
};


/***/ }),

/***/ 8105:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_id_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var fragment_1 = __webpack_require__(482);
exports.element_id_unique = {
    id: "element_id_unique",
    context: "dom:*[id]",
    refactor: {
        "RPT_Elem_UniqueId": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "group": "element_id_unique.html",
            "Pass_0": "element_id_unique.html",
            "Fail_1": "element_id_unique.html",
            "Fail_2": "element_id_unique.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Element 'id' attribute values must be unique within a document",
            "Pass_0": "Rule Passed",
            "Fail_1": "The <{0}> element has the id \"{1}\" that is empty",
            "Fail_2": "The <{0}> element has the id \"{1}\" that is already in use"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next"],
            "num": ["HTML"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [{
            "3ea0c8": {
                "Pass_0": "pass",
                "Fail_1": "pass",
                "Fail_2": "fail"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var id = ruleContext.getAttribute("id");
        // In the case that id is empty we should trigger a violation right away with out checking 
        // for uniqueness.
        if (id === "") {
            //return new ValidationResult(false, [ruleContext], '', '', [ruleContext.nodeName.toLowerCase(), id]);
            return (0, IRule_1.RuleFail)("Fail_1", [ruleContext.nodeName.toLowerCase(), id]);
        }
        var element = fragment_1.FragmentUtil.getById(ruleContext, id);
        var passed = element === ruleContext;
        //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [ruleContext.nodeName.toLowerCase(), id]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_2", [ruleContext.nodeName.toLowerCase(), id]);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 8687:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_lang_valid = exports.html_lang_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var lang_1 = __webpack_require__(2527);
var VisUtil_1 = __webpack_require__(8656);
var DOMWalker_1 = __webpack_require__(7440);
var AccNameUtil_1 = __webpack_require__(1421);
var validateLang = function (context) {
    var ruleContext = context["dom"].node;
    var nodeName = ruleContext.nodeName.toLowerCase();
    if (ruleContext.hasAttribute("lang")) {
        if (nodeName !== "html" && ruleContext.getAttribute("lang") === "") {
            // It's okay to have a lang="" if not on html
        }
        else {
            var langStr = ruleContext.getAttribute("lang");
            if (!lang_1.LangUtil.validPrimaryLang(langStr)) {
                return 1;
            }
            if (!lang_1.LangUtil.isBcp47(langStr)) {
                return 2;
            }
        }
    }
    if (ruleContext.hasAttribute("xml:lang")) {
        if (nodeName !== "html" && ruleContext.getAttribute("xml:lang") === "") {
            // It's okay to have a lang="" if not on html
        }
        else {
            var langStr = ruleContext.getAttribute("xml:lang");
            if (!lang_1.LangUtil.validPrimaryLang(langStr)) {
                return 3;
            }
            if (!lang_1.LangUtil.isBcp47(langStr)) {
                return 4;
            }
        }
    }
    return 0;
};
exports.html_lang_valid = {
    id: "html_lang_valid",
    context: "dom:html[lang], dom:html[xml:lang]",
    help: {
        "en-US": {
            "Pass_0": "html_lang_valid.html",
            "Fail_1": "html_lang_valid.html",
            "Fail_2": "html_lang_valid.html",
            "Fail_3": "html_lang_valid.html",
            "Fail_4": "html_lang_valid.html",
            "group": "html_lang_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Lang has a valid primary lang and conforms to BCP 47",
            "Fail_1": "Specified 'lang' attribute does not include a valid primary language",
            "Fail_2": "Specified 'lang' attribute does not conform to BCP 47",
            "Fail_3": "Specified 'xml:lang' attribute does not include a valid primary language",
            "Fail_4": "Specified 'xml:lang' attribute does not conform to BCP 47",
            "group": "The default human language of the page must be valid and specified in accordance with BCP 47"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["3.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [{
            "b5c3f8": {
                "Pass_0": "pass",
                "Fail_1": "fail",
                "Fail_2": "inapplicable",
                "Fail_3": "inapplicable",
                "Fail_4": "inapplicable"
            },
            "bf051a": {
                "Pass_0": "pass",
                "Fail_1": "fail",
                "Fail_2": "pass",
                "Fail_3": "fail",
                "Fail_4": "inapplicable"
            },
            // TODO: ACT: Mismatch because they don't check the html element in the same rule
            // "de46e4": {
            //     "Pass_0": "pass",
            //     "Fail_1": "fail",
            //     "Fail_2": "pass",
            //     "Fail_3": "inapplicable",
            //     "Fail_4": "inapplicable"
            // }
        }],
    run: function (context, options, contextHierarchies) {
        var reasonCode = validateLang(context);
        // This is done here instead of in validateLang so that the genHelp code will pick it up
        var retArr = [
            (0, IRule_1.RulePass)("Pass_0"),
            (0, IRule_1.RuleFail)("Fail_1"),
            (0, IRule_1.RuleFail)("Fail_2"),
            (0, IRule_1.RuleFail)("Fail_3"),
            (0, IRule_1.RuleFail)("Fail_4")
        ];
        return retArr[reasonCode];
    }
};
exports.element_lang_valid = {
    id: "element_lang_valid",
    context: "dom:*[lang], dom:*[xml:lang]",
    help: {
        "en-US": {
            "Pass_0": "element_lang_valid.html",
            "Fail_1": "element_lang_valid.html",
            "Fail_2": "element_lang_valid.html",
            "Fail_3": "element_lang_valid.html",
            "Fail_4": "element_lang_valid.html",
            "group": "element_lang_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Lang has a valid primary lang and conforms to BCP 47",
            "Fail_1": "Specified 'lang' attribute does not include a valid primary language",
            "Fail_2": "Specified 'lang' attribute does not conform to BCP 47",
            "Fail_3": "Specified 'xml:lang' attribute does not include a valid primary language",
            "Fail_4": "Specified 'xml:lang' attribute does not conform to BCP 47",
            "group": "The change in language of specific content must be valid and specified in accordance with BCP 47"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["3.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [{
            // "b5c3f8": {
            //     "Pass_0": "pass",
            //     "Fail_1": "fail",
            //     "Fail_2": "inapplicable",
            //     "Fail_3": "inapplicable",
            //     "Fail_4": "inapplicable"
            // },
            // "bf051a": {
            //     "Pass_0": "pass",
            //     "Fail_1": "fail",
            //     "Fail_2": "pass",
            //     "Fail_3": "fail",
            //     "Fail_4": "inapplicable"
            // },
            // TODO: ACT: Mismatch because they don't check the html element in the same rule
            "de46e4": {
                "Pass_0": "pass",
                "Fail_1": "fail",
                "Fail_2": "pass",
                "Fail_3": "inapplicable",
                "Fail_4": "inapplicable"
            }
        }],
    run: function (context, options, contextHierarchies) {
        // If it's the HTML node, that's handled by html_lang_valid
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (nodeName === "html")
            return null;
        var reasonCode = validateLang(context);
        // This is done here instead of in validateLang so that the genHelp code will pick it up
        var retArr = [
            (0, IRule_1.RulePass)("Pass_0"),
            (0, IRule_1.RuleFail)("Fail_1"),
            (0, IRule_1.RuleFail)("Fail_2"),
            (0, IRule_1.RuleFail)("Fail_3"),
            (0, IRule_1.RuleFail)("Fail_4")
        ];
        var retVal = retArr[reasonCode];
        if (retVal.value[1] !== IRule_1.eRuleConfidence.PASS) {
            // Ensure that there's actually content of this element - skip subtrees that have other lang attributes
            var hasContent = false;
            if (ruleContext.firstChild !== null) {
                var nw = new DOMWalker_1.DOMWalker(ruleContext, false, ruleContext, true);
                while (!hasContent && nw.nextNode()) {
                    // Skip hidden
                    if (nw.node.nodeType === 1) {
                        var element = nw.node;
                        if (!VisUtil_1.VisUtil.isNodeVisible(element) || element.hasAttribute("lang")) {
                            nw.bEndTag = true;
                        }
                        else {
                            var pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(element);
                            hasContent = hasContent
                                || element.nodeName.toLowerCase() === "img" && (pair && pair.name && pair.name.trim().length > 0) /**ARIAMapper.computeName(element).trim().length > 0*/;
                        }
                    }
                    else {
                        hasContent = hasContent
                            || nw.node.nodeType === 3 && nw.node.nodeValue.trim().length > 0;
                    }
                }
            }
            if (!hasContent)
                return null;
        }
        return retVal;
    }
};


/***/ }),

/***/ 2150:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_mouseevent_keyboard = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.element_mouseevent_keyboard = {
    id: "element_mouseevent_keyboard",
    context: "dom:*[ondblclick], dom:*[onmousemove], dom:*[onmousedown], dom:*[onmouseup], dom:*[onmouseover], dom:*[onmouseout], dom:*[onclick]",
    refactor: {
        "RPT_Elem_EventMouseAndKey": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "element_mouseevent_keyboard.html",
            "Manual_1": "element_mouseevent_keyboard.html",
            "group": "element_mouseevent_keyboard.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Confirm the <{0}> element with mouse event handler(s) '{1}' has a corresponding keyboard handler(s)",
            "group": "All interactive content with mouse event handlers must have equivalent keyboard access"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var passed = ruleContext.hasAttribute("href") ||
            (!ruleContext.hasAttribute("ondblclick") &&
                !ruleContext.hasAttribute("onmousemove") &&
                (!ruleContext.hasAttribute("onmousedown") || ruleContext.hasAttribute("onkeydown")) &&
                (!ruleContext.hasAttribute("onmouseup") || ruleContext.hasAttribute("onkeyup")) &&
                (!ruleContext.hasAttribute("onmouseover") || ruleContext.hasAttribute("onfocus")) &&
                (!ruleContext.hasAttribute("onmouseout") || ruleContext.hasAttribute("onblur")) &&
                (!ruleContext.hasAttribute("onclick") || ruleContext.hasAttribute("onkeypress") ||
                    nodeName == "a" || nodeName == "button"));
        var failedMouseEvents = new Array();
        if (!passed) {
            //store and display event name and node name in the tokens
            if (ruleContext.hasAttribute("ondblclick")) {
                failedMouseEvents.push("ondblclick");
            }
            if (ruleContext.hasAttribute("onmousemove")) {
                failedMouseEvents.push("onmousemove");
            }
            if (ruleContext.hasAttribute("onmousedown") && !ruleContext.hasAttribute("onkeydown")) {
                failedMouseEvents.push("onmousedown");
            }
            if (ruleContext.hasAttribute("onmouseup") && !ruleContext.hasAttribute("onkeyup")) {
                failedMouseEvents.push("onmouseup");
            }
            if (ruleContext.hasAttribute("onmouseover") && !ruleContext.hasAttribute("onfocus")) {
                failedMouseEvents.push("onmouseover");
            }
            if (ruleContext.hasAttribute("onmouseout") && !ruleContext.hasAttribute("onblur")) {
                failedMouseEvents.push("onmouseout");
            }
            if (ruleContext.hasAttribute("onclick") && !ruleContext.hasAttribute("onkeypress")) {
                if (!(nodeName == "a" || nodeName == "button"))
                    failedMouseEvents.push("onclick");
            }
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RuleManual)("Manual_1", [nodeName, failedMouseEvents.join(", ")]);
    }
};


/***/ }),

/***/ 4557:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_orientation_unlocked = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CSSUtil_1 = __webpack_require__(1775);
var VisUtil_1 = __webpack_require__(8656);
var CacheUtil_1 = __webpack_require__(7788);
var fragment_1 = __webpack_require__(482);
var CommonUtil_1 = __webpack_require__(8137);
exports.element_orientation_unlocked = {
    id: "element_orientation_unlocked",
    context: "dom:*",
    help: {
        "en-US": {
            "pass": "element_orientation_unlocked.html",
            "fail_locked": "element_orientation_unlocked.html",
            "group": "element_orientation_unlocked.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The element is not restricted to either landscape or portrait orientation using CSS transform property",
            "fail_locked": "The element <{0}> is restricted to either landscape or portrait orientation using CSS transform property",
            "group": "Elements should not be restricted to either landscape or portrait orientation using CSS transform property"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.4"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: ['b33eff'],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip invisible element
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext))
            return null;
        //skip elements
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["script", "meta", "title"]))
            return null;
        var nodeName = ruleContext.nodeName.toLowerCase();
        // cache the orientation result for all the elements in the page
        var doc = fragment_1.FragmentUtil.getOwnerFragment(ruleContext);
        var orientationTransforms = CacheUtil_1.CacheUtil.getCache(doc, "RPTUtil_MEDIA_ORIENTATION_TRANSFROM", null);
        if (!orientationTransforms) {
            orientationTransforms = CSSUtil_1.CSSUtil.getMediaOrientationTransform(doc);
            CacheUtil_1.CacheUtil.setCache(doc, "RPTUtil_MEDIA_ORIENTATION_TRANSFROM", orientationTransforms);
        }
        // find if the element matches orientation selector(s)
        var media_transforms = [];
        Object.keys(orientationTransforms).forEach(function (key) {
            Object.keys(orientationTransforms[key]).forEach(function (tag) {
                if (Object.keys(orientationTransforms[key][tag]).length > 0 && CSSUtil_1.CSSUtil.selectorMatchesElem(ruleContext, tag)) {
                    if (orientationTransforms[key][tag].transform)
                        media_transforms.push(orientationTransforms[key][tag].transform);
                    else
                        media_transforms.push(orientationTransforms[key][tag]);
                }
            });
        });
        // no match, the element is not in media orientation transform
        if (media_transforms.length === 0)
            return null;
        var ret = [];
        var _loop_1 = function (i) {
            var media_transform = media_transforms[i];
            if (typeof media_transform === 'object')
                for (var key in media_transform)
                    media_transform = key + "(" + media_transform[key] + ")";
            var containsRotation = false;
            ['rotate', 'rotate3d', 'rotateZ', 'matrix', 'matrix3d'].forEach(function (rotation) {
                if (media_transform.includes(rotation))
                    containsRotation = true;
            });
            // no rotation transform, skip
            if (!containsRotation)
                return "continue";
            var degree = CSSUtil_1.CSSUtil.getRotationDegree(media_transform);
            // no or 360n degree rotation 
            if (degree === 0) {
                ret.push((0, IRule_1.RulePass)("pass"));
                return "continue";
            }
            /**
             * calculate the original page rotation transformation, example
             *  html { transform: rotate(2.5deg); }
            */
            var definedStyle = CSSUtil_1.CSSUtil.getDefinedStyles(ruleContext);
            /**
             * compensate the media orientation with the page orientation
             */
            if (definedStyle['transform']) {
                var page_degree = CSSUtil_1.CSSUtil.getRotationDegree(definedStyle['transform']);
                // rotate is additive
                degree += page_degree;
            }
            // When degree is 1 turn (360 degree), it is not considered an orientation lock
            // allow 1 degree floating range for the right angle
            if (Math.abs(degree - 360) % 360 > 1)
                ret.push((0, IRule_1.RuleFail)("fail_locked", [nodeName]));
            else
                ret.push((0, IRule_1.RulePass)("pass"));
        };
        for (var i = 0; i < media_transforms.length; i++) {
            _loop_1(i);
        }
        if (ret.length > 0)
            return ret;
        return null;
    }
};


/***/ }),

/***/ 4721:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_scrollable_tabbable = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var IRule_1 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
var AriaUtil_1 = __webpack_require__(490);
exports.element_scrollable_tabbable = {
    id: "element_scrollable_tabbable",
    context: "dom:*",
    dependencies: [],
    help: {
        "en-US": {
            "group": "element_scrollable_tabbable.html",
            "pass_tabbable": "element_scrollable_tabbable.html",
            "pass_interactive": "element_scrollable_tabbable.html",
            "fail_scrollable": "element_scrollable_tabbable.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Scrollable elements should be tabbable or contain tabbable content",
            "pass_tabbable": "The scrollable element is tabbable",
            "pass_interactive": "The scrollable element has tabbable content",
            "fail_scrollable": "The scrollable element <{0}> with non-interactive content is not tabbable"
        }
    },
    /**
     * deprecated on 6/10/2025 due to Browser support for auto-focus of a scrollable element
     * rulesets: [{
        id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
        num: ["2.1.1"],
        level: eRulePolicy.VIOLATION,
        toolkitLevel: eToolkitLevel.LEVEL_ONE
    }],*/
    rulesets: [],
    act: ["0ssw9k"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return;
        //skip elements
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["iframe", "svg", "script", "meta", "style"]))
            return null;
        //skip if no visible content
        if (!CommonUtil_1.CommonUtil.hasInnerContent(ruleContext))
            return null;
        // ignore if the element's navigation is controlled or owned by another element
        if (AriaUtil_1.AriaUtil.isNavigationOwnedOrControlled(ruleContext))
            return null;
        // ignore if the element is not scrollable or content withouting needing a scroll
        if (!VisUtil_1.VisUtil.isElementScrollable(ruleContext))
            return null;
        // pass if element is tabbable
        if (CommonUtil_1.CommonUtil.isTabbable(ruleContext))
            return (0, IRule_1.RulePass)("pass_tabbable");
        // check if element content is tabbable
        var count = CommonUtil_1.CommonUtil.getTabbableChildren(ruleContext);
        if (count > 0)
            return (0, IRule_1.RulePass)("pass_interactive");
        // ignore in Firefox if no tabindex at all (not tested in embedded or any simulator)
        if (!ruleContext.hasAttribute("tabindex") && navigator.userAgent.indexOf("Firefox") > -1)
            return null;
        return (0, IRule_1.RuleFail)("fail_scrollable", [ruleContext.nodeName.toLowerCase()]);
    }
};


/***/ }),

/***/ 2814:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_tabbable_role_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var ARIADefinitions_1 = __webpack_require__(8235);
var DOMWalker_1 = __webpack_require__(7440);
var VisUtil_1 = __webpack_require__(8656);
exports.element_tabbable_role_valid = {
    id: "element_tabbable_role_valid",
    context: "dom:*",
    help: {
        "en-US": {
            "pass": "element_tabbable_role_valid.html",
            "fail_invalid_role": "element_tabbable_role_valid.html",
            "fail_no_valid_role": "element_tabbable_role_valid.html",
            "group": "element_tabbable_role_valid.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The tabbable element has a widget role",
            "fail_invalid_role": "The tabbable element's role '{0}' is not a widget role",
            "fail_no_valid_role": "The tabbable element does not have a valid widget role",
            "group": "A tabbable element must have a valid widget role"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        },
        {
            "id": ["WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext) || VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var nodeName = ruleContext.nodeName.toLowerCase();
        // if the element is tabbable by default with or without tabindex, let the other rules (such as widget_tabbable_single) to handle it
        if (nodeName in CommonUtil_1.CommonUtil.tabTagMap) {
            var value = CommonUtil_1.CommonUtil.tabTagMap[nodeName];
            if (typeof (value) === "function") {
                value = value(ruleContext);
            }
            if (value)
                return null;
        }
        // handle the case: no tabindex or tabindex < 0
        if (!ruleContext.hasAttribute("tabindex") || parseInt(ruleContext.getAttribute("tabindex")) < 0)
            return null;
        // ignore if the element's navigation is controlled by another element, such as combobox
        if (AriaUtil_1.AriaUtil.isNavigationOwnedOrControlled(ruleContext))
            return null;
        // ignore if the element is scrollable
        if (VisUtil_1.VisUtil.isElementScrollable(ruleContext))
            return null;
        // elements whose roles allow no descendants that are interactive or with a tabindex >= 0 
        // this case should be handled in widget_tabbable_single and aria_child_tabbable
        var roles_no_interactive_child = ["button", "checkbox", "img", "link", "menuitem", "menuitemcheckbox", "menuitemradio",
            "option", "radio", "switch", "tab"];
        var parent = DOMWalker_1.DOMWalker.parentNode(ruleContext);
        var parent_role = AriaUtil_1.AriaUtil.getResolvedRole(parent);
        // ignore if the parent role is in roles_no_interactive_child
        if (roles_no_interactive_child.includes(parent_role))
            return null;
        var role = AriaUtil_1.AriaUtil.getResolvedRole(ruleContext);
        if (!role)
            return (0, IRule_1.RuleFail)("fail_no_valid_role");
        // ignore 'application' role that contains one or more focusable elements that do not follow a standard interaction pattern supported by a widget role:https://www.w3.org/TR/2023/PR-WAI-ARIA-1.2-20230328/#application 
        if (role === "application")
            return null;
        // handle the case: tabindex >= 0 to examine whether a widget role is setup or not 
        // pass if one of the roles is a widget type
        // Row is weird. It's structure, but can also be widget
        // Focusable separators are widgets
        if (role === "row" || role === "separator" || ARIADefinitions_1.ARIADefinitions.designPatterns[role].roleType === 'widget') {
            return (0, IRule_1.RulePass)("pass");
        }
        return (0, IRule_1.RuleFail)("fail_invalid_role", [role]);
    }
};


/***/ }),

/***/ 9188:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_tabbable_unobscured = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
var DOMMapper_1 = __webpack_require__(5697);
exports.element_tabbable_unobscured = {
    id: "element_tabbable_unobscured",
    context: "dom:*",
    dependencies: [],
    help: {
        "en-US": {
            "group": "element_tabbable_unobscured.html",
            "pass": "element_tabbable_unobscured.html",
            "potential_obscured": "element_tabbable_unobscured.html"
        }
    },
    messages: {
        "en-US": {
            "group": "When an element receives focus, it is not entirely covered by other content",
            "pass": "The element is not entirely covered by other content",
            "potential_obscured": "Confirm that when the element receives focus, it is not covered or, if covered by user action, can be uncovered without moving focus"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_2"],
            num: ["2.4.11"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) || !CommonUtil_1.CommonUtil.isTabbable(ruleContext))
            return null;
        var nodeName = ruleContext.nodeName.toLocaleLowerCase();
        //ignore certain elements
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["pre", "code", "script", "meta"]) !== null
            || nodeName === "body" || nodeName === "html")
            return null;
        var mapper = new DOMMapper_1.DOMMapper();
        var bounds = mapper.getUnadjustedBounds(ruleContext);
        ;
        //in case the bounds not available
        if (!bounds)
            return null;
        //ignore if offscreen
        if (bounds['height'] === 0 || bounds['width'] === 0)
            return null;
        var doc = ruleContext.ownerDocument;
        if (!doc) {
            return null;
        }
        var win = doc.defaultView;
        if (!win) {
            return null;
        }
        var cStyle = win.getComputedStyle(ruleContext);
        if (cStyle === null)
            return null;
        var zindex = cStyle.zIndex;
        if (!zindex || zindex === 'auto')
            zindex = "0";
        var elems = doc.querySelectorAll('body *:not(script)');
        if (!elems || elems.length == 0)
            return;
        var violations = [];
        var before = true;
        elems.forEach(function (elem) {
            /**
             *  the nodes returned from querySelectorAll is in document order
             *  if two elements overlap and z-index are not defined, then the node rendered earlier will be overlaid by the node rendered later
             */
            if (ruleContext.contains(elem)) {
                //the next node in elems will be after the target node (ruleContext). 
                before = false;
            }
            else if (VisUtil_1.VisUtil.isNodeVisible(elem) && !elem.contains(ruleContext)) {
                var bnds = mapper.getUnadjustedBounds(elem);
                var zStyle = win.getComputedStyle(elem);
                var z_index = '0';
                if (zStyle) {
                    z_index = zStyle.zIndex;
                    if (!z_index || isNaN(Number(z_index)))
                        z_index = "0";
                }
                if (bnds.height !== 0 && bnds.width !== 0
                    && bnds.top <= bounds.top && bnds.left <= bounds.left && bnds.top + bnds.height >= bounds.top + bounds.height
                    && bnds.left + bnds.height >= bounds.left + bounds.width
                    && (before ? parseInt(zindex) < parseInt(z_index) : parseInt(zindex) <= parseInt(z_index))) {
                    violations.push(elem);
                }
            }
        });
        if (violations.length > 0) {
            return (0, IRule_1.RulePotential)("potential_obscured", []);
        }
        return (0, IRule_1.RulePass)("pass");
    }
};


/***/ }),

/***/ 7601:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.element_tabbable_visible = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var CSSUtil_1 = __webpack_require__(1775);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var DOMMapper_1 = __webpack_require__(5697);
exports.element_tabbable_visible = {
    id: "element_tabbable_visible",
    context: "dom:*",
    dependencies: [],
    help: {
        "en-US": {
            "group": "element_tabbable_visible.html",
            "pass": "element_tabbable_visible.html",
            "potential_visible": "element_tabbable_visible.html"
        }
    },
    messages: {
        "en-US": {
            "group": "A tabbable element should be visible on the screen when it has keyboard focus",
            "pass": "The tabbable element is visible on the screen",
            "potential_visible": "Confirm the element should be tabbable and if so, it becomes visible when it has keyboard focus"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            num: ["2.4.7"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!CommonUtil_1.CommonUtil.isTabbable(ruleContext))
            return null;
        var nodeName = ruleContext.nodeName.toLocaleLowerCase();
        var mapper = new DOMMapper_1.DOMMapper();
        var bounds = mapper.getUnadjustedBounds(ruleContext);
        //in case the bounds not available
        if (!bounds)
            return null;
        // defined styles only give the styles that changed
        var defined_styles = CSSUtil_1.CSSUtil.getDefinedStyles(ruleContext);
        var onfocus_styles = CSSUtil_1.CSSUtil.getDefinedStyles(ruleContext, ":focus");
        if (bounds['height'] === 0 || bounds['width'] === 0)
            return (0, IRule_1.RulePotential)("potential_visible", []);
        if (defined_styles['position'] === 'absolute' && defined_styles['clip'] && defined_styles['clip'].replaceAll(' ', '') === 'rect(0px,0px,0px,0px)'
            && !onfocus_styles['clip']) {
            /**
             * note that A user can select a checkbox and radio button by selecting the button or the label text.
             * When a checkbox or radio button is clipped to 0 size, it is still available to a keyboard or a screen reader.
             * The rule should be passed if the label text exists and the button on-focus style is defined by the user,
             * which likely incurs the changes of the label style.
             */
            if (nodeName === 'input' && (ruleContext.getAttribute('type') === 'checkbox' || ruleContext.getAttribute('type') === 'radio')) {
                var label = CommonUtil_1.CommonUtil.getLabelForElement(ruleContext);
                if (label && !CommonUtil_1.CommonUtil.isInnerTextEmpty(label)) {
                    var focus_styles = CSSUtil_1.CSSUtil.getDefinedStyles(ruleContext, ":focus");
                    var focus_visible_styles = CSSUtil_1.CSSUtil.getDefinedStyles(ruleContext, ":focus-visible");
                    var focus_within_styles = CSSUtil_1.CSSUtil.getDefinedStyles(ruleContext, ":focus-within");
                    var checked_styles = CSSUtil_1.CSSUtil.getDefinedStyles(ruleContext, ":checked");
                    if (focus_styles || focus_visible_styles || focus_within_styles || checked_styles)
                        return (0, IRule_1.RulePass)("pass");
                }
            }
            return (0, IRule_1.RulePotential)("potential_visible", []);
        }
        if (bounds['top'] >= 0 && bounds['left'] >= 0)
            return (0, IRule_1.RulePass)("pass");
        var default_styles = getComputedStyle(ruleContext);
        var top = bounds['top'];
        var left = bounds['left'];
        if (Object.keys(onfocus_styles).length === 0) {
            // no onfocus position change, but could be changed from js 
            return (0, IRule_1.RulePotential)("potential_visible", []);
        }
        else {
            // with onfocus position change
            var positions = ['absolute', 'fixed'];
            if (typeof onfocus_styles['top'] !== 'undefined') {
                if (positions.includes(onfocus_styles['position']) || (typeof onfocus_styles['position'] === 'undefined' && positions.includes(default_styles['position']))) {
                    top = onfocus_styles['top'].replace(/\D/g, '');
                }
                else {
                    // the position is undefined and the parent's position is 'relative'
                    top = Number.MIN_VALUE;
                }
            }
            if (typeof onfocus_styles['left'] !== 'undefined') {
                if (positions.includes(onfocus_styles['position']) || (typeof onfocus_styles['position'] === 'undefined' && positions.includes(default_styles['position']))) {
                    left = onfocus_styles['left'].replace(/\D/g, '');
                }
                else {
                    // the position is undefined and the parent's position is 'relative'
                    left = Number.MIN_VALUE;
                }
            }
        }
        if (top >= 0 && left >= 0)
            return (0, IRule_1.RulePass)("pass");
        else
            return (0, IRule_1.RulePotential)("potential_visible", []);
    }
};


/***/ }),

/***/ 4497:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.embed_alt_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.embed_alt_exists = {
    id: "embed_alt_exists",
    context: "dom:embed",
    refactor: {
        "RPT_Embed_HasAlt": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "embed_alt_exists.html",
            "Potential_1": "embed_alt_exists.html",
            "group": "embed_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that the <embed> element has alternative content",
            "group": "Provide alternative content for <embed> elements"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "alt");
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 152:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.embed_noembed_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.embed_noembed_exists = {
    id: "embed_noembed_exists",
    context: "dom:embed",
    refactor: {
        "WCAG20_Embed_HasNoEmbed": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "embed_noembed_exists.html",
            "Potential_1": "embed_noembed_exists.html",
            "group": "embed_noembed_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that the <embed> element is immediately followed by a non-embedded element",
            "group": "<embed> elements should be immediately followed by a non-embedded element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = ruleContext.getElementsByTagName("noembed").length > 0;
        if (!passed) {
            var walkNode = ruleContext.nextSibling;
            while (!passed && walkNode !== null) {
                if (walkNode.nodeName.toLowerCase() == "noembed")
                    passed = true;
                else if (walkNode.nodeName.toLowerCase() == "#text" && walkNode.nodeValue.trim().length > 0)
                    break;
                else if (walkNode.nodeType == 1)
                    break;
                walkNode = walkNode.nextSibling;
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 935:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.emoticons_alt_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.emoticons_alt_exists = {
    id: "emoticons_alt_exists",
    context: "dom:*",
    refactor: {
        "WCAG20_Text_Emoticons": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "emoticons_alt_exists.html",
            "Potential_1": "emoticons_alt_exists.html",
            "group": "emoticons_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that emoticons have a text alternative",
            "group": "Emoticons must have a short text alternative that describes their purpose"
        }
    },
    /**
     * Decision in planning 9/7/23 that this rule causes more reviews that we see actual problems in content, so turn these rules off
    
    rulesets: [{
        "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
        "num": ["1.1.1"],
        "level": eRulePolicy.VIOLATION,
        "toolkitLevel": eToolkitLevel.LEVEL_TWO
    }],
    */
    rulesets: [],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            emoticons: {
                value: [":-)", ":)", ":o)", ":]", ":3", ":c)", ":>", "=]", "8)", "=)", ":D", "C:",
                    ":-D", ":D", "8D", "XD", "=D", "=3", "<=3", "<=8", "--!--", ":-(", ":(", ":c", ":<", ":[",
                    "D:", "D8", "D;", "D=", "DX", "v.v", ":-9", ";-)", ";)", "*)", ";]", ";D", ":-P", ":P",
                    ":-p", ":p", "=p", ":-", ":", ":-b", ":b", ":-O", ":O", "O_O", "o_o", "8O", "OwO", "O-O",
                    "0_o", "O_o", "O3O", "o0o;o_o;", "o...o", "0w0", ":-/", ":/", ":\\", "=/", "=\\", ":S", ":|",
                    "d:-)", "qB-)", ":)~", ":-)>....", ":-X", ":X", ":-#", ":#", "O:-)", "0:3", "O:)", ":'(", ";*(",
                    "T_T", "TT_TT", "T.T", ":-*", ":*", "^o)", ">:)", ">;)", ">:-)", "B)", "B-)", "8)", "8-)",
                    "^>.>^", "^<.<^", "^>_>^", "^<_<^", "D:<", ">:(", "D-:<", ">:-(", ":-@[1]", ";(", "`_", "D<",
                    "<3", "<333", "=^_^=", "=>.>=", "=<_<=", "=>.<=", "\\,,/", "\\m/", "\\m/\\>.</\\m/", "\\o/", "\\o o/",
                    "o/\\o", ":&", ":u"
                ],
                type: "[string]"
            }
        };
        var ruleContext = context["dom"].node;
        var emoticons = validateParams.emoticons.value;
        var passed = true;
        var testText = "";
        var walkNode = ruleContext.firstChild;
        while (walkNode) {
            // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
            // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
            // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
            // a node walk only on siblings so it would not get text nodes from other siblings at all.
            // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
            // if.
            if (walkNode.nodeName == "#text") {
                testText += " " + walkNode.nodeValue;
            }
            walkNode = walkNode.nextSibling;
        }
        if (testText.trim().length > 0) {
            for (var j = 0; passed && j < emoticons.length; ++j) {
                var emotIdx = testText.indexOf(emoticons[j]);
                var eLngth = emoticons[j].length;
                while (passed && emotIdx != -1) {
                    // Passes if: the emoticon is not preceded by whitespace,
                    // or the emoticon is not followed by whitespace unless it's punctuation,
                    // or it's in a pre, code, or script
                    passed =
                        (emotIdx > 0 && !/\s/.test(testText.substring(emotIdx - 1, emotIdx))) ||
                            (emotIdx < testText.length - eLngth && !/\s/.test(testText.substring(emotIdx + eLngth, emotIdx + eLngth + 1)) &&
                                !/[.,!'"?]/.test(testText.substring(emotIdx + eLngth, emotIdx + eLngth + 1)));
                    // Allow usage of (: stuff :) since this is a comment in some languages
                    passed = passed || ((emoticons[j] == ":)" || emoticons[j] == "(:") && /\(\:.*\:\)/.test(testText));
                    passed = passed || ((emoticons[j] == ";)" || emoticons[j] == "(;") && /\(\;.*\;\)/.test(testText));
                    emotIdx = testText.indexOf(emoticons[j], emotIdx + 1);
                }
            }
        }
        if (!passed) {
            // Don't trigger if we're not in the body or if we're in a script, pre, code
            var checkAncestor = CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["pre", "code", "script", "body"]);
            passed = checkAncestor == null || checkAncestor.nodeName.toLowerCase() != "body";
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9719:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.error_message_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var fragment_1 = __webpack_require__(482);
var VisUtil_1 = __webpack_require__(8656);
exports.error_message_exists = {
    id: "error_message_exists",
    context: "dom:*[aria-invalid=true]",
    refactor: {
        "HAAC_Aria_ErrorMessage": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "error_message_exists.html",
            "Fail_1": "error_message_exists.html",
            "Fail_2": "error_message_exists.html",
            "group": "error_message_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Custom error message has invalid reference 'id' value",
            "Fail_2": "Custom error message is not visible",
            "group": "A custom error message must reference a valid 'id' value and when triggered the message must be appropriately exposed"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["3.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var aria_errMsgId = AriaUtil_1.AriaUtil.getAriaAttribute(ruleContext, "aria-errormessage");
        // If aria-errormessage is not provided, then OUT_OF_SCOPE
        if (!aria_errMsgId) {
            return null;
        }
        var msg_ele = fragment_1.FragmentUtil.getById(ruleContext, aria_errMsgId);
        // POF0: Invalid id reference
        if (!msg_ele) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        // POF1: Referenced element is not visible
        if (!VisUtil_1.VisUtil.isNodeVisible(msg_ele)) {
            return (0, IRule_1.RuleFail)("Fail_2");
        }
        return (0, IRule_1.RulePass)("Pass_0");
    }
};


/***/ }),

/***/ 5625:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fieldset_label_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var fragment_1 = __webpack_require__(482);
var CacheUtil_1 = __webpack_require__(7788);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
var AccNameUtil_1 = __webpack_require__(1421);
exports.fieldset_label_valid = {
    id: "fieldset_label_valid",
    context: "aria:group",
    refactor: {
        "group_withInputs_hasName": {
            "Pass_1": "Pass_1",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_1": "fieldset_label_valid.html",
            "Fail_1": "fieldset_label_valid.html",
            "Fail_2": "fieldset_label_valid.html",
            "group": "fieldset_label_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_1": "Group/Fieldset \"{0}\" with an input has a unique name",
            "Fail_1": "Group/Fieldset does not have an accessible name",
            "Fail_2": "Group/Fieldset \"{0}\" has a duplicate name to another group",
            "group": "Groups with nested inputs must have unique accessible name"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1", "3.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return;
        var ownerDocument = fragment_1.FragmentUtil.getOwnerFragment(ruleContext);
        var formCache = CacheUtil_1.CacheUtil.getCache(ruleContext.ownerDocument, "landmark_group_input", null);
        if (!formCache) {
            formCache = {
                groupsWithInputs: [],
                groupsWithInputsComputedLabels: [],
            };
            var allGroupsTemp = ownerDocument.querySelectorAll('fieldset,[role="group"]');
            var allGroups = Array.from(allGroupsTemp);
            var groupsWithInputs = [];
            for (var i = 0; i < allGroups.length; i++) {
                // Loop over all the group nodes
                if (allGroups[i].querySelector("input")) {
                    groupsWithInputs.push(allGroups[i]);
                }
            }
            var groupsWithInputsComputedLabels = [];
            for (var i = 0; i < groupsWithInputs.length; i++) {
                var pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(groupsWithInputs[i]);
                // Loop over all the landmark nodes
                groupsWithInputsComputedLabels.push(
                /**ARIAMapper.computeName(groupsWithInputs[i])*/
                pair && pair.name && pair.name.trim().length > 0 ? pair.name.trim() : "");
            }
            formCache.groupsWithInputs = groupsWithInputs;
            formCache.groupsWithInputsComputedLabels =
                groupsWithInputsComputedLabels;
            CacheUtil_1.CacheUtil.setCache(ruleContext.ownerDocument, "landmark_group_input", formCache);
        }
        // formCache.groupsWithInputs.forEach(element => {
        //     console.log("formCache.groupsWithInputs: " +element.id)
        // });
        // console.log("formCache.groupsWithInputsComputedLabels: " +formCache.groupsWithInputsComputedLabels)
        // console.log("formCache.groupsWithInputsComputedLabels: " +formCache.groupsWithInputsComputedLabels.length)
        var ruleContextFoundIngroupsWithInputsFlag = false;
        var computedName = "";
        if (!formCache.groupsWithInputs) {
            // We do not have any groups with inputs. Therefore we should skip this rule trigger.
            return null;
        }
        for (var i = 0; i < formCache.groupsWithInputs.length; i++) {
            if (ruleContext.isSameNode(formCache.groupsWithInputs[i])) {
                // We have found our ruleContext in the cache
                ruleContextFoundIngroupsWithInputsFlag = true;
                if (formCache.groupsWithInputsComputedLabels[i] === "" ||
                    formCache.groupsWithInputsComputedLabels[i] === null) {
                    // console.log("Fail_1")
                    return (0, IRule_1.RuleFail)("Fail_1");
                }
                var foundSameNameFlag = false;
                for (var j = 0; j < formCache.groupsWithInputsComputedLabels.length; j++) {
                    if (i == j) {
                        continue;
                    } // We do not want to compare against ourselfs
                    if (formCache.groupsWithInputsComputedLabels[i] ===
                        formCache.groupsWithInputsComputedLabels[j]) {
                        foundSameNameFlag = true;
                    }
                }
                if (foundSameNameFlag) {
                    // console.log("Fail_2")
                    return (0, IRule_1.RuleFail)("Fail_2", [
                        formCache.groupsWithInputsComputedLabels[i],
                    ]);
                }
                computedName = formCache.groupsWithInputsComputedLabels[i];
            }
        }
        if (!ruleContextFoundIngroupsWithInputsFlag) {
            // console.log("null return")
            return null;
        }
        // console.log("Pass_1")
        return (0, IRule_1.RulePass)("Pass_1", [computedName]);
    }
};


/***/ }),

/***/ 9115:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fieldset_legend_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.fieldset_legend_valid = {
    id: "fieldset_legend_valid",
    context: "dom:fieldset",
    refactor: {
        "WCAG20_Fieldset_HasLegend": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "fieldset_legend_valid.html",
            "Fail_1": "fieldset_legend_valid.html",
            "Fail_2": "fieldset_legend_valid.html",
            "Fail_3": "fieldset_legend_valid.html",
            "group": "fieldset_legend_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "<fieldset> element does not have a <legend>",
            "Fail_2": "<fieldset> element has more than one <legend>",
            "Fail_3": "<fieldset> element <legend> is empty",
            "group": " <fieldset> elements should have a single, non-empty <legend> as a label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip if the fieldset is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return null;
        // In the case a legend is hidden, we should still trigger a violations for this
        var legends = CommonUtil_1.CommonUtil.getChildByTagHidden(ruleContext, "legend", true, false);
        if (legends.length === 0) {
            // Fieldset has NO Legend
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else if (legends.length > 1) {
            // Fieldset has more than one legend
            return (0, IRule_1.RuleFail)("Fail_2");
        }
        else if (CommonUtil_1.CommonUtil.getInnerText(legends[0]).trim().length === 0) {
            // Fieldset has legend but legend is empty
            return (0, IRule_1.RuleFail)("Fail_3");
        }
        return (0, IRule_1.RulePass)("Pass_0");
    }
};


/***/ }),

/***/ 6072:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.figure_label_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
var AccNameUtil_1 = __webpack_require__(1421);
exports.figure_label_exists = {
    id: "figure_label_exists",
    context: "dom:figure",
    refactor: {
        "HAAC_Figure_label": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "figure_label_exists.html",
            "Fail_1": "figure_label_exists.html",
            "group": "figure_label_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The <figure> element does not have an associated label",
            "group": "A <figure> element must have an associated label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        // ignore if an explicit role is specified. this case will be covered in the aria_accessiblename_exists rules
        var role = ruleContext.getAttribute("role");
        if (role) {
            return null;
        }
        //let passed = AriaUtil.hasAriaLabel(ruleContext) || CommonUtil.attributeNonEmpty(ruleContext, "title");
        var pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(ruleContext);
        var passed = pair && pair.name && pair.name.trim().length > 0;
        //return new ValidationResult(passed, [ruleContext], '', '', []);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1", []);
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 6923:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.form_font_color = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.form_font_color = {
    id: "form_font_color",
    context: "dom:form",
    refactor: {
        "RPT_Font_ColorInForm": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "form_font_color.html",
            "Potential_1": "form_font_color.html",
            "group": "form_font_color.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Check color is not used as the only visual means to convey which fields are required",
            "group": "Combine color and descriptive markup to indicate required form fields"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = true;
        var fonts = ruleContext.getElementsByTagName("font");
        if (fonts != null) {
            for (var i = 0; i < fonts.length; ++i) {
                passed = !fonts[i].hasAttribute("color");
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9015:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.form_interaction_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.form_interaction_review = {
    id: "form_interaction_review",
    context: "dom:form[target]",
    refactor: {
        "WCAG20_Form_TargetAndText": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "form_interaction_review.html",
            "Potential_1": "form_interaction_review.html",
            "group": "form_interaction_review.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that interacting with content will not open pop-up windows or change the active window without informing the user",
            "group": "User should be informed in advance when interacting with content causes a change of context"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["3.2.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            paramWinText: {
                value: ["new window"],
                type: "array"
            }
        };
        var ruleContext = context["dom"].node;
        var tStr = ruleContext.getAttribute("target");
        var passed = tStr === "_parent" || tStr === "_self" || tStr === "_top" || CommonUtil_1.CommonUtil.getFrameByName(ruleContext, tStr) != null;
        if (!passed) {
            // Name is not part of this frameset  must have potential to create new window?
            // See if a new window is mentioned
            var textStr = CommonUtil_1.CommonUtil.getInnerText(ruleContext);
            if (ruleContext.hasAttribute("title"))
                textStr += " " + ruleContext.getAttribute("title");
            for (var i = 0; !passed && i < validateParams.paramWinText.value.length; ++i)
                if (textStr.indexOf(validateParams.paramWinText.value[i]) != -1)
                    passed = true;
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 3611:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.form_label_unique = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var fragment_1 = __webpack_require__(482);
var CacheUtil_1 = __webpack_require__(7788);
exports.form_label_unique = {
    id: "form_label_unique",
    context: "dom:label[for]",
    refactor: {
        "RPT_Label_UniqueFor": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "form_label_unique.html",
            "Fail_1": "form_label_unique.html",
            "group": "form_label_unique.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Form control has more than one label",
            "group": "Form controls should have exactly one label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // JCH - NO OUT OF SCOPE hidden in context
        var labelIds = CacheUtil_1.CacheUtil.getCache(fragment_1.FragmentUtil.getOwnerFragment(ruleContext), "RPT_Label_Single", {});
        var id = ruleContext.getAttribute("for");
        var passed = !(id in labelIds);
        labelIds[id] = true;
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.form_submit_button_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var DOMWalker_1 = __webpack_require__(7440);
exports.form_submit_button_exists = {
    id: "form_submit_button_exists",
    context: "dom:form",
    refactor: {
        "WCAG20_Form_HasSubmit": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "form_submit_button_exists.html",
            "Potential_1": "form_submit_button_exists.html",
            "group": "form_submit_button_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify the <form> element has a submit button or an image button",
            "group": "A <form> element should have a submit button or an image button"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["3.2.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = false;
        if (ruleContext.firstChild) {
            // submit buttons are usually at the bottom - walk backwards
            //let nw = new NodeWalker(ruleContext, true);
            var nw = new DOMWalker_1.DOMWalker(ruleContext, true);
            while (!passed && nw.prevNode() && nw.node != ruleContext) {
                if (!nw.bEndTag) {
                    var nodeName = nw.node.nodeName.toLowerCase();
                    if (nodeName === "input") {
                        var type = nw.elem().getAttribute("type");
                        if (type) {
                            type = type.toLowerCase();
                        }
                        passed = type === "submit" || type === "image";
                    }
                    else if (nodeName === "button") {
                        passed = nw.elem().hasAttribute("type") && nw.elem().getAttribute("type").toLowerCase() === "submit";
                    }
                    else if (nw.node.nodeType === 1) {
                        passed = AriaUtil_1.AriaUtil.hasRole(nw.node, "button");
                    }
                }
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 3277:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.form_submit_review = void 0;
var IRule_1 = __webpack_require__(4377);
exports.form_submit_review = {
    id: "form_submit_review",
    context: "dom:select[onchange], dom:input[onchange]",
    refactor: {
        "RPT_Form_ChangeEmpty": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "form_submit_review.html",
            "Potential_1": "form_submit_review.html",
            "group": "form_submit_review.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Confirm the form does not submit automatically without warning",
            "group": "A form should not be submitted automatically without warning the user"
        }
    },
    /**
     rulesets: [{
        "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
        "num": ["3.2.2"],
        "level": eRulePolicy.VIOLATION,
        "toolkitLevel": eToolkitLevel.LEVEL_THREE
    }],*/
    //deprecate the rule on Jun 10, 2024
    rulesets: [],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = ruleContext.getAttribute("onchange").trim().length === 0;
        if (passed)
            return null;
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 4525:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.frame_src_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.frame_src_valid = {
    id: "frame_src_valid",
    context: "dom:frame, dom:iframe",
    refactor: {
        "Valerie_Frame_SrcHtml": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "frame_src_valid.html",
            "Potential_1": "frame_src_valid.html",
            "group": "frame_src_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify <frame> content is accessible",
            "group": "A <frame> containing non-HTML content must be made accessible"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "src") &&
            CommonUtil_1.CommonUtil.isHtmlExt(CommonUtil_1.CommonUtil.getFileExt(ruleContext.getAttribute("src")));
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 7114:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.frame_title_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AccNameUtil_1 = __webpack_require__(1421);
var VisUtil_1 = __webpack_require__(8656);
exports.frame_title_exists = {
    id: "frame_title_exists",
    context: "dom:frame, dom:iframe",
    refactor: {
        "WCAG20_Frame_HasTitle": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "group": "frame_title_exists.html",
            "Pass_0": "frame_title_exists.html",
            "Fail_1": "frame_title_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Inline frames must have a unique, non-empty 'title' attribute",
            "Pass_0": "Rule Passed",
            "Fail_1": "Inline frame does not have a 'title' attribute",
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: "cae760",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        // ignore if an explicit role is specified. this case will be covered in the aria_accessiblename_exists rules
        var role = ruleContext.getAttribute("role");
        if (role) {
            return null;
        }
        var name_pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(ruleContext);
        if (name_pair && name_pair.name && name_pair.name.trim().length > 0) {
            //if (CommonUtil.attributeNonEmpty(ruleContext, "title")) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
    }
};


/***/ }),

/***/ 3751:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.heading_content_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.heading_content_exists = {
    id: "heading_content_exists",
    context: "dom:h1, dom:h2, dom:h3, dom:h4, dom:h5, dom:h6",
    refactor: {
        "RPT_Header_HasContent": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "heading_content_exists.html",
            "Fail_1": "heading_content_exists.html",
            "group": "heading_content_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Heading element has descriptive text",
            "Fail_1": "Heading element has no descriptive content",
            "group": "Heading elements must provide descriptive text"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.6"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = CommonUtil_1.CommonUtil.hasInnerContentHidden(ruleContext);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 7084:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.heading_markup_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.heading_markup_misuse = {
    id: "heading_markup_misuse",
    context: "dom:h1, dom:h2, dom:h3, dom:h4, dom:h5, dom:h6",
    dependencies: ["heading_content_exists"],
    refactor: {
        "RPT_Headers_FewWords": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "heading_markup_misuse.html",
            "Potential_1": "heading_markup_misuse.html",
            "group": "heading_markup_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that the heading element is a genuine heading",
            "group": "Heading elements must not be used for presentation"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            headingLengthThresh: {
                value: 20,
                type: "integer"
            }
        };
        var ruleContext = context["dom"].node;
        var headingLengthThresh = validateParams.headingLengthThresh.value;
        var passed = CommonUtil_1.CommonUtil.wordCount(CommonUtil_1.CommonUtil.getInnerText(ruleContext)) <= headingLengthThresh;
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 3981:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.html_lang_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var ancestor_1 = __webpack_require__(9193);
var lang_1 = __webpack_require__(2527);
exports.html_lang_exists = {
    id: "html_lang_exists",
    context: "dom:html",
    refactor: {
        "WCAG20_Html_HasLang": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3",
            "Fail_4": "Fail_4",
            "Fail_5": "Fail_5",
            "Potential_5": "Potential_5",
            "Potential_6": "Potential_6"
        }
    },
    help: {
        "en-US": {
            "group": "html_lang_exists.html",
            "Pass_0": "html_lang_exists.html",
            "Fail_1": "html_lang_exists.html",
            "Fail_2": "html_lang_exists.html",
            "Fail_3": "html_lang_exists.html",
            "Fail_4": "html_lang_exists.html",
            "Fail_5": "html_lang_exists.html",
            "Potential_5": "html_lang_exists.html",
            "Potential_6": "html_lang_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Page must identify the default language of the document with a 'lang' attribute",
            "Pass_0": "Page language detected as \"{0}\"",
            "Fail_1": "Page detected as XHTML 1.0, but has neither 'lang' nor 'xml:lang' attributes",
            "Fail_2": "Page detected as XHTML, but does not have an 'xml:lang' attribute",
            "Fail_3": "Page detected as HTML, but does not have a 'lang' attribute",
            "Fail_4": "Page detected with 'lang' and 'xml:lang' attributes and primary languages do not match: \"{0}\", \"{1}\"",
            "Fail_5": "Page detected with 'lang' and 'xml:lang' attributes that do not match: \"{0}\", \"{1}\"",
            "Potential_5": "Page detected as XHTML 1.0 with only a 'lang' attribute. Confirm that page is only delivered via text/html mime type",
            "Potential_6": "Page detected as XHTML 1.0 with only an 'xml:lang' attribute. Confirm that page is only delivered via xml mime type"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "3.1.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [{
            "b5c3f8": {
                "Pass_0": "pass",
                "Fail_1": "inapplicable",
                "Fail_2": "inapplicable",
                "Fail_3": "fail",
                "Fail_4": "inapplicable",
                "Fail_5": "inapplicable",
                "Potential_5": "inapplicable",
                "Potential_6": "inapplicable"
            },
            "5b7ae0": {
                "Pass_0": "pass",
                "Fail_1": "inapplicable",
                "Fail_2": "inapplicable",
                "Fail_3": "inapplicable",
                "Fail_4": "fail",
                "Fail_5": "pass",
                "Potential_5": "inapplicable",
                "Potential_6": "inapplicable"
            }
        }],
    run: function (context, options, contextHierarchies) {
        // This rule does not apply inside a presentational frame
        if (ancestor_1.AncestorUtil.isPresentationFrame(contextHierarchies)) {
            return null;
        }
        var ruleContext = context["dom"].node;
        var doctypeString = ruleContext.ownerDocument.doctype ? ruleContext.ownerDocument.doctype.publicId : "";
        if (!doctypeString)
            doctypeString = "";
        var lang = ruleContext.getAttribute("lang");
        var langXML = ruleContext.getAttribute("xml:lang");
        if (doctypeString.includes('XHTML') && !doctypeString.includes("1.0")) {
            if (!langXML) {
                // XHTML != 1.0 (must have xml:lang
                return (0, IRule_1.RuleFail)("Fail_2");
            }
            else {
                return (0, IRule_1.RulePass)("Pass_0", [langXML]);
            }
        }
        else if (doctypeString.includes('XHTML') && doctypeString.includes("1.0")) {
            // Handle XHTML 1.0
            // If neither is provided, it's a failure
            if (!lang && !langXML) {
                // XHTML and no lang
                return (0, IRule_1.RuleFail)("Fail_1");
            }
            else if (lang && langXML) {
                if (lang !== langXML) {
                    if (!lang_1.LangUtil.validPrimaryLang(lang) || !lang_1.LangUtil.validPrimaryLang(langXML)) {
                        // Let Elem_Lang_Valid handle this
                        return null;
                    }
                    if (!lang_1.LangUtil.matchPrimaryLang(lang, langXML)) {
                        // XHTML and lang and xml:lang, but they don't match
                        return (0, IRule_1.RuleFail)("Fail_4", [lang, langXML], []);
                    }
                    else {
                        return (0, IRule_1.RuleFail)("Fail_5", [lang, langXML], []);
                    }
                }
                else {
                    // XHTML and lang and xml:lang match
                    return (0, IRule_1.RulePass)("Pass_0", [lang]);
                }
            }
            else if (lang) {
                // XHTML and only lang (okay if only delivered via text/html)
                return (0, IRule_1.RulePotential)("Potential_5");
            }
            else {
                // XHTML and only xml:lang (okay if only delivered via xml mime type)
                return (0, IRule_1.RulePotential)("Potential_6");
            }
        }
        else {
            if (!lang) {
                return (0, IRule_1.RuleFail)("Fail_3");
            }
            else if (lang && langXML) {
                // HTML5 polyglot documents
                if (lang !== langXML) {
                    if (!lang_1.LangUtil.validPrimaryLang(lang) || !lang_1.LangUtil.validPrimaryLang(langXML)) {
                        // Let Elem_Lang_Valid handle this
                        return null;
                    }
                    if (!lang_1.LangUtil.matchPrimaryLang(lang, langXML)) {
                        // XHTML and lang and xml:lang, but they don't match
                        return (0, IRule_1.RuleFail)("Fail_4", [lang, langXML], []);
                    }
                    else {
                        return (0, IRule_1.RuleFail)("Fail_5", [lang, langXML], []);
                    }
                }
                else {
                    // XHTML and lang and xml:lang match
                    return (0, IRule_1.RulePass)("Pass_0", [lang]);
                }
            }
            else {
                return (0, IRule_1.RulePass)("Pass_0", [lang]);
            }
        }
    }
};


/***/ }),

/***/ 9788:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.html_skipnav_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var fragment_1 = __webpack_require__(482);
exports.html_skipnav_exists = {
    id: "html_skipnav_exists",
    context: "dom:html",
    refactor: {
        "RPT_Html_SkipNav": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "html_skipnav_exists.html",
            "Pass_0": "html_skipnav_exists.html",
            "Potential_1": "html_skipnav_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Provide a way to bypass blocks of content that are repeated on multiple Web pages",
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify there is a way to bypass blocks of content that are repeated on multiple Web pages"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "2.4.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = false;
        var frames = CommonUtil_1.CommonUtil.getDocElementsByTag(ruleContext, "frame");
        var headers = CommonUtil_1.CommonUtil.getDocElementsByTag(ruleContext, "h1");
        if ((frames != null && frames.length > 0) || (headers != null && headers.length > 0)) {
            // If frames or headings are used, pass
            passed = true;
        }
        else {
            // Look for skip anchors
            var anchors = CommonUtil_1.CommonUtil.getDocElementsByTag(ruleContext, "a");
            var targets = {};
            for (var idx = 0; !passed && idx < anchors.length; ++idx) {
                if (anchors[idx].hasAttribute("href")) {
                    var href = anchors[idx].href;
                    if (typeof href !== typeof "") {
                        if (href.baseVal) {
                            href = href.baseVal;
                        }
                        else {
                            href = "";
                        }
                    }
                    var tmpLocation = void 0;
                    if (typeof (ruleContext.ownerDocument.locationFromDAP) != "undefined" && ruleContext.ownerDocument.locationFromDAP != null) { // DAP sets it
                        tmpLocation = ruleContext.ownerDocument.locationFromDAP;
                    }
                    else { // server scan has the location object
                        tmpLocation = ruleContext.ownerDocument.location;
                    }
                    var docHref = "";
                    if (tmpLocation) {
                        docHref = tmpLocation.href;
                    }
                    // Fix weird bugs with how various parsers report on file: url's:
                    if (href.startsWith("file:///"))
                        href = "file:/" + href.substring("file:///".length);
                    if (docHref.startsWith("file:///"))
                        docHref = "file:/" + docHref.substring("file:///".length);
                    if (href.charAt(0) == "#" || href.startsWith(docHref + "#")) {
                        var target = CommonUtil_1.CommonUtil.getFileAnchor(href);
                        if (fragment_1.FragmentUtil.getById(ruleContext, target) != null)
                            passed = true;
                        else
                            targets[target] = true;
                    }
                }
                else if (anchors[idx].hasAttribute("name")) {
                    // Assume forward jumping targets
                    var name_1 = anchors[idx].getAttribute("name");
                    if (name_1.indexOf("#") != -1)
                        name_1 = CommonUtil_1.CommonUtil.getFileAnchor(name_1);
                    passed = name_1 in targets;
                }
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 4419:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iframe_interactive_tabbable = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
var DOMMapper_1 = __webpack_require__(5697);
exports.iframe_interactive_tabbable = {
    id: "iframe_interactive_tabbable",
    context: "dom:iframe",
    dependencies: [],
    help: {
        "en-US": {
            "group": "iframe_interactive_tabbable.html",
            "pass": "iframe_interactive_tabbable.html",
            "fail_invalid": "iframe_interactive_tabbable.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Iframe with interactive content should not be excluded from tab order using tabindex",
            "pass": "The iframe with interactive content is not excluded from the tab order using tabindex",
            "fail_invalid": "The <iframe> with interactive content is excluded from tab order using tabindex"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            num: ["2.1.1"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: ["akn7bn"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return;
        var mapper = new DOMMapper_1.DOMMapper();
        var bounds = mapper.getUnadjustedBounds(ruleContext);
        //in case the bounds not available
        if (!bounds)
            return null;
        // ignore if iframe is too small to be visible on screen
        if (Math.max(bounds['height'], bounds['width']) < 30 || Math.min(bounds['height'], bounds['width']) < 15)
            return null;
        // pass iframe element does not have a tabindex attribute value that is a negative number
        if (!ruleContext.hasAttribute("tabindex") || parseInt(ruleContext.getAttribute("tabindex")) >= 0)
            return (0, IRule_1.RulePass)("pass");
        // check iframe content
        var iframElem = ruleContext;
        if (!iframElem || !iframElem.contentDocument || !iframElem.contentDocument.documentElement)
            return null;
        var count = CommonUtil_1.CommonUtil.getTabbableChildren(ruleContext);
        if (count > 0)
            return (0, IRule_1.RuleFail)("fail_invalid");
        return null;
    }
};


/***/ }),

/***/ 2575:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.imagebutton_alt_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
exports.imagebutton_alt_exists = {
    id: "imagebutton_alt_exists",
    context: "dom:input",
    refactor: {
        "WCAG20_Input_ExplicitLabelImage": {
            "Pass_0": "Pass_0",
            "Pass_1": "Pass_1",
            "Pass_2": "Pass_2",
            "Fail": "Fail"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "imagebutton_alt_exists.html",
            "Pass_1": "imagebutton_alt_exists.html",
            "Pass_2": "imagebutton_alt_exists.html",
            "Fail": "imagebutton_alt_exists.html",
            "group": "imagebutton_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Image button provides alternative text using the 'alt' attribute",
            "Pass_1": "Image button provides alternative text using an ARIA label",
            "Pass_2": "Image button provides alternative text using the 'title' attribute",
            "Fail": "The <input> element of type \"image\" has no text alternative",
            "group": "The <input> element of type \"image\" should have a text alternative"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "59796f",
    run: function (context, options, contextHierarchies) {
        // See https://www.w3.org/WAI/WCAG22/Techniques/failures/F65
        var ruleContext = context["dom"].node;
        if (!ruleContext.hasAttribute("type") || ruleContext.getAttribute("type").toLowerCase() != "image") {
            return null;
        }
        if (CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "alt")) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else if (AriaUtil_1.AriaUtil.hasAriaLabel(ruleContext)) {
            return (0, IRule_1.RulePass)("Pass_1");
        }
        else if (ruleContext.hasAttribute("title") && ruleContext.getAttribute("title").length > 0) {
            return (0, IRule_1.RulePass)("Pass_2");
        }
        return (0, IRule_1.RuleFail)("Fail");
    }
};


/***/ }),

/***/ 8124:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.imagemap_alt_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.imagemap_alt_exists = {
    id: "imagemap_alt_exists",
    context: "dom:img[usemap], dom:img[ismap]",
    refactor: {
        "HAAC_Img_UsemapAlt": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "imagemap_alt_exists.html",
            "Fail_1": "imagemap_alt_exists.html",
            "group": "imagemap_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Image map or child <area> has no text alternative",
            "group": "An image map and each <area> element in an image map must have text alternative(s)"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "alt") ||
            (!ruleContext.hasAttribute("ismap") && !CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "usemap"));
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 3440:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_alt_background = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
exports.img_alt_background = {
    id: "img_alt_background",
    context: "dom:*",
    refactor: {
        "HAAC_BackgroundImg_HasTextOrTitle": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_alt_background.html",
            "Manual_1": "img_alt_background.html",
            "group": "img_alt_background.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Verify important background image information has a text alternative in system high contrast mode",
            "group": "Background images that convey important information must have a text alternative that describes the image"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var doc = ruleContext.ownerDocument;
        var style = doc.defaultView.getComputedStyle(ruleContext);
        if (style == null) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        var backgroundImgs = style.backgroundImage;
        var passed = true;
        if (backgroundImgs != null && backgroundImgs != "" && backgroundImgs != 'none' && backgroundImgs != 'inherit') {
            if (ruleContext.innerHTML != null && ruleContext.innerHTML.trim().length != 0) {
                passed = false;
            }
            else {
                var title = ruleContext.getAttribute('title');
                if (title != null && title.length != 0)
                    passed = false;
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 2193:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_alt_decorative = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
exports.img_alt_decorative = {
    id: "img_alt_decorative",
    context: "dom:img[alt]",
    refactor: {
        "WCAG20_Img_PresentationImgHasNonNullAlt": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_alt_decorative.html",
            "Fail_1": "img_alt_decorative.html",
            "group": "img_alt_decorative.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Image designated as decorative has non-null 'alt' attribute",
            "group": "Image designated as decorative must have 'alt=\"\""
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = true;
        if (AriaUtil_1.AriaUtil.hasRole(ruleContext, "presentation") || AriaUtil_1.AriaUtil.hasRole(ruleContext, "none")) {
            passed = ruleContext.getAttribute("alt").length == 0;
        }
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 309:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_alt_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
exports.img_alt_misuse = {
    id: "img_alt_misuse",
    context: "dom:img, dom:area, dom:input",
    refactor: {
        "RPT_Img_AltCommonMisuse": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_alt_misuse.html",
            "Potential_1": "img_alt_misuse.html",
            "group": "img_alt_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that the file name serves as a good inline replacement for the image",
            "group": "'alt' attribute value must be a good inline replacement for the image"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            badText: {
                value: ["short description"],
                type: "[string]"
            }
        };
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var passed = true;
        // Alt text check are elsewhere (See 41, 240, 455)
        if (ruleContext.hasAttribute("alt")) {
            var altText = ruleContext.getAttribute("alt").trim();
            if (altText.length > 0) {
                var badText = validateParams.badText.value;
                for (var i = 0; passed && i < badText.length; ++i) {
                    passed = altText.indexOf(badText[i]) == -1;
                }
                if (passed) {
                    var src = ruleContext.getAttribute((nodeName == "area") ? "href" : "src");
                    // Allow it to pass if there's no src - can't determine these.
                    if (src != null) {
                        // Fail if the alt matches the src exactly
                        // Also fail if the alt has a . in it and either the src is in the alt or the alt is in the src
                        passed = src.trim() != altText &&
                            (altText.indexOf(".") == -1 || (altText.indexOf(src) == -1 && src.indexOf(altText) == -1));
                    }
                }
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 6281:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_alt_null = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
exports.img_alt_null = {
    id: "img_alt_null",
    context: "dom:img[alt]",
    refactor: {
        "WCAG20_Img_TitleEmptyWhenAltNull": {
            "Pass_0": "pass",
            "Fail_1": "fail_decorative"
        }
    },
    help: {
        "en-US": {
            "pass": "img_alt_null.html",
            "fail_decorative": "img_alt_null.html",
            "potential_aria_override": "img_alt_null.html",
            "group": "img_alt_null.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Neither 'aria' nor 'title' attributes are used for the decorative image",
            "fail_decorative": "The image 'alt' attribute is empty, but the 'title' attribute is not empty",
            "potential_aria_override": "The image 'alt' attribute is empty, but the 'aria' label is not empty and overrides the 'alt' attribute",
            "group": "When the intent is to mark an image as decorative with an empty 'alt' attribute, the 'aria' or 'title' attributes should not be used"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE,
            reasonCodes: ["fail_decorative"]
        },
        {
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["ARIA"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE,
            reasonCodes: ["potential_aria_override"]
        }
    ],
    act: [{ "46ca7f": { "potential_aria_override": "fail" } }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        if (ruleContext.getAttribute("alt").trim().length > 0) {
            return null;
        }
        // We have a title, but alt is empty
        if (AriaUtil_1.AriaUtil.getAriaLabel(ruleContext).length > 0) {
            return (0, IRule_1.RulePotential)("potential_aria_override");
        }
        else if (CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "title")) {
            return (0, IRule_1.RuleFail)("fail_decorative");
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 7748:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_alt_redundant = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var DOMWalker_1 = __webpack_require__(7440);
var CommonUtil_1 = __webpack_require__(8137);
exports.img_alt_redundant = {
    id: "img_alt_redundant",
    context: "dom:img[alt]",
    refactor: {
        "WCAG20_Img_LinkTextNotRedundant": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_alt_redundant.html",
            "Fail_1": "img_alt_redundant.html",
            "Fail_2": "img_alt_redundant.html",
            "Fail_3": "img_alt_redundant.html",
            "group": "img_alt_redundant.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Link text is repeated in an image 'alt' value within the same link",
            "Fail_2": "Link text of previous link is repeated in image 'alt' value of a link",
            "Fail_3": "Image 'alt' value within a link is repeated in link text of the link after",
            "group": "The text alternative for an image within a link should not repeat the link text or adjacent link text"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1", "2.4.4"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var aNode = CommonUtil_1.CommonUtil.getAncestor(ruleContext, "a");
        //If not in an anchor, Out of Scope
        if (aNode == null)
            return null;
        var altText = ruleContext.getAttribute("alt").trim().toLowerCase();
        if (altText.length == 0) {
            // If alt text is empty, there's no text to be redundant - let a_text_purpose
            // trigger in that case.
            // So Out of Scope for this rule
            return null;
        }
        var innerText = aNode.innerText;
        var linkText = "";
        if (innerText != null) {
            linkText = innerText.trim().toLowerCase();
        }
        if (linkText.length > 0) {
            if (altText == linkText) {
                // Text in link
                return (0, IRule_1.RuleFail)("Fail_1");
            }
        }
        else {
            var passed = true;
            //alt is non-zero, but no link text - ensure adjacent link text isn't redundant
            //let walk = new NodeWalker(aNode);
            var walk = new DOMWalker_1.DOMWalker(aNode);
            while (passed && walk.prevNode()) {
                // Get the node and nodeName
                var node = walk.node;
                var nodeName = node.nodeName.toLowerCase();
                if ((nodeName == "#text" && node.nodeValue.length > 0) ||
                    (nodeName == "img" && CommonUtil_1.CommonUtil.attributeNonEmpty(node, "alt"))) {
                    break;
                }
                // Comply with the Check Hidden Content Setting if the a element should be checked or not
                else if (nodeName === "a" && !CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(node)) {
                    // Text before image link
                    passed = (node.innerText || node.textContent || "").trim().toLowerCase() != altText;
                }
            }
            if (!passed) {
                return (0, IRule_1.RuleFail)("Fail_2");
            }
            //walk = new NodeWalker(aNode, true);
            walk = new DOMWalker_1.DOMWalker(aNode, true);
            while (passed && walk.nextNode()) {
                // Get the node and nodeName
                var node = walk.node;
                var nodeName = node.nodeName.toLowerCase();
                if ((nodeName == "#text" && node.nodeValue.length > 0) ||
                    (nodeName == "img" && CommonUtil_1.CommonUtil.attributeNonEmpty(node, "alt"))) {
                    break;
                }
                // Comply with the Check Hidden Content Setting if the a element should be checked or not
                else if (nodeName == "a" && !CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(node)) {
                    passed = node.innerText.trim().toLowerCase() != altText;
                }
            }
            if (!passed) {
                // Text after image link
                return (0, IRule_1.RuleFail)("Fail_3");
            }
            else {
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
    }
};


/***/ }),

/***/ 8856:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_alt_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
var AccNameUtil_1 = __webpack_require__(1421);
exports.img_alt_valid = {
    id: "img_alt_valid",
    context: "dom:img",
    refactor: {
        "WCAG20_Img_HasAlt": {
            "pass": "pass",
            "fail_blank_alt": "fail_blank_alt",
            "fail_no_alt": "fail_no_alt",
            "fail_blank_title": "fail_blank_title"
        }
    },
    help: {
        "en-US": {
            "pass": "img_alt_valid.html",
            "fail_blank_alt": "img_alt_valid.html",
            "fail_no_alt": "img_alt_valid.html",
            "fail_blank_title": "img_alt_valid.html",
            "group": "img_alt_valid.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The image has an accessible name or is correctly marked as decorative or redundant",
            "fail_blank_alt": "Image 'alt' attribute value consists only of blank space(s)",
            "fail_no_alt": "The image has neither an accessible name nor is marked as decorative or redundant",
            "fail_blank_title": "The image does not have an 'alt' attribute or ARIA label, and the 'title' attribute value consists only of blank space(s)",
            "group": "Images must have accessible names unless they are decorative or redundant"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "23a2a8",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // If not visible to the screen reader, or can be ignored
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || AccNameUtil_1.AccNameUtil.isAccessibleNameIgnorable(ruleContext))
            return null;
        if (AriaUtil_1.AriaUtil.getAriaLabel(ruleContext).trim().length !== 0) {
            // the img has non-empty aria label
            return (0, IRule_1.RulePass)("pass");
        }
        var alt = ruleContext.hasAttribute("alt") ? ruleContext.getAttribute("alt") : null;
        // check title attribute
        if (alt === null) {
            // the img has no alt or attribute, examine the title attribute
            var title = ruleContext.hasAttribute("title") ? ruleContext.getAttribute("title") : null;
            if (title === null || title.length === 0) {
                // no title or title is empty, examine alt further
                if (alt === null) {
                    var role = AriaUtil_1.AriaUtil.getResolvedRole(ruleContext, false);
                    if (role === 'presentation' || role === 'none')
                        return (0, IRule_1.RulePass)("pass");
                    return (0, IRule_1.RuleFail)("fail_no_alt");
                }
                if (alt.length === 0)
                    return (0, IRule_1.RulePass)("pass");
            }
            else {
                if (title.trim().length === 0) {
                    // title contains blank space only (title="  ")
                    return (0, IRule_1.RuleFail)("fail_blank_title");
                }
                // title contains some text (title="some text")
                return (0, IRule_1.RulePass)("pass");
            }
        }
        else {
            if (alt.length === 0 || alt.trim().length > 0) {
                // the img has empty alt (alt="") or non-empty alt (alt="some text")
                return (0, IRule_1.RulePass)("pass");
            }
            else {
                // alt contains blank space only (alt=" ")
                return (0, IRule_1.RuleFail)("fail_blank_alt");
            }
        }
    }
};


/***/ }),

/***/ 7393:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_ismap_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.img_ismap_misuse = {
    id: "img_ismap_misuse",
    context: "dom:img[ismap]",
    refactor: {
        "RPT_Img_UsemapValid": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_ismap_misuse.html",
            "Potential_1": "img_ismap_misuse.html",
            "group": "img_ismap_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Server-side image map hot-spots do not have duplicate text links",
            "group": "Server-side image map hot-spots must have duplicate text links"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = false;
        if (ruleContext.hasAttribute("usemap")) {
            var usemap = ruleContext.getAttribute("usemap");
            usemap = usemap.trim().toLowerCase();
            var idx = usemap.indexOf("#");
            if (idx != -1)
                usemap = usemap.substr(idx + 1);
            if (usemap.length > 0) {
                var maps = CommonUtil_1.CommonUtil.getDocElementsByTag(ruleContext, "map");
                for (var i = 0; !passed && i < maps.length; ++i) {
                    passed = maps[i].hasAttribute("name") &&
                        maps[i].getAttribute("name").toLowerCase() == usemap;
                }
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9410:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.img_longdesc_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.img_longdesc_misuse = {
    id: "img_longdesc_misuse",
    context: "dom:img[longdesc]",
    refactor: {
        "RPT_Img_LongDescription2": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "img_longdesc_misuse.html",
            "Potential_1": "img_longdesc_misuse.html",
            "group": "img_longdesc_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that the file designated by the 'longdesc' attribute contains valid HTML content (file extension not recognized)",
            "group": " The 'longdesc' attribute must reference HTML content"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var longdesc = ruleContext.getAttribute("longdesc");
        // if (longdesc is bad URL) passed = false;
        var ext = CommonUtil_1.CommonUtil.getFileExt(longdesc);
        var passed = ext.length != 0 && CommonUtil_1.CommonUtil.isHtmlExt(ext)
            || longdesc.startsWith("#")
            || longdesc.startsWith("http://")
            || longdesc.startsWith("https://")
            || longdesc.startsWith("data:");
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 8081:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// This file is automatically generated by "npm run prebuild". Do not edit
__exportStar(__webpack_require__(8980), exports);
__exportStar(__webpack_require__(3961), exports);
__exportStar(__webpack_require__(1445), exports);
__exportStar(__webpack_require__(876), exports);
__exportStar(__webpack_require__(2768), exports);
__exportStar(__webpack_require__(2533), exports);
__exportStar(__webpack_require__(7178), exports);
__exportStar(__webpack_require__(9745), exports);
__exportStar(__webpack_require__(8019), exports);
__exportStar(__webpack_require__(6505), exports);
__exportStar(__webpack_require__(8910), exports);
__exportStar(__webpack_require__(3492), exports);
__exportStar(__webpack_require__(5316), exports);
__exportStar(__webpack_require__(8412), exports);
__exportStar(__webpack_require__(172), exports);
__exportStar(__webpack_require__(9844), exports);
__exportStar(__webpack_require__(9695), exports);
__exportStar(__webpack_require__(1699), exports);
__exportStar(__webpack_require__(4974), exports);
__exportStar(__webpack_require__(3054), exports);
__exportStar(__webpack_require__(4649), exports);
__exportStar(__webpack_require__(4193), exports);
__exportStar(__webpack_require__(3188), exports);
__exportStar(__webpack_require__(4176), exports);
__exportStar(__webpack_require__(7964), exports);
__exportStar(__webpack_require__(2554), exports);
__exportStar(__webpack_require__(1229), exports);
__exportStar(__webpack_require__(8523), exports);
__exportStar(__webpack_require__(3781), exports);
__exportStar(__webpack_require__(8509), exports);
__exportStar(__webpack_require__(3234), exports);
__exportStar(__webpack_require__(5217), exports);
__exportStar(__webpack_require__(4050), exports);
__exportStar(__webpack_require__(4275), exports);
__exportStar(__webpack_require__(1465), exports);
__exportStar(__webpack_require__(405), exports);
__exportStar(__webpack_require__(9136), exports);
__exportStar(__webpack_require__(5117), exports);
__exportStar(__webpack_require__(9062), exports);
__exportStar(__webpack_require__(5746), exports);
__exportStar(__webpack_require__(8685), exports);
__exportStar(__webpack_require__(2678), exports);
__exportStar(__webpack_require__(971), exports);
__exportStar(__webpack_require__(3709), exports);
__exportStar(__webpack_require__(6486), exports);
__exportStar(__webpack_require__(4151), exports);
__exportStar(__webpack_require__(8545), exports);
__exportStar(__webpack_require__(8538), exports);
__exportStar(__webpack_require__(1908), exports);
__exportStar(__webpack_require__(6360), exports);
__exportStar(__webpack_require__(5386), exports);
__exportStar(__webpack_require__(8752), exports);
__exportStar(__webpack_require__(4392), exports);
__exportStar(__webpack_require__(932), exports);
__exportStar(__webpack_require__(6255), exports);
__exportStar(__webpack_require__(5743), exports);
__exportStar(__webpack_require__(2671), exports);
__exportStar(__webpack_require__(3974), exports);
__exportStar(__webpack_require__(9881), exports);
__exportStar(__webpack_require__(1226), exports);
__exportStar(__webpack_require__(7369), exports);
__exportStar(__webpack_require__(2633), exports);
__exportStar(__webpack_require__(2429), exports);
__exportStar(__webpack_require__(7874), exports);
__exportStar(__webpack_require__(3334), exports);
__exportStar(__webpack_require__(4298), exports);
__exportStar(__webpack_require__(4435), exports);
__exportStar(__webpack_require__(1685), exports);
__exportStar(__webpack_require__(6313), exports);
__exportStar(__webpack_require__(9109), exports);
__exportStar(__webpack_require__(9918), exports);
__exportStar(__webpack_require__(8105), exports);
__exportStar(__webpack_require__(8687), exports);
__exportStar(__webpack_require__(2150), exports);
__exportStar(__webpack_require__(4557), exports);
__exportStar(__webpack_require__(4721), exports);
__exportStar(__webpack_require__(2814), exports);
__exportStar(__webpack_require__(9188), exports);
__exportStar(__webpack_require__(7601), exports);
__exportStar(__webpack_require__(4497), exports);
__exportStar(__webpack_require__(152), exports);
__exportStar(__webpack_require__(935), exports);
__exportStar(__webpack_require__(9719), exports);
__exportStar(__webpack_require__(5625), exports);
__exportStar(__webpack_require__(9115), exports);
__exportStar(__webpack_require__(6072), exports);
__exportStar(__webpack_require__(6923), exports);
__exportStar(__webpack_require__(9015), exports);
__exportStar(__webpack_require__(3611), exports);
__exportStar(__webpack_require__(4846), exports);
__exportStar(__webpack_require__(3277), exports);
__exportStar(__webpack_require__(4525), exports);
__exportStar(__webpack_require__(7114), exports);
__exportStar(__webpack_require__(3751), exports);
__exportStar(__webpack_require__(7084), exports);
__exportStar(__webpack_require__(3981), exports);
__exportStar(__webpack_require__(9788), exports);
__exportStar(__webpack_require__(4419), exports);
__exportStar(__webpack_require__(2575), exports);
__exportStar(__webpack_require__(8124), exports);
__exportStar(__webpack_require__(3440), exports);
__exportStar(__webpack_require__(2193), exports);
__exportStar(__webpack_require__(309), exports);
__exportStar(__webpack_require__(6281), exports);
__exportStar(__webpack_require__(7748), exports);
__exportStar(__webpack_require__(8856), exports);
__exportStar(__webpack_require__(7393), exports);
__exportStar(__webpack_require__(9410), exports);
__exportStar(__webpack_require__(8589), exports);
__exportStar(__webpack_require__(3366), exports);
__exportStar(__webpack_require__(8929), exports);
__exportStar(__webpack_require__(5403), exports);
__exportStar(__webpack_require__(5937), exports);
__exportStar(__webpack_require__(4452), exports);
__exportStar(__webpack_require__(7209), exports);
__exportStar(__webpack_require__(8262), exports);
__exportStar(__webpack_require__(7017), exports);
__exportStar(__webpack_require__(9980), exports);
__exportStar(__webpack_require__(7733), exports);
__exportStar(__webpack_require__(1256), exports);
__exportStar(__webpack_require__(9532), exports);
__exportStar(__webpack_require__(6698), exports);
__exportStar(__webpack_require__(9632), exports);
__exportStar(__webpack_require__(3692), exports);
__exportStar(__webpack_require__(5430), exports);
__exportStar(__webpack_require__(1018), exports);
__exportStar(__webpack_require__(3433), exports);
__exportStar(__webpack_require__(8012), exports);
__exportStar(__webpack_require__(3881), exports);
__exportStar(__webpack_require__(3106), exports);
__exportStar(__webpack_require__(1276), exports);
__exportStar(__webpack_require__(5424), exports);
__exportStar(__webpack_require__(4248), exports);
__exportStar(__webpack_require__(9526), exports);
__exportStar(__webpack_require__(9379), exports);
__exportStar(__webpack_require__(5495), exports);
__exportStar(__webpack_require__(7753), exports);
__exportStar(__webpack_require__(1252), exports);
__exportStar(__webpack_require__(3576), exports);
__exportStar(__webpack_require__(3617), exports);
__exportStar(__webpack_require__(6110), exports);
__exportStar(__webpack_require__(5681), exports);
__exportStar(__webpack_require__(1922), exports);
__exportStar(__webpack_require__(7906), exports);
__exportStar(__webpack_require__(5451), exports);
__exportStar(__webpack_require__(6349), exports);
__exportStar(__webpack_require__(5393), exports);
__exportStar(__webpack_require__(9887), exports);
__exportStar(__webpack_require__(5102), exports);
__exportStar(__webpack_require__(9977), exports);
__exportStar(__webpack_require__(8454), exports);
__exportStar(__webpack_require__(25), exports);
__exportStar(__webpack_require__(2884), exports);
__exportStar(__webpack_require__(5390), exports);
__exportStar(__webpack_require__(7196), exports);
__exportStar(__webpack_require__(9965), exports);
__exportStar(__webpack_require__(4468), exports);
__exportStar(__webpack_require__(4451), exports);
__exportStar(__webpack_require__(6087), exports);
__exportStar(__webpack_require__(5864), exports);
__exportStar(__webpack_require__(4066), exports);
__exportStar(__webpack_require__(2841), exports);
__exportStar(__webpack_require__(272), exports);
__exportStar(__webpack_require__(1348), exports);
__exportStar(__webpack_require__(6215), exports);
__exportStar(__webpack_require__(5275), exports);
__exportStar(__webpack_require__(7900), exports);
__exportStar(__webpack_require__(5027), exports);
__exportStar(__webpack_require__(3496), exports);
__exportStar(__webpack_require__(1131), exports);
__exportStar(__webpack_require__(8681), exports);
__exportStar(__webpack_require__(4577), exports);
__exportStar(__webpack_require__(8051), exports);


/***/ }),

/***/ 8589:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_autocomplete_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.input_autocomplete_valid = {
    id: "input_autocomplete_valid",
    context: "dom:input[autocomplete], dom:textarea[autocomplete], dom:select[autocomplete]",
    refactor: {
        "WCAG21_Input_Autocomplete": {
            "Pass_0": "pass",
            "Fail_1": "fail_inappropriate",
            "Fail_2": "fail_invalid",
            "Fail_attribute_incorrect": "fail_incorrect"
        }
    },
    help: {
        "en-US": {
            "group": "input_autocomplete_valid.html",
            "pass": "input_autocomplete_valid.html",
            "fail_inappropriate": "input_autocomplete_valid.html",
            "fail_invalid": "input_autocomplete_valid.html",
            "fail_incorrect": "input_autocomplete_valid.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The 'autocomplete' attribute's token(s) must be appropriate for the input form field",
            "pass": "The 'autocomplete' attribute's token(s) is appropriate for the input form field",
            "fail_inappropriate": "The 'autocomplete' attribute's token(s) are not appropriate for the input form field",
            "fail_invalid": "The 'autocomplete' attribute's token(s) are not appropriate for an input form field of any type",
            "fail_incorrect": "The 'autocomplete' attribute has an incorrect value"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.5"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [{
            "73f2c2": {
                "pass": "pass",
                "fail_inappropriate": "fail",
                "fail_invalid": "pass",
                "fail_incorrect": "fail"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext)) {
            return null;
        }
        var autocompleteAttr = ruleContext.getAttribute("autocomplete").trim().toLowerCase();
        var tokens = autocompleteAttr.split(/\s+/);
        if (tokens.length === 0 || autocompleteAttr.length === 0) {
            return null;
        }
        var cache = {
            "tokensOnOff": ["on", "off"],
            "tokenOptionalSection": "section-",
            "tokensOptionalPurpose": ["shipping", "billing"],
            "tokensMandatoryGroup1_password": ["new-password", "current-password", "one-time-code"],
            "tokensMandatoryGroup1_multiline": ["street-address"],
            "tokensMandatoryGroup1_month": ["cc-exp"],
            "tokensMandatoryGroup1_numeric": ["cc-exp-month",
                "cc-exp-year",
                "transaction-amount",
                "bday-day",
                "bday-month",
                "bday-year"],
            "tokensMandatoryGroup1_date": ["bday"],
            "tokensMandatoryGroup1_url": ["url", "photo"],
            "tokensMandatoryGroup1_text": ["name",
                "honorific-prefix",
                "given-name",
                "additional-name",
                "family-name",
                "honorific-suffix",
                "nickname",
                "username",
                "organization-title",
                "organization",
                "address-line1",
                "address-line2",
                "address-line3",
                "address-level4",
                "address-level3",
                "address-level2",
                "address-level1",
                "country",
                "country-name",
                "postal-code",
                "cc-name",
                "cc-given-name",
                "cc-additional-name",
                "cc-family-name",
                "cc-number",
                "cc-csc",
                "cc-type",
                "transaction-currency",
                "language",
                "sex"],
            "tokensMandatoryGroup1_all": ["name",
                "honorific-prefix",
                "given-name",
                "additional-name",
                "family-name",
                "honorific-suffix",
                "nickname",
                "username",
                "new-password",
                "current-password",
                "organization-title",
                "organization",
                "street-address",
                "address-line1",
                "address-line2",
                "address-line3",
                "address-level4",
                "address-level3",
                "address-level2",
                "address-level1",
                "country",
                "country-name",
                "postal-code",
                "cc-name",
                "cc-given-name",
                "cc-additional-name",
                "cc-family-name",
                "cc-number",
                "cc-exp",
                "cc-exp-month",
                "cc-exp-year",
                "cc-csc",
                "cc-type",
                "transaction-currency",
                "transaction-amount",
                "language",
                "bday",
                "bday-day",
                "bday-month",
                "bday-year",
                "sex",
                "url",
                "photo"],
            "tokensOptionalGroup2": ["home",
                "work",
                "mobile",
                "fax",
                "pager"],
            "tokensMandatoryGroup2_tel": ["tel"],
            "tokensMandatoryGroup2_email": ["email"],
            "tokensMandatoryGroup2_url": ["impp"],
            "tokensMandatoryGroup2_text": ["tel-country-code",
                "tel-national",
                "tel-area-code",
                "tel-local",
                "tel-local-prefix",
                "tel-local-suffix",
                "tel-extension"],
            "tokensMandatoryGroup2_all": ["tel",
                "tel-country-code",
                "tel-national",
                "tel-area-code",
                "tel-local",
                "tel-local-prefix",
                "tel-local-suffix",
                "tel-extension",
                "email",
                "impp"],
            "tokensOptionGroup1_webauthn": ["webauthn"]
        };
        var valid_values = [];
        for (var key in cache)
            valid_values = valid_values.concat(cache[key]);
        var foundMandatoryToken = false;
        var foundRecognizedToken = true;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (!tokens.every(function (r) { return valid_values.includes(r) || r.startsWith(cache['tokenOptionalSection']); }))
            return (0, IRule_1.RuleFail)("fail_incorrect");
        var type = ruleContext.hasAttribute("type") ? ruleContext.getAttribute("type").trim().toLowerCase() : "text";
        var tokensMandatoryGroup1 = [];
        var tokensMandatoryGroup2 = [];
        var tokensOptionalGroup = [];
        if (nodeName === "textarea" || nodeName === "select") {
            // accept all tokens
            tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_all;
            tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_all;
            if (nodeName === "textarea")
                tokensOptionalGroup = cache.tokensOptionGroup1_webauthn;
        }
        else if (nodeName === "input") {
            tokensOptionalGroup = cache.tokensOptionGroup1_webauthn;
            // handle the various 'input' types
            switch (type) {
                // Disable check for input type=hidden for now based on scrum discussion
                /*
                case "hidden":
                    // accept all tokens
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_all;
                    tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_all;
                    break;
                */
                case "text":
                case "search":
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_text.concat(cache.tokensMandatoryGroup1_password, cache.tokensMandatoryGroup1_url, cache.tokensMandatoryGroup1_numeric, cache.tokensMandatoryGroup1_month, cache.tokensMandatoryGroup1_date);
                    tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_all;
                    break;
                case "password":
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_password;
                    break;
                case "url":
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_url;
                    tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_url;
                    break;
                case "email":
                    tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_email;
                    break;
                case "tel":
                    tokensMandatoryGroup2 = cache.tokensMandatoryGroup2_tel;
                    break;
                case "number":
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_numeric;
                    break;
                case "month":
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_month;
                    break;
                case "date":
                    tokensMandatoryGroup1 = cache.tokensMandatoryGroup1_date;
                    break;
                default:
                    // unsupported type for this rule.
                    return null;
            }
        }
        else {
            // should never get here.
            return null;
        }
        // Disable check for input type=hidden for now based on scrum discussion
        var autofillMantle = /* (nodeName==="input" && type==="hidden") ? "anchor" : */ "expectation";
        if (autofillMantle === "expectation") {
            // check on|off for expectation mantle.
            if (tokens.includes("on") || tokens.includes("off")) {
                // on|off should be the only token
                if (tokens.length === 1) {
                    return (0, IRule_1.RulePass)("pass");
                }
                else {
                    return (0, IRule_1.RuleFail)("fail_invalid");
                }
            }
        }
        // check detail autofill tokens
        var currIndex = 0;
        var currRecognizedIndex = 0;
        // check optional 'section-*' tokens
        if (tokens[currIndex].startsWith(cache.tokenOptionalSection) &&
            tokens[currIndex].length > 8) {
            currIndex++; // consume token
            currRecognizedIndex++;
        }
        // check optional 'shipping|billing' tokens
        if (tokens.length > currIndex &&
            cache.tokensOptionalPurpose.includes(tokens[currIndex])) {
            currIndex++; // consume  token
            currRecognizedIndex++;
        }
        // check either mandatory group 1 or 2 tokens
        if (tokens.length > currIndex) {
            // check mandatory group 1
            if (tokensMandatoryGroup1.includes(tokens[currIndex])) {
                foundMandatoryToken = true;
                currIndex++;
            }
            else {
                // check optional tokens for group 2
                if (cache.tokensOptionalGroup2.includes(tokens[currIndex])) {
                    currIndex++;
                }
                // check mandatory group 2
                if (tokensMandatoryGroup2.includes(tokens[currIndex])) {
                    foundMandatoryToken = true;
                    currIndex++;
                }
            }
        }
        // check either mandatory group 1 or 2 tokens
        if (tokens.length > currRecognizedIndex) {
            // check mandatory group 1
            if (cache.tokensMandatoryGroup1_all.includes(tokens[currRecognizedIndex])) {
                foundRecognizedToken = true;
                currRecognizedIndex++;
            }
            else {
                // check optional tokens for group 2
                if (cache.tokensOptionalGroup2.includes(tokens[currRecognizedIndex])) {
                    currRecognizedIndex++;
                }
                // check mandatory group 2
                if (cache.tokensMandatoryGroup2_all.includes(tokens[currRecognizedIndex])) {
                    foundRecognizedToken = true;
                    currRecognizedIndex++;
                }
            }
        }
        if (tokens.length > currIndex + currRecognizedIndex) {
            // check optional tokens webauthn
            if (tokensOptionalGroup.includes(tokens[currIndex + currRecognizedIndex])) {
                currIndex++;
            }
        }
        if ((tokens.length > currIndex && tokensOptionalGroup.includes(tokens[currIndex]))
            || (tokens.length > currRecognizedIndex && tokensOptionalGroup.includes(tokens[currRecognizedIndex]))) {
            currIndex++;
            currRecognizedIndex++;
        }
        // Only pass if we have seen either of the mandatory groups and all tokens have been consumed
        if (foundMandatoryToken && tokens.length === currIndex) {
            return (0, IRule_1.RulePass)("pass");
        }
        else if (foundRecognizedToken && tokens.length === currRecognizedIndex) {
            return (0, IRule_1.RuleFail)("fail_incorrect");
        }
        else {
            return (0, IRule_1.RuleFail)("fail_inappropriate");
        }
    }
};


/***/ }),

/***/ 3366:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_checkboxes_grouped = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var DOMWalker_1 = __webpack_require__(7440);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8656);
var TableUtil_1 = __webpack_require__(5755);
exports.input_checkboxes_grouped = {
    id: "input_checkboxes_grouped",
    context: "dom:input[type=radio], dom:input[type=checkbox]",
    refactor: {
        "WCAG20_Input_RadioChkInFieldSet": {
            "Pass_LoneNogroup": "pass_lonenogroup",
            "Pass_Grouped": "pass_grouped",
            "Pass_RadioNoName": "pass_radioNoName",
            "Fail_ControlNameMismatch": "fail_controlnamemismatch",
            "Fail_NotGroupedOtherGrouped": "fail_notgroupedothergrouped",
            "Fail_NotGroupedOtherNotGrouped": "fail_notgroupedothernotgrouped",
            "Fail_NotSameGroup": "fail_notsamegroup",
            "Potential_LoneCheckbox": "potential_lonecheckbox",
            "Potential_UnnamedCheckbox": "potential_unnamedcheckbox"
        }
    },
    help: {
        "en-US": {
            "group": "input_checkboxes_grouped.html",
            "pass_lonenogroup": "input_checkboxes_grouped.html",
            "pass_grouped": "input_checkboxes_grouped.html",
            "pass_radiononame": "input_checkboxes_grouped.html",
            "fail_controlnamemismatch": "input_checkboxes_grouped.html",
            "fail_notgroupedothergrouped": "input_checkboxes_grouped.html",
            "fail_notgroupedothernotgrouped": "input_checkboxes_grouped.html",
            "fail_notsamegroup": "input_checkboxes_grouped.html",
            "potential_lonecheckbox": "input_checkboxes_grouped.html",
            "potential_unnamedcheckbox": "input_checkboxes_grouped.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Related sets of radio buttons or checkboxes should be programmatically grouped",
            "pass_lonenogroup": "{0} grouping not required for a control of this type",
            "pass_grouped": "{0} input is grouped with other related controls with the same name",
            "pass_radiononame": "Radio input is not grouped, but passes because it has no name to group with other radio inputs",
            "fail_controlnamemismatch": "{0} input found that has the same name, \"{2}\" as a {1} input",
            "fail_notgroupedothergrouped": "{0} input is not in the group with another {0} with the name \"{1}\"",
            "fail_notgroupedothernotgrouped": "{0} input and others with the name \"{1}\" are not grouped together",
            "fail_notsamegroup": "{0} input is in a different group than another {0} with the name \"{1}\"",
            "potential_lonecheckbox": "Verify that this ungrouped checkbox input is not related to other checkboxes",
            "potential_unnamedcheckbox": "Verify that this un-named, ungrouped checkbox input is not related to other checkboxes"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var getGroup = function (e) {
            var retVal = CommonUtil_1.CommonUtil.getAncestor(e, "fieldset")
                || AriaUtil_1.AriaUtil.getAncestorWithRole(e, "radiogroup")
                || AriaUtil_1.AriaUtil.getAncestorWithRole(e, "group")
                || AriaUtil_1.AriaUtil.getAncestorWithRole(e, "grid")
                || AriaUtil_1.AriaUtil.getAncestorWithRole(e, "table");
            if (!retVal) {
                retVal = CommonUtil_1.CommonUtil.getAncestor(e, "table");
                if (retVal && !TableUtil_1.TableUtil.isDataTable(retVal)) {
                    retVal = null;
                }
            }
            return retVal;
        };
        // Only radio buttons and checkboxes are in scope
        var ctxType = ruleContext.getAttribute("type").toLowerCase();
        // Determine which form we're in (if any) to determine our scope
        var ctxForm = AriaUtil_1.AriaUtil.getAncestorWithRole(ruleContext, "form")
            || CommonUtil_1.CommonUtil.getAncestor(ruleContext, "html")
            || ruleContext.ownerDocument.documentElement;
        // Get data about all of the visible checkboxes and radios in the scope of this form
        // and cache it for all of the other inputs in this scope
        var formCache = CacheUtil_1.CacheUtil.getCache(ctxForm, "input_checkboxes_grouped", null);
        if (!formCache) {
            formCache = {
                checkboxByName: {},
                radiosByName: {},
                nameToGroup: {},
                numCheckboxes: 0,
                numRadios: 0
            };
            // Get all of the checkboxes in the form or body (but not nested in something else and not hidden)
            // And get a mapping of these checkboxes to
            var cWalker = new DOMWalker_1.DOMWalker(ctxForm, false, ctxForm, true);
            var checkboxQ = [];
            var radiosQ = [];
            while (cWalker.nextNode()) {
                if (!cWalker.bEndTag
                    && cWalker.node.nodeType === 1
                    && cWalker.node.nodeName.toLowerCase() === "input"
                    && VisUtil_1.VisUtil.isNodeVisible(cWalker.node)) {
                    var type = cWalker.node.getAttribute("type");
                    if (type === "checkbox") {
                        checkboxQ.push(cWalker.node);
                    }
                    else if (type === "radio") {
                        radiosQ.push(cWalker.node);
                    }
                }
            }
            // let checkboxQ = ctxForm.querySelectorAll("input[type=checkbox]");
            for (var idx = 0; idx < checkboxQ.length; ++idx) {
                var cb = checkboxQ[idx];
                if ((AriaUtil_1.AriaUtil.getAncestorWithRole(cb, "form")
                    || CommonUtil_1.CommonUtil.getAncestor(ruleContext, "html")
                    || ruleContext.ownerDocument.documentElement) === ctxForm
                    && !CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(cb)) {
                    var name_1 = cb.getAttribute("name") || "";
                    (formCache.checkboxByName[name_1] = formCache.checkboxByName[name_1] || []).push(cb);
                    formCache.nameToGroup[name_1] = formCache.nameToGroup[name_1] || getGroup(cb);
                    ++formCache.numCheckboxes;
                }
            }
            // Get all of the radios in the form or body (but not nested in something else and not hidden)
            // let radiosQ = ctxForm.querySelectorAll("input[type=radio]");
            for (var idx = 0; idx < radiosQ.length; ++idx) {
                var r = radiosQ[idx];
                var radCtx = (AriaUtil_1.AriaUtil.getAncestorWithRole(r, "form")
                    || CommonUtil_1.CommonUtil.getAncestor(ruleContext, "html")
                    || ruleContext.ownerDocument.documentElement);
                if (radCtx === ctxForm
                    && !CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(r)) {
                    var name_2 = r.getAttribute("name") || "";
                    (formCache.radiosByName[name_2] = formCache.radiosByName[name_2] || []).push(r);
                    formCache.nameToGroup[name_2] = formCache.nameToGroup[name_2] || getGroup(r);
                    ++formCache.numRadios;
                }
            }
            CacheUtil_1.CacheUtil.setCache(ctxForm, "input_checkboxes_grouped", formCache);
        }
        ///////////// Calculated everything, now check the various cases
        var ctxName = ruleContext.getAttribute("name");
        var ctxGroup = getGroup(ruleContext);
        ctxType = ctxType === "radio" ? "Radio" : "Checkbox";
        if (!ctxName || ctxName === "") {
            // First process cases where the control is not named
            if (ctxType === "Radio") {
                // Radios without names don't act like groups, so don't enforce grouping
                if (ctxGroup === null) {
                    return (0, IRule_1.RulePass)("pass_radiononame", [ctxType]);
                }
                else {
                    return (0, IRule_1.RulePass)("pass_grouped", [ctxType]);
                }
            }
            else {
                // Must be an unnamed checkbox
                if (ctxGroup === null) {
                    if ((formCache.checkboxByName[""] || []).length > 1) {
                        return (0, IRule_1.RulePotential)("potential_unnamedcheckbox", [ctxType]);
                    }
                    else {
                        return (0, IRule_1.RulePass)("pass_lonenogroup", [ctxType]);
                    }
                }
                else {
                    return (0, IRule_1.RulePass)("pass_grouped", [ctxType]);
                }
            }
        }
        else {
            // Considering a named checkbox
            var numRadiosWithName = (formCache.radiosByName[ctxName] || []).length;
            var numCheckboxesWithName = (formCache.checkboxByName[ctxName] || []).length;
            // Capitalize the input type for messages
            if (numRadiosWithName > 0 && numCheckboxesWithName > 0) {
                // We have a naming mismatch between different controls
                return (0, IRule_1.RuleFail)("fail_controlnamemismatch", [ctxType, ctxType === "checkbox" ? "radio" : "checkbox", ctxName]);
            }
            else if (ctxType === "Radio" && (formCache.numRadios === 1 || numRadiosWithName === 1)
                || ctxType === "Checkbox" && formCache.numCheckboxes === 1) {
                // This is a lone control (either only control of this type on the page, or a radio button without any others by that name)
                // We pass this control in all cases
                if (ctxGroup === null) {
                    return (0, IRule_1.RulePass)("pass_lonenogroup", [ctxType]);
                }
                else {
                    return (0, IRule_1.RulePass)("pass_grouped", [ctxType]);
                }
            }
            else if (ctxType === "Checkbox" && formCache.numCheckboxes > 1 && numCheckboxesWithName === 1) {
                // We have only one checkbox with this name, but there are other checkboxes in the form.
                // If we're not grouped, ask them to examine it
                if (ctxGroup === null) {
                    return (0, IRule_1.RulePotential)("potential_lonecheckbox", [ctxType]);
                }
                else {
                    return (0, IRule_1.RulePass)("pass_grouped", [ctxType]);
                }
            }
            else {
                // We share a name with another similar control. Are we grouped together?
                if (ctxGroup === null) {
                    if (formCache.nameToGroup[ctxName] !== null) {
                        // We're not grouped, but some control with the same name is in a group
                        return (0, IRule_1.RuleFail)("fail_notgroupedothergrouped", [ctxType, ctxName]);
                    }
                    else {
                        // None of us are grouped
                        return (0, IRule_1.RuleFail)("fail_notgroupedothernotgrouped", [ctxType, ctxName]);
                    }
                }
                else if (formCache.nameToGroup[ctxName] !== ctxGroup) {
                    // We're not in the main group with the others
                    return (0, IRule_1.RuleFail)("fail_notsamegroup", [ctxType, ctxName]);
                }
                else {
                    // We're all grouped up!
                    return (0, IRule_1.RulePass)("pass_grouped", [ctxType]);
                }
            }
        }
    }
};


/***/ }),

/***/ 8929:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_fields_grouped = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.input_fields_grouped = {
    id: "input_fields_grouped",
    context: "dom:input, dom:textarea, dom:select",
    refactor: {
        "WCAG20_Input_InFieldSet": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "input_fields_grouped.html",
            "Potential_1": "input_fields_grouped.html",
            "group": "input_fields_grouped.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Use the <fieldset> element to group logically related input elements",
            "group": "Groups of logically related input elements should be contained within a <fieldset> element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Don't trigger for other input types or if we're in a fieldset
        if (ruleContext.nodeName.toLowerCase() == "input" && ruleContext.hasAttribute("type")) {
            var type = ruleContext.getAttribute("type").toLowerCase();
            if (type != "text" && type != "file" && type != "password")
                return (0, IRule_1.RulePass)("Pass_0");
        }
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, "fieldset") != null)
            return (0, IRule_1.RulePass)("Pass_0");
        // No fieldset - see if this input is all by itself - no need to group single inputs
        var parent = CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["form", "body"]);
        var checkTypes = ["input", "textarea", "select"];
        var passed = true;
        for (var i = 0; passed && i < checkTypes.length; ++i) {
            var controls = parent.getElementsByTagName(checkTypes[i]);
            for (var j = 0; passed && j < controls.length; ++j) {
                // Check if the node should be skipped or not based on the Check Hidden Content setting and if the node isVisible or
                // not.
                if (CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(controls[j])) {
                    continue;
                }
                // Note that textareas and selects will be called type='text'
                var type = controls[j].hasAttribute("type") ? controls[j].getAttribute("type").toLowerCase() : "text";
                // Only fail if this is another control in the form and its type is another text-like input
                passed = controls[j] == ruleContext || (type != "text" && type != "password" && type != "file");
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5403:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_haspopup_conflict = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.input_haspopup_conflict = {
    id: "input_haspopup_conflict",
    context: "dom:input[list][aria-haspopup]",
    refactor: {
        "input_haspopup_invalid": {
            // "Pass": "pass",
            "Potential_1": "potential_type_misuse",
            "Potential_2": "potential_misuse"
        }
    },
    help: {
        "en-US": {
            "group": "input_haspopup_conflict.html",
            // "pass": "input_haspopup_conflict.html",
            "potential_type_misuse": "input_haspopup_conflict.html",
            "potential_misuse": "input_haspopup_conflict.html",
            "potential_list_notexist": "input_haspopup_conflict.html",
            "fail_invalid_list_type": "input_haspopup_conflict.html",
            "fail_invalid_list_elem": "input_haspopup_conflict.html"
        }
    },
    messages: {
        "en-US": {
            "group": "<input> element with a 'list' attribute should not use an explicit 'aria-haspopup' attribute",
            // "pass": "The <input> element with a 'list' attribute does not use an explicit 'aria-haspopup' attribute",
            "potential_type_misuse": "The <input> element with type \"{0}\" and 'list' attribute uses an explicit 'aria-haspopup' attribute",
            "potential_misuse": "The <input> element with a missing or invalid type and 'list' attribute uses an explicit 'aria-haspopup' attribute",
            "potential_list_notexist": "The list attribute for the <input> element is invalid",
            "fail_invalid_list_type": "The list attribute for the <input> element with the type \"{0}\" is invalid",
            "fail_invalid_list_elem": "The list attribute for the <input> element does not reference a datalist element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip if the fieldset is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return null;
        var roles = AriaUtil_1.AriaUtil.getUserDefinedRoles(ruleContext);
        // let "aria_role_valid" to handle invalid role. Only allowed role is combobox which is implicit. 
        if (roles && roles.length > 0 && !roles.includes('combobox'))
            return null;
        //triggering input types: text, search, tel, url, email, or missing or invalid 
        var yesTypes = ["text", "search", "tel", "url", "email", "date", "month", "week", "time", "datetime-local", "number", "range", "color"];
        var noTypes = ["file", "password", "checkbox", "radio", "submit", "reset", "image", "hidden", "button"];
        var attrValue = ruleContext.getAttribute("type");
        //missing input type for list but with aria_has_popup
        if (!attrValue || attrValue.trim().length === 0)
            return (0, IRule_1.RulePotential)("potential_misuse");
        attrValue = attrValue.trim().toLowerCase();
        //invalid input types for list but with aria_has_popup
        if (!yesTypes.includes(attrValue) && !noTypes.includes(attrValue))
            return (0, IRule_1.RulePotential)("potential_misuse");
        // the list attribute is used for wrong input type
        if (attrValue && noTypes.includes(attrValue))
            return (0, IRule_1.RuleFail)("fail_invalid_list_type");
        var list = ruleContext.getAttribute("list");
        // the list attribute is blank
        if (!list || list.trim().length === 0)
            return (0, IRule_1.RulePotential)("potential_list_notexist");
        var listElem = ruleContext.ownerDocument.getElementById(list);
        // the list element doesn't exist
        if (!listElem)
            return (0, IRule_1.RuleFail)("potential_list_notexist");
        // the list element is not a datalist element
        if (listElem.nodeName.toLowerCase() !== 'datalist')
            return (0, IRule_1.RuleFail)("fail_invalid_list_elem");
        // valid input types for list but with aria_has_popup    
        if (yesTypes.includes(attrValue))
            return (0, IRule_1.RulePotential)("potential_type_misuse", [attrValue]);
        // shouldn't get here 
        return;
    }
};


/***/ }),

/***/ 5937:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_label_after = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var DOMWalker_1 = __webpack_require__(7440);
var CommonUtil_1 = __webpack_require__(8137);
exports.input_label_after = {
    id: "input_label_after",
    context: "dom:input",
    refactor: {
        "WCAG20_Input_LabelAfter": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "input_label_after.html",
            "Fail_1": "input_label_after.html",
            "Fail_2": "input_label_after.html",
            "group": "input_label_after.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Checkbox or radio button is nested in label, so label is not after the input control",
            "Fail_2": "Label text is located before its associated checkbox or radio button element",
            "group": "Checkboxes and radio buttons must have a label after the input control"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["3.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var type = "";
        if (ruleContext.hasAttribute("type"))
            type = ruleContext.getAttribute("type").toLowerCase();
        if (type != "checkbox" && type != "radio") {
            return null;
        }
        // Get only the non-hidden labels for element
        var labelElem = CommonUtil_1.CommonUtil.getLabelForElementHidden(ruleContext, true);
        if (labelElem === null || !CommonUtil_1.CommonUtil.hasInnerContentHidden(labelElem)) {
            // Due to dependency, label must be done via title - this rule doesn't apply
            return null;
        }
        var value = CommonUtil_1.CommonUtil.compareNodeOrder(labelElem, ruleContext);
        var passed;
        if (value === -2) {
            // input nested in label
            passed = false;
            //let walkNode = new NodeWalker(labelElem);
            var walkNode = new DOMWalker_1.DOMWalker(labelElem);
            walkNode.node = ruleContext;
            while (!passed && walkNode.nextNode()) {
                passed = ((walkNode.node.nodeName.toLowerCase() === "#text" && walkNode.node.nodeValue.trim().length > 0)
                    || (walkNode.node.nodeName.toLowerCase() === "span" && walkNode.node.textContent.trim().length > 0));
            }
            if (!passed) {
                // Input nested in label and text before input
                return (0, IRule_1.RuleFail)("Fail_1");
            }
        }
        else {
            if (value != 1) {
                // label is before input
                return (0, IRule_1.RuleFail)("Fail_2");
            }
        }
        return (0, IRule_1.RulePass)("Pass_0");
    }
};


/***/ }),

/***/ 4452:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_label_before = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.input_label_before = {
    id: "input_label_before",
    context: "dom:input, dom:textarea, dom:select",
    refactor: {
        "WCAG20_Input_LabelBefore": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "input_label_before.html",
            "Fail_1": "input_label_before.html",
            "Fail_2": "input_label_before.html",
            "group": "input_label_before.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Text input is nested in label such that input precedes the label text",
            "Fail_2": "Label text is located after its associated text input or <select> element",
            "group": "Text inputs and <select> elements must have a label before the input control"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["3.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (ruleContext.nodeName.toLowerCase() == "input" && ruleContext.hasAttribute("type")) {
            var type = ruleContext.getAttribute("type").toLowerCase();
            if (type != "text" && type != "file" && type != "password") {
                return null;
            }
        }
        // Get only the non-hidden labels for element
        var labelElem = CommonUtil_1.CommonUtil.getLabelForElementHidden(ruleContext, true);
        if (labelElem == null || !CommonUtil_1.CommonUtil.hasInnerContentHidden(labelElem)) {
            // Due to dependency, label must be done via title - this rule doesn't apply
            return null;
        }
        var value = CommonUtil_1.CommonUtil.compareNodeOrder(labelElem, ruleContext);
        if (value === -2) {
            // ignore if no label or the content for the label is only from the nested input control 
            var text = CommonUtil_1.CommonUtil.getInnerText(ruleContext);
            if (text && text.trim().length > 0 && CommonUtil_1.CommonUtil.getInnerText(ruleContext).trim() === text.trim()) {
                // Due to dependency, label must be done via title - this rule doesn't apply
                return null;
            }
            // input nested in label
            var passed = false;
            var walkNode = ruleContext.previousSibling;
            while (!passed && walkNode !== null) {
                passed = ((walkNode.nodeName.toLowerCase() == "#text" && walkNode.nodeValue.trim().length > 0)
                    || (walkNode.nodeName.toLowerCase() == "span" && walkNode.textContent.trim().length > 0));
                walkNode = walkNode.previousSibling;
            }
            if (!passed) {
                // Input nested in label and text after input
                return (0, IRule_1.RuleFail)("Fail_1");
            }
        }
        else {
            if (value != -1) {
                // label is after input
                return (0, IRule_1.RuleFail)("Fail_2");
            }
        }
        // Haven't returned yet, then I pass
        return (0, IRule_1.RulePass)("Pass_0");
    }
};


/***/ }),

/***/ 7209:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_label_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
var AccNameUtil_1 = __webpack_require__(1421);
exports.input_label_exists = {
    id: "input_label_exists",
    context: "aria:button,aria:checkbox,aria:combobox,aria:listbox,aria:menuitemcheckbox,aria:menuitemradio,aria:radio,aria:searchbox,aria:slider,aria:spinbutton,aria:switch,aria:textbox,aria:progressbar,dom:input[type=file],dom:output,dom:meter,dom:input[type=password]",
    //dependencies: ["aria_role_redundant", "aria_role_valid"],
    refactor: {
        "WCAG20_Input_ExplicitLabel": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "input_label_exists.html",
            "Fail_1": "input_label_exists.html",
            "Fail_2": "input_label_exists.html",
            "group": "input_label_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Form control element <{0}> has no associated label",
            "Fail_2": "Form control with \"{0}\" role has no associated label",
            "group": "Each form control must have an associated label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    // TODO: ACT: https://github.com/IBMa/equal-access/issues/756
    act: ["97a4e1", "e086e5"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext)) {
            return null;
        }
        var nodeName = ruleContext.nodeName.toLowerCase();
        //ignore datalist element check since it will be part of a input element or hidden by default
        if (nodeName === 'datalist')
            return null;
        // Determine the input type
        var passed = true;
        var type = "text";
        if (nodeName == "input" && ruleContext.hasAttribute("type")) {
            type = ruleContext.getAttribute("type").toLowerCase();
        }
        else if (nodeName === "button" || AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, "button")) {
            type = "buttonelem";
        }
        if (nodeName == "input" && type == "") {
            type = "text";
        }
        if (type === "image") {
            // Handled by input_label_existsImage
            return null;
        }
        /**
                let POF = -1;
                let textTypes = CommonUtil.input_text_types;
                let buttonTypes = CommonUtil.form_button_types;
               
                let buttonTypesWithDefaults = ["reset", "submit"]; // 'submit' and 'reset' have visible defaults.
                if (textTypes.indexOf(type) !== -1) { // If type is in the list
                    // Get only the non-hidden labels for elements, in the case that a label is hidden then it is a violation
                    // Note: label[for] does not work for ARIA defined inputs
                    let labelElem = ruleContext.hasAttribute("role") ? null : CommonUtil.getLabelForElementHidden(ruleContext, true);
                    let hasLabelElemContent = false;
                    if (labelElem) {
                        if (CommonUtil.hasInnerContentHidden(labelElem)) {
                            hasLabelElemContent = true;
                        } else if ((labelElem.getAttribute("aria-label") || "").trim().length > 0) {
                            hasLabelElemContent = true;
                        } else if (labelElem.hasAttribute("aria-labelledby")) {
                            let labelledByElem = FragmentUtil.getById(labelElem, labelElem.getAttribute('aria-labelledby'));
                            if (labelledByElem && !DOMUtil.sameNode(labelledByElem, labelElem) && CommonUtil.hasInnerContent(labelledByElem)) {
                                hasLabelElemContent = true;
                            }
                        }
                    }
                    passed = (!!labelElem && hasLabelElemContent) ||
                        (!labelElem && CommonUtil.attributeNonEmpty(ruleContext, "title") || CommonUtil.attributeNonEmpty(ruleContext, "placeholder")) ||
                        AriaUtil.getAriaLabel(ruleContext).trim().length > 0 || CommonUtil.hasImplicitLabel(ruleContext);
                    if (!passed) POF = 2 + textTypes.indexOf(type);
                    
                } else if (buttonTypes.indexOf(type) !== -1) { // If type is a button
                    if (buttonTypesWithDefaults.indexOf(type) !== -1 && !ruleContext.hasAttribute("value")) {
                        // 'submit' and 'reset' have visible defaults so pass if there is no 'value' attribute
                        passed = true;
                    } else {
                        passed = CommonUtil.attributeNonEmpty(ruleContext, "value") || AriaUtil.hasAriaLabel(ruleContext) || CommonUtil.attributeNonEmpty(ruleContext, "title");
                        if (!passed) POF = 2 + textTypes.length + buttonTypes.indexOf(type);
                    }
                } else if (type == "buttonelem") {
                    // If I am an image and I have alt text - accessibility-web-engine#269
                    let bAlt = false;
                    if (ruleContext.nodeName.toLowerCase() === "img" && ruleContext.hasAttribute("alt")) {
                        let alt = ruleContext.getAttribute("alt");
                        if (alt.trim().length === 0) {
                            bAlt = false;
                        } else {
                            bAlt = true;
                        }
                    };
                    passed = CommonUtil.hasInnerContentHidden(ruleContext) || AriaUtil.hasAriaLabel(ruleContext) || bAlt || CommonUtil.attributeNonEmpty(ruleContext, "title");
        
                    if (!passed) POF = 2 + textTypes.length + buttonTypes.length + 1;
                }
        
                //check if a native button is labelled
                if (!passed && nodeName == "button") {
                     if (CommonUtil.hasImplicitLabel(ruleContext))
                        passed = true;
                     else {
                        let label = CommonUtil.getLabelForElement(ruleContext);
                        if (label && CommonUtil.hasInnerContentHidden(label))
                            passed = true;
                     }
                }
        
                // Rpt_Aria_ValidIdRef determines if the aria-labelledby id points to a valid element
                if (!passed && (buttonTypes.indexOf(type) !== -1)) {
                    if (ruleContext.hasAttribute("class") && ruleContext.getAttribute("class") == "dijitOffScreen" && DOMWalker.parentElement(ruleContext).hasAttribute("widgetid")) {
                        // Special handling for dijit buttons
                        let labelId = DOMWalker.parentElement(ruleContext).getAttribute("widgetid") + "_label";
                        let label = FragmentUtil.getById(ruleContext, labelId);
                        if (label != null) {
                            passed = CommonUtil.hasInnerContentHidden(label);
                            // This means I failed above also
                            if (!passed) POF = 2 + textTypes.length + buttonTypes.length + 4 + buttonTypes.indexOf(type);
                        }
                    }
                }
        
                if (!passed && nodeName == "optgroup") {
                    passed = CommonUtil.attributeNonEmpty(ruleContext, "label");
                    if (!passed) POF = 2 + textTypes.length + buttonTypes.length + 2;
                }
                if (!passed && nodeName == "option") {
                    // Is a non-empty value attribute also enough for an option element?
                    passed = CommonUtil.attributeNonEmpty(ruleContext, "label") || ruleContext.innerHTML.trim().length > 0;
                    if (!passed) POF = 2 + textTypes.length + buttonTypes.length + 3;
                }
                
                if (!passed)
                    passed = AriaUtil.getAriaLabel(ruleContext).trim().length > 0 || CommonUtil.attributeNonEmpty(ruleContext, "title");
                        
                if (!passed) {
                    // check aria role to figure out if the accessible name can be from content
                    const roles = AriaUtil.getRoles(ruleContext, true);
                    //when multiple roles specified, only the first valid role (guaranteed by dependencies) is applied, and the others just as fallbacks
                    if (ARIADefinitions.designPatterns[roles[0]] && ARIADefinitions.designPatterns[roles[0]].nameFrom && ARIADefinitions.designPatterns[roles[0]].nameFrom.includes("contents"))
                        passed = CommonUtil.hasInnerContentHidden(ruleContext);
                }
        */
        var pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(ruleContext);
        passed = pair && pair.name && pair.name.trim().length > 0;
        if (passed) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else if (ruleContext.hasAttribute("role") && ruleContext.getAttribute("role").trim().length > 0) {
            return (0, IRule_1.RuleFail)("Fail_2", ruleContext.getAttribute("role").split(" "));
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1", [nodeName]);
        }
    }
};


/***/ }),

/***/ 8262:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_label_visible = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var fragment_1 = __webpack_require__(482);
var VisUtil_1 = __webpack_require__(8656);
var DOMUtil_1 = __webpack_require__(295);
var AccNameUtil_1 = __webpack_require__(1421);
exports.input_label_visible = {
    id: "input_label_visible",
    context: "aria:button,aria:checkbox,aria:combobox,aria:listbox,aria:menuitemcheckbox,aria:menuitemradio,aria:radio,aria:searchbox,aria:slider,aria:spinbutton,aria:switch,aria:textbox",
    dependencies: ["input_label_exists"],
    refactor: {
        "WCAG20_Input_VisibleLabel": {
            "Pass_0": "pass",
            "Potential_1": "potential_no_label",
            "potential_placeholder_only": "potential_placeholder_only"
        }
    },
    help: {
        "en-US": {
            "pass": "input_label_visible.html",
            "potential_placeholder_only": "input_label_visible.html",
            "potential_no_label": "input_label_visible.html",
            "group": "input_label_visible.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The input element has an associated visible label",
            "potential_placeholder_only": "The placeholder is the only visible label",
            "potential_no_label": "The input element does not have an associated visible label",
            "group": "An input element must have an associated visible label"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.5.3", "3.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        //ignore datalist element check since it will be part of a input element or hidden by default
        if (nodeName === 'datalist')
            return null;
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return null;
        // if a control is in a table cell, the col headers can act as visible label, which is checked in table heading rule
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, "table"))
            return null;
        // custom widget submission is not in scope for this success criteria (IBMa/equal-access#204) if it is not associated with data entry
        var role = AriaUtil_1.AriaUtil.getResolvedRole(ruleContext);
        if (role && role === "button" && nodeName !== 'input' && nodeName !== 'button') {
            // likely a custom widget, skip if not associated with data entry
            if (!CommonUtil_1.CommonUtil.getAncestor(ruleContext, "form"))
                return null;
        }
        // when in a combobox, only look at the input textbox.
        if (AriaUtil_1.AriaUtil.getAncestorWithRole(ruleContext, "combobox") &&
            !(AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, "textbox") || AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, "searchbox") ||
                nodeName === "input" || (nodeName === "select" && AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, "combobox")))) {
            return null;
        }
        // avoid diagnosing the popup list of a combobox.
        var rolesToCheck = ["listbox", "tree", "grid", "dialog"];
        for (var j = 0; j < rolesToCheck.length; j++) {
            if (AriaUtil_1.AriaUtil.hasRoleInSemantics(ruleContext, rolesToCheck[j])) {
                var comboboxes = CommonUtil_1.CommonUtil.getElementsByRoleHidden(ruleContext.ownerDocument, "combobox", true, true);
                for (var k = 0; k < comboboxes.length; k++) {
                    var combobox = comboboxes[k];
                    var aria_owns = CommonUtil_1.CommonUtil.getElementAttribute(combobox, "aria-owns");
                    if (aria_owns) {
                        var owns = CommonUtil_1.CommonUtil.normalizeSpacing(aria_owns.trim()).split(" ");
                        for (var i = 0; i < owns.length; i++) {
                            var owned = fragment_1.FragmentUtil.getById(ruleContext, owns[i]);
                            if (owned === ruleContext) {
                                return null;
                            }
                        }
                    }
                }
            }
        }
        var pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(ruleContext);
        // check visible label for input or button
        if (nodeName === 'input' || nodeName === 'button') {
            if (pair && pair.name && pair.name.trim().length > 0 && (pair.nameFrom === 'label' || pair.nameFrom === 'internal' || pair.nameFrom === 'alt'))
                return (0, IRule_1.RulePass)("pass");
        }
        // check if an alternative tooltip exists that can be made visible through mouseover
        if (pair && pair.name && pair.name.trim().length > 0 && (pair.nameFrom === 'text' || pair.nameFrom === 'title'))
            return (0, IRule_1.RulePass)("pass");
        // check if any visible text from the control. 
        // note that (1) the text doesnt need to be associated with the control to form a relationship
        //  (2) the text doesn't need to follow accessible name requirement (e.g. nameFrom)
        var text = CommonUtil_1.CommonUtil.getOnScreenInnerText(ruleContext);
        if (text && text.length !== 0)
            return (0, IRule_1.RulePass)("pass");
        // check if any descendant with an alternative tooltip that can be made visible through mouseover
        // only consider img and svg, and other text content of the descendant is covered in the isInnerText above  
        var descendants = AriaUtil_1.AriaUtil.getAllDescendantsWithRoles(ruleContext, ["img", "graphics-document", "graphics-object", "graphics-symbol"], false, true);
        if (descendants && descendants.length > 0) {
            for (var d = 0; d < descendants.length; d++) {
                if (CommonUtil_1.CommonUtil.attributeNonEmpty(descendants[d], "title") || CommonUtil_1.CommonUtil.attributeNonEmpty(descendants[d], "alt"))
                    return (0, IRule_1.RulePass)("pass");
            }
        }
        // check if there is a visible label pointed to by the aria-labelledby attribute.
        if (CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "aria-labelledby")) {
            var theLabel = ruleContext.getAttribute("aria-labelledby");
            var labelValues = theLabel.split(/\s+/);
            for (var j = 0; j < labelValues.length; ++j) {
                var elementById = fragment_1.FragmentUtil.getById(ruleContext, labelValues[j]);
                if (elementById && !DOMUtil_1.DOMUtil.sameNode(elementById, ruleContext) && VisUtil_1.VisUtil.isNodeVisible(elementById) && CommonUtil_1.CommonUtil.hasInnerContentHidden(elementById)) {
                    return (0, IRule_1.RulePass)("pass");
                }
            }
        }
        if ((nodeName === "optgroup" || nodeName == "option") && (pair && pair.name && pair.name.trim().length > 0 && (pair.nameFrom === 'label' || pair.nameFrom === 'content')))
            return (0, IRule_1.RulePass)("pass");
        // Determine if this is referenced by a combobox. If so, the label belongs to the combobox
        var id = ruleContext.getAttribute("id");
        if (id && id.trim().length > 0) {
            if (ruleContext.ownerDocument.querySelector("*[aria-controls='".concat(id, "'][role='combobox']"))) {
                return null;
            }
        }
        // check if a placeholder exists even though a placeholder text is not sufficient as a visible text
        if (CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "placeholder"))
            return (0, IRule_1.RulePotential)("potential_placeholder_only");
        return (0, IRule_1.RulePotential)("potential_no_label");
    }
};


/***/ }),

/***/ 7017:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_onchange_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.input_onchange_review = {
    id: "input_onchange_review",
    context: "dom:input[onchange], dom:textarea[onchange], dom:select[onchange]",
    refactor: {
        "WCAG20_Input_HasOnchange": {
            // "Pass_0": "pass",
            "Potential_1": "potential_warning"
        }
    },
    help: {
        "en-US": {
            // "pass": "input_onchange_review.html",
            "potential_warning": "input_onchange_review.html",
            "group": "input_onchange_review.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Users must be advised if, due to a change of element value, a form automatically submits, a new window opens, or a change in focus occurs",
            // "pass": "The user is advised of the automatic form submission, new window opening, or focus change",
            "potential_warning": "Confirm that the user is advised if, due to a change of element value, a form automatically submits, a new window opens, or a change in focus occurs"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["3.2.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (ruleContext.nodeName.toLowerCase() == "input" && ruleContext.hasAttribute("type")) {
            var type = ruleContext.getAttribute("type").toLowerCase();
            if (type === "hidden" || type === "submit" || type === "image" || type === "button" || type === "reset")
                return null;
        }
        return (0, IRule_1.RulePotential)("potential_warning");
    }
};


/***/ }),

/***/ 9980:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.input_placeholder_label_visible = void 0;
var IRule_1 = __webpack_require__(4377);
exports.input_placeholder_label_visible = {
    id: "input_placeholder_label_visible",
    context: "dom:input[placeholder], dom:textarea[placeholder]",
    refactor: {
        "HAAC_Input_Placeholder": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1",
            "Potential_2": "Potential_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "input_placeholder_label_visible.html",
            "Potential_1": "input_placeholder_label_visible.html",
            "Potential_2": "input_placeholder_label_visible.html",
            "group": "input_placeholder_label_visible.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "HTML5 placeholder is the only visible label",
            "Potential_2": "Additional visible label referenced by 'aria-labelledby' is not valid",
            "group": "HTML5 'placeholder' attribute must not be used as a visible label replacement"
        }
    },
    /**
     * merge the rule into input_label_visible
    rulesets: [{
        "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
        "num": ["3.3.2"],
        "level": eRulePolicy.VIOLATION,
        "toolkitLevel": eToolkitLevel.LEVEL_ONE
    }],
    */
    rulesets: [],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (ruleContext.hasAttribute("type")) {
            var type = ruleContext.getAttribute("type").toLowerCase();
            if (type == "hidden" || type == "button") {
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
        if (ruleContext.hasAttribute("hidden")) {
            var hidden = ruleContext.getAttribute("hidden");
            if (hidden == "" || hidden.toLowerCase() == "hidden") { // when hidden is empty in the element, "" is returned, same as it has a value of "".
                return (0, IRule_1.RulePass)("Pass_0");
            }
        }
        if (ruleContext.hasAttribute("aria-label")) {
            return (0, IRule_1.RulePotential)("Potential_1");
        }
        if (ruleContext.hasAttribute("aria-labelledby") && ruleContext.hasAttribute("id")) {
            var id = ruleContext.getAttribute("id").trim();
            var refIds = ruleContext.getAttribute("aria-labelledby").trim().split(/\s+/); // separated by one or more white spaces
            if (!refIds.includes(id)) {
                return (0, IRule_1.RulePass)("Pass_0");
            }
            else {
                return (0, IRule_1.RulePotential)("Potential_2");
            }
        }
        return (0, IRule_1.RulePass)("Pass_0");
    }
};


/***/ }),

/***/ 7733:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.label_content_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var fragment_1 = __webpack_require__(482);
var DOMUtil_1 = __webpack_require__(295);
exports.label_content_exists = {
    id: "label_content_exists",
    context: "dom:label",
    refactor: {
        "Valerie_Label_HasContent": {
            "Pass_Regular": "Pass_Regular",
            "Pass_AriaLabel": "Pass_AriaLabel",
            "Pass_LabelledBy": "Pass_LabelledBy",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_Regular": "label_content_exists.html",
            "Pass_AriaLabel": "label_content_exists.html",
            "Pass_LabelledBy": "label_content_exists.html",
            "Fail_1": "label_content_exists.html",
            "group": "label_content_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_Regular": "<label> element has accessible name with inner content",
            "Pass_AriaLabel": "<label> element has accessible name via 'aria-label'",
            "Pass_LabelledBy": "<label> element has accessible name via 'aria-labelledby'",
            "Fail_1": "The <label> element does not have descriptive text that identifies the expected input",
            "group": "A <label> element must have non-empty descriptive text that identifies the purpose of the interactive component"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (CommonUtil_1.CommonUtil.hasInnerContentHidden(ruleContext)) {
            return (0, IRule_1.RulePass)("Pass_Regular");
        }
        else if ((ruleContext.getAttribute("aria-label") || "").trim().length > 0) {
            return (0, IRule_1.RulePass)("Pass_AriaLabel");
        }
        else if (ruleContext.hasAttribute("aria-labelledby")) {
            var labelElem = fragment_1.FragmentUtil.getById(ruleContext, ruleContext.getAttribute('aria-labelledby'));
            if (labelElem && !DOMUtil_1.DOMUtil.sameNode(labelElem, ruleContext) && CommonUtil_1.CommonUtil.hasInnerContent(labelElem)) {
                return (0, IRule_1.RulePass)("Pass_LabelledBy");
            }
        }
        return (0, IRule_1.RuleFail)("Fail_1");
    }
};


/***/ }),

/***/ 1256:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.label_name_visible = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var fragment_1 = __webpack_require__(482);
var VisUtil_1 = __webpack_require__(8656);
var CSSUtil_1 = __webpack_require__(1775);
var DOMWalker_1 = __webpack_require__(7440);
exports.label_name_visible = {
    id: "label_name_visible",
    context: "aria:button,aria:checkbox,aria:gridcell,aria:link,aria:menuitem,aria:menuitemcheckbox,aria:menuitemradio,aria:option,aria:radio,aria:switch,aria:tab,aria:treeitem,dom:input,dom:textarea,dom:select,dom:output,dom:meter",
    refactor: {
        "WCAG21_Label_Accessible": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "label_name_visible.html",
            "Fail_1": "label_name_visible.html",
            "group": "label_name_visible.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Accessible name matches or contains the visible label text",
            "Fail_1": "Accessible name does not match or contain the visible label text",
            "group": "Accessible name must match or contain the visible label text"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_2"],
            "num": ["2.5.3"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    // TODO: ACT: Review https://github.com/act-rules/act-rules.github.io/issues/1618
    // https://www.w3.org/WAI/WCAG21/Techniques/aria/ARIA24
    act: "2ee8b8",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) ||
            CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext)) {
            return null;
        }
        // pass if the visible text uses Material Icon font
        if (CSSUtil_1.CSSUtil.isMaterialIconFont(ruleContext))
            return (0, IRule_1.RulePass)("Pass_0");
        var passed = true;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var isInputButton = false;
        //let buttonTypes = ["button", "reset", "submit"]; //"image"
        var inputType = null;
        if (nodeName === "input" && ruleContext.hasAttribute("type")) {
            inputType = ruleContext.getAttribute("type").toLowerCase();
            if (CommonUtil_1.CommonUtil.form_button_types.indexOf(inputType) !== -1) {
                isInputButton = true;
            }
        }
        var theLabelBy = AriaUtil_1.AriaUtil.getAriaAttribute(ruleContext, "aria-labelledby");
        if (theLabelBy && !CommonUtil_1.CommonUtil.isIdReferToSelf(ruleContext, theLabelBy) && !isInputButton) {
            // skip the checks if it has an aria-labelledby since it takes precedence.
        }
        else {
            var theLabel = null;
            if (theLabelBy && !CommonUtil_1.CommonUtil.isIdReferToSelf(ruleContext, theLabelBy)) {
                var labelValues = theLabelBy.split(/\s+/);
                for (var j = 0; j < labelValues.length; ++j) {
                    var elementById = fragment_1.FragmentUtil.getById(ruleContext, labelValues[j]);
                    if (elementById) {
                        theLabel = CommonUtil_1.CommonUtil.getInnerText(elementById);
                        break;
                    }
                }
            }
            else {
                theLabel = AriaUtil_1.AriaUtil.getAriaAttribute(ruleContext, "aria-label");
            }
            if (!theLabel) {
                return null;
            }
            var text = null;
            if (isInputButton) {
                /* Note: Disable the alt check in images until we get confirmation
                if (inputType==="image" && ruleContext.hasAttribute("alt")){
                    // use 'alt' attribute as visible text
                    text = ruleContext.getAttribute("alt");
                }else
                */
                if (ruleContext.hasAttribute("value")) {
                    // use 'value' attribute as visible text
                    text = ruleContext.getAttribute("value");
                }
                else {
                    // use default value
                    if (inputType === "submit" /*||inputType==="image"*/) {
                        text = "submit";
                    }
                    else if (inputType === "reset") {
                        text = "reset";
                    }
                }
            }
            if (!text) {
                // look for a <label> element
                var labelElem = CommonUtil_1.CommonUtil.getLabelForElementHidden(ruleContext, true);
                if (!labelElem) {
                    var parentNode = DOMWalker_1.DOMWalker.parentNode(ruleContext);
                    if (parentNode.nodeName.toLowerCase() === "label" /*&& RPTUtil.isFirstFormElement(parentNode, ruleContext)*/) {
                        var parentClone = parentNode.cloneNode(true);
                        // exclude all form elements from the label since they might also have inner content
                        labelElem = CommonUtil_1.CommonUtil.removeAllFormElementsFromLabel(parentClone);
                    }
                }
                var element = labelElem ? labelElem : ruleContext;
                var elementsToSkipContentCheck = ["meter", "output", "progress", "select", "textarea"];
                if (!labelElem && elementsToSkipContentCheck.indexOf(nodeName) !== -1) {
                    text = ""; // skip content check for some elements
                }
                else {
                    // get the visible text only
                    text = CommonUtil_1.CommonUtil.getOnScreenInnerText(element);
                }
                /* Note: Disable this alt check in images for now until we get confirmation
                // Look for the alt attribute of an image which is considered visible text.
                let hasImgAlt = false;
                if (element.firstChild != null) {
                    let nw = RPTUtil.new NodeWalker(element);
                    while (!hasImgAlt && nw.nextNode() && nw.node != element && nw.node != element.nextSibling) {
                        hasImgAlt = (nw.node.nodeName.toLowerCase() == "img" && RPTUtil.attributeNonEmpty(nw.node, "alt"));
                        if (hasImgAlt) {
                            text = text ? text + nw.node.getAttribute("alt") : nw.node.getAttribute("alt");
                        }
                    }
                }
                */
            }
            var nonalphanumeric = /[^a-zA-Z0-9]/g;
            text = text.replace(nonalphanumeric, " "); // only consider alphanumeric characters
            var normalizedText = CommonUtil_1.CommonUtil.normalizeSpacing(text).toLowerCase(); // Leading and trailing whitespace and difference in case sensitivity should be ignored.
            theLabel = theLabel.replace(nonalphanumeric, " "); // only consider alphanumeric characters
            var normalizedLabel = CommonUtil_1.CommonUtil.normalizeSpacing(theLabel).toLowerCase();
            if (normalizedText.length > 1) { // skip non-text content. e.g., <button aria-label="close">X</button>
                var location_1 = normalizedLabel.indexOf(normalizedText);
                // Avoid matching partial words.e.g., text "name" should not match 'surname' or 'names'
                if (location_1 >= 0 && normalizedLabel.length > normalizedText.length) {
                    var letters = /^[0-9a-zA-Z]+$/;
                    if ((location_1 + normalizedText.length) < normalizedLabel.length) {
                        // check ending
                        var theChar = normalizedLabel.charAt(location_1 + normalizedText.length);
                        if (theChar.match(letters)) {
                            passed = false;
                        }
                    }
                    if (passed && location_1 > 0) {
                        // check beginning
                        var theChar = normalizedLabel.charAt(location_1 - 1);
                        if (theChar.match(letters)) {
                            passed = false;
                        }
                    }
                }
                if (location_1 === -1) { // check that visible text content of the target is contained within its accessible name.
                    passed = false;
                }
            }
        }
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 9532:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.label_ref_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var fragment_1 = __webpack_require__(482);
var VisUtil_1 = __webpack_require__(8656);
exports.label_ref_valid = {
    id: "label_ref_valid",
    context: "dom:label[for]",
    refactor: {
        "WCAG20_Label_RefValid": {
            "Pass_0": "pass",
            "Fail_1": "fail_invalid"
        }
    },
    help: {
        "en-US": {
            "pass": "label_ref_valid.html",
            "fail_invalid": "label_ref_valid.html",
            "group": "label_ref_valid.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "The 'for' attribute for a label referencea a unique non-empty 'id' attribute of a valid element",
            "fail_invalid": "The value \"{0}\" of the 'for' attribute is not the 'id' of a valid element",
            "group": "The 'for' attribute for a label should reference a non-empty, unique 'id' attribute of a valid element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var id = ruleContext.getAttribute("for");
        var passed = false;
        var target = fragment_1.FragmentUtil.getById(ruleContext, id);
        if (target) {
            // ignore if both label and control are invisible
            if (!VisUtil_1.VisUtil.isNodeVisible(target) && !VisUtil_1.VisUtil.isNodeVisible(ruleContext))
                return null;
            passed = true;
            // handles null and undefined
            if (!target.hasAttribute("role")) {
                // Fail if we're pointing at something that is labelled by another mechanism
                var nodeName = target.nodeName.toLowerCase();
                passed = nodeName == "input" || nodeName == "select" || nodeName == "textarea"
                    || nodeName == "button" || nodeName == "datalist"
                    || nodeName == "optgroup" || nodeName == "option"
                    || nodeName == "keygen" || nodeName == "output"
                    || nodeName == "progress" || nodeName == "meter"
                    || nodeName == "fieldset" || nodeName == "legend";
                if (target.nodeName.toLowerCase() == "input" && target.hasAttribute("type")) {
                    var type = target.getAttribute("type").toLowerCase();
                    passed = type == "text" || type == "password" || type == "file" ||
                        type == "checkbox" || type == "radio" ||
                        type == "hidden" || type == "search" || type == "tel" || type == "url" || type == "email" || //HTML 5
                        type == "date" || type == "number" || type == "range" || type == "image" || //HTML 5
                        type == "time" || type == "color" || // HTML 5
                        type == "datetime-local" || type == "month" || type == "week"; //HTML5.1
                }
            }
            // Add one more check to make sure the target element is NOT hidden, in the case the target is hidden
            // flag a violation regardless of what the Check Hidden Content setting is.
            if (passed && !VisUtil_1.VisUtil.isNodeVisible(target)) {
                passed = false;
            }
        }
        var retToken = [];
        if (!passed) {
            retToken.push(id);
        }
        //return new ValidationResult(passed, [ruleContext], '', '', passed == true ? [] : [retToken]);
        if (!passed) {
            return (0, IRule_1.RuleFail)("fail_invalid", retToken);
        }
        else {
            return (0, IRule_1.RulePass)("pass");
        }
    }
};


/***/ }),

/***/ 6698:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.list_children_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var DOMWalker_1 = __webpack_require__(7440);
exports.list_children_valid = {
    id: "list_children_valid",
    context: "aria:group",
    refactor: {
        "HAAC_List_Group_ListItem": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "list_children_valid.html",
            "Fail_1": "list_children_valid.html",
            "group": "list_children_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "List component with \"group\" role has children that are not <listitem> elements",
            "group": "List component with \"group\" role must limit children to <listitem> elements"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var parent = DOMWalker_1.DOMWalker.parentElement(ruleContext);
        if (!AriaUtil_1.AriaUtil.hasRoleInSemantics(parent, "list")) {
            return null;
        }
        var passed = true;
        var children = ruleContext.children;
        for (var i = 0; passed && i < children.length; i++) {
            passed = AriaUtil_1.AriaUtil.hasRoleInSemantics(children[i], "listitem");
        }
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 9632:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.list_markup_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var DOMWalker_1 = __webpack_require__(7440);
var VisUtil_1 = __webpack_require__(8656);
exports.list_markup_review = {
    id: "list_markup_review",
    context: "dom:*",
    refactor: {
        "RPT_List_UseMarkup": {
            // "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            // "pass": "list_markup_review.html",
            "potential_list": "list_markup_review.html",
            "group": "list_markup_review.html"
        }
    },
    messages: {
        "en-US": {
            // "pass": "Proper HTML elements are used to create a list",
            "potential_list": "Verify this is a list and if so, modify to use proper HTML elements for the list",
            "group": "Proper HTML elements should be used to create a list"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Extract the nodeName of the context node
        var nodeName = ruleContext.nodeName.toLowerCase();
        //skip the check if the element is hidden or disabled
        if (CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext) || VisUtil_1.VisUtil.hiddenByDefaultElements.includes(nodeName))
            return null;
        // Don't trigger if we're not in the body or if we're in a script
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["body"]) === null)
            return null;
        // ignore script, label and their child elements
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["script", 'label']) !== null)
            return null;
        // ignore all widgets and their children, and certain structure roles
        var roles = AriaUtil_1.AriaUtil.getRolesWithTypes(ruleContext, ["widget"]);
        // add some structure roles
        CommonUtil_1.CommonUtil.concatUniqueArrayItemList(["caption", "code", "columnheader", "figure", "list", "listitem", "math", "meter", "columnheader", "rowheader"], roles);
        if (AriaUtil_1.AriaUtil.getAncestorWithRoles(ruleContext, roles) !== null)
            return null;
        var passed = true;
        var walkNode = ruleContext.firstChild;
        while (passed && walkNode) {
            // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
            // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
            // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
            // a node walk only on siblings so it would not get text nodes from other siblings at all.
            // In the case in the future something changes, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
            // if.
            if (walkNode.nodeName == "#text") {
                var txtVal = walkNode.nodeValue;
                var failure = /^[ \t\r\n]*[( ]*[1-9]*[\*\-).][ \t][A-Z,a-z]+/.test(txtVal);
                passed = !failure;
                if (!passed) {
                    // Ensure that there's some sort of block level element before this
                    // Avoid failures due to things like <i>Some sentence</i>. New sentence.
                    //let nw = new NodeWalker(walkNode);
                    var nw = new DOMWalker_1.DOMWalker(walkNode);
                    while (!passed && nw.prevNode()) {
                        var nodeName_1 = nw.node.nodeName.toLowerCase();
                        if (["blockquote", "center", "dir", "div", "form", "h1",
                            "h2", "h3", "h4", "h5", "h6", "hr", "br", "menu", "p",
                            "pre"].includes(nodeName_1)) {
                            break;
                        }
                        if (nodeName_1 == "#text") {
                            var txt = nw.node.nodeValue;
                            passed = txt.length > 0 && ![" ", "\t", "\n"].includes(txt.charAt(txt.length - 1));
                        }
                    }
                }
            }
            walkNode = walkNode.nextSibling;
        }
        if (passed)
            return null;
        if (!passed)
            return (0, IRule_1.RulePotential)("potential_list");
    }
};


/***/ }),

/***/ 3692:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.list_structure_proper = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
exports.list_structure_proper = {
    id: "list_structure_proper",
    context: "dom:dl, dom:ul, dom:ol, dom:dir, dom:menu, dom:li, dom:dd, dom:dt",
    refactor: {
        "RPT_List_Misuse": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "list_structure_proper.html",
            "Potential_1": "list_structure_proper.html",
            "group": "list_structure_proper.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "List element is missing or improperly structured",
            "group": "List elements should only be used for lists of related items"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed;
        var nodeName = ruleContext.nodeName.toLowerCase();
        // Get all the childrens of the ruleContext
        var children = ruleContext.children;
        if (nodeName == "dl") {
            var first = "";
            var last = "";
            var walkChildren = ruleContext.firstChild;
            passed = true;
            var presentationalFound = false;
            // If there are no childrens set as passed, since dl elements can have
            // zero or more of: one or more dt elements, followed by one or more dd elements
            if (!ruleContext.children || ruleContext.children.length == 0) {
                passed = true;
            }
            else {
                while (passed && walkChildren != null) {
                    if (walkChildren.nodeType == 1) {
                        var nodeName_1 = walkChildren.nodeName.toLowerCase();
                        // While walking through the elements under dl, if we find a 
                        // presentational element we move to the next element as presentational
                        // elements are allowed under list elements as they are only for
                        // formatting text nodes.
                        if (AriaUtil_1.AriaUtil.isPresentationalElement(walkChildren)) {
                            presentationalFound = true;
                            walkChildren = walkChildren.nextSibling;
                            continue;
                        }
                        // Only set to pass if we find dd or dt element, in the case of
                        // an element that is not supported we will catch it here. i.e. img 
                        // element
                        passed = nodeName_1 == "dd" || nodeName_1 == "dt";
                        // Set the first and last node depending on which is found first and last
                        if (first == "")
                            first = nodeName_1;
                        last = nodeName_1;
                    }
                    walkChildren = walkChildren.nextSibling;
                }
                // In the case that we have found dt and dd elements under dl we pass right away.
                // In the case that there is no dt or dd element, but bunch of presentational elements we mark this as a
                // pass. In the case that there are other elements, such as img we will still trigger a violation.
                passed = (passed && first == "dt" && last == "dd") || (passed && presentationalFound);
            }
        }
        else if (nodeName == "li") {
            passed = CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["ul", "ol", "dir", "menu"]) != null;
        }
        else if (nodeName == "dd" || nodeName == "dt") {
            passed = CommonUtil_1.CommonUtil.getAncestor(ruleContext, "dl") != null;
        }
        else {
            var walkChildren = ruleContext.firstChild;
            // Zero or more li elements are permitted inside of <ol>, <ul> or <menu> elements now as per the html5 spec. This handles the case
            // when there are zero elements under the <ol>, <ul> or <menu>.
            if ((nodeName == "ul" || nodeName == "ol" || nodeName == "menu") && (!ruleContext.children || ruleContext.children.length == 0)) {
                passed = true;
            }
            else {
                var liFound = false;
                var presentationalFound = false;
                passed = true;
                while (passed && walkChildren != null) {
                    // While walking through the list elements, if we find a 
                    // presentational element we skip checking as presentational
                    // elements are allowed under list elements as they are only for
                    // formatting text.
                    if (AriaUtil_1.AriaUtil.isPresentationalElement(walkChildren)) {
                        presentationalFound = true;
                        walkChildren = walkChildren.nextSibling;
                        continue;
                    }
                    // Pass if the node type is anything but 1, or in the case that it is a li element. For any other node 
                    // it will be caught here that element is not allowed under list node.
                    // Furthermore in the case that there is a template element with the parent being ul/ol don't flag a violation
                    passed = walkChildren.nodeType != 1 || walkChildren.nodeName.toLowerCase() == "li" || (walkChildren.nodeName.toLowerCase() == "template" && (nodeName == "ul" || nodeName == "ol"));
                    // Set li found to true if the current element (nodeType=1) is an li element
                    liFound = liFound || (walkChildren.nodeType == 1 && walkChildren.nodeName.toLowerCase() == "li");
                    walkChildren = walkChildren.nextSibling;
                }
                // In the case that it has passed and also li element is found under list node, we pass right away.
                // In the case that there is no li element, but bunch of presentational elements we mark this as a
                // pass. In the case that there are other elements, such as img we will still trigger a violation.
                passed = (passed && liFound) || (passed && presentationalFound);
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5430:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.marquee_elem_avoid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.marquee_elem_avoid = {
    id: "marquee_elem_avoid",
    context: "dom:marquee",
    refactor: {
        "RPT_Marquee_Trigger": {
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Fail_1": "marquee_elem_avoid.html",
            "group": "marquee_elem_avoid.html"
        }
    },
    messages: {
        "en-US": {
            "Fail_1": "Scrolling content found that uses the obsolete <marquee> element",
            "group": "The <marquee> element is obsolete and should not be used"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.2.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // JCH - NO OUT OF SCOPE hidden in context
        return (0, IRule_1.RuleFail)("Fail_1");
    }
};


/***/ }),

/***/ 1018:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_alt_brief = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
exports.media_alt_brief = {
    id: "media_alt_brief",
    context: "dom:img[alt], dom:applet[alt], dom:area[alt], dom:embed[alt], dom:input[type][alt]",
    refactor: {
        "RPT_Media_AltBrief": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "media_alt_brief.html",
            "Potential_1": "media_alt_brief.html",
            "group": "media_alt_brief.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Text alternative is more than 150 characters",
            "group": "Alternative text in 'alt' attribute should be brief (<150 characters)"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            maxAlt: {
                value: 150,
                type: "integer"
            }
        };
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var altLength = ruleContext.getAttribute("alt").trim().length;
        var passed = altLength <= validateParams.maxAlt.value;
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 3433:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_alt_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.media_alt_exists = {
    id: "media_alt_exists",
    context: "dom:area[alt], dom:embed[alt]",
    refactor: {
        "RPT_Media_AudioVideoAltFilename": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "media_alt_exists.html",
            "Potential_1": "media_alt_exists.html",
            "group": "media_alt_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Filename used as label for embedded audio or video",
            "group": "Audio or video on the page must have a short text alternative that describes the media content"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var uri = "";
        if (ruleContext.nodeName.toLowerCase() == "area") {
            uri = ruleContext.getAttribute("href");
        }
        else {
            uri = ruleContext.getAttribute("src");
        }
        if (uri == null)
            uri = "";
        var ext = CommonUtil_1.CommonUtil.getFileExt(uri);
        var isAudVid = ext.length != 0 && (CommonUtil_1.CommonUtil.isAudioExt(ext) || CommonUtil_1.CommonUtil.isVideoExt(ext));
        var altText = ruleContext.getAttribute("alt");
        var passed = !isAudVid || (altText.length > 0 && altText.indexOf(ext) == -1);
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 8012:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_audio_transcribed = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.media_audio_transcribed = {
    id: "media_audio_transcribed",
    context: "dom:bgsound, dom:a[href], dom:area[href], dom:embed, dom:object",
    refactor: {
        "RPT_Media_AudioTrigger": {
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Manual_1": "media_audio_transcribed.html",
            "group": "media_audio_transcribed.html"
        }
    },
    messages: {
        "en-US": {
            "Manual_1": "Provide transcripts for audio files",
            "group": "Audio information should also be available in text form"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.2.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed;
        var thisNode = ruleContext.nodeName.toLowerCase();
        if (thisNode == "bgsound") {
            passed = false;
        }
        else {
            passed = !CommonUtil_1.CommonUtil.isAudioObjEmbedLink(ruleContext);
        }
        if (passed)
            return null; // Out of Scope
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 3881:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_autostart_controllable = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.media_autostart_controllable = {
    id: "media_autostart_controllable",
    context: "dom:param[name=autoplay], dom:param[name=autostart], dom:embed[flashvars], dom:embed[src], dom:*[autostart=true], dom:*[autostart=1], dom:bgsound",
    refactor: {
        "RPT_Embed_AutoStart": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "media_autostart_controllable.html",
            "Potential_1": "media_autostart_controllable.html",
            "group": "media_autostart_controllable.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify there is a mechanism to pause or stop and control the volume for the audio that plays automatically",
            "group": "Mechanism must be available to pause or stop and control the volume of the audio that plays automatically"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.4.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var passed;
        if (nodeName == "bgsound") {
            passed = false;
        }
        else if (nodeName == "param") {
            var content = "";
            if (ruleContext.hasAttribute("value"))
                content = ruleContext.getAttribute("value").toLowerCase();
            passed = content.indexOf("0;") == 0 ||
                !(content.indexOf("true") != -1 || content.indexOf("1") != -1);
        }
        else if (nodeName == "embed") {
            passed = true;
            if (ruleContext.hasAttribute("flashvars")) {
                var str = ruleContext.getAttribute("flashvars");
                passed = str.indexOf("autostart=true") == -1 &&
                    str.indexOf("autostart=1") == -1;
            }
            if (passed && ruleContext.hasAttribute("src")) {
                var str = ruleContext.getAttribute("src");
                passed = str.indexOf("autostart=true") == -1 &&
                    str.indexOf("autostart=1") == -1;
            }
        }
        if (passed && ruleContext.hasAttribute("autostart")) {
            var val = ruleContext.getAttribute("autostart").toLowerCase();
            passed = val != 'true' && val != '1';
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 3106:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_keyboard_controllable = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
exports.media_keyboard_controllable = {
    id: "media_keyboard_controllable",
    context: "dom:audio, dom:video",
    refactor: {
        "HAAC_Audio_Video_Trigger": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "media_keyboard_controllable.html",
            "Manual_1": "media_keyboard_controllable.html",
            "group": "media_keyboard_controllable.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Verify media using <audio> and/or <video> elements have keyboard accessible controls",
            "group": "Media using <audio> and/or <video> elements must have keyboard accessible controls"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = true;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (nodeName == "audio" || nodeName === "video") {
            passed = false;
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 1276:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_live_captioned = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.media_live_captioned = {
    id: "media_live_captioned",
    context: "dom:embed, dom:object",
    refactor: {
        "RPT_Media_VideoObjectTrigger": {
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Manual_1": "media_live_captioned.html",
            "group": "media_live_captioned.html"
        }
    },
    messages: {
        "en-US": {
            "Manual_1": "Verify captions are provided for live media (streaming video with audio)",
            "group": "Live media (streaming video with audio) should have captions for audio content"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.2.4"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = !CommonUtil_1.CommonUtil.isVideoObjEmbedLink(ruleContext);
        if (passed)
            return null;
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 5424:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.media_track_available = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.media_track_available = {
    id: "media_track_available",
    context: "dom:a[href], dom:area[href], dom:applet, dom:embed, dom:object",
    refactor: {
        "RPT_Media_VideoReferenceTrigger": {
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Manual_1": "media_track_available.html",
            "group": "media_track_available.html"
        }
    },
    messages: {
        "en-US": {
            "Manual_1": "Verify availability of a user-selectable audio track with description of visual content",
            "group": "Pre-recorded media should have an audio track that describes visual information"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.2.3", "1.2.5"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var passed = true;
        if (nodeName == "applet") {
            passed = false;
        }
        else {
            passed = !CommonUtil_1.CommonUtil.isVideoObjEmbedLink(ruleContext);
        }
        if (passed)
            return null;
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 4248:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.meta_redirect_optional = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CacheUtil_1 = __webpack_require__(7788);
exports.meta_redirect_optional = {
    id: "meta_redirect_optional",
    context: "dom:meta[http-equiv][content]",
    refactor: {
        "WCAG20_Meta_RedirectZero": {
            "pass": "pass",
            "fail": "fail",
            "fail_longrefresh": "fail_longrefresh"
        }
    },
    help: {
        "en-US": {
            "group": "meta_redirect_optional.html",
            "pass": "meta_redirect_optional.html",
            "fail": "meta_redirect_optional.html",
            "fail_longrefresh": "meta_redirect_optional.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Page should not automatically refresh without warning or option to turn it off or adjust the time limit",
            "pass": "Rule Passed",
            "fail": "Check page does not automatically refresh without warning or options",
            "fail_longrefresh": "Check page does not automatically refresh without warning or options"
        }
    },
    /**
     * deprecate WCAG AAA
    rulesets: [{
        "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
        "num": ["2.2.4", "3.2.5"],
        "level": eRulePolicy.VIOLATION,
        "toolkitLevel": eToolkitLevel.LEVEL_THREE
    }],
    */
    rulesets: [{
            "id": [],
            "num": ["2.2.4", "3.2.5"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    // Removed ACT bisz58 AAA
    /**act: [{
        "bc659a" : {
            "pass": "pass",
            "fail": "fail",
            "fail_longrefresh": "pass"
        }
    }],*/
    act: ["bisz58"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (ruleContext.getAttribute("http-equiv").toLowerCase() !== 'refresh') {
            return null;
        }
        var doc = ruleContext.ownerDocument;
        if (!doc)
            return;
        // check if the rule already passed or failed: only the first one tridders if multiple
        if (CacheUtil_1.CacheUtil.getCache(doc, "meta_redirect_optional_done", false))
            return null;
        var content = ruleContext.getAttribute("content").toLowerCase();
        if (!content || content.trim().length === 0)
            return null;
        var time = -1;
        if (content.match(/^\d+$/))
            time = parseInt(content);
        else if (content.match(/^\d+;/)) {
            var pos = content.indexOf(";");
            time = parseInt(content.substring(0, pos));
        }
        // Invalid content field
        if (time === -1) {
            return null;
        }
        CacheUtil_1.CacheUtil.setCache(doc, "meta_redirect_optional_done", true);
        if (time === 0)
            return (0, IRule_1.RulePass)("pass");
        else if (time < 72001)
            return (0, IRule_1.RuleFail)("fail");
        return (0, IRule_1.RuleFail)("fail_longrefresh");
    }
};


/***/ }),

/***/ 9526:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.meta_refresh_delay = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CacheUtil_1 = __webpack_require__(7788);
exports.meta_refresh_delay = {
    id: "meta_refresh_delay",
    context: "dom:meta[http-equiv][content]",
    refactor: {
        "RPT_Meta_Refresh": {
            "Pass_0": "pass",
            "Potential_1": "potential_refresh"
        }
    },
    help: {
        "en-US": {
            "group": "meta_refresh_delay.html",
            "pass": "meta_refresh_delay.html",
            "potential_refresh": "meta_refresh_delay.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Pages should not refresh automatically",
            "pass": "Pages do not refresh automatically",
            "potential_refresh": "Verify page is not being caused to refresh automatically",
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.2.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    //act: [ "bisz58", "bc659a" ],
    act: ["bc659a"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (ruleContext.getAttribute("http-equiv").toLowerCase() !== 'refresh')
            return null;
        var doc = ruleContext.ownerDocument;
        if (!doc)
            return;
        // check if the rule already passed: the first one takes priority
        if (CacheUtil_1.CacheUtil.getCache(doc, "meta_refresh_delay_done", false))
            return null;
        var content = ruleContext.getAttribute("content").toLowerCase();
        if (!content || content.trim().length === 0)
            return null;
        var time = -1;
        if (content.match(/^\d+$/))
            time = parseInt(content);
        else if (content.match(/^\d+;/)) {
            var pos = content.indexOf(";");
            time = parseInt(content.substring(0, pos));
        }
        // Invalid content field
        if (time === -1) {
            return null;
        }
        CacheUtil_1.CacheUtil.setCache(doc, "meta_refresh_delay_done", true);
        if (time === 0)
            return (0, IRule_1.RulePass)("pass");
        return (0, IRule_1.RulePotential)("potential_refresh");
    }
};


/***/ }),

/***/ 9379:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.meta_viewport_zoomable = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.meta_viewport_zoomable = {
    id: "meta_viewport_zoomable",
    context: "dom:meta[name][content]",
    refactor: {
        "meta_viewport_zoom": {
            "Pass_0": "pass",
            "Potential_1": "potential_zoomable"
        }
    },
    help: {
        "en-US": {
            "group": "meta_viewport_zoomable.html",
            "pass": "meta_viewport_zoomable.html",
            "potential_zoomable": "meta_viewport_zoomable.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The 'meta[name=viewport]' should not prevent the browser zooming the content",
            "pass": "The 'meta[name=viewport]' does not prevent the browser zooming the content",
            "potential_zoomable": "Confirm the 'meta[name=viewport]' with \"{0}\" can be zoomed by user"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.4.4"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [{
            "b4f0c3": {
                "pass": "pass",
                "potential_zoomable": "fail"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        if (ruleContext.getAttribute("name").toLowerCase() !== 'viewport')
            return null;
        var content = ruleContext.getAttribute("content").toLowerCase();
        // neither maximum-scale nor user-scalable (default yes)
        if (!content || content.trim() === '' || (!content.includes('maximum-scale') && !content.includes('user-scalable')))
            return null;
        var user_msg = null;
        var max_msg = null;
        var props = content.split(",");
        var user_scale_value = 'yes';
        var maximum_scale_value = '2.0';
        for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
            var prop = props_1[_i];
            var pieces = prop.trim().split('=');
            if (pieces.length < 2)
                continue;
            if (prop.includes('user-scalable')) {
                user_msg = prop;
                user_scale_value = pieces[1].trim();
                if (user_scale_value.startsWith("'") || user_scale_value.startsWith('"')) {
                    user_scale_value = user_scale_value.substring(1, user_scale_value.length - 1);
                }
            }
            else if (prop.includes('maximum-scale')) {
                max_msg = prop;
                maximum_scale_value = pieces[1].trim();
                if (maximum_scale_value.startsWith("'") || maximum_scale_value.startsWith('"')) {
                    maximum_scale_value = maximum_scale_value.substring(1, maximum_scale_value.length - 1).trim();
                }
            }
        }
        var value = Number(user_scale_value);
        if (!isNaN(value)) {
            if (value >= 1 || value <= -1)
                user_scale_value = 'yes';
        }
        var maximum_scale = 2.0;
        value = Number(maximum_scale_value);
        if (!isNaN(value)) {
            if (value < 0)
                maximum_scale = 2.0;
            else
                maximum_scale = value;
        }
        else {
            if (maximum_scale_value === 'yes')
                maximum_scale = 1.0;
            else
                maximum_scale = 0.1;
        }
        // user-scalable is not set to 'yes', ignore maximum_scale
        if (user_scale_value !== 'yes') {
            return (0, IRule_1.RulePotential)("potential_zoomable", [user_msg]);
        }
        // user-scalable is 'yes', but maximum_scale is too small
        if (maximum_scale < 2.0) {
            return (0, IRule_1.RulePotential)("potential_zoomable", [max_msg]);
        }
        return (0, IRule_1.RulePass)("pass");
    }
};


/***/ }),

/***/ 5495:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.noembed_content_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.noembed_content_exists = {
    id: "noembed_content_exists",
    context: "dom:noembed",
    refactor: {
        "Valerie_Noembed_HasContent": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "noembed_content_exists.html",
            "Potential_1": "noembed_content_exists.html",
            "group": "noembed_content_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Add descriptive text to the <noembed> element",
            "group": "<noembed> elements should contain descriptive text"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = CommonUtil_1.CommonUtil.hasInnerContentHidden(ruleContext);
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 7753:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.object_text_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
var AccNameUtil_1 = __webpack_require__(1421);
exports.object_text_exists = {
    id: "object_text_exists",
    context: "dom:object",
    refactor: {
        "WCAG20_Object_HasText": {
            "pass": "pass",
            "fail_no_text_alternative": "fail_no_text_alternative"
        }
    },
    help: {
        "en-US": {
            "group": "object_text_exists.html",
            "pass": "object_text_exists.html",
            "fail_no_text_alternative": "object_text_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "<object> element must have a text alternative for the content rendered by the object",
            "pass": "<object> element has a text alternative",
            "fail_no_text_alternative": "An <object> element does not have a text alternative"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: "8fc3b6",
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        // Detect if this object is of type text, by checking the object type in the case it is text then do not trigger this rule
        if (ruleContext.hasAttribute("type") && (ruleContext.getAttribute("type")).indexOf("text") !== -1) {
            return null;
        }
        // ignore if an explicit role is specified: including 'presentation', 'none', 'application', 'document' or 'img'
        // this case will be covered in other rules
        var role = ruleContext.getAttribute("role");
        if (role) {
            return null;
        }
        // Per ACT, ignore embedded HTML files
        var data = ruleContext.getAttribute("data");
        var ext = data && typeof data === typeof "" ? data.substring(data.lastIndexOf(".")) : "";
        if (ext === ".html" || ext === ".htm") {
            return null;
        }
        var pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(ruleContext);
        var passed = pair && pair.name && pair.name.trim().length > 0;
        //let passed = ARIAMapper.computeName(ruleContext).trim().length > 0;
        if (passed) {
            return (0, IRule_1.RulePass)("pass");
        }
        else {
            return (0, IRule_1.RuleFail)("fail_no_text_alternative");
        }
    }
};


/***/ }),

/***/ 1252:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.page_title_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var ancestor_1 = __webpack_require__(9193);
exports.page_title_exists = {
    id: "page_title_exists",
    context: "dom:html",
    refactor: {
        "WCAG20_Doc_HasTitle": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2",
            "Fail_3": "Fail_3"
        }
    },
    help: {
        "en-US": {
            "group": "page_title_exists.html",
            "Pass_0": "page_title_exists.html",
            "Fail_1": "page_title_exists.html",
            "Fail_2": "page_title_exists.html",
            "Fail_3": "page_title_exists.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The page should have a title that correctly identifies the subject of the page",
            "Pass_0": "Rule Passed",
            "Fail_1": "Missing <head> element so there can be no <title> element present",
            "Fail_2": "Missing <title> element in <head> element",
            "Fail_3": "The <title> element is empty (no innerHTML)"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [{
            "2779a5": {
                "Pass_0": "pass",
                "Fail_1": "pass",
                "Fail_2": "fail",
                "Fail_3": "fail"
            }
        }],
    run: function (context, options, contextHierarchies) {
        // This rule does not apply inside a presentational frame
        if (ancestor_1.AncestorUtil.isFrame(contextHierarchies)) {
            return null;
        }
        var ruleContext = context["dom"].node;
        // First, find the head element
        var findHead = ruleContext.firstChild;
        var findTitle = null;
        while (findHead != null) {
            if (findHead.nodeName.toLowerCase() == "head")
                break;
            findHead = findHead.nextSibling;
        }
        var possibleTitles = ruleContext.querySelectorAll("title");
        for (var idx = 0; idx < possibleTitles.length; ++idx) {
            if (!CommonUtil_1.CommonUtil.getAncestor(possibleTitles[idx], ["svg"])) {
                findTitle = possibleTitles[idx];
                break;
            }
        }
        if (findHead === null) {
            if (!findTitle) {
                return (0, IRule_1.RuleFail)("Fail_1");
            }
        }
        if (findTitle === null) { // don't have title second PoF
            return (0, IRule_1.RuleFail)("Fail_2");
        }
        // if we get here we have <head> and <title>
        if (findTitle != null && CommonUtil_1.CommonUtil.getInnerText(findTitle).trim().length > 0) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else { // <title> has no innerHTML third PoF
            return (0, IRule_1.RuleFail)("Fail_3");
        }
    }
};


/***/ }),

/***/ 3576:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.page_title_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.page_title_valid = {
    id: "page_title_valid",
    context: "dom:head dom:title",
    refactor: {
        "RPT_Title_Valid": {
            "Pass_0": "Pass_0",
            // "Fail_1": "Fail_1",
            "Potential_2": "Potential_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "page_title_valid.html",
            // "Fail_1": "page_title_valid.html",
            "Potential_2": "page_title_valid.html",
            "group": "page_title_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            // "Fail_1": "Page <title> is empty",
            "Potential_2": "Verify that using the filename as the page <title> value is descriptive",
            "group": "Page <title> should be a descriptive title, rather than a filename"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var titleStr = CommonUtil_1.CommonUtil.getInnerText(ruleContext).trim();
        // allow .com, .net and .org
        var titleStrLowercase = titleStr.toLowerCase();
        if (titleStrLowercase.includes(".com") || titleStrLowercase.includes(".net") || titleStrLowercase.includes(".org")) {
            return (0, IRule_1.RulePass)("Pass_0", [titleStr]);
        }
        if (titleStr.length === 0) {
            // This is covered by page_title_exists
            return null; //RuleFail("Fail_1");
        }
        else {
            var passed = !/^\S*\.[a-zA-Z]{1,4}(?!.)|^https?:\/\/\S*/i.test(titleStr);
            if (!passed) {
                return (0, IRule_1.RulePotential)("Potential_2");
            }
            else {
                return (0, IRule_1.RulePass)("Pass_0", [titleStr]);
            }
        }
    }
};


/***/ }),

/***/ 3617:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.script_focus_blur_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.script_focus_blur_review = {
    id: "script_focus_blur_review",
    context: "dom:*[onfocus]",
    refactor: {
        "WCAG20_Script_FocusBlurs": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "script_focus_blur_review.html",
            "Potential_1": "script_focus_blur_review.html",
            "group": "script_focus_blur_review.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify script does not remove focus from content that normally receives focus",
            "group": "Scripting must not remove focus from content that normally receives focus"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.1.1", "2.4.7", "3.2.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = ruleContext.getAttribute("onfocus").indexOf(".blur(") == -1;
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 6110:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.script_onclick_avoid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.script_onclick_avoid = {
    id: "script_onclick_avoid",
    context: "dom:*[onclick]",
    dependencies: ["script_onclick_misuse"],
    refactor: {
        "RPT_Script_OnclickHTML2": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "script_onclick_avoid.html",
            "Potential_1": "script_onclick_avoid.html",
            "group": "script_onclick_avoid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that 'onclick' events are not used in script to emulate a link",
            "group": "Scripts should not be used to emulate links"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Don't trigger this for SVG element for now until a determination is made (by Rich)
        // to support SVG at a point when the SVG a11y spec is ready.
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, "svg")) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        // If there's an aria-role specified, don't trigger this.
        if (CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "role"))
            return (0, IRule_1.RulePass)("Pass_0");
        var nodeName = ruleContext.nodeName.toLowerCase();
        var passed = nodeName == "a" || nodeName == "area" || nodeName == "input";
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.script_onclick_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.script_onclick_misuse = {
    id: "script_onclick_misuse",
    context: "dom:*[onclick]",
    refactor: {
        "RPT_Script_OnclickHTML1": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "script_onclick_misuse.html",
            "Potential_1": "script_onclick_misuse.html",
            "group": "script_onclick_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Possible use of a script to emulate a link",
            "group": "Scripts should not be used to emulate links"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            failSubstring: {
                value: [".asp", ".aspx", ".cfm", ".cfml", ".cgi", ".htm", ".html", ".shtm",
                    ".shtml", ".php", ".pl", ".py", ".shtm", ".shtml", ".xhtml",
                    "location.href"],
                type: "[string]"
            }
        };
        var ruleContext = context["dom"].node;
        // If there's an aria-role specified, don't trigger this.
        var passed = CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "role");
        // If this is an a or area, don't trigger if there's an href.
        var nodeName = ruleContext.nodeName.toLowerCase();
        passed = passed || ((nodeName == "a" || nodeName == "area") && CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "href"));
        // If the guards failed, check to see if they're looking at links
        if (!passed) {
            var failSubstring = validateParams.failSubstring.value;
            ;
            var onclick_1 = ruleContext.getAttribute("onclick").toLowerCase();
            passed = true;
            for (var i = 0; passed && i < failSubstring.length; ++i) {
                passed = onclick_1.indexOf(failSubstring[i]) == -1;
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 1922:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.script_select_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.script_select_review = {
    id: "script_select_review",
    context: "dom:select",
    refactor: {
        "WCAG20_Select_NoChangeAction": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "script_select_review.html",
            "Potential_1": "script_select_review.html",
            "group": "script_select_review.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that no change of context or action occurs when selection options in this component receive focus",
            "group": "No changes of context should occur when a selection value receives focus"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["3.2.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = !ruleContext.hasAttribute("onchange") && !ruleContext.hasAttribute("onfocus");
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 7906:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.select_options_grouped = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.select_options_grouped = {
    id: "select_options_grouped",
    context: "dom:select",
    refactor: {
        "WCAG20_Select_HasOptGroup": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "select_options_grouped.html",
            "Potential_1": "select_options_grouped.html",
            "group": "select_options_grouped.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Group of related options may need <optgroup>",
            "group": "Groups of related options within a selection list should be grouped with <optgroup>"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            paramNumOptions: {
                value: 10,
                type: "integer"
            }
        };
        var ruleContext = context["dom"].node;
        // Handle the cases where optgroup is hidden, which should trigger a violations
        // but in the case that Check hidden option is set then should not trigger a violation.
        var passed = CommonUtil_1.CommonUtil.getChildByTagHidden(ruleContext, "optgroup", false, true).length > 0 ||
            CommonUtil_1.CommonUtil.getChildByTagHidden(ruleContext, "option", false, true).length <=
                validateParams.paramNumOptions.value;
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5451:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skip_main_described = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8656);
exports.skip_main_described = {
    id: "skip_main_described",
    context: "dom:body",
    dependencies: ["skip_main_exists"],
    refactor: {
        "WCAG20_Body_FirstAContainsSkipText_Native_Host_Sematics": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "skip_main_described.html",
            "Potential_1": "skip_main_described.html",
            "group": "skip_main_described.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that if this hyperlink skips content, the description communicates where it links to",
            "group": "The description of a hyperlink used to skip content must communicate where it links to"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            paramSkipText: {
                value: ["skip", "jump"],
                type: "[string]"
            }
        };
        var ruleContext = context["dom"].node;
        // Get the anchors on the page
        var doc = ruleContext.ownerDocument;
        // Check for landmarks first
        var passed;
        if (CacheUtil_1.CacheUtil.getCache(ruleContext, "IBM_hasLandmarks_Implicit", null) === null) {
            CacheUtil_1.CacheUtil.setCache(ruleContext, "IBM_hasLandmarks_Implicit", CommonUtil_1.CommonUtil.getElementsByRoleHidden(ruleContext.ownerDocument, ["application", "banner", "complementary", "contentinfo",
                "form", "main", "navigation", "search"
            ], true, true).length > 0);
        }
        passed = CacheUtil_1.CacheUtil.getCache(ruleContext, "IBM_hasLandmarks_Implicit", false);
        if (!passed) { // No landmarks, check for skip links
            var links = doc.links;
            // Skip link should be the first one on the page with an href attribute (i.e., links[0])
            // also if the first link is hidden then we should also trigger a violation.
            if (links && links.length > 0 && VisUtil_1.VisUtil.isNodeVisible(links[0])) {
                var testText = CommonUtil_1.CommonUtil.getInnerText(doc.links[0]).toLowerCase();
                for (var i = 0; !passed && i < validateParams.paramSkipText.value.length; ++i) {
                    passed = testText.indexOf(validateParams.paramSkipText.value[i]) != -1;
                }
            }
            else
                passed = false;
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 6349:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.skip_main_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var ancestor_1 = __webpack_require__(9193);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8656);
exports.skip_main_exists = {
    id: "skip_main_exists",
    context: "dom:body",
    refactor: {
        "WCAG20_Body_FirstASkips_Native_Host_Sematics": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "skip_main_exists.html",
            "Fail_1": "skip_main_exists.html",
            "group": "skip_main_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The page does not provide a way to quickly navigate to the main content (ARIA \"main\" landmark or a skip link)",
            "group": "Pages must provide a way to skip directly to the main content"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.4.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        // This rule does not apply inside a presentational frame
        if (ancestor_1.AncestorUtil.isPresentationFrame(contextHierarchies)) {
            return null;
        }
        var ruleContext = context["dom"].node;
        // Get the anchors on the page
        var doc = ruleContext.ownerDocument;
        // Check for landmarks first
        var passed;
        if (CacheUtil_1.CacheUtil.getCache(ruleContext, "IBM_hasLandmarks_Implicit", null) === null) {
            CacheUtil_1.CacheUtil.setCache(ruleContext, "IBM_hasLandmarks_Implicit", CommonUtil_1.CommonUtil.getElementsByRoleHidden(ruleContext.ownerDocument, ["application", "banner", "complementary", "contentinfo",
                "form", "main", "navigation", "search"
            ], true, true).length > 0);
        }
        passed = CacheUtil_1.CacheUtil.getCache(ruleContext, "IBM_hasLandmarks_Implicit", false);
        if (!passed) { // No landmarks, check for skip links
            var anchors = CommonUtil_1.CommonUtil.getDocElementsByTag(ruleContext, "a");
            // Skip anchor should be the first one on the page with an href attribute
            var testAnchor = null;
            for (var i = 0; i < anchors.length; ++i) {
                if (anchors[i].hasAttribute("href") && VisUtil_1.VisUtil.isNodeVisible(anchors[i])) {
                    testAnchor = anchors[i];
                    break;
                }
            }
            // Pull out the target id
            var targetId = null;
            if (testAnchor != null) {
                var hrefStr = testAnchor.getAttribute("href");
                var idx = hrefStr.indexOf("#");
                if (idx != -1) {
                    targetId = hrefStr.substring(idx + 1);
                }
            }
            // Determine if there is an element id or named anchor on the page with this
            // target id.
            if (targetId != null) {
                passed = doc.getElementById(targetId) != null;
                for (var i = 0; !passed && i < anchors.length; ++i) {
                    if (!anchors[i].hasAttribute("href") &&
                        anchors[i].hasAttribute("name") &&
                        anchors[i].getAttribute("name") == targetId) {
                        passed = true;
                    }
                }
            }
        }
        //return new ValidationResult(passed, [ruleContext], '', '', []);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 5393:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_background_decorative = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.style_background_decorative = {
    id: "style_background_decorative",
    context: "dom:style, dom:*[style]",
    refactor: {
        "RPT_Style_BackgroundImage": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "style_background_decorative.html",
            "Potential_1": "style_background_decorative.html",
            "group": "style_background_decorative.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify the CSS background image does not convey important information",
            "group": "Images included by using CSS alone must not convey important information"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var passed = true;
        if (nodeName === "link" && ruleContext.hasAttribute("rel") &&
            ruleContext.getAttribute("rel").toLowerCase() === "stylesheet") {
            // External stylesheet - trigger
            passed = CommonUtil_1.CommonUtil.triggerOnce(ruleContext, "style_background_decorative", false);
        }
        if (passed && nodeName === "style" || ruleContext.hasAttribute("style")) {
            var styleText = void 0;
            if (nodeName === "style")
                styleText = CommonUtil_1.CommonUtil.getInnerText(ruleContext);
            else
                styleText = ruleContext.getAttribute("style");
            var bgMatches = styleText.match(/background:[^;]*/g);
            if (bgMatches !== null) {
                for (var i = 0; passed && i < bgMatches.length; ++i)
                    passed = bgMatches[i].indexOf("url(") === -1;
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9887:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_before_after_review = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CSSUtil_1 = __webpack_require__(1775);
/**
 * Description: Trigger if :before and :after are used in CSS (Internal and External) with content
 * Origin: WCAG 2.0 F87
 */
exports.style_before_after_review = {
    id: "style_before_after_review",
    context: "dom:style, dom:link",
    refactor: {
        "WCAG20_Style_BeforeAfter": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "style_before_after_review.html",
            "Pass_0": "style_before_after_review.html",
            "Potential_1": "style_before_after_review.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Do not use CSS '::before' and '::after' pseudo-elements to insert non-decorative content",
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify the '::before' and '::after' pseudo-elements do not insert non-decorative content"
        }
    },
    rulesets: [{
            // Turn off the rule due to the obsolete requirement
            //id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            id: [],
            num: "1.3.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = true;
        //check Internal styles        
        if (ruleContext.nodeName.toLowerCase() === "style") {
            var css = CSSUtil_1.CSSUtil.getCSSStyle(ruleContext);
            for (var i = 0; passed && i < css.length; ++i) {
                // Guard against bad CSS
                if (css[i].selector) {
                    passed = (css[i].selector.indexOf(":before") === -1 && css[i].selector.indexOf(":after") === -1) ||
                        !("content" in css[i].values) || css[i].values["content"].trim().length === 0 || css[i].values["content"].trim() === "\"\""
                        || css[i].values["content"].trim() === "\'\'" || css[i].values["content"].trim() === "none" || css[i].values["content"].trim() === "attr(x)"
                        || css[i].values["content"].trim() === "attr(y)";
                }
            }
            // check special rules in the stylesheets
            if (passed) {
                for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                    var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                    if (sheet.ownerNode === ruleContext) {
                        try {
                            var styleRules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                            if (styleRules) {
                                for (var styleRuleIndex = 0; passed && styleRuleIndex < styleRules.length; styleRuleIndex++) {
                                    var styleRule = styleRules[styleRuleIndex];
                                    // check @media rules 
                                    //
                                    // The check 'if (styleRule instanceof CSSMediaRule)' doesn't work when run in Karma(but works in DAP) 
                                    // so let's access the type directly as a workaround
                                    var styleImportRule = void 0;
                                    if (styleRule.type && styleRule.type === 4 /* CSSRule.MEDIA_RULE */) {
                                        var styleMediaRule = styleRule;
                                        var mediaRules = styleMediaRule.cssRules;
                                        if (mediaRules) {
                                            for (var rIndex = 0; passed && rIndex < mediaRules.length; rIndex++) {
                                                var mRule = mediaRules[rIndex]; // selectorText not recognized
                                                if (mRule.selectorText !== null && mRule.selectorText !== undefined) {
                                                    var rule = mRule.selectorText.toLowerCase();
                                                    if (rule.indexOf(":before") !== -1 || rule.indexOf(":after") !== -1) {
                                                        var content = mRule.style['content'];
                                                        if (content && content.trim().length) {
                                                            if (content.trim() !== "\"\"" &&
                                                                content.trim() !== "\'\'" &&
                                                                content.trim() !== "none" &&
                                                                content.trim() !== "attr(x)" &&
                                                                content.trim() !== "attr(y)") {
                                                                passed = false;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    // check import rules
                                    else if (styleRule.type && styleRule.type === 3 /* CSSRule.IMPORT_RULE */ && (styleImportRule = styleRule).styleSheet) {
                                        var rules = styleImportRule.styleSheet.cssRules ?
                                            styleImportRule.styleSheet.cssRules :
                                            styleImportRule.styleSheet.rules;
                                        if (rules) {
                                            for (var rIndex = 0; passed && rIndex < rules.length; rIndex++) {
                                                var importedRule = rules[rIndex];
                                                // check @media rules 
                                                if (importedRule.type && importedRule.type === 4 /* CSSRule.MEDIA_RULE */) {
                                                    var mediaRules = importedRule.cssRules;
                                                    if (mediaRules) {
                                                        for (var mIndex = 0; mIndex < mediaRules.length; mIndex++) {
                                                            var mRule = mediaRules[mIndex]; // selectorText not recognized
                                                            if (mRule.selectorText !== null && mRule.selectorText !== undefined) {
                                                                var rule = mRule.selectorText.toLowerCase();
                                                                if (rule.indexOf(":before") !== -1 || rule.indexOf(":after") !== -1) {
                                                                    var content = mRule.style['content'];
                                                                    if (content && content.trim().length) {
                                                                        if (content.trim() !== "\"\"" &&
                                                                            content.trim() !== "\'\'" &&
                                                                            content.trim() !== "none" &&
                                                                            content.trim() !== "attr(x)" &&
                                                                            content.trim() !== "attr(y)") {
                                                                            passed = false;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (importedRule.selectorText !== null && importedRule.selectorText !== undefined) {
                                                    var rule = importedRule.selectorText.toLowerCase();
                                                    //support both single colon (:) and double colon (::) pseudo                        
                                                    if (rule.indexOf(":before") !== -1 || rule.indexOf(":after") !== -1) {
                                                        var content = importedRule.style['content'];
                                                        if (content && content.trim().length) {
                                                            if (content.trim() !== "\"\"" &&
                                                                content.trim() !== "\'\'" &&
                                                                content.trim() !== "none" &&
                                                                content.trim() !== "attr(x)" &&
                                                                content.trim() !== "attr(y)") {
                                                                passed = false;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        catch (e) {
                            // Ignore css access issues
                        }
                    }
                }
            }
        }
        //check external styles 
        if (ruleContext.nodeName.toLowerCase() === "link" && ruleContext.hasAttribute("rel") &&
            ruleContext.getAttribute("rel").toLowerCase() === "stylesheet" &&
            ruleContext.hasAttribute("href") && ruleContext.getAttribute("href").trim().length !== 0) {
            for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                if (sheet && sheet.ownerNode === ruleContext) {
                    try {
                        var rules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                        if (rules) {
                            for (var rIndex = 0; passed && rIndex < rules.length; rIndex++) {
                                var ruleFromLink = rules[rIndex];
                                // check @media rules 
                                if (ruleFromLink.type && ruleFromLink.type === 4 /* CSSRule.MEDIA_RULE */) {
                                    var mediaRules = ruleFromLink.cssRules;
                                    if (mediaRules) {
                                        for (var mIndex = 0; passed && mIndex < mediaRules.length; mIndex++) {
                                            var mRule = mediaRules[mIndex];
                                            if (mRule.selectorText !== null && mRule.selectorText !== undefined) {
                                                var ruleSelTxt = mRule.selectorText.toLowerCase();
                                                if (ruleSelTxt.indexOf(":before") !== -1 || ruleSelTxt.indexOf(":after") !== -1) {
                                                    var content = mRule.style['content'];
                                                    if (content && content.trim().length) {
                                                        if (content.trim() !== "\"\"" &&
                                                            content.trim() !== "\'\'" &&
                                                            content.trim() !== "none" &&
                                                            content.trim() !== "attr(x)" &&
                                                            content.trim() !== "attr(y)") {
                                                            passed = false;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                else if (rules[rIndex].selectorText !== null && rules[rIndex].selectorText !== undefined) {
                                    var rule = rules[rIndex].selectorText.toLowerCase();
                                    //support both single colon (:) and double colon (::) pseudo                        
                                    if (rule.indexOf(":before") !== -1 || rule.indexOf(":after") !== -1) {
                                        var content = rules[rIndex].style['content'];
                                        if (content && content.trim().length) {
                                            if (content.trim() !== "\"\"" &&
                                                content.trim() !== "\'\'" &&
                                                content.trim() !== "none" &&
                                                content.trim() !== "attr(x)" &&
                                                content.trim() !== "attr(y)") {
                                                passed = false;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (e) {
                        // Ignore css access issues
                    }
                }
            }
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5102:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_color_misuse = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var DOMWalker_1 = __webpack_require__(7440);
var CacheUtil_1 = __webpack_require__(7788);
exports.style_color_misuse = {
    id: "style_color_misuse",
    context: "dom:style, dom:*[style], dom:font[color], dom:link",
    refactor: {
        "RPT_Style_ColorSemantics1": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "style_color_misuse.html",
            "Pass_0": "style_color_misuse.html",
            "Potential_1": "style_color_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Combine color and descriptive markup to convey information",
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify color is not used as the only visual means of conveying information"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "1.4.1",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var styleText = "";
        if (nodeName === "style") {
            styleText = CommonUtil_1.CommonUtil.getInnerText(ruleContext).toLowerCase();
            // check import
            for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                if (sheet && sheet.ownerNode === ruleContext) {
                    try {
                        var styleRules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                        for (var styleRuleIndex = 0; styleRuleIndex < styleRules.length; styleRuleIndex++) {
                            var styleRule = styleRules[styleRuleIndex];
                            var styleImportRule = void 0;
                            if (styleRule.type && styleRule.type === 3 /* CSSRule.IMPORT_RULE */ && (styleImportRule = styleRule).styleSheet) {
                                var importRules = styleImportRule.styleSheet.cssRules ? styleImportRule.styleSheet.cssRules : styleImportRule.styleSheet.rules;
                                for (var rIndex = 0; rIndex < importRules.length; rIndex++) {
                                    var iRule = importRules[rIndex];
                                    styleText += iRule.cssText;
                                }
                            }
                        }
                    }
                    catch (e) {
                        // Silence css access issues
                    }
                }
            }
        }
        else if (ruleContext.hasAttribute("style")) {
            styleText = ruleContext.getAttribute("style").toLowerCase();
        }
        else if (nodeName === "link" && //check external styles
            ruleContext.hasAttribute("rel") &&
            ruleContext.getAttribute("rel").toLowerCase() === "stylesheet" &&
            ruleContext.hasAttribute("href") &&
            ruleContext.getAttribute("href").trim().length !== 0) {
            for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                if (sheet && sheet.ownerNode === ruleContext) {
                    try {
                        var rules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                        for (var rIndex = 0; rIndex < rules.length; rIndex++) {
                            styleText += rules[rIndex].cssText;
                        }
                    }
                    catch (e) {
                        // Silence css access issues
                    }
                }
            }
        }
        var passed = true;
        // Defect 1022: Find uses of 'color' and '*background*' only
        var isBgUsed = styleText.match(/\bbackground\b/i);
        var theColorStyleToCheck = styleText.replace(/-color/g, "");
        var isColorUsed = theColorStyleToCheck.match(/\bcolor\b/i);
        if (ruleContext.hasAttribute("color") || isColorUsed || isBgUsed) {
            var goodTagNames = {
                "em": "", "strong": "", "cite": "", "dfn": "",
                "code": "", "samp": "", "kbd": "", "var": "", "abbr": "", "acronym": ""
            };
            // Color used  are there semantics involved?
            passed = nodeName in goodTagNames ||
                CommonUtil_1.CommonUtil.getAncestor(ruleContext, goodTagNames) !== null;
            if (!passed && ruleContext.hasChildNodes()) {
                //let nw = new NodeWalker(ruleContext);
                var nw = new DOMWalker_1.DOMWalker(ruleContext);
                while (!passed && nw.nextNode() && nw.node !== ruleContext) {
                    passed = nw.node.nodeName.toLowerCase() in goodTagNames;
                }
            }
        }
        // Trigger only once
        if (!passed) {
            var triggered = CacheUtil_1.CacheUtil.getCache(ruleContext.ownerDocument, "style_color_misuse", false);
            passed = triggered;
            CacheUtil_1.CacheUtil.setCache(ruleContext.ownerDocument, "style_color_misuse", true);
        }
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 9977:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_focus_visible = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CSSUtil_1 = __webpack_require__(1775);
var ColorUtil_1 = __webpack_require__(8680);
exports.style_focus_visible = {
    id: "style_focus_visible",
    context: "dom:*",
    refactor: {
        "RPT_Style_HinderFocus1": {
            "Potential_1": "potential_focus_not_visible"
        }
    },
    help: {
        "en-US": {
            "group": "style_focus_visible.html",
            "potential_focus_not_visible": "style_focus_visible.html",
            "pass_focus_visible": "style_focus_visible.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The keyboard focus indicator should be visible when default border or outline is modified by CSS",
            "potential_focus_not_visible": "Check the keyboard focus indicator is visible when using CSS declaration for 'border' or 'outline'",
            "pass_focus_visible": "The keyboard focus indicator is visible or is not changed from the browser default"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "2.4.7",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var validateParams = {
            skipNodes: {
                value: ["table"],
                type: "[string]"
            },
            checkParams: {
                value: ["border", "border-width", "border-style",
                    "border-top-width", "border-right-width", "border-bottom-width", "border-left-width",
                    "border-top-color", "border-right-color", "border-bottom-color", "border-left-color",
                    "border-top-style", "border-right-style", "border-bottom-style", "border-left-style",
                    "outline", "outline-width", "outline-color", "outline-style"],
                type: "[string]"
            }
        };
        var ruleContext = context["dom"].node;
        if (!CommonUtil_1.CommonUtil.isTabbable(ruleContext) || validateParams.skipNodes.value.includes(ruleContext.nodeName.toLowerCase())) {
            return null;
        }
        var normalStyles = CSSUtil_1.CSSUtil.getDefinedStyles(ruleContext); // consider noth user-defined and browser default
        var focusStyles = [];
        focusStyles.push(CSSUtil_1.CSSUtil.getDefinedStyles(ruleContext, ":focus"));
        focusStyles.push(CSSUtil_1.CSSUtil.getDefinedStyles(ruleContext, ":focus-visible"));
        focusStyles.push(CSSUtil_1.CSSUtil.getDefinedStyles(ruleContext, ":focus-within"));
        // if focus style is defined
        var styleObj = focusStyles[0];
        if (Object.keys(styleObj).length > 0) {
            //pass if outline is not defined at all, browser will override 
            if (((!normalStyles["outline-width"] && !normalStyles["outline-style"])
                || (normalStyles["outline-width"] === '0px' || normalStyles["outline-style"] === 'none'))
                && (!styleObj["outline-style"] || styleObj["outline-style"] !== 'none'))
                return (0, IRule_1.RulePass)("pass_focus_visible");
            var noneStyle = false;
            var numOtherStyle = 0;
            for (var focusStyle in styleObj) {
                if (validateParams.checkParams.value.includes(focusStyle)) {
                    /**
                     * failure case:
                     *  1. focus outline or border style is none and no other style (color or width) defined
                     *  2. focus outline or border style is same with the normal
                     *  3. size in focus is same or smaller than default
                     *  4. color contrast in focus is better
                     */
                    var focusStyleValue = styleObj[focusStyle];
                    var normalStyleValue = normalStyles[focusStyle];
                    if (focusStyle.includes("style")) {
                        if (focusStyleValue === "none")
                            noneStyle = true;
                        else
                            noneStyle = false;
                        if (normalStyleValue && focusStyleValue !== "none" && focusStyleValue === normalStyleValue)
                            return (0, IRule_1.RulePotential)("potential_focus_not_visible");
                    }
                    else if (focusStyle.includes("width")) {
                        numOtherStyle++;
                        //proximation of the width style
                        if (focusStyleValue === 'initial')
                            focusStyleValue = '2px';
                        else if (focusStyleValue === 'thin')
                            focusStyleValue = '1px';
                        else if (focusStyleValue === 'medium')
                            focusStyleValue = '2px';
                        else if (focusStyleValue === 'thick')
                            focusStyleValue = '3px';
                        if (normalStyleValue) {
                            if (normalStyleValue === 'initial')
                                normalStyleValue = '2px';
                            else if (normalStyleValue === 'thin')
                                normalStyleValue = '1px';
                            else if (normalStyleValue === 'medium')
                                normalStyleValue = '2px';
                            else if (normalStyleValue === 'thick')
                                normalStyleValue = '3px';
                        }
                        focusStyleValue = CSSUtil_1.CSSUtil.getPixelsFromStyle(focusStyleValue, ruleContext);
                        normalStyleValue = CSSUtil_1.CSSUtil.getPixelsFromStyle(normalStyleValue, ruleContext);
                        if (focusStyleValue == 0 || focusStyleValue <= normalStyleValue)
                            return (0, IRule_1.RulePotential)("potential_focus_not_visible");
                    }
                    else if (focusStyle.includes("color")) {
                        numOtherStyle++;
                        // get the element bg color
                        var colorCombo = ColorUtil_1.ColorUtil.ColorCombo(ruleContext);
                        if (colorCombo === null)
                            continue;
                        var bg = colorCombo.bg;
                        if (!bg)
                            continue;
                        //proximation of the width style
                        if (focusStyleValue === 'initial')
                            focusStyleValue = 'black';
                        if (normalStyleValue && normalStyleValue === 'initial')
                            normalStyleValue = 'black';
                        // get the border/outline color as fg colors
                        focusStyleValue = ColorUtil_1.ColorUtil.Color(focusStyleValue);
                        normalStyleValue = ColorUtil_1.ColorUtil.Color(normalStyleValue);
                        if (focusStyleValue === null || normalStyleValue === null)
                            continue;
                        //get the border/outline color contrast ratios
                        var focusRatio = focusStyleValue.contrastRatio(bg);
                        var normalRatio = normalStyleValue.contrastRatio(bg);
                        if (focusRatio < 3.0 || focusRatio <= normalRatio)
                            return (0, IRule_1.RulePotential)("potential_focus_not_visible");
                    }
                    else {
                        //other
                        numOtherStyle++;
                        if (normalStyleValue != null && focusStyleValue === normalStyleValue)
                            return (0, IRule_1.RulePotential)("potential_focus_not_visible");
                    }
                }
            }
            // warn if a border/outline focus style is 'none' and noe other (color and/or width) is defined 
            if (noneStyle && numOtherStyle === 0)
                return (0, IRule_1.RulePotential)("potential_focus_not_visible");
        }
        else {
            // no focus style defined 
            // warn if normal style is defined and is not "none"
            for (var normalStyle in normalStyles) {
                if (validateParams.checkParams.value.includes(normalStyle)) {
                    var normalStyleValue = normalStyles[normalStyle];
                    // ignore if border or outline style is "none" 
                    if (normalStyleValue !== 'none')
                        return (0, IRule_1.RulePotential)("potential_focus_not_visible");
                }
            }
        }
        return (0, IRule_1.RulePass)("pass_focus_visible");
    }
};


/***/ }),

/***/ 8454:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_highcontrast_visible = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CacheUtil_1 = __webpack_require__(7788);
exports.style_highcontrast_visible = {
    id: "style_highcontrast_visible",
    context: "dom:style, dom:link, dom:*[style]",
    refactor: {
        "RPT_Style_Trigger2": {
            "Pass_0": "Pass_0",
            "Manual_1": "Manual_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "style_highcontrast_visible.html",
            "Manual_1": "style_highcontrast_visible.html",
            "group": "style_highcontrast_visible.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Manual_1": "Confirm Windows high contrast mode is supported when using CSS to include, position or alter non-decorative content",
            "group": "Windows high contrast mode must be supported when using CSS to include, position or alter non-decorative content"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next"],
            "num": ["1.1.1", "1.3.2", "1.4.11"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        },
        {
            "id": ["WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1", "1.3.2", "1.4.11"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (nodeName === "link" &&
            (!ruleContext.hasAttribute("rel") || ruleContext.getAttribute("rel").toLowerCase() !== "stylesheet"))
            return (0, IRule_1.RulePass)("Pass_0");
        if (nodeName !== "style" && nodeName !== "link" &&
            ruleContext.hasAttribute("style") && ruleContext.getAttribute("style").trim().length === 0)
            return (0, IRule_1.RulePass)("Pass_0");
        var triggered = CacheUtil_1.CacheUtil.getCache(ruleContext.ownerDocument, "style_highcontrast_visible", false);
        var passed = triggered;
        //        Packages.java.lang.System.out.println(triggered);
        CacheUtil_1.CacheUtil.setCache(ruleContext.ownerDocument, "style_highcontrast_visible", true);
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RuleManual)("Manual_1");
    }
};


/***/ }),

/***/ 25:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_hover_persistent = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.style_hover_persistent = {
    id: "style_hover_persistent",
    context: "dom:style, dom:*[style], dom:*",
    help: {
        "en-US": {
            "Pass_0": "style_hover_persistent.html",
            // "Pass_1": "style_hover_persistent.html",
            "Pass_2": "style_hover_persistent.html",
            "Potential_1": "style_hover_persistent.html",
            "Potential_2": "style_hover_persistent.html",
            "Potential_3": "style_hover_persistent.html",
            "group": "style_hover_persistent.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "the hover: pseudo-class is not used to display content",
            // "Pass_1": "content displayed via the :hover pseudo-class is a direct child of the trigger element",
            "Pass_2": "content displayed via the :hover pseudo-class is the adjacent sibling of the trigger element",
            "Potential_1": "Confirm the pointer can be positioned over the displayed element, not just the trigger",
            "Potential_2": "Confirm the pointer can be positioned over all the information displayed on hover",
            "Potential_3": "Confirm the margin style attribute has not prevented the pointer from hovering over the displayed element, not just the trigger",
            "group": "The pointer should be able to move over content displayed on hover"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_2"],
            "num": ["1.4.13"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var pass0 = false;
        var pass1 = false;
        var pass2 = false; // never happen
        var potential1 = false;
        var potential2 = false;
        var potential3 = false;
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var styleText = "";
        if (nodeName === "style") {
            // console.log("RULE RUN ******************");
            styleText = CommonUtil_1.CommonUtil.getInnerText(ruleContext).toLowerCase();
            // check import
            // console.log("ruleContext.ownerDocument.styleSheets.length = "+ruleContext.ownerDocument.styleSheets.length);
            for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; ++sIndex) {
                var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                if (sheet && sheet.ownerNode === ruleContext) {
                    try {
                        var styleRules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                        // console.log("styleRules.length = "+styleRules.length);
                        for (var styleRuleIndex = 0; styleRuleIndex < styleRules.length; styleRuleIndex++) {
                            // console.log("**********");
                            // console.log("********** FOR LOOP styleRuleIndex = "+styleRuleIndex);
                            var foundHover = false;
                            var hoverElement = "";
                            var plusCombinator = false;
                            var tildeCombinator = false;
                            var afterCombinatorElement = "";
                            var afterCombinatorElementDisplay = false;
                            var afterCombinatorElementDisplayValue = false;
                            var afterCombinatorElementHover = false;
                            var supportingElement = false;
                            var supportingHover = false;
                            var supportingHoverElementDisplayProperty = false;
                            var supportingHoverElementDisplayValue = false;
                            var adjacentPlusSibling = false;
                            var adjacentTildeMultipleSibling = false;
                            var styleRule = styleRules[styleRuleIndex];
                            var ruleText = styleRules[styleRuleIndex].cssText;
                            // console.log("styleRules["+styleRuleIndex+"] = "+ruleText);
                            // 1. Check for :hover
                            if (ruleText.match(/:hover/g)) {
                                foundHover = true;
                                // console.log("1. found :hover = "+ foundHover);
                                // 2. Get hover element
                                hoverElement = ruleText.split(":")[0];
                                // console.log("2. found element that goes with :hover = "+hoverElement);
                            }
                            else {
                                // console.log("1. No hover on css element so skip this rule");
                                continue; // if no :hover skip this rule
                            }
                            // 3a. Check for css combinator +
                            // 4a. if so do we have an after combinator element
                            var plusTempStr = ruleText.substring(ruleText.indexOf("+") + 1);
                            plusTempStr = plusTempStr.trim();
                            if (ruleText.match(/:hover \+/g) || ruleText.match(/:hover\+/g)) {
                                plusCombinator = true;
                                // console.log("3a. Found plusCombinator = "+ plusCombinator);
                                afterCombinatorElement = plusTempStr.split(" ")[0];
                                // console.log("4a. Found plus afterCombinatorElement = "+afterCombinatorElement);
                            }
                            // 3b. Check for css combinator +
                            // 4b. if so do we have an after combinator element
                            if (ruleText.match(/:hover \~/g) || ruleText.match(/:hover\~/g)) {
                                // console.log("match = "+ruleText.match(":hover \~"));
                                tildeCombinator = true;
                                // console.log("3b. Found tildeCombinator = "+ tildeCombinator);
                                var plusTempStr_1 = ruleText.substring(ruleText.indexOf("~") + 1);
                                plusTempStr_1 = plusTempStr_1.trim();
                                afterCombinatorElement = plusTempStr_1.split(" ")[0];
                                // console.log("4b. Found tilde afterCombinatorElement = "+afterCombinatorElement);
                            }
                            if (!plusCombinator && !tildeCombinator) {
                                // NO plusCombinator or tildeCombinator so skip this rule
                                // console.log("NO plusCombinator or tildeCombinator so PASS");
                                // console.log("**** REPORT PASS 0 HERE");
                                return (0, IRule_1.RulePass)("Pass_0"); // JCH: should we have a N/A pass
                            }
                            // So now we have a css element with hover - element:hover so we have problems
                            // to check
                            // 5. Check if the after combinator element has display: property
                            // 6. Check if display property is not none
                            if (afterCombinatorElement) {
                                // get index of display:
                                // console.log("plusTempStr = "+plusTempStr);
                                var index = plusTempStr.indexOf("display:");
                                if (index) {
                                    afterCombinatorElementDisplay = true;
                                    // console.log("5. Found afterCombinatorElementDisplay = "+afterCombinatorElementDisplay);
                                    if (plusTempStr.slice(index + 8).trim().split(" ")[0] !== "none;") {
                                        afterCombinatorElementDisplayValue = true;
                                        // console.log("6. Found afterCombinatorElementDisplayValue not none = "+afterCombinatorElementDisplayValue);
                                    }
                                    else {
                                        // console.log("afterCombinatorElementDisplayValue === none");
                                        // console.log("**** PUT POTENTIAL 0 HERE");
                                        continue;
                                    }
                                }
                                else {
                                    // this is bad css so it won't happen
                                    // console.log("NO afterCombinatorElementDisplay so skip this rule");
                                    continue;
                                }
                            }
                            else {
                                // this is bad css so it won't happen
                                // console.log("NO afterCombinatorElement so skip this rule");
                                continue;
                            }
                            if (afterCombinatorElementDisplayValue)
                                if (sheet && sheet.ownerNode === ruleContext) {
                                    // console.log("**** At this point we have verified that we have a css element with a hover of the format span:hover + div { display: block; } with all the proper properties and values");
                                    // NOTE: At this point we have verified that we have a css element with a hover
                                    //       of the format span:hover + div { display: block; }
                                    //       with all the proper properties and values
                                    try {
                                        var styleRules2 = sheet.cssRules ? sheet.cssRules : sheet.rules;
                                        // console.log("styleRules2.length = "+styleRules2.length);
                                        for (var styleRuleIndex2 = 0; styleRuleIndex2 < styleRules2.length; styleRuleIndex2++) {
                                            // Check rule for afterCominatorElement:hover
                                            // If find afterCombinatorElement:hover see if rule has property display: value where
                                            // value != none
                                            // console.log("**********");
                                            // console.log("********** 2nd FOR styleRuleIndex2 = "+styleRuleIndex2);
                                            var ruleText2 = styleRules[styleRuleIndex2].cssText;
                                            // console.log("ruleText2 = ", ruleText2);
                                            // console.log("afterCombinatorElement = "+afterCombinatorElement);
                                            // Check all supporting elements for margin property
                                            // If find margin STOP and REPORT ERROR
                                            var regExString = afterCombinatorElement + " {";
                                            var trimRuleText2 = ruleText2.trim();
                                            var regIndex = trimRuleText2.indexOf(regExString);
                                            var afterCombinatorElementProperties = trimRuleText2.slice(regIndex).trim();
                                            //if (!afterCombinatorElementProperties.match(/margin/g)) {
                                            if (!trimRuleText2.match(/margin/g)) {
                                                // console.log("No margin problem so continue on...");
                                                // do we have a supporting element css definitions
                                                var supportingHoverElement = ruleText2.split(":")[0];
                                                supportingHoverElement = supportingHoverElement.split(" ")[0];
                                                // console.log("supportingHoverElement = "+supportingHoverElement);
                                                // console.log("afterCombinatorElement = "+afterCombinatorElement);
                                                // NEED TO CHECK FOR afterCominatorElement:hover in ONE STEP
                                                if (supportingHoverElement === afterCombinatorElement && ruleText2.match(/:hover/g)) {
                                                    // console.log("7. Found supporting hover element same as afterCombinatorElement")
                                                    // 7. Found supporting hover element same as afterCombinatorElement
                                                    supportingElement = true;
                                                    // does supporting element have hover
                                                    // console.log("8. Supporting element has hover also = "+ foundHover);
                                                    // 8. Supporting element has hover also
                                                    supportingHover = true;
                                                    var index = ruleText2.indexOf("display:");
                                                    // console.log("index = "+index);
                                                    if (index) {
                                                        // 9. Found supportingHoverElementDisplayProperty
                                                        supportingHoverElementDisplayProperty = true;
                                                        // console.log("9. Found supportingHoverElementDisplayProperty = "+supportingHoverElementDisplayProperty);
                                                        if (plusTempStr.slice(index + 8).trim().split(" ")[0] !== "none;") {
                                                            // 10. Found supportingHoverElementDisplayValue not none
                                                            supportingHoverElementDisplayValue = true;
                                                            // console.log("10. Found supportingHoverElementDisplayValue not none = "+supportingHoverElementDisplayValue);
                                                            // Get list of hover elements and next sibling for +
                                                            // For + there must be at least one ADJACENT sibling
                                                            if (hoverElement !== "" && plusCombinator) {
                                                                var hoverElementList = ruleContext.ownerDocument.getElementsByTagName(hoverElement.toUpperCase());
                                                                // console.log("hoverElementList.length = "+hoverElementList.length);
                                                                // console.log("hoverElementList[0].tagName = "+hoverElementList[0].tagName);
                                                                // Get adjacent sibling
                                                                // console.log("Adjacent sibling = "+hoverElementList[0].nextElementSibling.tagName);
                                                                // console.log("afterCombinatorElement.toUpperCase() = "+afterCombinatorElement.toUpperCase());
                                                                if (afterCombinatorElement.toUpperCase() === hoverElementList[0].nextElementSibling.tagName) {
                                                                    // console.log("11a. Hover with plus has adjacent sibling.")
                                                                    // 11a. Hover with plus has adjacent sibling.
                                                                    adjacentPlusSibling = true;
                                                                    // At this point we have verified a supporting afterCombinatorElement css rule that contains hover and display property that is not equal to none and has a hover element in the body with an adjacent sibling
                                                                    // console.log("**** REPORT PASS 1 HERE");
                                                                    pass0 = true;
                                                                    continue;
                                                                }
                                                            }
                                                            else if (plusCombinator) {
                                                                // console.log("11a. Main hover with + combinator has no adjacent sibling");
                                                                if (!potential1) {
                                                                    // console.log("**** PUT POTENTIAL 1 HERE");
                                                                    potential1 = true;
                                                                    break;
                                                                }
                                                                continue;
                                                            }
                                                            // Get list of hover elements and determine if there are 2 or more adjacent siblings for ~
                                                            // For ~ there must be at least one ADJACENT sibling
                                                            if (hoverElement !== "" && tildeCombinator) {
                                                                // console.log("hoverElement.toUpperCase() = "+hoverElement.toUpperCase());
                                                                var hoverElementList = ruleContext.ownerDocument.getElementsByTagName(hoverElement.toUpperCase());
                                                                // console.log("hoverElementList.length = "+hoverElementList.length);
                                                                // Check for two or more adjacent siblings
                                                                var siblings = [];
                                                                var sibling = hoverElementList[0].nextElementSibling;
                                                                do {
                                                                    // console.log("sibling.tagName = "+sibling.tagName);
                                                                    if (sibling.tagName === afterCombinatorElement.toUpperCase()) {
                                                                        siblings.push(sibling);
                                                                    }
                                                                    else {
                                                                        break;
                                                                    }
                                                                } while ((sibling = sibling.nextElementSibling));
                                                                var siblingCount = siblings.length;
                                                                // console.log("siblingCount = "+siblingCount);
                                                                // JCH TODO: what if sibling count 0
                                                                if (siblingCount === 1) {
                                                                    // console.log("11b. Hover with tilde and one adjacent sibling");
                                                                    adjacentTildeMultipleSibling = true;
                                                                    // console.log("**** REPORT PASS 2 HERE");
                                                                    return (0, IRule_1.RulePass)("Pass_2");
                                                                }
                                                                else if (siblingCount > 1) {
                                                                    // console.log("Main hover with ~ combinator has two or more siblings");
                                                                    if (!potential2) {
                                                                        // console.log("**** PUT POTENTIAL 2 HERE");
                                                                        return (0, IRule_1.RulePotential)("Potential_2");
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        else if (plusCombinator) {
                                                            // supportingHoverElementDisplayValue
                                                            // if we make it to the last rule and supportingHoverElementDisplayValue is still false => potential1
                                                            if (styleRuleIndex2 === styleRules2.length - 1 && supportingHoverElementDisplayValue === false) {
                                                                // console.log("NO plus supportingHoverElementDisplayProperty");
                                                                // console.log("**** PUT POTENTIAL 1 HERE");
                                                                return (0, IRule_1.RulePotential)("Potential_1");
                                                            }
                                                            else {
                                                                continue;
                                                            }
                                                        }
                                                        else if (tildeCombinator) {
                                                            // if we make it to the last rule and supportingHoverElementDisplayValue is still false => potential2
                                                            if (styleRuleIndex2 === styleRules2.length - 1 && supportingHoverElementDisplayValue === false) {
                                                                // console.log("NO plus supportingHoverElementDisplayProperty");
                                                                // console.log("**** PUT POTENTIAL 2 HERE");
                                                                return (0, IRule_1.RulePotential)("Potential_1");
                                                            }
                                                            else {
                                                                continue;
                                                            }
                                                        }
                                                        // note at least one of the rules must have a display property
                                                    }
                                                    else if (plusCombinator) {
                                                        // if we make it to the last rule and supportingHoverElementDisplayProperty is still false => potential1
                                                        if (styleRuleIndex2 === styleRules2.length - 1 && supportingHoverElementDisplayProperty === false) {
                                                            // console.log("NO plus supportingHoverElementDisplayProperty");
                                                            // console.log("**** PUT POTENTIAL 1 HERE");
                                                            return (0, IRule_1.RulePotential)("Potential_1");
                                                        }
                                                        else {
                                                            continue;
                                                        }
                                                    }
                                                    else if (tildeCombinator) {
                                                        // if we make it to the last rule and supportingHoverElementDisplayProperty is still false => potential2
                                                        if (styleRuleIndex2 === styleRules2.length - 1 && supportingHoverElementDisplayProperty === false) {
                                                            // console.log("NO tilde supportingHoverElementDisplayProperty");
                                                            // console.log("**** PUT POTENTIAL 2 HERE");
                                                            return (0, IRule_1.RulePotential)("Potential_1");
                                                        }
                                                        else {
                                                            continue;
                                                        }
                                                    }
                                                    // note at least one of the rules must have a supportingElement:hover
                                                }
                                                else if (plusCombinator) {
                                                    // if we make it to the last rule and supportingElement is still false => potential1
                                                    // console.log("styleRuleIndex2 = "+styleRuleIndex2);
                                                    // console.log("styleRules2.length = "+styleRules2.length);
                                                    // console.log("supportingElement = "+supportingHover);
                                                    if (styleRuleIndex2 === styleRules2.length - 1 && supportingHover === false) {
                                                        // console.log("NO plus supportingElement:hover");
                                                        // console.log("**** PUT POTENTIAL 1 HERE");
                                                        return (0, IRule_1.RulePotential)("Potential_1");
                                                    }
                                                    else {
                                                        continue;
                                                    }
                                                }
                                                else if (tildeCombinator) {
                                                    // if we make it to the last rule and supportingElement is still false => potential2
                                                    // console.log("styleRuleIndex2 = "+styleRuleIndex2);
                                                    // console.log("styleRules2.length = "+styleRules2.length);
                                                    // console.log("supportingElement = "+supportingHover);
                                                    if (styleRuleIndex2 === styleRules2.length - 1 && supportingHover === false) {
                                                        // console.log("NO tilde supportingElement:hover");
                                                        // console.log("**** PUT POTENTIAL 2 HERE");
                                                        return (0, IRule_1.RulePotential)("Potential_2");
                                                    }
                                                    else {
                                                        continue;
                                                    }
                                                }
                                            }
                                            else {
                                                // console.log("There is a margin in the supporting element");
                                                if (!potential3) {
                                                    // console.log("**** PUT POTENTIAL 3 HERE");
                                                    potential3 = true;
                                                    return (0, IRule_1.RulePotential)("Potential_3");
                                                }
                                            }
                                        }
                                    }
                                    catch (e) {
                                        // Silence css access issues
                                    }
                                }
                        }
                    }
                    catch (e) {
                        // Silence css access issues
                    }
                }
            }
        }
        // console.log("----------------------");
        // console.log("pass0 = "+pass0);
        // console.log("pass1 = "+pass1);
        // console.log("pass2 = "+pass2);
        // console.log("potential1 = "+potential1);
        // console.log("potential2 = "+potential2);
        // console.log("potential3 = "+potential3);
        if (pass0)
            return (0, IRule_1.RulePass)("Pass_0");
        // if (pass1) return RulePass("Pass_2"); // Doesn't trigger
        // if (pass2) return RulePass("Pass_3"); // Doesn't trigger
        if (potential1)
            return (0, IRule_1.RulePotential)("Potential_1");
        if (potential2)
            return (0, IRule_1.RulePotential)("Potential_2");
        if (potential3)
            return (0, IRule_1.RulePotential)("Potential_3");
    }
};


/***/ }),

/***/ 2884:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.style_viewport_resizable = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
/**
 * Description: Trigger when viewport units are used for font size.
 * Origin: Various
 */
exports.style_viewport_resizable = {
    id: "style_viewport_resizable",
    context: "dom:link, dom:style, dom:*[style]",
    refactor: {
        "WCAG21_Style_Viewport": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "group": "style_viewport_resizable.html",
            "Pass_0": "style_viewport_resizable.html",
            "Potential_1": "style_viewport_resizable.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Text must scale up to 200% without loss of content or functionality",
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify that text sized using viewport units can be resized up to 200%"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: ["1.4.4", "1.4.10"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = true;
        var thePattern = /\d+(vw|vh|vmin|vmax)/gi;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (nodeName === "style") {
            for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                if (sheet.ownerNode === ruleContext) {
                    try {
                        var styleRules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                        if (styleRules) {
                            for (var styleRuleIndex = 0; passed && styleRuleIndex < styleRules.length; styleRuleIndex++) {
                                var rule = styleRules[styleRuleIndex];
                                if (rule.type && rule.type === 1 /* CSSRule.STYLE_RULE */) {
                                    var styleRule = rule;
                                    if (styleRule.style['fontSize']) {
                                        var fontSize = styleRule.style['fontSize'].trim();
                                        var found = fontSize.match(thePattern);
                                        if (fontSize.length && found) {
                                            passed = false;
                                        }
                                    }
                                }
                                // check import rules
                                else if (rule.type && rule.type === 3 /* CSSRule.IMPORT_RULE */ && rule.styleSheet) {
                                    var importRule = rule;
                                    var rules = importRule.styleSheet.cssRules ? importRule.styleSheet.cssRules : importRule.styleSheet.rules;
                                    if (rules) {
                                        for (var rIndex = 0; passed && rIndex < rules.length; rIndex++) {
                                            var importedRule = rules[rIndex];
                                            if (importedRule.type && importedRule.type === 1 /* CSSRule.STYLE_RULE */) {
                                                if (importedRule.style['fontSize']) {
                                                    var fontSize = importedRule.style['fontSize'].trim();
                                                    var found = fontSize.match(thePattern);
                                                    if (fontSize.length && found) {
                                                        passed = false;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (e) {
                        // Ignore css access issues
                    }
                }
            }
        }
        else if (nodeName === "link") {
            for (var sIndex = 0; sIndex < ruleContext.ownerDocument.styleSheets.length; sIndex++) {
                var sheet = ruleContext.ownerDocument.styleSheets[sIndex];
                if (sheet && sheet.ownerNode === ruleContext) {
                    try {
                        var rules = sheet.cssRules ? sheet.cssRules : sheet.rules;
                        if (rules) {
                            for (var rIndex = 0; passed && rIndex < rules.length; rIndex++) {
                                var ruleFromLink = rules[rIndex];
                                // check rules 
                                if (ruleFromLink.type && ruleFromLink.type === 1 /* CSSRule.STYLE_RULE */) {
                                    if (ruleFromLink.style['fontSize']) {
                                        var fontSize = ruleFromLink.style['fontSize'].trim();
                                        var found = fontSize.match(thePattern);
                                        if (fontSize.length && found) {
                                            passed = false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (e) {
                        // Ignore css access issues
                    }
                }
            }
        }
        else {
            var styleValue = ruleContext.getAttribute('style');
            if (styleValue) {
                var stylePattern = /font-size:\s*\d+(vw|vh|vmin|vmax)/gi;
                var found = styleValue.match(stylePattern);
                if (found) {
                    passed = false;
                }
            }
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 5390:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.svg_graphics_labelled = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AccNameUtil_1 = __webpack_require__(1421);
var VisUtil_1 = __webpack_require__(8656);
exports.svg_graphics_labelled = {
    id: "svg_graphics_labelled",
    context: "dom:svg",
    help: {
        "en-US": {
            "group": "svg_graphics_labelled.html",
            "pass": "svg_graphics_labelled.html",
            "fail_acc_name": "svg_graphics_labelled.html"
        }
    },
    messages: {
        "en-US": {
            "group": "A non-decorative SVG element must have an accessible name",
            "pass": "The SVG element has an accessible name",
            "fail_acc_name": "The SVG element has no accessible name"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [{
            "7d6734": {
                "pass": "pass",
                "fail_acc_name": "fail"
            }
        }],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || VisUtil_1.VisUtil.isNodePresentational(ruleContext) || AccNameUtil_1.AccNameUtil.isAccessibleNameIgnorable(ruleContext))
            return null;
        var name_pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(ruleContext);
        if (name_pair && name_pair.name && name_pair.name.trim().length > 0)
            return (0, IRule_1.RulePass)("pass");
        return (0, IRule_1.RuleFail)("fail_acc_name");
    }
};


/***/ }),

/***/ 7196:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_aria_descendants = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.table_aria_descendants = {
    id: "table_aria_descendants",
    context: "aria:table dom:tr[role], aria:table dom:th[role], aria:table dom:td[role], aria:grid dom:tr[role], aria:grid dom:th[role], aria:grid dom:td[role], aria:treegrid dom:tr[role], aria:treegrid dom:th[role], aria:treegrid dom:td[role]",
    help: {
        "en-US": {
            "group": "table_aria_descendants.html",
            "explicit_role": "table_aria_descendants.html"
        }
    },
    messages: {
        "en-US": {
            "group": "Table structure elements cannot specify an explicit 'role' within table containers",
            "explicit_role": "An explicit ARIA 'role' is not valid for <{0}> element within an ARIA role '{1}' per the ARIA in HTML specification"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["4.1.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var parentRole = CommonUtil_1.CommonUtil.isTableDescendant(contextHierarchies);
        // cache the result
        if (parentRole === null || parentRole.length === 0)
            return;
        return (0, IRule_1.RuleFail)("explicit_role", [context["dom"].node.nodeName.toLowerCase(), parentRole[0].role]);
    }
};


/***/ }),

/***/ 9965:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_caption_empty = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.table_caption_empty = {
    id: "table_caption_empty",
    context: "dom:caption",
    refactor: {
        "Valerie_Caption_HasContent": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_caption_empty.html",
            "Fail_1": "table_caption_empty.html",
            "group": "table_caption_empty.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The <table> element has an empty <caption> element",
            "group": "A <caption> element for a <table> element must contain descriptive text"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = CommonUtil_1.CommonUtil.hasInnerContentHidden(ruleContext);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4468:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_caption_nested = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.table_caption_nested = {
    id: "table_caption_nested",
    context: "dom:caption",
    refactor: {
        "Valerie_Caption_InTable": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_caption_nested.html",
            "Fail_1": "table_caption_nested.html",
            "group": "table_caption_nested.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "<caption> element is not nested inside a <table> element",
            "group": "The <caption> element must be nested inside the associated <table> element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var passed = CommonUtil_1.CommonUtil.getAncestor(ruleContext, "table") != null;
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4451:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_headers_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var TableUtil_1 = __webpack_require__(5755);
exports.table_headers_exists = {
    id: "table_headers_exists",
    context: "dom:table",
    refactor: {
        "RPT_Table_DataHeadingsAria": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_headers_exists.html",
            "Fail_1": "table_headers_exists.html",
            "group": "table_headers_exists.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Table has no headers identified",
            "group": "Data table must identify headers"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // If this is a layout table or there are no rows, the rule does not apply.
        var rows = ruleContext.rows;
        if (!TableUtil_1.TableUtil.isDataTable(ruleContext) || rows === null || rows.length === 0)
            return null;
        var passed = TableUtil_1.TableUtil.tableHeaderExists(ruleContext);
        if (passed === null)
            return;
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 6087:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_headers_ref_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var DOMUtil_1 = __webpack_require__(295);
var VisUtil_1 = __webpack_require__(8656);
var ARIAMapper_1 = __webpack_require__(4944);
exports.table_headers_ref_valid = {
    id: "table_headers_ref_valid",
    context: "dom:td[headers], dom:th[headers]",
    help: {
        "en-US": {
            "Pass_0": "table_headers_ref_valid.html",
            "Fail_1": "table_headers_ref_valid.html",
            "Fail_2": "table_headers_ref_valid.html",
            "Fail_3": "table_headers_ref_valid.html",
            "Fail_4": "table_headers_ref_valid.html",
            "group": "table_headers_ref_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The 'headers' attribute value \"{0}\" does not reference a valid 'id' in this document",
            "Fail_2": "The 'headers' attribute value \"{0}\" refers to itself",
            "Fail_3": "The 'headers' attribute value \"{0}\" does not refer to a cell in the same table",
            "Fail_4": "The 'headers' attribute value \"{0}\" does not refer to a cell indicated with <th> or a role of \"columnheader\" or \"rowheader\"",
            "group": "The 'headers' attribute should refer to a valid cell in the same table"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: ["a25f45"],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var parentTable = CommonUtil_1.CommonUtil.getAncestor(ruleContext, "table");
        var parentRole = ARIAMapper_1.ARIAMapper.nodeToRole(parentTable);
        // If this is a layout table or a simple table the rule does not apply.
        if (parentTable == null || !VisUtil_1.VisUtil.isNodeVisible(parentTable) || !["table", "grid"].includes(parentRole))
            return null;
        var nodeName = ruleContext.nodeName.toLowerCase();
        var doc = ruleContext.ownerDocument;
        var value = ruleContext.getAttribute("headers");
        if (!value)
            return null;
        var ids = value.split(" ");
        var invalidHeaderValues = [];
        var sameNodeHeaderValues = [];
        var sameTableHeaderValues = [];
        var invalidElemHeaderValues = [];
        for (var i = 0; i < ids.length; i++) {
            var id = ids[i];
            if (id.trim() === '')
                continue;
            var elem = doc.getElementById(id);
            if (!elem)
                invalidHeaderValues.push(id);
            else if (DOMUtil_1.DOMUtil.sameNode(elem, ruleContext))
                sameNodeHeaderValues.push(id);
            else if (!DOMUtil_1.DOMUtil.isInSameTable(elem, ruleContext))
                sameTableHeaderValues.push(id);
            else {
                var elemName = elem.nodeName.toLowerCase();
                if (elemName !== 'th') {
                    var roles = AriaUtil_1.AriaUtil.getRoles(elem, true);
                    if (!roles.includes('columnheader') && !roles.includes('rowheader'))
                        invalidElemHeaderValues.push(id);
                }
            }
        }
        var results = [];
        if (invalidHeaderValues.length != 0)
            results.push((0, IRule_1.RuleFail)("Fail_1", [invalidHeaderValues.toString()]));
        if (sameNodeHeaderValues.length != 0)
            results.push((0, IRule_1.RuleFail)("Fail_2", [sameNodeHeaderValues.toString()]));
        if (sameTableHeaderValues.length != 0)
            results.push((0, IRule_1.RuleFail)("Fail_3", [sameTableHeaderValues.toString()]));
        if (invalidElemHeaderValues.length != 0)
            results.push((0, IRule_1.RuleFail)("Fail_4", [invalidElemHeaderValues.toString()]));
        if (results.length == 0) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return results;
        }
    }
};


/***/ }),

/***/ 5864:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_headers_related = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var CacheUtil_1 = __webpack_require__(7788);
var TableUtil_1 = __webpack_require__(5755);
exports.table_headers_related = {
    id: "table_headers_related",
    context: "dom:td, dom:th",
    refactor: {
        "Valerie_Table_DataCellRelationships": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_headers_related.html",
            "Fail_1": "table_headers_related.html",
            "group": "table_headers_related.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Complex table does not have headers for each cell properly defined with 'header' or 'scope'",
            "group": "For a complex data table, all <th> and <td> elements must be related via 'header' or 'scope' attributes"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var parentTable = CommonUtil_1.CommonUtil.getAncestor(ruleContext, "table");
        // If this is a layout table or a simple table the rule does not apply.
        if (parentTable == null || !TableUtil_1.TableUtil.isComplexDataTable(parentTable))
            return null;
        // If this table hasn't been preprocessed, process it.
        if (CacheUtil_1.CacheUtil.getCache(ruleContext, "table_headers_related", null) === null) {
            // Build a grid that's actually usable (rowspan and colspan elements are duplicated)
            // This builds a real 2d table array.
            var grid = [];
            for (var i = 0; i < parentTable.rows.length; ++i) {
                var row = parentTable.rows[i];
                if (!grid[i])
                    grid[i] = [];
                for (var j = 0; j < row.cells.length; ++j) {
                    var cell = row.cells[j];
                    CacheUtil_1.CacheUtil.setCache(cell, "table_headers_related", i + ":" + j);
                    var width = parseInt(cell.getAttribute("colspan"));
                    if (!width)
                        width = 1;
                    var height = parseInt(cell.getAttribute("rowspan"));
                    if (!height)
                        height = 1;
                    var gX = 0;
                    while (grid[i][gX])
                        gX += 1;
                    for (var k = 0; k < height; ++k) {
                        if (!grid[i + k])
                            grid[i + k] = [];
                        for (var l = 0; l < width; ++l) {
                            grid[i + k][gX + l] = cell;
                        }
                    }
                }
            }
            // Iterate through the table grid and record headers that point to cells and
            // cells that are pointed to by headers
            var doc = ruleContext.ownerDocument;
            var lookup = {};
            var scopedCols = {};
            for (var i = 0; i < grid.length; ++i) {
                var rowScoped = false;
                for (var j = 0; j < grid[i].length; ++j) {
                    var gridCell = grid[i][j];
                    var gridNodeName = gridCell.nodeName.toLowerCase();
                    if (gridNodeName == "th") {
                        if (gridCell.getAttribute("scope") == "row") {
                            rowScoped = true;
                            // If there's an axis attribute, it must be referred to by headers,
                            // scope is not enough.
                            if (!CommonUtil_1.CommonUtil.attributeNonEmpty(gridCell, "axis"))
                                lookup[CacheUtil_1.CacheUtil.getCache(gridCell, "table_headers_related", null)] = true;
                        }
                        else if (gridCell.getAttribute("scope") == "col") {
                            scopedCols[j] = true;
                            // If there's an axis attribute, it must be referred to by headers,
                            // scope is not enough.
                            if (!CommonUtil_1.CommonUtil.attributeNonEmpty(gridCell, "axis"))
                                lookup[CacheUtil_1.CacheUtil.getCache(gridCell, "table_headers_related", null)] = true;
                        }
                        // Headers can refer to other headers
                        if (CommonUtil_1.CommonUtil.attributeNonEmpty(gridCell, "headers")) {
                            var hdrs = gridCell.getAttribute("headers").split(" ");
                            for (var k = 0; k < hdrs.length; ++k) {
                                var headElem = doc.getElementById(hdrs[k].trim());
                                if (headElem && CommonUtil_1.CommonUtil.getAncestor(headElem, "table") == parentTable) {
                                    lookup[CacheUtil_1.CacheUtil.getCache(headElem, "table_headers_related", null)] = true;
                                }
                            }
                        }
                    }
                    else if (gridNodeName == "td") {
                        if (rowScoped || scopedCols[j]) {
                            lookup[CacheUtil_1.CacheUtil.getCache(gridCell, "table_headers_related", null)] = true;
                        }
                        else if (CommonUtil_1.CommonUtil.attributeNonEmpty(gridCell, "headers")) {
                            var hdrs = gridCell.getAttribute("headers").split(" ");
                            for (var k = 0; k < hdrs.length; ++k) {
                                var headElem = doc.getElementById(hdrs[k].trim());
                                if (headElem && CommonUtil_1.CommonUtil.getAncestor(headElem, "table") == parentTable) {
                                    lookup[CacheUtil_1.CacheUtil.getCache(gridCell, "table_headers_related", null)] = true;
                                    lookup[CacheUtil_1.CacheUtil.getCache(headElem, "table_headers_related", null)] = true;
                                }
                            }
                        }
                    }
                }
            }
            CacheUtil_1.CacheUtil.setCache(parentTable, "table_headers_related", lookup);
        }
        var rcInfo = CacheUtil_1.CacheUtil.getCache(ruleContext, "table_headers_related", null);
        var tInfo = CacheUtil_1.CacheUtil.getCache(parentTable, "table_headers_related", null);
        var passed = rcInfo && tInfo && rcInfo in tInfo;
        if (!passed && rcInfo === "0:0" &&
            CommonUtil_1.CommonUtil.getInnerText(ruleContext).trim().length == 0) {
            // We don't test if it's the upper-left cell and it's empty
            return null;
        }
        // If the table has no th's, it may just be that this was supposed to be a layout
        // table, which introduces a lot of noise.  In that case, only trigger this error
        // once per table.
        if (!passed && parentTable.getElementsByTagName("th").length == 0) {
            if (CacheUtil_1.CacheUtil.getCache(parentTable, "table_headers_related_TrigOnce", false) === true) {
                passed = true;
            }
            else {
                CacheUtil_1.CacheUtil.setCache(parentTable, "table_headers_related_TrigOnce", true);
            }
        }
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 4066:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_layout_linearized = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var VisUtil_1 = __webpack_require__(8656);
var TableUtil_1 = __webpack_require__(5755);
exports.table_layout_linearized = {
    id: "table_layout_linearized",
    context: "dom:table",
    refactor: {
        "RPT_Table_LayoutTrigger": {
            "Pass_0": "Pass_0",
            "Potential_1": "Potential_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_layout_linearized.html",
            "Potential_1": "table_layout_linearized.html",
            "group": "table_layout_linearized.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "Verify table is not being used to format text content in columns unless the table can be linearized",
            "group": "Avoid using tables to format text documents in columns unless the table can be linearized"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.RECOMMENDATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_FOUR
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        var passed = !TableUtil_1.TableUtil.isLayoutTable(ruleContext);
        if (passed)
            return (0, IRule_1.RulePass)("Pass_0");
        if (!passed)
            return (0, IRule_1.RulePotential)("Potential_1");
    }
};


/***/ }),

/***/ 2841:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_scope_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
exports.table_scope_valid = {
    id: "table_scope_valid",
    context: "dom:td[scope], dom:th[scope]",
    refactor: {
        "WCAG20_Table_Scope_Valid": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1",
            "Fail_2": "Fail_2"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_scope_valid.html",
            "Fail_1": "table_scope_valid.html",
            "Fail_2": "table_scope_valid.html",
            "group": "table_scope_valid.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "Value provided is invalid for the 'scope' attribute",
            "Fail_2": "The 'scope' attribute should only be used on a <th> element",
            "group": "Value for 'scope' attribute must be \"row\", \"col\", \"rowgroup\", or \"colgroup\""
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        if (nodeName === 'td')
            return (0, IRule_1.RuleFail)("Fail_2");
        //only continue for 'th'
        var scopeVal = ruleContext.getAttribute("scope").trim().toLowerCase();
        var passed = /^(row|col|rowgroup|colgroup)$/.test(scopeVal);
        if (!passed) {
            return (0, IRule_1.RuleFail)("Fail_1");
        }
        else {
            return (0, IRule_1.RulePass)("Pass_0");
        }
    }
};


/***/ }),

/***/ 272:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_structure_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
var TableUtil_1 = __webpack_require__(5755);
exports.table_structure_misuse = {
    id: "table_structure_misuse",
    context: "dom:table",
    refactor: {
        "WCAG20_Table_Structure": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_structure_misuse.html",
            "Fail_1": "table_structure_misuse.html",
            "group": "table_structure_misuse.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The <{0}> element with \"presentation\" role or \"none\" role has structural element(s) and/or attribute(s) '{1}'",
            "group": "Table elements with 'role=\"presentation\" or 'role=\"none\" should not have structural elements or attributes"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the rule
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext))
            return null;
        // JCH - OUT OF SCOPE hidden in context
        if (TableUtil_1.TableUtil.isDataTable(ruleContext))
            return null;
        if (AriaUtil_1.AriaUtil.isNodeInGrid(ruleContext))
            return null;
        var errorNodes = [];
        if (CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "summary"))
            errorNodes.push(ruleContext);
        var captionElems = ruleContext.getElementsByTagName("caption");
        for (var i = 0; i < captionElems.length; ++i) {
            if (CommonUtil_1.CommonUtil.getAncestor(captionElems[i], "table") == ruleContext) {
                // Check if the node should be skipped or not based on the Check Hidden Content setting and if the node isVisible or
                // not.
                if (CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(captionElems[i])) {
                    continue;
                }
                // Add the node to the errorNodes
                errorNodes.push(captionElems[i]);
                // Since we are not actually making use of theses errorNodes even though they are passed along with
                // ValidationResult, we do not need to keep looping over and getting every single violating node under
                // the rule context. This can be a future enhancenment where we actually make use of the error nodes that
                // are passed along. Adding this break to speed up performance at this point.
                break; // There is no point to keep adding the error nodes, stop after finding the first one
            }
        }
        var thNodes = ruleContext.getElementsByTagName("th");
        for (var i = 0; i < thNodes.length; ++i) {
            if (CommonUtil_1.CommonUtil.getAncestor(thNodes[i], "table") == ruleContext) {
                // Check if the node should be skipped or not based on the Check Hidden Content setting and if the node isVisible or
                // not.
                if (CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(thNodes[i])) {
                    continue;
                }
                // Add the node to the errorNodes
                errorNodes.push(thNodes[i]);
                // Since we are not actually making use of theses errorNodes even though they are passed along with
                // ValidationResult, we do not need to keep looping over and getting every single violating node under
                // the rule context. This can be a future enhancenment where we actually make use of the error nodes that
                // are passed along. Adding this break to speed up performance at this point.
                break; // There is no point to keep adding the error nodes, stop after finding the first one
            }
        }
        var tdNodes = ruleContext.getElementsByTagName("td");
        for (var i = 0; i < tdNodes.length; ++i) {
            if ((tdNodes[i].hasAttribute("scope") || tdNodes[i].hasAttribute("headers")) &&
                CommonUtil_1.CommonUtil.getAncestor(tdNodes[i], "table") == ruleContext) {
                // Check if the node should be skipped or not based on the Check Hidden Content setting and if the node isVisible or
                // not.
                if (CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(tdNodes[i])) {
                    continue;
                }
                // Add the node to the errorNodes
                errorNodes.push(tdNodes[i]);
                // Since we are not actually making use of theses errorNodes even though they are passed along with
                // ValidationResult, we do not need to keep looping over and getting every single violating node under
                // the rule context. This can be a future enhancenment where we actually make use of the error nodes that
                // are passed along. Adding this break to speed up performance at this point.
                break; // There is no point to keep adding the error nodes, stop after finding the first one
            }
        }
        // Get the node name for the rule context element in this case it will always be table
        var currentElementToken = ruleContext.nodeName.toLowerCase();
        // Construct a new array which will contan only the element tag for the violation elements
        var structuralElementTokens = new Array();
        // Construct a seen hash that will keep trask of all the elements that were already added to the token array, to make sure
        // we do not duplicate any of the elements. Duplicate element tags in the token message looks bad and confusing.
        var seen = {};
        // Loop through all the violating structural elements and extract the element tag to be used as a token
        for (var i = 0; i < errorNodes.length; i++) {
            // Get the node name (tag name) for the violating structural element
            var nodeName = errorNodes[i].nodeName.toLowerCase();
            // Only need to add the violating element once
            if (!seen.hasOwnProperty(nodeName)) {
                // Since we are adding the token as elements and attributes we need to handle
                // the summary attribute on the ruleContext (table). We only add summary once, same as
                // for elements to avoid duplication in the message. (Summary should not duplicate, but just in case)
                if (nodeName == "table" && !seen.hasOwnProperty["summary"]) {
                    // Mark this as a new attribute
                    seen["summary"] = true;
                    // Since this is a new violating element add it to the structural element tokens array
                    structuralElementTokens.push("summary");
                }
                else {
                    // Mark this as a new element
                    seen[nodeName] = true;
                    // Since this is a new violating element add it to the structural element tokens array
                    structuralElementTokens.push(nodeName);
                }
            }
        }
        // We need to take the array of structural elements and join them with a comma and a space to make grammatical correct in
        // the message.
        var structuralElementTokensStr = structuralElementTokens.join(", ");
        //return new ValidationResult(errorNodes.length == 0, errorNodes, '', '', [currentElementToken, structuralElementTokens]);
        if (errorNodes.length == 0) {
            return (0, IRule_1.RulePass)("Pass_0");
        }
        else {
            return (0, IRule_1.RuleFail)("Fail_1", [currentElementToken, structuralElementTokensStr]);
        }
    }
};


/***/ }),

/***/ 1348:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.table_summary_redundant = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var fragment_1 = __webpack_require__(482);
var DOMUtil_1 = __webpack_require__(295);
exports.table_summary_redundant = {
    id: "table_summary_redundant",
    context: "dom:table",
    refactor: {
        "WCAG20_Table_CapSummRedundant": {
            "Pass_0": "Pass_0",
            "Fail_1": "Fail_1"
        }
    },
    help: {
        "en-US": {
            "Pass_0": "table_summary_redundant.html",
            "Fail_1": "table_summary_redundant.html",
            "group": "table_summary_redundant.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Fail_1": "The table summary duplicates the caption",
            "group": "The table summary must not duplicate the caption"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var pofId;
        var passed = true;
        var sumStr;
        if (ruleContext.hasAttribute("summary")) {
            pofId = 0;
            sumStr = ruleContext.getAttribute("summary").trim().toLowerCase();
        }
        else if (ruleContext.hasAttribute("aria-describedby")) {
            pofId = 1;
            var summaryNodeIds = ruleContext.getAttribute("aria-describedby").split(" ");
            var summaryNodeConcat = "";
            for (var i = 0; i < summaryNodeIds.length; i++) {
                var summaryNodeId = summaryNodeIds[i];
                if (summaryNodeId) {
                    var summaryNode = fragment_1.FragmentUtil.getById(ruleContext, summaryNodeId);
                    if (summaryNode && !DOMUtil_1.DOMUtil.sameNode(summaryNode, ruleContext)) {
                        summaryNodeConcat += " " + CommonUtil_1.CommonUtil.getInnerText(summaryNode).trim().toLowerCase();
                    }
                }
            }
            sumStr = summaryNodeConcat;
        }
        if (!sumStr) {
            return null;
        }
        else {
            var capElems = ruleContext.getElementsByTagName("caption");
            if (capElems.length === 0) {
                return null;
            }
            else if (sumStr.length > 0) {
                var capStr = CommonUtil_1.CommonUtil.getInnerText(capElems[0]).trim().toLowerCase();
                if (!sumStr.includes(capStr)) {
                    return (0, IRule_1.RulePass)("Pass_0");
                }
                else {
                    return (0, IRule_1.RuleFail)("Fail_1");
                }
            }
        }
    }
};


/***/ }),

/***/ 6215:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.target_spacing_sufficient = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var DOMMapper_1 = __webpack_require__(5697);
var CSSUtil_1 = __webpack_require__(1775);
exports.target_spacing_sufficient = {
    id: "target_spacing_sufficient",
    context: "dom:*",
    dependencies: [],
    help: {
        "en-US": {
            "group": "target_spacing_sufficient.html",
            "pass_spacing": "target_spacing_sufficient.html",
            "pass_sized": "target_spacing_sufficient.html",
            "pass_inline": "target_spacing_sufficient.html",
            "pass_default": "target_spacing_sufficient.html",
            "violation_spacing": "target_spacing_sufficient.html",
            "recommendation_inline": "target_spacing_sufficient.html",
            "potential_overlap": "target_spacing_sufficient.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The target must be sufficiently sized or spaced from other targets",
            "pass_spacing": "The target's spacing from other targets is sufficient",
            "pass_sized": "The targets size is more than 24 CSS pixels",
            "pass_inline": "The target is in a sentence or its size is otherwise constrained by the line-height of non-target text",
            "pass_default": "The target's size is determined by the user agent and is not modified by the author",
            "violation_spacing": "Undersized target \"{0}\" does not have sufficient spacing of 12 CSS pixels from another target \"{1}\"",
            "recommendation_inline": "Confirm the inline target \"{0}\" is sufficiently spaced from another inline target \"{1}\"",
            "potential_overlap": "Ensure the overlapped target \"{0}\" meets a minimum target size or has sufficient spacing from the overlapping target \"{1}\""
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_2"],
            num: ["2.5.8"],
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_THREE,
            reasonCodes: ["pass_spacing", "pass_sized", "pass_inline", "pass_default", "violation_spacing", "potential_overlap"]
        },
        {
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_2"],
            num: ["2.5.8"],
            level: IRule_2.eRulePolicy.RECOMMENDATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_THREE,
            reasonCodes: ["recommendation_inline"]
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLocaleLowerCase();
        var mapper = new DOMMapper_1.DOMMapper();
        var bounds = mapper.getUnadjustedBounds(ruleContext); //context["dom"].bounds;    
        if (!bounds)
            return null;
        // ignore hidden, non-target
        if (!CommonUtil_1.CommonUtil.isTarget(ruleContext))
            return null;
        if (bounds.height >= 24 && bounds.width >= 24)
            return (0, IRule_1.RulePass)("pass_sized");
        // check inline element: without text in the same line
        var status = CSSUtil_1.CSSUtil.getInlineStatus(ruleContext);
        if (status === null)
            return null;
        if (status.inline) {
            if (status.text) {
                if (status.violation === null)
                    return (0, IRule_1.RulePass)("pass_inline");
                else
                    // case 1: inline element is too close horizontally
                    return (0, IRule_1.RulePotential)("recommendation_inline", [nodeName, status.violation]);
            }
            else {
                if (status.violation === null)
                    return (0, IRule_1.RulePass)("pass_default");
                else
                    // case 1: inline element is too close horizontally
                    return (0, IRule_1.RulePotential)("recommendation_inline", [nodeName, status.violation]);
            }
        }
        else {
            // ignore browser default
            if (CSSUtil_1.CSSUtil.isTargetBrowserDefault(ruleContext))
                return (0, IRule_1.RulePass)("pass_default");
        }
        var doc = ruleContext.ownerDocument;
        if (!doc) {
            return null;
        }
        var cStyle = getComputedStyle(ruleContext);
        if (cStyle === null)
            return null;
        var zindex = cStyle.zIndex;
        if (!zindex || isNaN(Number(zindex)))
            zindex = "0";
        //select all elements except itself and descendants
        var elems = doc.querySelectorAll('body *:not(script):not(style)');
        if (!elems || elems.length === 0)
            return;
        var before = true;
        var minX = 24;
        var minY = 24;
        var adjacentX = null;
        var adjacentY = null;
        var checked = []; //contains a list of elements that have been checked so their descendants don't need to be checked again
        var _loop_1 = function (i) {
            var elem = elems[i];
            /**
             *  the nodes returned from querySelectorAll is in document order
             *  if two elements overlap and z-index are not defined, then the node rendered earlier will be overlaid by the node rendered later
             *  filter out the elements thatre descendant or ancestors of the target element, nor descendant of the target element's siblings
             */
            if (ruleContext.contains(elem)) {
                //the next node in elems will be after the target node (ruleContext). 
                before = false;
                return "continue";
            }
            // ignore ascendants of the element, not a target, or itself or its ascendant already checked   
            if (elem.contains(ruleContext) || !CommonUtil_1.CommonUtil.isTarget(elem)
                || checked.some(function (item) { return item.contains(elem); }))
                return "continue";
            var bnds = mapper.getUnadjustedBounds(elem);
            if (!bnds)
                return "continue";
            zStyle = getComputedStyle(elem);
            var z_index = '0';
            if (zStyle) {
                z_index = zStyle.zIndex;
                if (!z_index || isNaN(Number(z_index)))
                    z_index = "0";
            }
            // case 2: the element overlaps the target entirely
            // note when a link is inline with other target, if the link text wraps in another line in a given viewport,  
            // the bounds of the link may cover and the entire two lines, causing the other tagets to be overlapped, see two links in the test case: element_inline.html 
            if (bnds.top <= bounds.top && bnds.left <= bounds.left && bnds.top + bnds.height >= bounds.top + bounds.height
                && bnds.left + bnds.width >= bounds.left + bounds.width) {
                // if the target on top    
                if (before ? parseInt(zindex) < parseInt(z_index) : parseInt(zindex) <= parseInt(z_index)) {
                    return { value: null };
                }
                else
                    return { value: (0, IRule_1.RulePotential)("potential_overlap", [nodeName, elem.nodeName.toLowerCase()]) };
            }
            // case 3: if the target overlaps the element entirely
            if (bounds.top <= bnds.top && bounds.left <= bnds.left && bounds.top + bounds.height >= bnds.top + bnds.height
                && bounds.left + bounds.width >= bnds.left + bnds.width) {
                // if the element on top    
                if (before ? parseInt(zindex) < parseInt(z_index) : parseInt(zindex) <= parseInt(z_index)) {
                    return { value: (0, IRule_1.RulePotential)("potential_overlap", [nodeName, elem.nodeName.toLowerCase()]) };
                }
                else // the target on top
                    return { value: (0, IRule_1.RuleFail)("violation_spacing", [nodeName, elem.nodeName.toLowerCase()]) };
            }
            // case 4: the element overlaps partially with the target
            if ((((bounds.top >= bnds.top && bounds.top <= bnds.top + bnds.height) || (bounds.top + bounds.height <= bnds.top && bounds.top + bounds.height >= bnds.top + bnds.height))
                && ((bounds.left > bnds.left && bounds.left < bnds.left + bnds.width) || (bnds.left > bounds.left && bnds.left < bounds.left + bounds.width)))
                || (((bounds.top > bnds.top && bounds.top < bnds.top + bnds.height) || (bnds.top > bounds.top && bnds.top < bounds.top + bounds.height))
                    && ((bounds.left >= bnds.left && bounds.left <= bnds.left + bnds.width) || (bounds.left + bounds.width >= bnds.left && bounds.left + bounds.width <= bnds.left + bnds.width)))) {
                return { value: (0, IRule_1.RulePotential)("potential_overlap", [nodeName, elem.nodeName.toLowerCase()]) };
            }
            else { // no overlap with the elem, though may overlap withe other elements
                var disX = 24;
                var disY = 24;
                // the element is in the horizontally same row with the target
                if (bounds.width < 24 && ((bounds.top >= bnds.top && bounds.top <= bnds.top + bnds.height) || (bounds.top <= bnds.top && bounds.top + bounds.height > bnds.top)))
                    disX = Math.min(Math.abs(bounds.left - bnds.left), Math.abs(bounds.left - (bnds.left + bnds.width)), Math.abs(bounds.left + bounds.width - (bnds.left + bnds.width)), Math.abs(bounds.left + bounds.width - bnds.left));
                // the element is in the vertically same column with the target    
                if (bounds.height < 24 && ((bounds.left >= bnds.left && bounds.left <= bnds.left + bnds.width) || (bounds.left <= bnds.left && bounds.left + bounds.width > bnds.left)))
                    disY = Math.min(Math.abs(bounds.top - bnds.top), Math.abs(bounds.top - (bnds.top + bnds.height)), Math.abs(bounds.top + bounds.height - (bnds.top + bnds.height)), Math.abs(bounds.top + bounds.height - bnds.top));
                if (disX < minX) {
                    minX = disX;
                    adjacentX = elem;
                }
                if (disY < minY) {
                    minY = disY;
                    adjacentY = elem;
                }
            }
            checked.push(elem);
        };
        var zStyle;
        for (var i = 0; i < elems.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        // case 5: no overlap + insufficient target size. check spacing    
        if (Math.round(bounds.width / 2) + minX < 12 || Math.round(bounds.height / 2) + minY < 12) {
            if (Math.round(bounds.width / 2) + minX < Math.round(bounds.height / 2) + minY)
                return (0, IRule_1.RuleFail)("violation_spacing", [nodeName, adjacentX.nodeName.toLowerCase()]);
            return (0, IRule_1.RuleFail)("violation_spacing", [nodeName, adjacentY.nodeName.toLowerCase()]);
        }
        else
            return (0, IRule_1.RulePass)("pass_spacing");
    }
};


/***/ }),

/***/ 5275:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text_block_heading = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var DOMWalker_1 = __webpack_require__(7440);
var CSSUtil_1 = __webpack_require__(1775);
var VisUtil_1 = __webpack_require__(8656);
exports.text_block_heading = {
    id: "text_block_heading",
    context: "dom:p, dom:div, dom:br",
    refactor: {
        "RPT_Block_ShouldBeHeading": {
            // "Pass_0": "pass",
            "Potential_1": "potential_heading"
        }
    },
    help: {
        "en-US": {
            // "pass": "text_block_heading.html",
            "potential_heading": "text_block_heading.html",
            "group": "text_block_heading.html"
        }
    },
    messages: {
        "en-US": {
            // "pass": "Heading text uses a heading element or role",
            "potential_heading": "Confirm this text '{0}' is used as a heading and if so, modify to use a heading element or role",
            "group": "Heading text should use a heading element or role"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext) || !VisUtil_1.VisUtil.isNodeVisible(ruleContext))
            return null;
        // Don't trigger if we're not in the body or if we're in a script
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["body"]) === null || CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["script"]) !== null)
            return null;
        var validateParams = {
            numWords: {
                value: 10,
                type: "integer"
            }
        };
        var bodyFont = 0;
        var body = ruleContext.ownerDocument.getElementsByTagName("body");
        if (body != null) {
            var bodyStyle = getComputedStyle(body[0]);
            if (bodyStyle)
                bodyFont = CSSUtil_1.CSSUtil.getPixelsFromStyle(bodyStyle['font-size'], body);
        }
        var numWords = validateParams.numWords.value;
        var wordsSeen = 0;
        var wordStr = [];
        var emphasizedText = false;
        //let nw = new NodeWalker(ruleContext);
        var nw = new DOMWalker_1.DOMWalker(ruleContext);
        nw.nextNode();
        var passed = false;
        while (!passed &&
            nw.nextNode() &&
            nw.node !== ruleContext &&
            nw.node !== DOMWalker_1.DOMWalker.parentNode(ruleContext) &&
            !["br", "div", "p"].includes(nw.node.nodeName.toLowerCase())) // Don't report twice
         {
            if (nw.node === ruleContext || CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(nw.node))
                continue;
            var nwName = nw.node.nodeName.toLowerCase();
            if (nw.node.nodeType === 3) {
                // for text child
                if (nw.node.nodeValue.trim().length > 0 && nw.node.parentElement) {
                    // check it's style if the target element contains text, e.g., <p> fake heading</p> 
                    var style = getComputedStyle(nw.node.parentElement);
                    if (style && (style['font-weight'] === 'bold' || style['font-weight'] >= 700
                        || (style['font-size'] && style['font-size'].includes("large"))
                        || (style['font-size'] && bodyFont !== 0 && CSSUtil_1.CSSUtil.getPixelsFromStyle(style['font-size'], nw.node.parentElement) > bodyFont))) {
                        var nextStr = nw.node.nodeValue.trim();
                        var wc = CommonUtil_1.CommonUtil.wordCount(nextStr);
                        if (wc > 0) {
                            wordStr.push(nextStr);
                            emphasizedText = true;
                            wordsSeen += wc;
                        }
                        passed = wordsSeen > numWords;
                        // Skip this node because it's emphasized
                        nw.bEndTag = true;
                    }
                    else {
                        // the node contain regular text
                        passed = true;
                    }
                }
            }
            else if (nw.node.nodeType === 1) {
                // for element child
                if (nwName === "b" || nwName === "strong" || nwName === "u" || nwName === "font") {
                    // if the target element contains emphasis child, e.g., <p><strong>fake heading</strong></p> 
                    var nextStr = CommonUtil_1.CommonUtil.getInnerText(nw.node);
                    var wc = CommonUtil_1.CommonUtil.wordCount(nextStr);
                    if (wc > 0) {
                        wordStr.push(nextStr);
                        emphasizedText = true;
                        wordsSeen += wc;
                    }
                    passed = wordsSeen > numWords;
                    // Skip this node because it's emphasized
                    nw.bEndTag = true;
                }
                else {
                    // ignore the element which has a role except 'generic', 'paragraph' or 'strong'
                    // ignore applet element that is deprecated anyway
                    var role = AriaUtil_1.AriaUtil.getResolvedRole(nw.node);
                    passed = (role !== null && role !== 'generic' && role !== 'paragraph' && role !== 'strong') || nwName === "applet";
                }
            }
        }
        if (wordsSeen == 0)
            passed = true;
        //ignore if the string ends with :  ,  -  ; or . 
        if (!passed)
            passed = /[:,;\-\.]$/.test(wordStr.join(" ").trim());
        if (passed) {
            return null;
        }
        else {
            return (0, IRule_1.RulePotential)("potential_heading", [wordStr.join(" ")]);
        }
    }
};


/***/ }),

/***/ 7900:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
    Copyright:: 2022- IBM, Inc
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text_contrast_sufficient = void 0;
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
var ColorUtil_1 = __webpack_require__(8680);
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CSSUtil_1 = __webpack_require__(1775);
exports.text_contrast_sufficient = {
    id: "text_contrast_sufficient",
    context: "dom:*",
    refactor: {
        "IBMA_Color_Contrast_WCAG2AA": {
            "Pass_0": "pass",
            "Fail_1": "fail_contrast",
            "Potential_1": "potential_same_color"
        },
        "IBMA_Color_Contrast_WCAG2AA_PV": {
            "pass_0": "pass",
            "potential_1": "potential_graphic_background"
        }
    },
    help: {
        "en-US": {
            "group": "text_contrast_sufficient.html",
            "pass": "text_contrast_sufficient.html",
            "fail_contrast": "text_contrast_sufficient.html",
            "potential_same_color": "text_contrast_sufficient.html",
            "potential_graphic_background": "text_contrast_sufficient.html",
            "potential_text_shadow": "text_contrast_sufficient.html"
        }
    },
    messages: {
        "en-US": {
            "group": "The contrast ratio of text with its background must meet WCAG AA requirements",
            "pass": "The contrast ratio of text with its background meets WCAG AA requirements",
            "fail_contrast": "Text contrast of {0} with its background is less than the WCAG AA minimum requirements for text of size {1}px and weight of {2}",
            "potential_same_color": "The foreground text and its background color are both detected as {3}. Verify the text meets the WCAG AA requirements for minimum contrast",
            "potential_graphic_background": "Verify the contrast ratio of the text against the lightest and the darkest colors of the background meets the WCAG AA minimum requirements for text of size {1}px and weight of {2}",
            "potential_text_shadow": "Verify the contrast ratio of the text with shadow meets the WCAG AA minimum requirements for text of size {1}px and weight of {2}"
        }
    },
    rulesets: [{
            id: ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_0", "WCAG_2_1", "WCAG_2_2"],
            num: "1.4.3",
            level: IRule_2.eRulePolicy.VIOLATION,
            toolkitLevel: IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: ['afw4f7'],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        // avoid diagnosing elements that are not visible
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) ||
            (VisUtil_1.VisUtil.hiddenByDefaultElements != null &&
                VisUtil_1.VisUtil.hiddenByDefaultElements != undefined &&
                VisUtil_1.VisUtil.hiddenByDefaultElements.indexOf(nodeName) > -1)) {
            return null;
        }
        //TODO ? should only consider native disabled, ignore aria-disabled
        //skip disabled element
        if (CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return null;
        //skip elements
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["svg", "script", "meta", "style"]))
            return null;
        var doc = ruleContext.ownerDocument;
        if (!doc) {
            return null;
        }
        var win = doc.defaultView;
        if (!win) {
            return null;
        }
        // Ensure that this element has children with actual text.
        var childStr = CommonUtil_1.CommonUtil.getNodeText(ruleContext);
        if (!CommonUtil_1.CommonUtil.isShadowHostElement(ruleContext) || (CommonUtil_1.CommonUtil.isShadowHostElement(ruleContext) && CommonUtil_1.CommonUtil.getNodeText(ruleContext.shadowRoot) === '')) {
            if (childStr.trim().length == 0)
                return null;
            // ignore if the text does not convey anything in human language
            /**
             * (1) ignore non-alphanumeric or special characters in ASCI: ^(a-zA-Z\d\s)
             * (2) ignore non-printable unicode characters: \u0000-\u0008\u000B-\u001F\u007F-\u009F\u2000-\u200F\u2028-\u202F\u205F-\u206F\u3000\uFEFF
             *  see https://stackoverflow.com/questions/3770117/what-is-the-range-of-unicode-printable-characters
             * (3) for now not consider unicode special characters that are different in different languages
            */
            //let regex = /[^(a-zA-Z\d\s)\u0000-\u0008\u000B-\u001F\u007F-\u009F\u2000-\u200F\u2028-\u202F\u205F-\u206F\u3000\uFEFF]+/g;
            var regex = /[^(a-zA-Z\d\s)\^(\u4e00-\u9fff\u3400-\u4dbf)\u0000-\u0008\u000B-\u001F\u007F-\u009F\u2000-\u200F\u2028-\u202F\u205F-\u206F\u3000\uFEFF]+/g;
            childStr = childStr.trim().replace(regex, '');
            if (childStr.trim().length === 0)
                return null;
        }
        var elem = ruleContext;
        // the child elements (rather than shadow root) of a shadow host is either re-assigned to the shadow slot if the slot exists 
        // or not displayed, so shouldn't be checked from the light DOM, rather it should be checked as reassginged slot element(s) in the shadow DOM.
        if (CommonUtil_1.CommonUtil.isShadowHostElement(ruleContext)) {
            // if it's direct text of a shadow host
            if (ruleContext.shadowRoot) {
                for (var node = ruleContext.firstChild; node; node = node.nextSibling) {
                    if (node.nodeType == 3) {
                        //if multiple texts exist, only need to check one 
                        elem = node.assignedSlot;
                        break;
                    }
                }
            }
            if (elem === null)
                return;
        }
        var style = win.getComputedStyle(elem);
        // JCH clip INFO:
        //      The clip property lets you specify a rectangle to clip an absolutely positioned element. 
        //      The rectangle specified as four coordinates, all from the top-left corner of the element to be clipped.
        //      Property values:
        //          none        This is default. No clipping is done
        //          auto        No clipping will be done
        //          shape       The only valid value is: rect (top, right, bottom, left)
        //                      e.g., clip: rect(10px, 20px, 30px, 40px);
        //                      Note: the four values are in the same order as margin/padding
        //                      The rect values are positive pixel values, e.g., 10px, etc.
        //          margin-box  Uses the margin box as the reference box
        //          border-box  Uses the border box as the reference box
        //          padding-box Uses the padding box as the reference box
        //          content-box
        //          fill-box
        //          stroke-box
        //      NOTE: the CSS clip property is deprecated
        //      Also: clip only works if the element is absolutely positioned and can only do rectangles
        // check if element visible
        var visible = true;
        if (style.width !== "0" &&
            style.height !== "0" &&
            style.opacity !== "0" &&
            style.display !== 'none' &&
            style.visibility !== 'hidden' &&
            style.overflow !== 'hidden' &&
            // left and right work with all absolute units
            (style.left === "auto" || (style.position === 'absolute' && parseInt(style.left.replace(/[^0-9.+-]/, '')) > 0)) &&
            (style.left === "auto" || (style.position === 'absolute' && parseInt(style.top.replace(/[^0-9.+-]/, '')) > 0))) {
            visible = true;
            // console.log("element IS visible");
            // console.log("CHECK COLOR CONTRAST unless to small");
        }
        else {
            visible = false;
            // console.log("element NOT visible");
        }
        if (visible === false) {
            // console.log("DO NOT CHECK COLOR CONTRAST");
            return null;
        }
        var clipHeight = -1;
        if (style.clip !== "auto") {
            var clipString = style.clip.toString();
            if (clipString.includes("rect")) {
                var reBrackets = /\((.*)\)/g;
                var listOfText = [];
                var found = reBrackets.exec(clipString);
                var foundArr = found[1].split(', ');
                for (var i = 0; i < foundArr.length; i++) {
                    // console.log("foundArr[",i,"] = ",foundArr[i]);
                    listOfText.push(foundArr[i]);
                }
                ;
            }
            // console.log("listOfText = ",listOfText);
            clipHeight = parseInt(listOfText[0].replace(/px/g, '')) - parseInt(listOfText[2].replace(/px/g, ''));
            clipHeight = Math.abs(clipHeight);
        }
        // JCH clip-path INFO:
        //      Excellent article on clip-path: https://ishadeed.com/article/clip-path/
        //      clip-path is a totally different animal with many, many different variations
        //      The goal was for it to not be as limited as clip
        //      The syntax is more complicated (as it does more) and it is different from clip,
        //      e.g., the above clip rectangle would be clip-path: inset(10px 20px 30px 40px);
        //      Note: there are no commas
        //      Also, it can take single values to make all sides the same, or 2 values (vert/hori).
        //      or 3 values (top/hori/bottom)
        //      And percentages can works as well as px
        //      
        //      Although there are five different shapes: inset (term used for rectangle), circle,
        //          ellipse, polygon, path - we will only concern ourselves with inset
        //      There are 7 box values: margin-box, border-box, padding-box, content-box, fill-box, stroke-box, view-box
        //      Box and shape values may be combined: clip-path: padding-box circle(50px at 0 100px);
        //      NOTE: the box values are NOT intuitive, see: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes/From_box_values#margin-box
        //      
        //      So the key question is what amount of effort do we want to invest into clip-path
        // 
        // JCH don't do clip-path now 
        var clipPathHeight = -1;
        // if (style.clipPath !== "auto") {
        //     console.log("style.clipPath = ",style.clipPath);
        //     console.log("style.clipPath.toString = ",style.clipPath.toString());
        //     let clipString = style.clipPath.toString();
        //     if (clipString.includes("inset")) {
        //         var reBrackets = /\((.*)\)/g;
        //       var listOfText = [];
        //       var found = reBrackets.exec(clipString);
        //       var foundArr = found[1].split(' ');
        //       for (let i=0; i<foundArr.length; i++) {
        //         console.log("foundArr[",i,"] = ",foundArr[i]);
        //         listOfText.push(foundArr[i]);
        //       };
        //     }
        //     console.log("listOfText = ",listOfText);
        // clipPathHeight = parseInt(listOfText[0].replace(/px/g, '')) - parseInt(listOfText[2].replace(/px/g, ''));
        // clipPathHeight = Math.abs(clipHeight);
        // }
        // console.log("clipPathHeight = ", clipPathHeight);
        // if (style.position === "absolute" && style.clip === "rect(0px, 0px, 0px, 0px)" && style.overflow !== "visible") {
        // JCH arbitrarily use less that 7px for clipHeight
        if (style.position === "absolute" && clipHeight < 7 && clipHeight !== -1) {
            // console.log("DO NOT CHECK COLOR CONTRAST because too small");
            // Corner case where item is hidden (accessibility hiding technique)
            return null;
        }
        // First determine the color contrast ratio
        var colorCombo = ColorUtil_1.ColorUtil.ColorCombo(elem);
        if (colorCombo === null) {
            //some exception occurred, or not able to get color combo for some reason
            console.log("unable to get color combo for element: " + elem.nodeName);
            return;
        }
        var fg = colorCombo.fg;
        var bg = colorCombo.bg;
        var ratio = fg.contrastRatio(bg);
        var weight = CSSUtil_1.CSSUtil.getWeightNumber(style.fontWeight);
        var size = CSSUtil_1.CSSUtil.getFontInPixels(style.fontSize, elem);
        var isLargeScale = size >= 24 || size >= 18.6 && weight >= 700;
        if (CSSUtil_1.CSSUtil.containsCKJ(childStr)) {
            // https://github.com/act-rules/act-rules.github.io/pull/2121/files
            // for CJK, 22 pt or 18 pt with font-weight >= 700, 1pt = 1.333 px
            isLargeScale = size >= 29.3 || size >= 24 && weight >= 700;
        }
        var passed = ratio >= 4.5 || (ratio >= 3 && isLargeScale);
        var hasBackground = colorCombo.hasBGImage || colorCombo.hasGradient;
        var textShadow = colorCombo.textShadow;
        var isDisabled = CommonUtil_1.CommonUtil.isNodeDisabled(elem);
        if (!isDisabled) {
            var control = CommonUtil_1.CommonUtil.getControlOfLabel(elem);
            if (control) {
                isDisabled = CommonUtil_1.CommonUtil.isNodeDisabled(control);
            }
        }
        if (!isDisabled && nodeName === 'label' && CommonUtil_1.CommonUtil.isDisabledByFirstChildFormElement(elem)) {
            isDisabled = true;
        }
        if (!isDisabled && ruleContext.hasAttribute("id") && CommonUtil_1.CommonUtil.isDisabledByReferringElement(elem)) {
            isDisabled = true;
        }
        /**setCache(ruleContext, "EXT_Color_Contrast_WCAG2AA", {
            "ratio": ratio,
            "isLargeScale": isLargeScale,
            "weight": weight,
            "size": size,
            "hasBackground": hasBackground,
            "isDisabled": isDisabled
        });*/
        // If element or parent is disabled, this rule does not apply (but may be 3:1 in future)
        if (!passed && isDisabled) {
            passed = true;
        }
        if (!passed) {
            if (hasBackground) {
                // fire potential since a text on an image or gradient may be still viewable, depending on the text location on the gradient or image
                return (0, IRule_1.RulePotential)("potential_graphic_background", [ratio.toFixed(2), size, weight]);
                ;
            }
            else if (textShadow) {
                // fire potential since a text with shadow may be still viewable, depending on the shadow efffects
                return (0, IRule_1.RulePotential)("potential_text_shadow", [ratio.toFixed(2), size, weight]);
                ;
            }
            else {
                if (fg.toHex() === bg.toHex()) {
                    return (0, IRule_1.RulePotential)("potential_same_color", [ratio.toFixed(2), size, weight, fg.toHex(), bg.toHex(), colorCombo.hasBGImage, colorCombo.hasGradient]);
                }
                else {
                    return (0, IRule_1.RuleFail)("fail_contrast", [ratio.toFixed(2), size, weight, fg.toHex(), bg.toHex(), colorCombo.hasBGImage, colorCombo.hasGradient]);
                }
            }
        }
        else {
            return (0, IRule_1.RulePass)("pass", [ratio.toFixed(2), size, weight, fg.toHex(), bg.toHex(), colorCombo.hasBGImage, colorCombo.hasGradient]);
        }
    }
};


/***/ }),

/***/ 5027:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text_quoted_correctly = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
exports.text_quoted_correctly = {
    id: "text_quoted_correctly",
    context: "dom:*",
    help: {
        "en-US": {
            "Pass_0": "text_quoted_correctly.html",
            "Potential_1": "text_quoted_correctly.html",
            "group": "text_quoted_correctly.html"
        }
    },
    messages: {
        "en-US": {
            "Pass_0": "Rule Passed",
            "Potential_1": "If the following text is a quotation, mark it as a <q> or <blockquote> element: {0}",
            "group": "Quotations should be marked with <q> or <blockquote> elements"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // ignore the check if the node is hidden
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext))
            return null;
        // Don't trigger if the element is not in the body
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["body"]) === null)
            return null;
        var validateParams = {
            minWords: {
                value: 3,
                type: "integer"
            }
        };
        var minWords = validateParams.minWords.value;
        var passed = true;
        var walkNode = ruleContext.firstChild;
        var violatedtext = null;
        // ignore the check for the text of the following elements
        var ignored = ["blockquote", "q", "script", "style", "pre", "code", "ruby", "samp"];
        while (passed && walkNode) {
            // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
            // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
            // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
            // a node walk only on siblings so it would not get text nodes from other siblings at all.
            // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
            // if.
            if (walkNode.nodeName === "#text") {
                var txtVal = walkNode.nodeValue;
                // Do the regex tests first - should be fast
                // Remove apostrophe's
                txtVal = txtVal.replace(/(\S)'(\S)/g, "$1$2");
                var dblQuotes = txtVal.match(/("[^"]+")/g);
                var snglQuotes = txtVal.match(/('[^']+')/g);
                // Walk the parents - only continue testing if we found a quote, but
                // we're not already marked up
                // Also skip if we're in a script - there's lots of quotes used in scripts
                if ((dblQuotes !== null || snglQuotes !== null) &&
                    CommonUtil_1.CommonUtil.getAncestor(walkNode, ignored) === null) {
                    if (dblQuotes != null) {
                        for (var i = 0; passed && i < dblQuotes.length; ++i)
                            passed = CommonUtil_1.CommonUtil.wordCount(dblQuotes[i]) < minWords;
                    }
                    if (snglQuotes != null) {
                        for (var i = 0; passed && i < snglQuotes.length; ++i)
                            passed = CommonUtil_1.CommonUtil.wordCount(snglQuotes[i]) < minWords;
                    }
                    // Remove any linefeed inside the quote
                    // violatedtext = txtVal.replace(new RegExp("\\r?\\n|\\r","g"),"");
                    if (dblQuotes === null) {
                        violatedtext = snglQuotes.join(", ").replace(new RegExp("\\r?\\n|\\r", "g"), "");
                    }
                    else if (snglQuotes === null) {
                        violatedtext = dblQuotes.join(", ").replace(new RegExp("\\r?\\n|\\r", "g"), "");
                    }
                    else {
                        violatedtext = dblQuotes.concat(snglQuotes).join(", ").replace(new RegExp("\\r?\\n|\\r", "g"), "");
                    }
                }
            }
            walkNode = walkNode.nextSibling;
        }
        //if the violatedtext is longer than 69 chars, only keep the first 32, the " ... ", and the last 32 chars 
        if (!passed && violatedtext.length && violatedtext.length > 69) {
            violatedtext = violatedtext.substring(0, 32) + " ... " + violatedtext.substring(violatedtext.length - 32);
        }
        return passed ? (0, IRule_1.RulePass)("Pass_0") : (0, IRule_1.RulePotential)("Potential_1", [violatedtext]);
    }
};


/***/ }),

/***/ 3496:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text_sensory_misuse = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8656);
exports.text_sensory_misuse = {
    id: "text_sensory_misuse",
    context: "dom:body, dom:body dom:*",
    refactor: {
        "RPT_Text_SensoryReference": {
            // "Pass_0": "pass",
            "Potential_1": "potential_position, potential_other"
        }
    },
    help: {
        "en-US": {
            // "pass": "text_sensory_misuse.html",
            "potential_position": "text_sensory_misuse.html",
            "potential_other": "text_sensory_misuse.html",
            "group": "text_sensory_misuse.html"
        }
    },
    messages: {
        "en-US": {
            // "pass": "Instructions are meaningful without relying solely on shape, size, or location words",
            "potential_position": "Confirm the word(s) '{0}' of the user instruction is used to indicate a logical rather than visual position",
            "potential_other": "Confirm the user instruction is still understandable without the word(s) '{0}'",
            "group": "Instructions should be meaningful without relying solely on shape, size, or location words"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.3"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_TWO
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Extract the nodeName of the context node
        var nodeName = ruleContext.nodeName.toLowerCase();
        //skip the check if the element is hidden or disabled
        if (!VisUtil_1.VisUtil.isNodeVisible(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext) || VisUtil_1.VisUtil.hiddenByDefaultElements.includes(nodeName))
            return null;
        // Don't trigger if we're not in the body or if we're in a script
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["body"]) === null)
            return null;
        // ignore script, link, label and their child elements
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["script", "a", 'label']) !== null)
            return null;
        // ignore text on landmark roles, but not on their children (e.g., section, main)
        var role = AriaUtil_1.AriaUtil.getResolvedRole(ruleContext);
        if (role) {
            var lmRoles = AriaUtil_1.AriaUtil.getRolesWithTypes(ruleContext, ["landmark"]);
            if (lmRoles && lmRoles.includes(role))
                return null;
        }
        // ignore all widgets and headings, and their children, and certain structure roles
        var roles = AriaUtil_1.AriaUtil.getRolesWithTypes(ruleContext, ["widget", "heading"]);
        // add some structure roles
        CommonUtil_1.CommonUtil.concatUniqueArrayItemList(["caption", "cell", "code", "columnheader", "definition", "figure", "list", "listitem", "math", "meter", "row", "rowgroup", "rowheader", "term"], roles);
        if (AriaUtil_1.AriaUtil.getAncestorWithRoles(ruleContext, roles) !== null)
            return null;
        var violatedPositionText = "";
        var violatedOtherText = "";
        var walkNode = ruleContext.firstChild;
        var txtVal = "";
        while (walkNode) {
            // for each element it only checks that single elements text nodes and nothing else. 
            // all inner elements will be covered on their own. 
            // whitespace characters (space, newline, tab) between elements are considered a node too.
            if (walkNode.nodeName === "#text") {
                var txt = walkNode.nodeValue.trim();
                if (txt.length > 0)
                    txtVal += (txtVal.length > 0 ? ", " + txt : txt);
            }
            walkNode = walkNode.nextSibling;
        }
        if (txtVal.length > 0) {
            // first to remove each exempt word with a single space in the text
            var exemptRegex = getRegex(ruleContext.ownerDocument, "exemptText");
            txtVal = txtVal.replace(exemptRegex, " ");
            violatedPositionText = getViolatedText(ruleContext.ownerDocument, "positionText", txtVal);
            violatedOtherText = getViolatedText(ruleContext.ownerDocument, "otherText", txtVal);
        }
        var ret = [];
        if (violatedPositionText)
            ret.push((0, IRule_1.RulePotential)("potential_position", [violatedPositionText]));
        if (violatedOtherText)
            ret.push((0, IRule_1.RulePotential)("potential_other", [violatedOtherText]));
        return ret.length == 0 ? null : ret;
    }
};
var validateParams = {
    positionText: {
        value: ["top-left", "top-right", "bottom-right", "bottom-left",
            "top-to-bottom", "left-to-right", "bottom-to-top", "right-to-left",
            "right", "left", "above", "below", "top", "bottom",
            "upper", "lower", "corner", "beside"
        ],
        type: "[string]"
    },
    otherText: {
        value: ["round", "square", "shape", "rectangle", "triangle",
            "size", "large", "small", "medium", "big", "huge", "tiny", "extra",
            "larger", "smaller", "bigger", "little", "largest", "smallest", "biggest"
        ],
        type: "[string]"
    },
    exemptText: {
        value: ["right-click", "left-click", "right-clicking", "right-clicks",
            "left-clicking", "left-clicks", "square root", "right now", "off the top" //append as needed
        ],
        type: "[string]"
    }
};
function getRegex(doc, type) {
    if (!validateParams[type])
        return "";
    var sensoryRegex = CacheUtil_1.CacheUtil.getCache(doc, type + "_sensory_misuse", null);
    if (sensoryRegex == null) {
        var sensoryText = validateParams[type].value;
        var regexStr = "(\s\s+|" + sensoryText[0];
        for (var j = 1; j < sensoryText.length; ++j) {
            var words = sensoryText[j].trim().split(" ");
            regexStr += "|" + words[0];
            if (words.length > 1) {
                for (var c = 1; c < words.length; ++c)
                    regexStr += " +" + words[c];
            }
        }
        //regexStr += ")\\W";
        regexStr += ")";
        sensoryRegex = new RegExp(regexStr, "gi");
        CacheUtil_1.CacheUtil.setCache(doc, type + "_sensory_misuse", sensoryRegex);
    }
    return sensoryRegex;
}
function getViolatedText(doc, type, txtVal) {
    if (!txtVal)
        return "";
    var sensoryTextArr = validateParams[type].value;
    var hash = {}, result = [];
    // split the string into words
    var counts = txtVal.split(/\s+/).reduce(function (map, word) {
        var wordWoTrailingPunc = word.replace(/[.?!:;()'",`\]]+$/, "");
        var lcWordWoPunc = word.toLowerCase().replace(/[.?!:;()'",`\]]/g, "");
        for (var counter = 0; counter < sensoryTextArr.length; counter++) {
            var a = lcWordWoPunc.indexOf(sensoryTextArr[counter]);
            var sensoryWordLen = sensoryTextArr[counter].length;
            var charFollowSensoryText = lcWordWoPunc.charAt(sensoryWordLen + a);
            // If the word does not contains substring of sensoryTextArr[counter]
            // proceed to the next loop iteration for next sensoryText.
            if (a < 0) {
                continue;
            }
            //check the following and proceeding punctuations
            //let isPuncfollowing = ((charFollowSensoryText == '\-') ||
            var isPuncfollowing = ((charFollowSensoryText == '\.') ||
                (charFollowSensoryText == '\?') || (charFollowSensoryText == '\!') ||
                (charFollowSensoryText == '\:') || (charFollowSensoryText == '\;') ||
                (charFollowSensoryText == '\(') || (charFollowSensoryText == '\)') ||
                (charFollowSensoryText == '\'') || (charFollowSensoryText == '\"') ||
                (charFollowSensoryText == '\,') || (charFollowSensoryText == '.\`') ||
                (charFollowSensoryText == '\\') || (charFollowSensoryText == '\]'));
            var isPuncPreceding = false;
            if (a > 0) {
                var charPrecedeSensoryText = lcWordWoPunc.charAt(a - 1);
                isPuncPreceding = ((charPrecedeSensoryText == '\-') ||
                    (charPrecedeSensoryText == '\.') ||
                    (charPrecedeSensoryText == '\?') || (charPrecedeSensoryText == '\!') ||
                    (charPrecedeSensoryText == '\:') || (charPrecedeSensoryText == '\;') ||
                    (charPrecedeSensoryText == '\(') || (charPrecedeSensoryText == '\)') ||
                    (charPrecedeSensoryText == '\'') || (charPrecedeSensoryText == '\"') ||
                    (charPrecedeSensoryText == '\,') || (charPrecedeSensoryText == '.\`') ||
                    (charPrecedeSensoryText == '\\') || (charPrecedeSensoryText == '\]'));
            }
            if (((lcWordWoPunc.length == sensoryWordLen) || (isPuncfollowing == true) || (isPuncPreceding == true))) {
                if (!hash.hasOwnProperty(wordWoTrailingPunc)) {
                    hash[wordWoTrailingPunc] = true;
                    result.push(wordWoTrailingPunc);
                }
                counter = sensoryTextArr.length;
            }
        }
        map[wordWoTrailingPunc] = (map[wordWoTrailingPunc] || 0) + 1;
        return map;
    }, Object.create(null));
    return result.join(", ");
}


/***/ }),

/***/ 1131:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text_spacing_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
var VisUtil_1 = __webpack_require__(8656);
var CSSUtil_1 = __webpack_require__(1775);
var DOMMapper_1 = __webpack_require__(5697);
exports.text_spacing_valid = {
    id: "text_spacing_valid",
    context: "dom:*",
    help: {
        "en-US": {
            "pass": "text_spacing_valid.html",
            "group": "text_spacing_valid.html",
            "fail_letter_spacing_style": "text_spacing_valid.html",
            "fail_word_spacing_style": "text_spacing_valid.html",
            "fail_line_height_style": "text_spacing_valid.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "CSS !important is not used in inline style to control letter or word spacing or line height",
            "group": "CSS !important should not be used in inline style to control letter or word spacing or line height",
            "fail_letter_spacing_style": "CSS !important should not be used in inline letter-spacing style",
            "fail_word_spacing_style": "CSS !important should not be used in inline word-spacing style",
            "fail_line_height_style": "CSS !important should not be used in inline line-height style"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.4.12"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: ['9e45ec', '24afc2', '78fd32'],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        var nodeName = ruleContext.nodeName.toLowerCase();
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return null;
        //skip the check if the element is off screen
        var mapper = new DOMMapper_1.DOMMapper();
        var bounds = mapper.getUnadjustedBounds(ruleContext);
        //in case the bounds not available
        if (!bounds)
            return null;
        if (bounds['top'] < 0 || bounds['left'] < 0)
            return null;
        //skip no-html element
        if (CommonUtil_1.CommonUtil.getAncestor(ruleContext, "svg"))
            return null;
        // Ensure that this element has children with actual text.
        var childStr = "";
        var childNodes = ruleContext.childNodes;
        for (var i = 0; i < childNodes.length; ++i) {
            if (childNodes[i].nodeType == 3) {
                childStr += childNodes[i].nodeValue;
            }
        }
        if (childStr.trim().length == 0)
            return null;
        //font size always resolved to 'px'    
        var font_size_style = getComputedStyle(ruleContext).getPropertyValue('font-size');
        var font_size = parseFloat(font_size_style);
        var styles = CSSUtil_1.CSSUtil.getDefinedStyles(ruleContext);
        if (Object.keys(styles).length === 0)
            return null;
        //note that CSS unit is required for non-zero values, otherwise it's ignored
        var ret = [];
        // matched string: original style, the style value and unit
        var regex = /(-?[\d.]+)([a-z%]*)/;
        var word_style = styles['word-spacing'];
        if (word_style) {
            if (word_style.startsWith('inherit') || word_style.startsWith('unset')) {
                //get closet ancestor's word-spacing
                var ancestor = CSSUtil_1.CSSUtil.getAncestorWithStyles(ruleContext.parentElement, { "word-spacing": ["*"] }, ['inherit', 'unset']);
                if (ancestor !== null) {
                    word_style = CSSUtil_1.CSSUtil.getDefinedStyles(ancestor)['word-spacing'];
                }
                else if (word_style.startsWith('unset')) {
                    word_style = "initial";
                }
            }
            if (ruleContext.style.getPropertyPriority("word-spacing") === 'important') {
                word_style = word_style.substring(0, word_style.length - "!important".length - 1);
                // computed space is 0 for 'normal' or 'initial'.
                if (word_style === 'initial' || word_style === 'normal')
                    ret.push((0, IRule_1.RuleFail)("fail_word_spacing_style"));
                else {
                    var wordSpacing = parseFloat(word_style);
                    if (!isNaN(wordSpacing)) {
                        var parsed = word_style.trim().match(regex);
                        if (parsed[2] !== '' && parsed[1] !== 0) { //no zero value without unit which is considered as error, so implicable
                            var pixels = CSSUtil_1.CSSUtil.convertValue2Pixels(parsed[2], parsed[1], ruleContext);
                            if (pixels !== null && pixels / font_size < 0.16)
                                ret.push((0, IRule_1.RuleFail)("fail_word_spacing_style"));
                            else
                                ret.push((0, IRule_1.RulePass)("pass"));
                        }
                    }
                    else
                        ret.push((0, IRule_1.RulePass)("pass"));
                }
            }
            else
                ret.push((0, IRule_1.RulePass)("pass"));
        }
        var letter_style = styles['letter-spacing'];
        if (letter_style) {
            if (letter_style.startsWith('inherit') || letter_style.startsWith('unset')) {
                //get closet ancestor's word-spacing
                var ancestor = CSSUtil_1.CSSUtil.getAncestorWithStyles(ruleContext.parentElement, { "letter-spacing": ["*"] }, ['inherit', 'unset']);
                if (ancestor !== null) {
                    letter_style = CSSUtil_1.CSSUtil.getDefinedStyles(ancestor)['letter-spacing'];
                }
                else if (letter_style.startsWith('unset')) {
                    letter_style = "initial";
                }
            }
            if (ruleContext.style.getPropertyPriority("letter-spacing") === 'important') {
                letter_style = letter_style.substring(0, letter_style.length - "!important".length - 1);
                // computed space is 0 for 'normal' or 'initial'.
                if (letter_style === 'initial' || letter_style === 'normal')
                    ret.push((0, IRule_1.RuleFail)("fail_letter_spacing_style"));
                else {
                    var letterSpacing = parseFloat(letter_style);
                    if (!isNaN(letterSpacing)) {
                        var parsed = letter_style.trim().match(regex);
                        if (parsed[2] !== '' && parsed[1] !== 0) { //no zero value without unit which is considered as error, so implicable
                            var pixels = CSSUtil_1.CSSUtil.convertValue2Pixels(parsed[2], parsed[1], ruleContext);
                            if (pixels !== null && pixels / font_size < 0.12)
                                ret.push((0, IRule_1.RuleFail)("fail_letter_spacing_style"));
                            else
                                ret.push((0, IRule_1.RulePass)("pass"));
                        }
                    }
                    else
                        ret.push((0, IRule_1.RulePass)("pass"));
                }
            }
            else
                ret.push((0, IRule_1.RulePass)("pass"));
        }
        var line_style = styles['line-height'];
        var overflow = { "overflow": ['auto', 'scroll'], "overflow-x": ['auto', 'scroll'], "overflow-y": ['auto', 'scroll'] };
        if (line_style && CSSUtil_1.CSSUtil.getAncestorWithStyles(ruleContext, overflow) === null) {
            if (line_style.startsWith('inherit') || line_style.startsWith('unset')) {
                //get closet ancestor's word-spacing
                var ancestor = CSSUtil_1.CSSUtil.getAncestorWithStyles(ruleContext.parentElement, { "line-height": ["*"] }, ['inherit', 'unset']);
                if (ancestor !== null) {
                    line_style = CSSUtil_1.CSSUtil.getDefinedStyles(ancestor)['line-height'];
                }
                else if (line_style.startsWith('unset')) {
                    line_style = "initial";
                }
            }
            if (ruleContext.style.getPropertyPriority("line-height") === 'important') {
                line_style = line_style.substring(0, line_style.length - "!important".length - 1);
                // computed space is 0 for 'normal' or 'initial'.
                if (line_style === 'initial' || line_style === 'normal')
                    ret.push((0, IRule_1.RuleFail)("fail_line_height_style"));
                else {
                    var lineHeight = parseFloat(line_style);
                    if (!isNaN(lineHeight)) {
                        var parsed = line_style.trim().match(regex);
                        if (parsed[2] === '') { //line-height are allowed unitless when the valie is multiple (or fraction) of the font size
                            if (parsed[1] < 1.5)
                                ret.push((0, IRule_1.RuleFail)("fail_line_height_style"));
                            else
                                ret.push((0, IRule_1.RulePass)("pass"));
                        }
                        else {
                            var pixels = CSSUtil_1.CSSUtil.convertValue2Pixels(parsed[2], parsed[1], ruleContext);
                            if (pixels !== null && pixels / font_size < 1.5)
                                ret.push((0, IRule_1.RuleFail)("fail_line_height_style"));
                            else
                                ret.push((0, IRule_1.RulePass)("pass"));
                        }
                    }
                    else
                        ret.push((0, IRule_1.RulePass)("pass"));
                }
            }
            else
                ret.push((0, IRule_1.RulePass)("pass"));
        }
        if (ret.length > 0)
            return ret;
        return null; //implicable or ignore
    }
};


/***/ }),

/***/ 8681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text_whitespace_valid = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var CommonUtil_1 = __webpack_require__(8137);
exports.text_whitespace_valid = {
    id: "text_whitespace_valid",
    context: "dom:*",
    help: {
        "en-US": {
            "pass": "text_whitespace_valid.html",
            "potential_text": "text_whitespace_valid.html",
            "group": "text_whitespace_valid.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "potential_text": "Space characters should not be used to create space between the letters of a word",
            "group": "Space characters should not be used to control spacing within a word"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["1.3.2"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_THREE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        // Don't trigger if we're not in the body or if we're in a script
        var checkAncestor = CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["body", "script", "code"]);
        if (checkAncestor == null || checkAncestor.nodeName.toLowerCase() != "body")
            return null;
        var passed = true;
        var walkNode = ruleContext.firstChild;
        while (passed && walkNode) {
            // Comply to the Check Hidden Content setting will be done by default as this rule triggers on each element
            // and for each element it only checks that single elements text nodes and nothing else. So all inner elements will be
            // covered on their own. Currently for this rule by default Check Hidden Content will work, as we are doing
            // a node walk only on siblings so it would not get text nodes from other siblings at all.
            // In the case in the future something chnges, just need to add && !RPTUtil.shouldNodeBeSkippedHidden(walkNode) to the below
            // if.
            if (walkNode.nodeName == "#text") {
                var txtVal = walkNode.nodeValue;
                passed = !(/(^|\s)[a-zA-Z] [a-zA-Z] [a-zA-Z]($|\s)/.test(txtVal));
            }
            walkNode = walkNode.nextSibling;
        }
        if (passed)
            return (0, IRule_1.RulePass)("pass");
        return (0, IRule_1.RulePotential)("potential_text");
    }
};


/***/ }),

/***/ 4577:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.widget_tabbable_exists = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var ARIAMapper_1 = __webpack_require__(4944);
var DOMWalker_1 = __webpack_require__(7440);
var VisUtil_1 = __webpack_require__(8656);
exports.widget_tabbable_exists = {
    id: "widget_tabbable_exists",
    context: "aria:button,aria:link,aria:spinbutton,aria:tablist,aria:combobox,aria:listbox,aria:menu,aria:radiogroup,aria:tree,aria:menubar, aria:grid, aria:treegrid, aria:checkbox,aria:slider,aria:spinbutton,aria:textbox,aria:scrollbar,aria:slider,aria:spinbutton",
    refactor: {
        "IBMA_Focus_Tabbable": {
            "pass": "pass",
            "fail_no_tabbable": "fail_no_tabbable"
        }
    },
    help: {
        "en-US": {
            "pass": "widget_tabbable_exists.html",
            "fail_no_tabbable": "widget_tabbable_exists.html",
            "group": "widget_tabbable_exists.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Rule Passed",
            "fail_no_tabbable": "Component with \"{0}\" role does not have a tabbable element",
            "group": "Component must have at least one tabbable element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.1.1"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return;
        //skip the check if the element should be a presentational child of an element
        if (AriaUtil_1.AriaUtil.shouldBePresentationalChild(ruleContext))
            return;
        var nodeName = ruleContext.nodeName.toLowerCase();
        //ignore datalist element check since it will be part of a input element or hidden by default
        if (nodeName === 'datalist')
            return null;
        // Composite user interface widget roles. They act as containers that manage other, contained widgets.
        var roleContainers = ["combobox", "grid", "listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"];
        for (var _i = 0, roleContainers_1 = roleContainers; _i < roleContainers_1.length; _i++) {
            var role_1 = roleContainers_1[_i];
            if (AriaUtil_1.AriaUtil.getAncestorWithRole(ruleContext, role_1, true) != null)
                // it's a descendant of a composite widget already examined
                return null;
        }
        var role = ARIAMapper_1.ARIAMapper.nodeToRole(ruleContext);
        var count = 0;
        if (CommonUtil_1.CommonUtil.isTabbable(ruleContext)) {
            ++count;
        }
        // If node has children, look for tab stops in the children
        // skip the count if the element requires presentational children only
        if (count < 1 && !AriaUtil_1.AriaUtil.containsPresentationalChildrenOnly(ruleContext) && ruleContext.firstChild) {
            //let nw = new NodeWalker(ruleContext);
            var nw = new DOMWalker_1.DOMWalker(ruleContext);
            while (count < 1 && nw.nextNode() && nw.node != ruleContext) {
                if (nw.node.nodeType == 1 && !nw.bEndTag && CommonUtil_1.CommonUtil.isTabbable(nw.node)) {
                    ++count;
                }
            }
        }
        var passed = count >= 1;
        return passed ? (0, IRule_1.RulePass)("pass") : (0, IRule_1.RulePotential)("fail_no_tabbable", [role]);
    }
};


/***/ }),

/***/ 8051:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.widget_tabbable_single = void 0;
var IRule_1 = __webpack_require__(4377);
var IRule_2 = __webpack_require__(4377);
var DOMWalker_1 = __webpack_require__(7440);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var ARIAMapper_1 = __webpack_require__(4944);
var CacheUtil_1 = __webpack_require__(7788);
var VisUtil_1 = __webpack_require__(8656);
exports.widget_tabbable_single = {
    id: "widget_tabbable_single",
    context: "aria:button,aria:link,aria:menuitem,aria:spinbutton,aria:tablist,aria:combobox,aria:listbox,aria:menu,aria:radiogroup,aria:tree,aria:checkbox,aria:option,aria:radio,aria:slider,aria:spinbutton,aria:textbox,aria:columnheader,aria:rowheader,aria:slider,aria:tab",
    refactor: {
        "IBMA_Focus_MultiTab": {
            "pass": "pass",
            "potential_multiple_tabbable": "potential_multiple_tabbable"
        }
    },
    help: {
        "en-US": {
            "pass": "widget_tabbable_single.html",
            "potential_multiple_tabbable": "widget_tabbable_single.html",
            "group": "widget_tabbable_single.html"
        }
    },
    messages: {
        "en-US": {
            "pass": "Components with a widget role should have no more than one tabbable element",
            "potential_multiple_tabbable": "Component with \"{0}\" role has more than one tabbable element",
            "group": "Components with a widget role must have no more than one tabbable element"
        }
    },
    rulesets: [{
            "id": ["IBM_Accessibility", "IBM_Accessibility_next", "WCAG_2_1", "WCAG_2_0", "WCAG_2_2"],
            "num": ["2.1.1", "2.4.3"],
            "level": IRule_2.eRulePolicy.VIOLATION,
            "toolkitLevel": IRule_2.eToolkitLevel.LEVEL_ONE
        }],
    act: [],
    run: function (context, options, contextHierarchies) {
        var ruleContext = context["dom"].node;
        //skip the check if the element is hidden or disabled
        if (VisUtil_1.VisUtil.isNodeHiddenFromAT(ruleContext) || CommonUtil_1.CommonUtil.isNodeDisabled(ruleContext))
            return;
        //skip the check if the element should be a presentational child of an element
        if (AriaUtil_1.AriaUtil.shouldBePresentationalChild(ruleContext))
            return;
        var role = ARIAMapper_1.ARIAMapper.nodeToRole(ruleContext);
        var count = 0;
        if (CommonUtil_1.CommonUtil.isTabbable(ruleContext)) {
            ++count;
        }
        // If node has children, look for tab stops in the children
        //skip the count if the element requires presentational children only
        var name = [];
        if (count < 2 && !AriaUtil_1.AriaUtil.containsPresentationalChildrenOnly(ruleContext) && ruleContext.firstChild) {
            //let nw = new NodeWalker(ruleContext);
            var nw = new DOMWalker_1.DOMWalker(ruleContext);
            while (count < 2 && nw.nextNode() && nw.node != ruleContext) {
                if (nw.node.nodeType == 1 && !nw.bEndTag && CommonUtil_1.CommonUtil.isTabbable(nw.node)) {
                    // Radio inputs with the same name natively are only one tab stop
                    /**if (nw.node.nodeName.toLowerCase() === 'input' && (nw.node as Element).getAttribute("type") === 'radio') {
                        let curName = (nw.node as Element).getAttribute("name");
                        if (name.includes(curName))
                            continue;
                        else
                            name.push(curName);
                    }*/
                    ++count;
                }
            }
        }
        var passed = count < 2;
        if (!passed)
            CacheUtil_1.CacheUtil.setCache(ruleContext, "widget_tabbable_single", "potential_multiple_tabbable");
        return passed ? (0, IRule_1.RulePass)("pass") : (0, IRule_1.RulePotential)("potential_multiple_tabbable", [role]);
    }
};


/***/ }),

/***/ 1070:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.a11yRulesets = void 0;
// This file comes from https://raw.githubusercontent.com/act-rules/act-tools/main/src/data/sc-urls.json
var SCURLs = __webpack_require__(4976);
var IGuideline_1 = __webpack_require__(3005);
var SCs = [];
for (var key in SCURLs) {
    SCs.push(SCURLs[key]);
}
var summaries = {
    "1.1.1": "All non-text content that is presented to the user has a text alternative that serves the equivalent purpose.",
    "1.2.1": "For prerecorded audio-only or video-only media, an alternative provides equivalent information.",
    "1.2.2": "Captions are provided for all prerecorded audio content in synchronized media.",
    "1.2.3": "An alternative for time-based media or audio description of the prerecorded video content is provided for synchronized media.",
    "1.2.4": "Captions are provided for all live audio content in synchronized media.",
    "1.2.5": "Audio description is provided for all prerecorded video content in synchronized media.",
    "1.3.1": "Information, structure, and relationships conveyed through presentation can be programmatically determined or are available in text.",
    "1.3.2": "When the sequence in which content is presented affects its meaning, a correct reading sequence can be programmatically determined.",
    "1.3.3": "Instructions provided for understanding and operating content do not rely solely on sensory characteristics of components such as shape, size, visual location, orientation, or sound.",
    "1.3.4": "Content does not restrict its view and operation to a single display orientation, such as portrait or landscape.",
    "1.3.5": "The purpose of each input field that collects information about the user can be programmatically determined when the field serves a common purpose.",
    "1.4.1": "Color is not used as the only visual means of conveying information, indicating an action, prompting a response, or distinguishing a visual element.",
    "1.4.2": "If any audio plays automatically for more than 3 seconds, either a mechanism is available to pause or stop the audio, or a mechanism is available to control audio volume independently from the overall system volume level.",
    "1.4.3": "The visual presentation of text and images of text has a contrast ratio of at least 4.5:1, with a 3:1 ratio for large-scale text.",
    "1.4.4": "Text can be resized without assistive technology up to 200 percent without loss of content or functionality.",
    "1.4.5": "If the technologies being used can achieve the visual presentation, text should not be used to convey information rather than images of text.",
    "1.4.10": "Content can reflow without loss of information or functionality, and without requiring scrolling in two dimensions.",
    "1.4.11": "The parts of graphical objects required to understand the content, and the visual information required to identify UI components and states, have a contrast ratio of at least 3:1 against adjacent colors.",
    "1.4.12": "No loss of content or functionality occurs when users change letter, word and paragraph spacing, as well as line height.",
    "1.4.13": "Where hover or focus actions cause additional content to become visible and hidden, the additional content is dismissable, hoverable and persistent.",
    "2.1.1": "All functionality of the content is operable through a keyboard interface without requiring specific timings for individual keystrokes.",
    "2.1.2": "If keyboard focus can be moved to a component using a keyboard interface, then focus can be moved away from that component using only a keyboard interface, and, if it requires more than unmodified arrow or tab keys or other standard exit methods, the user is advised of the method for moving focus away.",
    "2.1.4": "If a keyboard shortcut is implemented using only letter, punctuation, number or symbol characters, then the shortcut can be turned off, remapped or activated only on focus.",
    "2.2.1": "For each time limit that is set by the content, the user can turn off, adjust, or extend the limit.",
    "2.2.2": "For moving, blinking, scrolling, or auto-updating information, the user can pause, stop, hide or adjust the information.",
    "2.3.1": "Content does not contain anything that flashes more than three times in any one second period, or the flash is below the general flash and red flash thresholds.",
    "2.4.1": "A mechanism is available to bypass blocks of content that are repeated on multiple Web pages.",
    "2.4.2": "Web pages, non-web documents, and software have titles that describe topic or purpose.",
    "2.4.3": "If content can be navigated sequentially and the navigation sequences affect meaning or operation, focusable components receive focus in an order that preserves meaning and operability.",
    "2.4.4": "The purpose of each link can be determined from the link text alone or from the link text together with its programmatically determined link content.",
    "2.4.5": "More than one way is available to locate a Web page within a set of Web pages, except where the Web Page is the result of, or a step in, a process.",
    "2.4.6": "Headings and labels describe topic or purpose.",
    "2.4.7": "Any keyboard operable user interface has a mode of operation where the keyboard focus indicator is visible.",
    "2.4.11": "When an element receives focus, it is not entirely covered by other content.",
    "2.5.1": "All functionality that uses multipoint or path-based gestures for operation can be operated with a single pointer without a path-based gesture.",
    "2.5.2": "For functionality that can be operated using a single pointer, completion of the function is on the up-event with an ability to abort, undo or reverse the outcome.",
    "2.5.3": "For user interface components with labels that include text or images of text, the accessible name contains the text that is presented visually.",
    "2.5.4": "Functionality that can be operated by motion can also be operated by user interface components, and the motion trigger can be disabled.",
    "2.5.8": "The size of the target for pointer inputs is at least 24 by 24 CSS pixels.",
    "2.5.7": "All functionality that uses a dragging movement for operation can be achieved by a single pointer without dragging.",
    "3.1.1": "The default human language of Web pages, non-Web documents, or software can be programmatically determined.",
    "3.1.2": "The human language of each passage or phrase in the content can be programmatically determined.",
    "3.2.1": "When any component receives focus, it does not initiate a change of context.",
    "3.2.2": "Changing the setting of any user interface component does not automatically cause a change of context unless the user has been advised of the behavior before using the component.",
    "3.2.3": "Navigational mechanisms that are repeated on multiple Web pages within a set of Web pages occur in the same relative order each time they are repeated, unless a change is initiated by the user.",
    "3.2.4": "Components that have the same functionality within a set of Web pages are identified consistently.",
    "3.2.6": "Make it easier to find help and support. If a Web page contains help mechanisms they occur in the same order relative to other page content, unless a change is initiated by the user.",
    "3.3.1": "If an input error is automatically detected, the item that is in error is identified and the error is described to the user in text.",
    "3.3.2": "Labels or instructions are provided when content requires user input.",
    "3.3.3": "If an input error is automatically detected and suggestions for correction are known, then the suggestions are provided to the user, unless it would jeopardize the security or purpose of the content.",
    "3.3.4": "For content that cause legal commitments or financial transactions for the user to occur, that modify or delete user-controllable data in data storage systems, or that submit user test responses, the user can reverse, correct, or confirm the action.",
    "3.3.7": "Make it easier for users to complete multi-step processes. Don't ask for the same information twice in the same session.",
    "3.3.8": "Make logins possible with less mental effort. Don't make people solve, recall, or transcribe something to log in.",
    "4.1.1": "(Obsolete and removed) This requirement was originally adopted to address problems that assistive technology (AT) had directly parsing HTML. AT no longer has any need to directly parse HTML. Consequently, these problems either no longer exist or are addressed by other requirements.",
    "4.1.2": "For all user interface components (including, but not limited to: form elements, links and components generated by scripts), the name and role can be programmatically determined; states, properties, and values that can be set by the user can be programmatically set; and notification of changes to these items is available to user agents, including assistive technologies.",
    "4.1.3": "In content implemented using markup languages, status messages can be programmatically determined through role or properties such that they can be presented to the user by assistive technologies without receiving focus.",
    "HTML": "The HTML specification issues that cause accessibility issues may be covered by other rules and will be reported under those accessibility requirements. However, some non-conforming HTML specification issues are still reported.",
    "ARIA": "The ARIA specification issues that cause accessibility issues may be covered by other rules and will be reported under those accessibility requirements. However, some non-conforming ARIA specification issues are still reported.",
};
exports.a11yRulesets = [
    // {
    //     id: "DEBUG",
    //     name: "DEBUG Rules",
    //     category: eRuleCategory.ACCESSIBILITY,
    //     description: "Rules for debugging",
    //     checkpoints: [{
    //         num: "1",
    //         name: "Debug CP 1",
    //         wcagLevel: "A",
    //         summary: "Rules for Debug"
    //     }]
    // },
    {
        id: "EXTENSIONS",
        name: "Extension Rules",
        category: IGuideline_1.eGuidelineCategory.ACCESSIBILITY,
        description: "Rules for enabling the browser extensions",
        type: IGuideline_1.eGuidelineType.EXTENSION,
        checkpoints: [{
                num: "1",
                name: "Extension CP 1",
                wcagLevel: "A",
                summary: "Rules for Extension"
            }]
    },
    {
        id: "IBM_Accessibility",
        name: "IBM Accessibility 7.3",
        category: IGuideline_1.eGuidelineCategory.ACCESSIBILITY,
        description: "Rules for WCAG 2.0, 2.1, 2.2 A and AA plus additional IBM supplemental requirements.",
        // This ruleset has all 2.0 and 2.1 checkpoints that are A or AA
        checkpoints: SCs
            .filter(function (sc) { return (sc.level === "A" || sc.level === "AA" || sc.level === "NA") && (sc.wcagType === "2.0" || sc.wcagType === "2.1" || sc.wcagType === "2.2" || sc.wcagType === "NA"); })
            .map(function (sc) { return ({
            num: sc.num,
            scId: sc.scId,
            name: sc.handle,
            wcagLevel: sc.level,
            summary: summaries[sc.num]
        }); })
    },
    {
        id: "IBM_Accessibility_next",
        name: "IBM Accessibility next",
        category: IGuideline_1.eGuidelineCategory.ACCESSIBILITY,
        description: "Rules for WCAG 2.0, 2.1, 2.2 A and AA plus additional IBM supplemental requirements.",
        // This ruleset has all 2.0 and 2.1 checkpoints that are A or AA
        checkpoints: SCs
            .filter(function (sc) { return (sc.level === "A" || sc.level === "AA" || sc.level === "NA") && (sc.wcagType === "2.0" || sc.wcagType === "2.1" || sc.wcagType === "2.2" || sc.wcagType === "NA"); })
            .map(function (sc) { return ({
            num: sc.num,
            scId: sc.scId,
            name: sc.handle,
            wcagLevel: sc.level,
            summary: summaries[sc.num]
        }); })
    },
    {
        id: "WCAG_2_2",
        name: "WCAG 2.2 (A, AA)",
        category: IGuideline_1.eGuidelineCategory.ACCESSIBILITY,
        description: "Rules for WCAG 2.2 A & AA. This is the current W3C recommendation (specification). Content that conforms to WCAG 2.2 also conforms to WCAG 2.1.",
        // This ruleset has all 2.0 and 2.1 checkpoints that are A or AA
        checkpoints: SCs
            .filter(function (sc) { return (sc.level === "A" || sc.level === "AA") && (sc.wcagType === "2.0" || sc.wcagType === "2.1" || sc.wcagType === "2.2"); })
            .map(function (sc) { return ({
            num: sc.num,
            scId: sc.scId,
            name: sc.handle,
            wcagLevel: sc.level,
            summary: summaries[sc.num]
        }); })
    },
    {
        id: "WCAG_2_1",
        name: "WCAG 2.1 (A, AA)",
        category: IGuideline_1.eGuidelineCategory.ACCESSIBILITY,
        description: "Rules for WCAG 2.1 A & AA. Content that conforms to WCAG 2.1 also conforms to WCAG 2.0.",
        // This ruleset has all 2.0 and 2.1 checkpoints that are A or AA
        checkpoints: SCs
            .filter(function (sc) { return (sc.level === "A" || sc.level === "AA") && (sc.wcagType === "2.0" || sc.wcagType === "2.1"); })
            .map(function (sc) { return ({
            num: sc.num,
            scId: sc.scId,
            name: sc.handle,
            wcagLevel: sc.level,
            summary: summaries[sc.num]
        }); })
    },
    {
        id: "WCAG_2_0",
        name: "WCAG 2.0 (A, AA)",
        category: IGuideline_1.eGuidelineCategory.ACCESSIBILITY,
        description: "Rules for WCAG 2.0 A & AA. Referenced by US Section 508, but not the latest W3C recommendation.",
        // This ruleset has all 2.0 checkpoints that are A or AA
        checkpoints: SCs
            .filter(function (sc) { return (sc.level === "A" || sc.level === "AA") && (sc.wcagType === "2.0"); })
            .map(function (sc) { return ({
            num: sc.num,
            scId: sc.scId,
            name: sc.handle,
            wcagLevel: sc.level,
            summary: summaries[sc.num]
        }); })
    }
];


/***/ }),

/***/ 1421:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccNameUtil = void 0;
var ARIADefinitions_1 = __webpack_require__(8235);
var CommonUtil_1 = __webpack_require__(8137);
var AriaUtil_1 = __webpack_require__(490);
var VisUtil_1 = __webpack_require__(8656);
var CacheUtil_1 = __webpack_require__(7788);
var DOMWalker_1 = __webpack_require__(7440);
var DOMUtil_1 = __webpack_require__(295);
var AccNameUtil = /** @class */ (function () {
    function AccNameUtil() {
    }
    // calculate accessible name for a given node
    AccNameUtil.computeAccessibleName = function (elem) {
        if (!elem)
            return null;
        var nodeName = elem.nodeName.toLowerCase();
        var name_pair = CacheUtil_1.CacheUtil.getCache(elem, "ELEMENT_ACCESSBLE_NAME", undefined);
        if (name_pair !== undefined)
            return name_pair;
        // 1. name from author, or elements without a role but with aria-labelledby or aria-label 
        //   get aria label even for the role where the name is prohibited or is 'presentation' or 'none'
        var accName = AriaUtil_1.AriaUtil.getAriaLabel(elem);
        if (accName && accName.trim() !== "") {
            CacheUtil_1.CacheUtil.setCache(elem, "ELEMENT_ACCESSBLE_NAME", { "name": CommonUtil_1.CommonUtil.truncateText(accName), "nameFrom": "ariaLabel" });
            return { "name": CommonUtil_1.CommonUtil.truncateText(accName), "nameFrom": "ariaLabel" };
        }
        // 2. accessible name mapping for native html elements
        name_pair = AccNameUtil.computeAccessibleNameForNativeElement(elem);
        if (name_pair) {
            CacheUtil_1.CacheUtil.setCache(elem, "ELEMENT_ACCESSBLE_NAME", name_pair);
            return name_pair;
        }
        // 3. name from native or aria attribute
        /**name_pair = AccNameUtil.computeAccessibleNameFromAttribute(elem);
        if (name_pair) {
            CacheUtil.setCache(elem, "ELEMENT_ACCESSBLE_NAME", name_pair);
            return name_pair;
        }*/
        // 4. name from content for custom elements with a role
        var role = AriaUtil_1.AriaUtil.getResolvedRole(elem);
        if (ARIADefinitions_1.ARIADefinitions.designPatterns[role] && ARIADefinitions_1.ARIADefinitions.designPatterns[role].nameFrom.includes("contents")) {
            name_pair = AccNameUtil.computeAccessibleNameFromContent(elem);
            if (name_pair) {
                CacheUtil_1.CacheUtil.setCache(elem, "ELEMENT_ACCESSBLE_NAME", name_pair);
                return name_pair;
            }
        }
        // 5. name from the global attribute "title"
        if (elem.hasAttribute("title")) {
            var title = elem.getAttribute("title").trim();
            if (title && title.trim().length > 0) {
                title = CommonUtil_1.CommonUtil.truncateText(title);
                CacheUtil_1.CacheUtil.setCache(elem, "ELEMENT_ACCESSBLE_NAME", { "name": title, "nameFrom": "title" });
                return { "name": title, "nameFrom": "title" };
            }
        }
        // 6. name from the attribute "placeholder"
        if (nodeName === 'textarea' || (nodeName === 'input' && (!elem.hasAttribute("type") || CommonUtil_1.CommonUtil.input_type_with_placeholder.includes(elem.getAttribute("type"))))) {
            var placeholder = elem.getAttribute("placeholder");
            if (placeholder && placeholder.trim().length > 0) {
                placeholder = CommonUtil_1.CommonUtil.truncateText(placeholder);
                CacheUtil_1.CacheUtil.setCache(elem, "ELEMENT_ACCESSBLE_NAME", { "name": placeholder, "nameFrom": "placeholder" });
                return { "name": placeholder, "nameFrom": "placeholder" };
            }
        }
        CacheUtil_1.CacheUtil.setCache(elem, "ELEMENT_ACCESSBLE_NAME", null);
        return null;
    };
    // calculate accessible name for native elements
    AccNameUtil.computeAccessibleNameForNativeElement = function (elem) {
        var nodeName = elem.nodeName.toLowerCase();
        // labellable fields
        if (CommonUtil_1.CommonUtil.form_labelable_elements.includes(nodeName)) {
            // Get only the non-hidden labels for element
            var label = CommonUtil_1.CommonUtil.getFormFieldLabel(elem);
            if (label && label.trim() !== '')
                return { "name": CommonUtil_1.CommonUtil.truncateText(label), "nameFrom": "label" };
        }
        // input types: button, reset, submit, image
        if (nodeName === "input" && elem.hasAttribute("type")) {
            if (CommonUtil_1.CommonUtil.form_button_types.includes(elem.getAttribute("type"))) {
                // input types: button, reset, submit
                // Get the "value" attribute for the element
                var value = CommonUtil_1.CommonUtil.getElementAttribute(elem, "value");
                if (value && value.trim() !== '')
                    return { "name": CommonUtil_1.CommonUtil.truncateText(value), "nameFrom": "value" };
                // input 'submit' and 'reset' have visible defaults so pass if there is no explicit 'value' attribute
                var type = elem.getAttribute("type");
                if (type === 'submit' || type === 'reset')
                    return { "name": type, "nameFrom": "internal" };
            }
            else if (elem.getAttribute("type") === 'image') {
                // input type = 'image'
                // note that though HTML 5 spec indicates "The element's [value] attribute must be omitted", Chrome uses the value.
                // Get the accessible name for the alt attribute
                var alt = CommonUtil_1.CommonUtil.getElementAttribute(elem, "alt");
                if (alt && alt.trim() !== '')
                    return { "name": CommonUtil_1.CommonUtil.truncateText(alt), "nameFrom": "alt" };
                ;
                // the visible default text for type "image" is "Submit" same with the type "submit"
                //return {"name":elem.getAttribute("type"), "nameFrom": "internal"};
            }
        }
        // button
        // note button may have a value attribute, but it's not a visible text
        if (nodeName === "button") {
            // first use the button text
            var text = elem.innerText;
            if (text && text.trim() !== '')
                return { "name": CommonUtil_1.CommonUtil.truncateText(text), "nameFrom": "text" };
            // for image button: get the first image if exists
            var image = elem.querySelector('img');
            if (image && !VisUtil_1.VisUtil.isNodeHiddenFromAT(image) && !VisUtil_1.VisUtil.isNodePresentational(image)) {
                var pair = AccNameUtil.computeAccessibleName(image);
                if (pair && pair.name && pair.name.trim().length > 0)
                    return pair;
            }
            // for a button with a svg image
            var svg = elem.querySelector('svg');
            if (svg && !VisUtil_1.VisUtil.isNodeHiddenFromAT(svg) && !VisUtil_1.VisUtil.isNodePresentational(svg)) {
                var pair = AccNameUtil.computeAccessibleName(svg);
                if (pair && pair.name && pair.name.trim().length > 0)
                    return pair;
            }
        }
        // fieldset
        if (nodeName === "fieldset") {
            // if the fieldset element's first child is a legend element, then use the subtree of the legend
            var first = elem.firstElementChild;
            if (first && first.nodeName.toLowerCase() === 'legend') {
                // legend can be mixed text
                var text = first.innerText;
                if (text && text.trim().length > 0)
                    return { "name": CommonUtil_1.CommonUtil.truncateText(text), "nameFrom": "legend" };
            }
        }
        // output
        if (nodeName === "output") {
            // if the associated label element exists, use concatenated accessible name(s) from labelled elements.
            if (elem.hasAttribute("for")) {
                var labelIDs = elem.getAttribute("for").trim().split(" ");
                if (labelIDs && labelIDs.length > 0) {
                    var label = "";
                    for (var j = 0; j < labelIDs.length; j++) {
                        var labelNode = elem.ownerDocument.getElementById(labelIDs[j]);
                        if (labelNode && !DOMUtil_1.DOMUtil.sameNode(labelNode, elem) && !VisUtil_1.VisUtil.isNodeHiddenFromAT(labelNode) && !VisUtil_1.VisUtil.isNodePresentational(labelNode)) {
                            var pair = AccNameUtil.computeAccessibleName(labelNode);
                            if (pair && pair.name && pair.name.trim().length > 0)
                                label += " " + CommonUtil_1.CommonUtil.normalizeSpacing(pair.name);
                        }
                    }
                    if (label.trim().length > 0)
                        return { "name": CommonUtil_1.CommonUtil.truncateText(label), "nameFrom": "label" };
                }
            }
        }
        // summary
        if (nodeName === "summary") {
            // use summary element subtree
            var text = elem.innerText;
            if (text && text.trim().length > 0)
                return { "name": CommonUtil_1.CommonUtil.truncateText(text), "nameFrom": "legend" };
        }
        // details
        if (nodeName === "details") {
            var first = elem.firstElementChild;
            if (first && first.nodeName.toLowerCase() === 'summary') {
                // get accessible name from summary
                var pair = AccNameUtil.computeAccessibleName(first);
                if (pair && pair.name && pair.name.trim().length > 0)
                    return { "name": CommonUtil_1.CommonUtil.truncateText(pair.name.trim()), "nameFrom": "summary" };
            }
            // If no summary element as a direct child of the details element, 
            // the user agent should provide one with a subtree containing a localized string of the word "details".
            return { "name": "details", "nameFrom": "internal" };
        }
        // figure
        if (nodeName === "figure") {
            // if the figure element has a figcaption as a child
            var caption = CommonUtil_1.CommonUtil.getChildByTagHidden(elem, "figcaption", true, false);
            if (caption && caption.length > 0) {
                // figcaption can be mixed text
                var text = caption[0].innerText;
                if (text && text.trim().length > 0)
                    return { "name": CommonUtil_1.CommonUtil.truncateText(text), "nameFrom": "figcaption" };
            }
        }
        // img elements: use attribute "alt"
        if (nodeName === "img") {
            if (elem.hasAttribute("alt")) {
                var alt = elem.getAttribute("alt");
                return { "name": CommonUtil_1.CommonUtil.truncateText(alt), "nameFrom": "alt" };
            }
        }
        // area elements: use attribute "alt"
        if (nodeName === "area") {
            if (elem.hasAttribute("alt")) {
                var alt = elem.getAttribute("alt");
                if (alt && alt.trim().length > 0)
                    return { "name": CommonUtil_1.CommonUtil.truncateText(alt), "nameFrom": "alt" };
            }
        }
        // table element
        if (nodeName === "table") {
            // if the figure element has a caption as the first child
            var captionElem = elem.firstElementChild;
            if (captionElem && captionElem.nodeName.toLowerCase() === 'caption') {
                // caption can be mixed text
                var caption = captionElem.innerText;
                if (caption && caption.trim().length > 0)
                    return { "name": CommonUtil_1.CommonUtil.truncateText(caption), "nameFrom": "caption" };
            }
        }
        // a element
        if (nodeName === "a") {
            // first use the link text
            var text = elem.innerText;
            if (text && text.trim() !== '')
                return { "name": CommonUtil_1.CommonUtil.truncateText(text), "nameFrom": "text" };
            //for image link: get the image or svg if exists
            var images = elem.querySelectorAll(":scope > img, :scope > svg");
            if (images && images.length > 0) {
                var text_1 = "";
                images.forEach(function (image) {
                    if (!VisUtil_1.VisUtil.isNodeHiddenFromAT(image) && !VisUtil_1.VisUtil.isNodePresentational(image)) {
                        var pair = AccNameUtil.computeAccessibleName(image);
                        if (pair && pair.name && pair.name.trim().length > 0)
                            text_1 += " " + pair.name.trim();
                    }
                });
                if (text_1.trim() !== '')
                    return { "name": text_1.trim(), "nameFrom": "alt" };
            }
        }
        // optgroup
        // label participate in accessible name calculation: https://www.w3.org/TR/html-aam-1.0/#att-label
        // The label attribute must be specified. Its value gives the name of the group
        // the value is disabled in the interface
        if (nodeName === "optgroup" || nodeName === "option" || nodeName === "track") {
            var label = elem.getAttribute("label");
            if (label && label.trim().length > 0)
                return { "name": CommonUtil_1.CommonUtil.truncateText(label), "nameFrom": "label" };
        }
        // svg
        if (nodeName === "svg") {
            var pair = AccNameUtil.computeAccessibleNameForSVGElement(elem);
            if (pair && pair.name && pair.name.trim().length > 0)
                return pair;
        }
        return null;
    };
    // calculate accessible name for native elements
    AccNameUtil.computeAccessibleNameForSVGElement = function (elem) {
        // 1. a direct child or descendant title element 
        var svgTitles = elem.querySelectorAll(":scope > title");
        if (svgTitles && svgTitles.length > 0) {
            var text_2 = "";
            svgTitles.forEach(function (svgTitle) {
                if (svgTitle && !VisUtil_1.VisUtil.isNodeHiddenFromAT(svgTitle) && !VisUtil_1.VisUtil.isNodePresentational(svgTitle)) {
                    var title = svgTitle.textContent;
                    if (title && title.trim() !== '')
                        text_2 += title.trim();
                }
            });
            if (text_2 && text_2.trim() !== '')
                return { "name": text_2.trim(), "nameFrom": "svgTitle" };
        }
        // 2. xlink:title attribute on a link
        var linkTitle = elem.querySelector("a");
        if (linkTitle && !VisUtil_1.VisUtil.isNodeHiddenFromAT(linkTitle) && !VisUtil_1.VisUtil.isNodePresentational(linkTitle)) {
            var link = linkTitle.getAttribute("xlink:title");
            if (link && link.trim() !== '')
                return { "name": CommonUtil_1.CommonUtil.truncateText(link), "nameFrom": "svglinkTitle" };
        }
        /** 3. for text container elements, the text content.
         * note the SVG text content elements are: text, textPath and tspan.
         *  svg element can be nested. One of the purposes is to to group SVG shapes together as a collection for responsive design.
         *
         * select text content excluded the text from the nested svg elements and their children
         */
        var text = "";
        elem.querySelectorAll(":scope > *").forEach(function (element) {
            if (element.nodeName.toLowerCase() !== 'svg' && !VisUtil_1.VisUtil.isNodeHiddenFromAT(element) && !VisUtil_1.VisUtil.isNodePresentational(element)) {
                var value = CommonUtil_1.CommonUtil.getInnerText(element);
                if (value && value.trim().length > 0)
                    text += value;
            }
        });
        if (text.trim() !== '')
            return { "name": CommonUtil_1.CommonUtil.truncateText(text), "nameFrom": "svgText" };
        // 4. from aria-describedby or aria-description 
        var descby = AriaUtil_1.AriaUtil.getAriaDescription(elem);
        if (descby && descby.trim().length > 0)
            return { "name": CommonUtil_1.CommonUtil.truncateText(descby), "nameFrom": "aria-description" };
        // 5. a direct child or descendant desc element
        var descElems = elem.querySelectorAll(":scope > desc");
        if (descElems && descElems.length > 0) {
            var text_3 = "";
            descElems.forEach(function (descElem) {
                if (descElem && !VisUtil_1.VisUtil.isNodeHiddenFromAT(descElem) && !VisUtil_1.VisUtil.isNodePresentational(descElem)) {
                    var desc = descElem.textContent;
                    if (desc && desc.trim() !== '')
                        text_3 += desc.trim();
                }
            });
            if (text_3 && text_3.trim() !== '')
                return { "name": text_3.trim(), "nameFrom": "svgDesc" };
        }
    };
    // calculate accessible name for custom elements marked with aria
    AccNameUtil.computeAccessibleNameFromContent = function (elem) {
        var nodeName = elem.nodeName.toLowerCase();
        var role = AriaUtil_1.AriaUtil.getResolvedRole(elem);
        /** for acc name from content, the content from CSS pseudo-elements
         *  :before and :after pseudo elements [CSS2] can provide textual content for elements that have a content model.
         * For :before or :after pseudo elements, user agents must prepend CSS textual content, without a space,
         *   to the textual content of the current node.
         */
        var pair = AccNameUtil.computeAccessibleNameForCSSPseudoElement(elem, "before");
        if (pair !== null && pair.name && pair.name.trim().length > 0)
            return pair;
        pair = AccNameUtil.computeAccessibleNameForCSSPseudoElement(elem, "after");
        if (pair && pair.name && pair.name.trim().length > 0)
            return pair;
        //  shadow host
        if (elem.shadowRoot) {
            pair = AccNameUtil.computeAccessibleNameForShadowHost(elem);
            if (pair && pair.name && pair.name.trim().length > 0)
                return { "name": pair.name, "nameFrom": "shadow" };
            ;
        }
        // slot element
        if (nodeName === "slot") {
            pair = AccNameUtil.computeAccessibleNameForSlostElement(elem);
            if (pair && pair.name && pair.name.trim().length > 0)
                return { "name": pair.name, "nameFrom": "slot" };
        }
        // otherwise: get the value from the element
        pair = AccNameUtil.computeAccessibleNameFromChildren(elem);
        if (pair && pair.name && pair.name.trim().length > 0)
            return { "name": pair.name, "nameFrom": "content" };
        // no accessible name exists
        return null;
    };
    // calculate accessible name from CSS generated content
    AccNameUtil.computeAccessibleNameForCSSPseudoElement = function (elem, type) {
        var contentElem = elem.ownerDocument.defaultView.getComputedStyle(elem, type);
        if (contentElem) {
            var content = contentElem.content;
            if (content && content !== "none" && content !== "no" && content !== "normal") {
                content = content.replace(/^"/, "").replace(/"$/, "");
                if (content.trim().length > 0)
                    return { "name": CommonUtil_1.CommonUtil.truncateText(content), "nameFrom": "css-" + type };
            }
        }
        return null;
    };
    // calculate accessible name for SLOT element
    AccNameUtil.computeAccessibleNameForShadowHost = function (elem) {
        var text = "";
        var shadowRoot = elem.shadowRoot;
        if (shadowRoot) {
            var children = shadowRoot.querySelectorAll('*');
            // check text from all the children elements
            children.forEach(function (child) {
                var pair = AccNameUtil.computeAccessibleName(child);
                if (pair && pair.name && pair.name.trim().length > 0)
                    text += " " + pair.name.trim();
            });
        }
        if (text.trim().length > 0)
            return { "name": CommonUtil_1.CommonUtil.truncateText(text), "nameFrom": "shadow-host" };
        return null;
    };
    // calculate accessible name for SLOT element
    AccNameUtil.computeAccessibleNameForSlostElement = function (elem) {
        //if no assignedNode, check its own text 
        var text = "";
        if (!elem.assignedNodes() || elem.assignedNodes().length === 0) {
            var pair = AccNameUtil.computeAccessibleName(elem);
            if (pair && pair.name && pair.name.trim().length > 0)
                text += " " + pair.name.trim();
        }
        else {
            // check text from all assigned nodes
            for (var _i = 0, _a = elem.assignedNodes(); _i < _a.length; _i++) {
                var slotChild = _a[_i];
                var pair = AccNameUtil.computeAccessibleName(slotChild);
                if (pair && pair.name && pair.name.length > 0)
                    text += " " + pair.name.trim();
            }
        }
        if (text.trim().length > 0)
            return { "name": CommonUtil_1.CommonUtil.truncateText(text), "nameFrom": "content-slot" };
        return null;
    };
    // calculate accessible name from children content
    AccNameUtil.computeAccessibleNameFromChildren = function (elem) {
        var text = "";
        //let walkChild = elem.firstChild;
        var nw = new DOMWalker_1.DOMWalker(elem);
        // Loop over all the childrens of the element to get the text
        while (nw.nextNode() && nw.node !== elem && nw.node !== elem.parentNode) {
            if (nw.bEndTag)
                continue;
            //while (walkChild) { 
            var walkChild = nw.node;
            if (walkChild.nodeType === 3) {
                // for the text node, get the parentnode to check visibility
                var parent_1 = walkChild.parentElement;
                if (!VisUtil_1.VisUtil.isNodeHiddenFromAT(parent_1) && !VisUtil_1.VisUtil.isNodePresentational(parent_1) && walkChild.nodeValue && walkChild.nodeValue.trim().length > 0)
                    text += " " + walkChild.nodeValue.trim();
            }
            else if (walkChild.nodeType === 1 && !VisUtil_1.VisUtil.isNodeHiddenFromAT(walkChild) && !VisUtil_1.VisUtil.isNodePresentational(walkChild)) {
                var pair = AccNameUtil.computeAccessibleName(walkChild);
                if (pair && pair.name && pair.name.length > 0)
                    text += " " + pair.name.trim();
            }
        }
        if (text.trim().length > 0)
            return { "name": CommonUtil_1.CommonUtil.truncateText(text), "nameFrom": "content" };
        return null;
    };
    // if accessible name can be ignored for image or svg
    AccNameUtil.isAccessibleNameIgnorable = function (elem) {
        if (!elem)
            return false;
        var nodeName = elem.nodeName.toLowerCase();
        if (nodeName !== 'img' && nodeName !== 'svg')
            return false;
        var parent = elem.parentElement;
        if (parent) {
            // if the parent is a widget and has an aria label, then image/svg label is not necessary
            if ((AriaUtil_1.AriaUtil.isWidget(parent) || AriaUtil_1.AriaUtil.containsPresentationalChildrenOnly(parent)) && AriaUtil_1.AriaUtil.hasAriaLabel(parent))
                return true;
        }
        return false;
    };
    return AccNameUtil;
}());
exports.AccNameUtil = AccNameUtil;


/***/ }),

/***/ 490:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AriaUtil = void 0;
var CacheUtil_1 = __webpack_require__(7788);
var ARIADefinitions_1 = __webpack_require__(8235);
var ARIAMapper_1 = __webpack_require__(4944);
var DOMWalker_1 = __webpack_require__(7440);
var VisUtil_1 = __webpack_require__(8656);
var CommonUtil_1 = __webpack_require__(8137);
var AccNameUtil_1 = __webpack_require__(1421);
var fragment_1 = __webpack_require__(482);
var DOMUtil_1 = __webpack_require__(295);
var AriaUtil = /** @class */ (function () {
    function AriaUtil() {
    }
    AriaUtil.isDefinedAriaAttributeAtIndex = function (ele, index) {
        var attrName = ele.attributes[index].name;
        return AriaUtil.isDefinedAriaAttribute(ele, attrName);
    };
    /**
     * this method returns user-defined aria attribute name from dom
     * @param ele  element
     * @returns user defined aria attributes
     */
    AriaUtil.getUserDefinedAriaAttributes = function (elem) {
        var ariaAttributes = [];
        var domAttributes = elem.attributes;
        if (domAttributes) {
            for (var i = 0; i < domAttributes.length; i++) {
                var attrName = domAttributes[i].name.trim().toLowerCase();
                var isAria = attrName.substring(0, 5) === 'aria-';
                if (isAria)
                    ariaAttributes.push(attrName);
            }
        }
        return ariaAttributes;
    };
    /**
     * this method returns user-defined html attribute name from dom
     * @param ele  element
     * @returns user defined html attributes
     */
    AriaUtil.getUserDefinedHtmlAttributes = function (elem) {
        var htmlAttributes = [];
        var domAttributes = elem.attributes;
        if (domAttributes) {
            for (var i = 0; i < domAttributes.length; i++) {
                var attrName = domAttributes[i].name.trim().toLowerCase();
                var isAria = attrName.substring(0, 5) === 'aria-';
                if (!isAria)
                    htmlAttributes.push(attrName);
            }
        }
        return htmlAttributes;
    };
    /**
     * this method returns user-defined aria attribute name-value pair from dom
     * @param ele  element
     * @returns user defined aria attributes
     */
    AriaUtil.getUserDefinedAriaAttributeNameValuePairs = function (elem) {
        var ariaAttributes = [];
        var domAttributes = elem.attributes;
        if (domAttributes) {
            for (var i = 0; i < domAttributes.length; i++) {
                var attrName = domAttributes[i].name.trim().toLowerCase();
                var attrValue = elem.getAttribute(attrName);
                if (attrValue === '')
                    attrValue = null;
                var isAria = attrName.substring(0, 5) === 'aria-';
                if (isAria)
                    ariaAttributes.push({ name: attrName, value: attrValue });
            }
        }
        return ariaAttributes;
    };
    /**
     * this method returns user-defined html attribute name-value pair from dom
     * @param ele  element
     * @returns user defined html attributes
     */
    AriaUtil.getUserDefinedHtmlAttributeNameValuePairs = function (elem) {
        var htmlAttributes = [];
        var domAttributes = elem.attributes;
        if (domAttributes) {
            for (var i = 0; i < domAttributes.length; i++) {
                var attrName = domAttributes[i].name.trim().toLowerCase();
                var attrValue = elem.getAttribute(attrName);
                if (attrValue === '')
                    attrValue = null;
                var isAria = attrName.substring(0, 5) === 'aria-';
                if (!isAria)
                    htmlAttributes.push({ name: attrName, value: attrValue });
            }
        }
        return htmlAttributes;
    };
    /**
     * This method handles implicit aria definitions, for example, an input with checked is equivalent to aria-checked="true"
     */
    AriaUtil.getAriaAttribute = function (ele, attributeName) {
        // If the attribute is defined, it takes precedence
        var retVal = ele.getAttribute(attributeName);
        if (ele.hasAttribute(attributeName) && retVal.trim() === "") { //"" is treated as false, so we need return it before the below check
            return retVal;
        }
        // Then determine implicit values from other attributes
        if (!retVal) {
            var tag = ele.nodeName.toLowerCase();
            if (attributeName in AriaUtil.ariaAttributeImplicitMappings) {
                if (tag in AriaUtil.ariaAttributeImplicitMappings[attributeName]) {
                    retVal = AriaUtil.ariaAttributeImplicitMappings[attributeName][tag];
                    if (typeof (retVal) === "function") {
                        retVal = retVal(ele);
                    }
                }
                else if ("*" in AriaUtil.ariaAttributeImplicitMappings[attributeName]) {
                    retVal = AriaUtil.ariaAttributeImplicitMappings[attributeName]["*"];
                    if (typeof (retVal) === "function") {
                        retVal = retVal(ele);
                    }
                }
            }
        }
        // Check role-based defaults
        if (!retVal) {
            var role = ARIAMapper_1.ARIAMapper.nodeToRole(ele);
            if (role in AriaUtil.ariaAttributeRoleDefaults && attributeName in AriaUtil.ariaAttributeRoleDefaults[role]) {
                retVal = AriaUtil.ariaAttributeRoleDefaults[role][attributeName];
                if (typeof (retVal) === "function") {
                    retVal = retVal(ele);
                }
            }
        }
        // Still not defined? Check global defaults
        if (!retVal && attributeName in AriaUtil.ariaAttributeGlobalDefaults) {
            retVal = AriaUtil.ariaAttributeGlobalDefaults[attributeName];
        }
        return retVal;
    };
    AriaUtil.isDefinedAriaAttribute = function (ele, attrName) {
        var isDefinedAriaAttribute = false;
        if (attrName.substring(0, 5) === 'aria-') {
            // User agents SHOULD treat state and property attributes with a value of "" the same as they treat an absent attribute.
            isDefinedAriaAttribute = ele.hasAttribute && ele.hasAttribute(attrName) && ele.getAttribute(attrName).length > 0;
        }
        return isDefinedAriaAttribute;
    };
    /**
     * WAI-ARIAs role attribute may have a list of values, but only the first valid and supported WAI-ARIA role is used
     * https://www.w3.org/TR/wai-aria-implementation/#mapping_role_table
     * This function is responsible for retrieving the resoled role for an element.
     * @parm {HTMLElement} ele - element for which to find role.
     *
     * @return string - resolved role for the element:
     *       explicit role: resoled from the list of values
     *       implicit role: if not explicitely specified, or none of the specified role values is allowed for the element
     *       null: if none of the specified role values is allowed for the element, neither implicit role exists
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getResolvedRole = function (elem, considerImplicitRoles) {
        if (considerImplicitRoles === void 0) { considerImplicitRoles = true; }
        if (!elem)
            return null;
        var role = CacheUtil_1.CacheUtil.getCache(elem, "RPTUTIL_ELEMENT_RESOLVED_ROLE", null);
        if (role === null) {
            var roles = AriaUtil.getUserDefinedRoles(elem);
            var tagProperty = AriaUtil.getElementAriaProperty(elem);
            var allowedRoles = AriaUtil.getAllowedAriaRoles(elem, tagProperty);
            var containsGeneric = false;
            if (roles && roles.length > 0 && allowedRoles && allowedRoles.length > 0) {
                for (var i = 0; i < roles.length; i++) {
                    if (allowedRoles.includes("any") || allowedRoles.includes(roles[i])) {
                        if (allowedRoles.includes("any") && roles[i] === 'generic') {
                            containsGeneric = true;
                            continue;
                        }
                        role = roles[i];
                        if (role === "presentation" || role === "none") {
                            // If element is focusable, then presentation roles are to be ignored
                            if (CommonUtil_1.CommonUtil.isFocusable(elem)) {
                                //reset rule to null
                                role = null;
                                continue;
                            }
                        }
                        break;
                    }
                }
                if (containsGeneric)
                    role = 'generic';
            }
            if (role === null && considerImplicitRoles) {
                var implicitRole = AriaUtil.getImplicitRole(elem);
                role = implicitRole && implicitRole.length > 0 ? implicitRole[0] : undefined;
            }
            CacheUtil_1.CacheUtil.setCache(elem, "RPTUTIL_ELEMENT_RESOLVED_ROLE", role);
        }
        return role !== undefined ? role : null;
    };
    /**
     * This function is responsible for retrieving user defined element's roles from dom.
     * @parm {HTMLElement} ele - element for which to find role.
     *
     * @return {List} roles - list of user defined roles in the element role attribute.
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getUserDefinedRoles = function (ele) {
        return AriaUtil.getRoles(ele, false);
    };
    /**
     * This function is responsible for retrieving element's roles.
     * This function also finds implicit roles.
     * @parm {HTMLElement} ele - element for which to find role.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {List} roles - list of attribute roles and implicit roles.
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getRoles = function (ele, considerImplicitRoles) {
        var roles = [];
        if (ele && ele.hasAttribute && ele.hasAttribute("role")) {
            var attrRoles = CommonUtil_1.CommonUtil.normalizeSpacing(ele.getAttribute("role").trim()).split(" ");
            for (var i = 0; i < attrRoles.length; ++i) {
                roles.push(attrRoles[i]);
            }
        }
        //check if implicit roles exist.
        //Note: element can have multiple implicit roles
        if (considerImplicitRoles) {
            var implicitRole = AriaUtil.getImplicitRole(ele);
            if (implicitRole !== null && implicitRole.length > 0) {
                //add implicit roles to the attributes roles.
                CommonUtil_1.CommonUtil.concatUniqueArrayItemList(implicitRole, roles);
            }
        }
        return roles;
    };
    /**
     * Returns the implicit role of the elemement
     * @parm {HTMLElement} ele - element for which to find role.
     *
     * @return the implicit role or [] if doesn't exist
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getImplicitRole = function (ele) {
        if (!ele || ele.nodeType !== 1)
            return null;
        var implicitRoles = CacheUtil_1.CacheUtil.getCache(ele, "AriaUtil_ImplicitRole", null);
        if (!implicitRoles) {
            var tagProperty = AriaUtil.getElementAriaProperty(ele);
            // check if there are any implicit roles for this element.
            if (tagProperty && tagProperty.implicitRole) {
                if (tagProperty.implicitRole.includes("generic")) {
                    // the 'generic' role is only allowed if a valid aria attribute exists.
                    var domAriaAttributes_1 = AriaUtil.getUserDefinedAriaAttributes(ele);
                    if (domAriaAttributes_1.length === 0) {
                        CacheUtil_1.CacheUtil.setCache(ele, "AriaUtil_ImplicitRole", []);
                        return [];
                    }
                    var roleAttributes = [];
                    var pattern = ARIADefinitions_1.ARIADefinitions.designPatterns['generic'];
                    if (pattern.reqProps && pattern.reqProps.length > 0)
                        CommonUtil_1.CommonUtil.concatUniqueArrayItemList(pattern.reqProps, roleAttributes);
                    if (tagProperty.globalAriaAttributesValid)
                        CommonUtil_1.CommonUtil.concatUniqueArrayItemList(ARIADefinitions_1.ARIADefinitions.globalProperties, roleAttributes);
                    if (pattern.deprecatedProps && pattern.deprecatedProps.length > 0)
                        CommonUtil_1.CommonUtil.reduceArrayItemList(pattern.deprecatedProps, roleAttributes);
                    // remove 'generic' role if roleAttributes doesn't contain any of domAriaAttributes 
                    if (roleAttributes.length > 0 && !roleAttributes.some(function (attr) { return domAriaAttributes_1.includes(attr); })) {
                        var implicit = CommonUtil_1.CommonUtil.reduceArrayItemList(['generic'], tagProperty.implicitRole);
                        CacheUtil_1.CacheUtil.setCache(ele, "AriaUtil_ImplicitRole", implicit);
                        return implicit;
                    }
                }
                CacheUtil_1.CacheUtil.setCache(ele, "AriaUtil_ImplicitRole", tagProperty.implicitRole);
                return tagProperty.implicitRole;
            }
            CacheUtil_1.CacheUtil.setCache(ele, "AriaUtil_ImplicitRole", []);
            return [];
        }
        return implicitRoles;
    };
    /**
     * Returns the required properties of the role
     * @parm {string} role - the role
     * @parm {HTMLElement} ele - element for which to find role.
     *
     * @return {List} properties - list of properties that are required by the role
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getRoleRequiredProperties = function (role, ele) {
        if (role === null) {
            return null;
        }
        if (ARIADefinitions_1.ARIADefinitions.designPatterns[role]) {
            var requiredAttributes = ARIADefinitions_1.ARIADefinitions.designPatterns[role].reqProps;
            // handle special case of separator
            if (role.toLowerCase() === "separator" && ele && CommonUtil_1.CommonUtil.isFocusable(ele)) {
                requiredAttributes = CommonUtil_1.CommonUtil.concatUniqueArrayItemList(["aria-valuenow"], requiredAttributes || []);
            }
            return requiredAttributes;
        }
        else {
            return null;
        }
    };
    /**
     * This function is responsible for finding if a element has given role.
     * This function aslo finds if element has given roles as implicit role.
     * @parm {HTMLElement} ele - element for which to find role.
     * @parm {list or string} roles - List or single role for which to find if element has these roles.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {List} retVal - true or false based on if th element has the specified role.
     *
     * @memberOf AriaUtil
     *
     * Consider to use hasRoleInSemantics() instead.
     */
    AriaUtil.hasRole = function (ele, role, considerImplicitRoles) {
        var retVal = false;
        if (ele && ele.hasAttribute && ele.hasAttribute("role")) {
            if (typeof (role) != typeof ("")) {
                var roles = ele.getAttribute("role").trim().split(" ");
                for (var i = 0; !retVal && i < roles.length; ++i) {
                    retVal = roles[i] in role;
                }
            }
            else {
                var roles = ele.getAttribute("role").trim().split(" ");
                for (var i = 0; !retVal && i < roles.length; ++i) {
                    retVal = roles[i] === role;
                }
            }
        }
        //if none of the the attribute roles matched with given role
        //check if implicit roles matches.
        //Note: element can have multiple implicit roles
        if (!retVal && considerImplicitRoles) {
            var wRoles = [];
            //check if there are any implicit roles for this element.
            var implicitRole = AriaUtil.getImplicitRole(ele);
            if (implicitRole !== null && implicitRole.length > 0) {
                CommonUtil_1.CommonUtil.concatUniqueArrayItemList(implicitRole, wRoles);
                //if role is array loop thru and see if any  of the implicit role present in the array
                if (typeof (role) != typeof ("")) {
                    for (var i = 0; !retVal && i < wRoles.length; ++i) {
                        retVal = wRoles[i] in role;
                    }
                }
                else {
                    for (var i = 0; !retVal && i < wRoles.length; ++i) {
                        retVal = wRoles[i] === role;
                    }
                }
            }
        }
        return retVal;
    };
    /**
     * Checks if the element has the role, including the implied role if role is not explicitly specified.
     *
     * This function is replacing the hasRole function
     *
     * @parm {HTMLElement} ele - element for which to find role.
     * @parm {list or string} roles - List or single role for which to find if element has these roles.
     *
     * @return {List} retVal - true or false based on if the element has the specified role.
     *
     * @memberOf AriaUtil
     */
    AriaUtil.hasRoleInSemantics = function (ele, role) {
        var retVal = false;
        var roleSpecified = false;
        if (ele && ele.hasAttribute && ele.hasAttribute("role")) {
            if (typeof (role) != typeof ("")) {
                var roles = ele.getAttribute("role").trim().toLowerCase().split(/\s+/);
                for (var i = 0; !retVal && i < roles.length; ++i) {
                    roleSpecified = true;
                    retVal = roles[i] in role;
                }
            }
            else {
                var roles = ele.getAttribute("role").trim().toLowerCase().split(/\s+/);
                for (var i = 0; !retVal && i < roles.length; ++i) {
                    roleSpecified = true;
                    retVal = roles[i] === role;
                }
            }
        }
        if (roleSpecified) {
            return retVal;
        }
        //check if implicit roles matches.
        //Note: element can have multiple implicit roles
        //check if there are any implicit roles for this element.
        var impRoles = AriaUtil.getImplicitRole(ele);
        if (impRoles !== null && impRoles.length > 0) {
            //if role is array loop thru and see if any  of the implicit role present in the array
            if (typeof (role) != typeof ("")) {
                for (var i = 0; !retVal && i < impRoles.length; ++i) {
                    retVal = impRoles[i] in role;
                }
            }
            else {
                for (var i = 0; !retVal && i < impRoles.length; ++i) {
                    retVal = impRoles[i] === role;
                }
            }
        }
        return retVal;
    };
    /**
     * This function is responsible for finding if a element has given role.
     * This function also checks if element has given roles as implicit roles.
     * @parm {HTMLElement} ele - element for which to find role.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {bool} retVal - true or false based on if the element has the specified role.
     *
     * @memberOf AriaUtil
     */
    AriaUtil.hasAnyRole = function (ele, considerImplicitRoles) {
        var retVal = false;
        if (ele && ele.hasAttribute && ele.hasAttribute("role")) {
            retVal = true;
        }
        //check if implicit roles exist.
        //Note: element can have multiple implicit roles
        if (!retVal && considerImplicitRoles) {
            //check if there are any implicit roles for this element.
            var impRoles = AriaUtil.getImplicitRole(ele);
            if (impRoles !== null && impRoles.length > 0)
                retVal = true;
        }
        return retVal;
    };
    AriaUtil.isPresentationalElement = function (node) {
        // Elements extracted from https://developer.mozilla.org/en/docs/Web/HTML/Element#Inline_text_semantics,
        // http://dev.w3.org/html5/html-author/#text-level-semantics and https://wiki.whatwg.org/wiki/Presentational_elements_and_attributes
        var presentationalElements = ["abbr", "b", "bdi", "bdo", "br", "cite", "code", "data", "dfn",
            "em", "i", "kbd", "mark", "q", "rp", "rt", "rtc", "ruby", "s",
            "samp", "small", "span", "strong", "sub", "sup", "time", "u",
            "var", "wbr", "a", "progress", "meter", "basefont", "big", "center",
            "strike", "tt", "font", "blink", "h1", "h2", "h3", "h4", "h5", "h6",
            "hr", "blockquote", "p"
        ];
        return CommonUtil_1.CommonUtil.valInArray(node.nodeName.toLowerCase(), presentationalElements);
    };
    /**
     * return the ancestor of the given element and role.
     *
     * @parm {element} element - The element to start the node walk on to find parent node
     * @parm {string} role - The role to search for on an element under the provided element
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node} walkNode - A parent node of the element passed in, which has the provided role
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getAncestorWithRole = function (element, roleName, considerImplicitRoles) {
        var walkNode = DOMWalker_1.DOMWalker.parentNode(element);
        while (walkNode !== null) {
            if (considerImplicitRoles) {
                if (AriaUtil.hasRoleInSemantics(walkNode, roleName)) {
                    break;
                }
            }
            else {
                if (AriaUtil.hasRole(walkNode, roleName, false)) {
                    break;
                }
            }
            walkNode = DOMWalker_1.DOMWalker.parentNode(walkNode);
        }
        return walkNode;
    };
    /**
     * return the ancestor of the given element and roles.
     *
     * @parm {element} element - The element to start the node walk on to find parent node
     * @parm {array} roles - the role names to search for
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node} walkNode - A parent node of the element passed in, which has the provided role
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getAncestorWithRoles = function (element, roleNames) {
        if (!element || !roleNames || !roleNames.length || roleNames.length === 0)
            return null;
        var walkNode = element;
        while (walkNode !== null) {
            var role = AriaUtil.getResolvedRole(walkNode);
            if (role !== null && roleNames.includes(role))
                return walkNode;
            walkNode = DOMWalker_1.DOMWalker.parentNode(walkNode);
        }
        return null;
    };
    /**
     * return the roles with given role type.
     *
     * @parm {element} element - The element to start the node walk on to find parent node
     * @parm {array} roleTyples - role types, such as 'widget', 'structure' etc.
     *
     * @return {array} roles - A parent node of the element passed in, which has the provided role
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getRolesWithTypes = function (element, types) {
        if (!element || !types || !types.length || types.length === 0)
            return null;
        var roles = CacheUtil_1.CacheUtil.getCache(element.ownerDocument, "roles_with_given_types", null);
        if (!roles || roles.length === 0) {
            roles = [];
            Object.entries(ARIADefinitions_1.ARIADefinitions.designPatterns).forEach(function (_a) {
                var key = _a[0], value = _a[1];
                if (types.includes(value.roleType))
                    roles.push(key);
            });
            CacheUtil_1.CacheUtil.setCache(element.ownerDocument, "roles_with_given_types", roles);
        }
        return roles;
    };
    /**
     * return the roles with given role type.
     *
     * @parm {element} element - The element to start the node walk on to find parent node
     * @parm {array} roleTyples - role types, such as 'widget', 'structure' etc.
     *
     * @return {array} roles - A parent node of the element passed in, which has the provided role
     *
     * @memberOf AriaUtil
     */
    AriaUtil.isWidget = function (element) {
        if (!element)
            return false;
        var widget = CacheUtil_1.CacheUtil.getCache(element.ownerDocument, "is_element_widget", null);
        if (widget === null) {
            var ret = false;
            var role = AriaUtil.getResolvedRole(element);
            if (role && ARIADefinitions_1.ARIADefinitions.designPatterns[role] && ARIADefinitions_1.ARIADefinitions.designPatterns[role].roleType === 'widget')
                ret = true;
            CacheUtil_1.CacheUtil.setCache(element.ownerDocument, "is_element_widget", ret);
            return ret;
        }
        return widget;
    };
    /**
     * return if the element is owned or controlled by another element.
     * If an ancestor of an element is owned or controlled by another element, then the element is also considered as owned or controlled.
     * an element can be owned or controlled by another element through aria-owns or aria-controls
     *   when the DOM hierarchy cannot be used to represent the relationship.
     * aria-owns attribute is used to define contextual relationship with a owning parent
     * aria-controls attribute is used to associate an element with the controlling element.
     *  example elements with roles: combobox, scrollbar, tab, button, listbox, menu, menubar, radiogroup, tree, treegrid
     *
     * when an element is owned or controlled by another element, its navigation may be controlled by the parent
     *  through aria-activedescendants attribute or roving tabindex
     *
     * Note navigation with native combobox (input with a datalist) is in native focus navigation, not considered here
     *
     * @parm {element} element - The element to inspect
     * @return {boolean}
     *
     * @memberOf AriaUtil
     */
    AriaUtil.isNavigationOwnedOrControlled = function (element) {
        if (!element)
            return false;
        var ownerElems = CacheUtil_1.CacheUtil.getCache(element.ownerDocument, "AriaUtil_NavigationOwnedOrControlled", null);
        if (ownerElems !== null && ownerElems.length > 0) {
            if (CommonUtil_1.CommonUtil.getAncestor(element, ownerElems))
                return true;
        }
        var role = AriaUtil.getResolvedRole(element);
        if (!role)
            return false;
        var id = element.getAttribute("id");
        if (!id || id.trim().length === 0)
            return false;
        var elem = element.ownerDocument.querySelector("*[aria-controls~='".concat(id, "'], *[aria-owns~='").concat(id, "']"));
        if (!elem)
            return false;
        var containers = ['combobox', 'scrollbar', 'button', 'tab', 'listbox', 'menu', 'menubar', 'radiogroup', 'tree', 'treegrid'];
        if (containers.includes(role)) {
            if (ownerElems === null)
                ownerElems = [];
            ownerElems.push(element);
            CacheUtil_1.CacheUtil.setCache(element.ownerDocument, "AriaUtil_NavigationOwnedOrControlled", ownerElems);
            return true;
        }
        return false;
    };
    /**
     * This function is responsible for finding a node which matches the role and is a sibling of the
     * provided element.
     *
     * This function by default will not consider Check Hidden Setting at all.
     *
     * Note: This is a wrapper function to: AriaUtil.getSiblingWithRoleHidden
     *
     * @parm {element} element - The element to start the node walk on to find sibling node
     * @parm {string} role - The role to search for on an element under the provided element
     *
     * @return {node} walkNode - A sibling node of the element passed in, which has the provided role
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getSiblingWithRole = function (element, role) {
        return AriaUtil.getSiblingWithRoleHidden(element, role, false);
    };
    /**
     * This function is responsible for finding a node which matches the role and is a sibling of the
     * provided element.
     *
     * This function also considers implicit roles for the elements.
     *
     * This function will also consider elements that are hidden based on the if the Check
     * Hidden Content settings should be considered or not.
     *
     * @parm {element} element - The element to start the node walk on to find sibling node
     * @parm {string} role - The role to search for on an element under the provided element
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicit - true or false based on if Implicit roles should be considered.
     *
     * @return {node} walkNode - A sibling node of the element passed in, which has the provided role
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getSiblingWithRoleHidden = function (element, role, considerHiddenSetting, considerImplicitRole) {
        // Variable Declaration
        var walkNode = null;
        var hasRole = false;
        // Only perform the check if element and role are both provided
        if (element && role) {
            // Fetch the next sibling element
            walkNode = element.nextSibling;
            // Keep looping over the next siblings to find element which matches
            // the provided role.
            while (walkNode !== null && !hasRole) {
                // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                // or not.
                //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
                //     Check Hidden Content that is provided.
                //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                //     add it to the roleToElems hash at all or even do any checking for it at all.
                //
                // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                //       so on and so forth.
                if (considerHiddenSetting && CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(walkNode)) {
                    // Move on to the next node
                    walkNode = walkNode.nextSibling;
                    continue;
                }
                // Check if this node has the role that we need to check exists
                if (considerImplicitRole) {
                    hasRole = AriaUtil.hasRoleInSemantics(walkNode, role);
                }
                else {
                    hasRole = AriaUtil.hasRole(walkNode, role, false);
                }
                // Move on to the next node
                walkNode = walkNode.nextSibling;
            }
            // If we still have not found a node that matches the role, start a reverse look up
            if (!walkNode) {
                // Fetch the previous Sibling of this element
                walkNode = element.previousSibling;
                // Keep looping over all the previous siblings to search for an element which
                // matches the provided role.
                while (walkNode !== null && !hasRole) {
                    // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                    // or not.
                    //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
                    //     Check Hidden Content that is provided.
                    //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                    //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                    //     add it to the roleToElems hash at all or even do any checking for it at all.
                    //
                    // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                    //       so on and so forth.
                    if (considerHiddenSetting && CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(walkNode)) {
                        // Move on to the next node
                        walkNode = walkNode.previousSibling;
                        continue;
                    }
                    // Check if this node has the role that we need to check exists
                    hasRole = AriaUtil.hasRole(walkNode, role, considerImplicitRole);
                    // Move on to the next node
                    walkNode = walkNode.previousSibling;
                }
            }
        }
        return walkNode;
    };
    /**
     * This function is responsible for getting a descendant element with the specified role, under
     * the element that was provided.
     *
     * Note by default this function will not consider the Check Hidden Content Setting.
     *
     * Note: This is a wrapper function to: AriaUtil.getDescendantWithRoleHidden
     *
     * @parm {element} element - parent element for which we will be checking descendants for
     * @parm {string} roleName - The role to look for on the descendant's elements
     *
     * @return {node} - The descendant element that matches the role specified (only one)
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getDescendantWithRole = function (element, roleName) {
        return AriaUtil.getDescendantWithRoleHidden(element, roleName, false);
    };
    /**
     * This function is responsible for getting a descendant element with the specified role, under
     * the element that was provided. This function aslo finds elements with implicit roles.
     *
     * @parm {element} element - parent element for which we will be checking descendants for
     * @parm {string} roleName - The role to look for on the descendant's elements
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node} - The descendant element that matches the role specified (only one)
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getDescendantWithRoleHidden = function (element, roleName, considerHiddenSetting, considerImplicitRoles) {
        // Variable Decleration
        var descendant = null;
        //let nw = new NodeWalker(element);
        var nw = new DOMWalker_1.DOMWalker(element);
        // Loop over all the childrens of the element provided and check if the rolename provided exists
        while (nw.nextNode() && nw.node != element && nw.node != element.nextSibling) {
            // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
            // or not.
            //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
            //     Check Hidden Content that is provided.
            //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
            //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
            //     add it to the roleToElems hash at all or even do any checking for it at all.
            //
            // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
            //       so on and so forth.
            if (considerHiddenSetting && CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(nw.node)) {
                continue;
            }
            // Check if this node has the role specified, if it does then set this as the descendant and stop checking the rest of the
            // nodes.
            // Check if this node has the implicit roles, if it does then set this as the descendant and stop checking the rest of the
            // nodes.
            if (considerImplicitRoles ? AriaUtil.hasRoleInSemantics(nw.node, roleName) : AriaUtil.hasRole(nw.node, roleName, false)) {
                descendant = nw.node;
                break;
            }
        }
        return descendant;
    };
    /**
     * This function is responsible for getting All descendant elements with the specified roles, under
     * the element that was provided. This function aslo finds elements with implicit roles.
     *
     * @parm {element} element - parent element for which we will be checking descendants for
     * @parm {string[]} roleNames - The roles to look for on the descendant's elements
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node[]} - all descendant elements that match the roles specified
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getAllDescendantsWithRoles = function (element, roleNames, considerHiddenSetting, considerImplicitRoles) {
        if (!roleNames || roleNames.length === 0)
            return;
        // Variable Decleration
        var descendants = [];
        roleNames.forEach(function (roleName) {
            var kids = AriaUtil.getAllDescendantsWithRoleHidden(element, roleName, considerHiddenSetting, considerImplicitRoles);
            if (kids && kids.length > 0)
                descendants = descendants.concat(kids);
        });
        return descendants;
    };
    /**
     * This function is responsible for getting All descendant elements with the specified role, under
     * the element that was provided. This function aslo finds elements with implicit roles.
     *
     * @parm {element} element - parent element for which we will be checking descendants for
     * @parm {string} roleName - The role to look for on the descendant's elements
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node[]} - The descendant elements that match the role specified
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getAllDescendantsWithRoleHidden = function (element, roleName, considerHiddenSetting, considerImplicitRoles) {
        // Variable Decleration
        var descendants = [];
        //let nw = new NodeWalker(element);
        var nw = new DOMWalker_1.DOMWalker(element);
        // Loop over all the childrens of the element provided and check if the rolename provided exists
        while (nw.nextNode() && nw.node != element && nw.node != element.nextSibling) {
            if (nw.bEndTag) {
                continue;
            }
            // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
            // or not.
            //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
            //     Check Hidden Content that is provided.
            //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
            //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
            //     add it to the roleToElems hash at all or even do any checking for it at all.
            //
            // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
            //       so on and so forth.
            if (considerHiddenSetting && CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(nw.node)) {
                continue;
            }
            // Check if this node has the role specified, if it does then set this as the descendant and stop checking the rest of the
            // nodes.
            // Check if this node has the implicit roles, if it does then set this as the descendant and stop checking the rest of the
            // nodes.
            if (AriaUtil.hasRole(nw.node, roleName, considerImplicitRoles)) {
                descendants.push(nw.node);
            }
        }
        return descendants;
    };
    /**
     * This function is responsible for getting All direct children in AT tree with a role (exclude none and presentation)
     *
     * @parm {element} element - parent element for which we will be checking children for
     * @return {node} - The direct child elements in AT tree that has a role
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getDirectATChildren = function (element) {
        var requiredChildRoles = AriaUtil.getRequiredChildRoles(element, true);
        var direct = [];
        AriaUtil.retrieveDirectATChildren(element, requiredChildRoles, direct);
        return direct;
    };
    /**
     * This function is responsible for recursively any child path till either no child or a child with a role is found (exclude none and presentation)
     *
     * @parm {element} element - parent element for which we will be checking children for
     * @return {node} - The direct child elements in AT tree
     *
     * @memberOf AriaUtil
     */
    AriaUtil.retrieveDirectATChildren = function (element, requiredChildRoles, direct) {
        var children = [];
        if (element.children !== null && element.children.length > 0) {
            for (var i = 0; i < element.children.length; i++) {
                children.push(element.children[i]);
            }
        }
        // if the element contains "aria-own" attribute, then the aria-owned children need to be included too
        var owned = element.getAttribute("aria-owns");
        if (owned) {
            var doc = element.ownerDocument;
            if (doc) {
                var ownedIds = owned.split(" ");
                for (var i = 0; i < ownedIds.length; i++) {
                    var ownedElem = doc.getElementById(ownedIds[i]);
                    if (ownedElem) {
                        children.push(ownedElem);
                    }
                }
            }
        }
        if (children.length > 0) {
            for (var i = 0; i < children.length; i++) {
                //ignore hidden and invisible child
                if (VisUtil_1.VisUtil.isNodeHiddenFromAT(children[i]) || !VisUtil_1.VisUtil.isNodeVisible(children[i]))
                    continue;
                var roles = AriaUtil.getRoles(children[i], false);
                if (roles === null || roles.length === 0) {
                    roles = AriaUtil.getImplicitRole(children[i]);
                }
                if (roles && roles !== null && roles.length > 0) {
                    //remove 'none' and 'presentation'
                    roles = roles.filter(function (role) {
                        return role !== "none" && role !== "presentation";
                    });
                    // a 'group' role is allowed but not required for some elements so remove it if exists
                    if (roles.includes("group") && requiredChildRoles && requiredChildRoles.includes('group')) {
                        roles = roles.filter(function (role) {
                            return role !== 'group';
                        });
                    }
                }
                if (roles && roles !== null && roles.length > 0) {
                    direct.push(children[i]);
                }
                else {
                    // recursive until get a return value, 
                    AriaUtil.retrieveDirectATChildren(children[i], requiredChildRoles, direct);
                }
            }
            return null;
        }
        else
            return null;
    };
    /**
     * this function returns null or required child roles for a given element with one more roles,
     * return null if the role is 'none' or 'presentation'
     * @param element
     * @param includeImplicit include implicit roles if no role is explicitly provided
     * @returns
     */
    AriaUtil.getRequiredChildRoles = function (element, includeImplicit) {
        var roles = AriaUtil.getRoles(element, false);
        // if explicit role doesn't exist, get the implicit one
        if ((!roles || roles.length === 0) && includeImplicit) {
            roles = AriaUtil.getImplicitRole(element);
        }
        /**
         * ignore if the element doesn't have any explicit or implicit role
        */
        if (!roles || roles.length === 0) {
            return null;
        }
        /**
         * ignore if the element contains none or presentation role
        */
        var presentationRoles = ["none", "presentation"];
        var found = roles.some(function (r) { return presentationRoles.includes(r); });
        if (found)
            return null;
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        var requiredChildRoles = new Array();
        for (var j = 0; j < roles.length; ++j) {
            if (designPatterns[roles[j]] && designPatterns[roles[j]].reqChildren !== null) {
                requiredChildRoles = CommonUtil_1.CommonUtil.concatUniqueArrayItemList(designPatterns[roles[j]].reqChildren, requiredChildRoles);
            }
        }
        return requiredChildRoles;
    };
    /**
     * This function is responsible for getting an element referenced by aria-owns and has the
     * role that was specified.
     *
     * Note by default this function will not consider the Check Hidden Content Setting.
     *
     * Note: This is a wrapper function to: AriaUtil.getAriaOwnsWithRoleHidden
     *
     * @parm {element} element - Element to check for aria-owns
     * @parm {string} roleName - The role to look for on the aria-owns element
     *
     * @return {node} - The element that is referenced by aria-owns and has role specified.
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getAriaOwnsWithRole = function (element, roleName) {
        return AriaUtil.getAriaOwnsWithRoleHidden(element, roleName, false);
    };
    /**
     * This function is responsible for getting an element referenced by aria-owns and has the
     * role that was specified. This function aslo finds elements with implicit roles.
     *
     * @parm {element} element - Element to check for aria-owns
     * @parm {string} roleName - The role to look for on the aria-owns element
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {node} - The element that is referenced by aria-owns and has role specified.
     *
     * @memberOf AriaUtil
     */
    AriaUtil.getAriaOwnsWithRoleHidden = function (element, roleName, considerHiddenSetting, considerImplicitRoles) {
        // Variable Decleration
        var referencedElement = null;
        var referencedElemHasRole = false;
        // In the case aria-owns is not on the element just break out of this function with null
        if (CommonUtil_1.CommonUtil.attributeNonEmpty(element, "aria-owns")) {
            // Get the reference ID
            var referenceID = element.getAttribute("aria-owns");
            // Get the element for the reference ID
            referencedElement = fragment_1.FragmentUtil.getById(element, referenceID);
            //ignore if the aria-owns point to the element itself
            if (DOMUtil_1.DOMUtil.sameNode(element, referencedElement))
                return null;
            // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
            // or not.
            //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
            //     Check Hidden Content that is provided.
            //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
            //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
            //     add it to the roleToElems hash at all or even do any checking for it at all.
            if (considerHiddenSetting && referencedElement != null && CommonUtil_1.CommonUtil.shouldNodeBeSkippedHidden(referencedElement)) {
                referencedElemHasRole = null;
            }
            else {
                referencedElemHasRole = AriaUtil.hasRole(referencedElement, roleName, considerImplicitRoles);
            }
        }
        return referencedElemHasRole ? referencedElement : null;
    };
    // Return true if the element has an ARIA label
    AriaUtil.hasAriaLabel = function (element) {
        // Rpt_Aria_ValidIdRef determines if the aria-labelledby id points to a valid element
        return CommonUtil_1.CommonUtil.attributeNonEmpty(element, "aria-label") || CommonUtil_1.CommonUtil.attributeNonEmpty(element, "aria-labelledby");
    };
    // Given an array of elements, return true if the elements have unique ARIA labels
    AriaUtil.hasUniqueAriaLabelsLocally = function (elements, isGlobal) {
        if (elements.length === 0)
            return false;
        var doc = elements[0].ownerDocument;
        var hasDuplicateLabels = false;
        var uniqueAriaLabels = null;
        if (isGlobal) {
            uniqueAriaLabels = CacheUtil_1.CacheUtil.getCache(doc, "AriaUtil_HAS_UNIQUE_ARIA_LABELS", null);
        }
        if (uniqueAriaLabels === null) {
            uniqueAriaLabels = {};
        }
        for (var i = 0; !hasDuplicateLabels && i < elements.length; ++i) {
            if (elements[i].hasAttribute) {
                if (elements[i].hasAttribute("aria-label")) {
                    var ariaLabel = CommonUtil_1.CommonUtil.normalizeSpacing(elements[i].getAttribute("aria-label")).toLowerCase();
                    hasDuplicateLabels = ariaLabel in uniqueAriaLabels;
                    uniqueAriaLabels[ariaLabel] = true;
                }
                else if (elements[i].hasAttribute("aria-labelledby")) {
                    var labelID = elements[i].getAttribute("aria-labelledby");
                    var labelNode = fragment_1.FragmentUtil.getById(elements[i], labelID);
                    var label = labelNode && !DOMUtil_1.DOMUtil.sameNode(labelNode, elements[i]) ? CommonUtil_1.CommonUtil.getInnerText(labelNode) : "";
                    var normalizedLabel = CommonUtil_1.CommonUtil.normalizeSpacing(label).toLowerCase();
                    hasDuplicateLabels = normalizedLabel in uniqueAriaLabels;
                    uniqueAriaLabels[normalizedLabel] = true;
                }
                else {
                    // Has no label at all
                    hasDuplicateLabels = true;
                }
            }
        }
        if (isGlobal) {
            CacheUtil_1.CacheUtil.setCache(doc, "AriaUtil_HAS_UNIQUE_ARIA_LABELS", uniqueAriaLabels);
        }
        return !hasDuplicateLabels;
    };
    AriaUtil.getAriaLabel = function (ele) {
        if (ele.hasAttribute) {
            if (ele.hasAttribute("aria-labelledby")) {
                var labelIDs = ele.getAttribute("aria-labelledby").trim().split(" ");
                var normalizedLabel = "";
                for (var j = 0, length_1 = labelIDs.length; j < length_1; ++j) {
                    var labelID = labelIDs[j];
                    var labelNode = fragment_1.FragmentUtil.getById(ele, labelID);
                    var label = labelNode && !DOMUtil_1.DOMUtil.sameNode(labelNode, ele) ? CommonUtil_1.CommonUtil.getInnerText(labelNode) : "";
                    normalizedLabel += CommonUtil_1.CommonUtil.normalizeSpacing(label).toLowerCase();
                }
                return normalizedLabel.trim();
            }
            else if (ele.hasAttribute("aria-label")) {
                return CommonUtil_1.CommonUtil.normalizeSpacing(ele.getAttribute("aria-label")).toLowerCase().trim();
            }
        }
        return "";
    };
    AriaUtil.getAriaDescription = function (ele) {
        if (!ele)
            return "";
        var normalizedLabel = "";
        var desc = ele.getAttribute("aria-labelledby");
        if (desc && desc.trim().length > 0) {
            var labelIDs = desc.trim().split(" ");
            for (var j = 0, length_2 = labelIDs.length; j < length_2; ++j) {
                var labelID = labelIDs[j];
                var labelNode = fragment_1.FragmentUtil.getById(ele, labelID);
                var label = labelNode && !DOMUtil_1.DOMUtil.sameNode(labelNode, ele) ? CommonUtil_1.CommonUtil.getInnerText(labelNode) : "";
                if (label && label.trim().length > 0)
                    normalizedLabel += CommonUtil_1.CommonUtil.normalizeSpacing(label).toLowerCase();
            }
            if (normalizedLabel.trim().length > 0)
                return normalizedLabel.trim();
        }
        desc = ele.getAttribute("aria-description");
        if (desc && desc.trim().length > 0)
            return desc.trim().toLowerCase();
        return "";
    };
    AriaUtil.findAriaLabelDupes = function (elements) {
        var dupeMap = {};
        elements.forEach(function (ele) {
            dupeMap[AriaUtil.getAriaLabel(ele)] = (dupeMap[AriaUtil.getAriaLabel(ele)] || 0) + 1;
        });
        return dupeMap;
    };
    /**
     * return accessible names for all AT visible landmark elements
     * @param doc
     * @returns
     */
    AriaUtil.getLandmarkAccNames = function (doc) {
        var nameMap = CacheUtil_1.CacheUtil.getCache(doc, "AriaUtil_Landmark_AccNames", null);
        if (nameMap && nameMap.length !== 0)
            return nameMap;
        nameMap = [];
        var landmarkElems = doc.querySelectorAll('aside,[role="complementary"], footer,[role="contentinfo"], header,[role="banner"], main,[role="main"], nav,[role="navigation"], form,[role="form"], section,[role="region"], article,[role="article"], [role="search"],[role="application"],[role="document"]');
        if (landmarkElems.length === 0) {
            CacheUtil_1.CacheUtil.setCache(doc, "AriaUtil_Landmark_AccNames", nameMap);
            return nameMap;
        }
        landmarkElems.forEach(function (elem) {
            // ignore node that is AT hidden or in a dialog that is considered as a separate location from the rest of the main page
            if (!VisUtil_1.VisUtil.isNodeHiddenFromAT(elem) && CommonUtil_1.CommonUtil.getAncestor(elem, ["DIALOG"]) === null && AriaUtil.getAncestorWithRole(elem, "dialog", true) === null) {
                var name_1 = "";
                var pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(elem);
                if (pair && pair.name && pair.name.trim().length > 0)
                    name_1 = pair.name.trim();
                var role = AriaUtil.getResolvedRole(elem);
                nameMap.push({ "elem": elem, "role": role, "name": name_1 });
            }
        });
        CacheUtil_1.CacheUtil.setCache(doc, "AriaUtil_Landmark_AccNames", nameMap);
        return nameMap;
    };
    /**
     * check if the given element with the landmark rolw is unique
     * @param element
     * @param role: a specific landmark role, or "any" for all landmark role
     * @param considerNoneLabel: if consider the landmarks without a label
     * @returns
     */
    AriaUtil.isLandmarkNameUnique = function (element, role, considerNoneLabel) {
        if (considerNoneLabel === void 0) { considerNoneLabel = false; }
        var nameMap = AriaUtil.getLandmarkAccNames(element.ownerDocument);
        var exist = null;
        if (role === 'any')
            exist = nameMap.find(function (entry) { return entry.elem === element; });
        else
            exist = nameMap.find(function (entry) { return entry.elem === element && entry.role === role; });
        if (!exist)
            return null;
        var name = exist.name;
        if (!considerNoneLabel && name === '')
            return null;
        for (var i = 0; i < nameMap.length; i++) {
            if (nameMap[i].elem === element)
                continue;
            if (name === nameMap[i].name) {
                if (role === 'any')
                    return true;
                else if (nameMap[i].role === role)
                    return true;
            }
        }
        return false;
    };
    // Given an array of elements, return true if the elements have unique ARIA labels globally
    AriaUtil.hasUniqueAriaLabels = function (elements) {
        return AriaUtil.hasUniqueAriaLabelsLocally(elements, true);
    };
    // Given an array of elements, return true if the elements have unique ARIA labels
    AriaUtil.hasDuplicateAriaLabelsLocally = function (elements, isGlobal) {
        if (elements.length === 0)
            return false;
        var doc = elements[0].ownerDocument;
        var hasDuplicateLabels = false;
        var uniqueAriaLabels = null;
        var duplicateLabelNameArray = new Array();
        if (isGlobal) {
            uniqueAriaLabels = CacheUtil_1.CacheUtil.getCache(doc, "AriaUtil_HAS_UNIQUE_ARIA_LABELS", null);
        }
        if (uniqueAriaLabels === null) {
            uniqueAriaLabels = {};
        }
        for (var i = 0; i < elements.length; ++i) {
            if (elements[i].hasAttribute) {
                if (elements[i].hasAttribute("aria-label")) {
                    var ariaLabel = CommonUtil_1.CommonUtil.normalizeSpacing(elements[i].getAttribute("aria-label")).toLowerCase();
                    hasDuplicateLabels = ariaLabel in uniqueAriaLabels;
                    uniqueAriaLabels[ariaLabel] = true;
                    if (!(ariaLabel in duplicateLabelNameArray)) {
                        duplicateLabelNameArray[ariaLabel] = new Array();
                    }
                    duplicateLabelNameArray[ariaLabel].push(elements[i].nodeName.toLowerCase());
                }
                else if (elements[i].hasAttribute("aria-labelledby")) {
                    var labelIDs = elements[i].getAttribute("aria-labelledby").trim().split(" ");
                    var normalizedLabel = "";
                    for (var j = 0, length_3 = labelIDs.length; j < length_3; ++j) {
                        var labelID = labelIDs[j];
                        var labelNode = fragment_1.FragmentUtil.getById(elements[i], labelID);
                        var label = labelNode && !DOMUtil_1.DOMUtil.sameNode(labelNode, elements[i]) ? CommonUtil_1.CommonUtil.getInnerText(labelNode) : "";
                        normalizedLabel += CommonUtil_1.CommonUtil.normalizeSpacing(label).toLowerCase();
                    }
                    hasDuplicateLabels = normalizedLabel in uniqueAriaLabels;
                    uniqueAriaLabels[normalizedLabel] = true;
                    if (!(normalizedLabel in duplicateLabelNameArray)) {
                        duplicateLabelNameArray[normalizedLabel] = new Array();
                    }
                    duplicateLabelNameArray[normalizedLabel].push(elements[i].nodeName.toLowerCase());
                }
            }
        }
        if (isGlobal) {
            CacheUtil_1.CacheUtil.setCache(doc, "AriaUtil_HAS_UNIQUE_ARIA_LABELS", uniqueAriaLabels);
        }
        return duplicateLabelNameArray;
    };
    // Given an array of elements, return true if the elements have unique ARIA labels globally
    AriaUtil.hasDuplicateAriaLabels = function (elements) {
        return AriaUtil.hasDuplicateAriaLabelsLocally(elements, true);
    };
    // Given an array of elements, return true if the elements have unique aria-labelledby attributes
    AriaUtil.hasUniqueAriaLabelledby = function (elements) {
        var hasDuplicateLabels = false;
        var labelRefs = {};
        for (var i = 0; !hasDuplicateLabels && i < elements.length; ++i) {
            if (elements[i].hasAttribute && elements[i].hasAttribute("aria-labelledby") && !CommonUtil_1.CommonUtil.isIdReferToSelf(elements[i], elements[i].getAttribute("aria-labelledby"))) {
                var labelRef = CommonUtil_1.CommonUtil.normalizeSpacing(elements[i].getAttribute("aria-labelledby"));
                hasDuplicateLabels = labelRef in labelRefs;
                labelRefs[labelRef] = true;
            }
            else {
                hasDuplicateLabels = true;
            }
        }
        return !hasDuplicateLabels;
    };
    /**
     * this function is responsible for resolving ARIA requirements for an HTML element per ARIA in HTML
     * @param ruleContext the HTML element to be examined
     * @returns
     */
    AriaUtil.getElementAriaProperty = function (ruleContext) {
        var tagProperty = CacheUtil_1.CacheUtil.getCache(ruleContext, "AriaUtil_ElementAriaProperty", null);
        if (!tagProperty) {
            var tagName = null;
            var name_2 = null;
            if (ruleContext.tagName) {
                tagName = ruleContext.tagName.toLowerCase();
            }
            else if (ruleContext.nodeName) {
                tagName = ruleContext.nodeName.toLowerCase();
            }
            // check if the tagProperty exists in the documentConformanceRequirement hash.
            tagProperty = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirement[tagName];
            // The tag needs to check some special attributes
            if (tagProperty === null || tagProperty === undefined) {
                var specialTagProperties = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags[tagName];
                switch (tagName) { // special cases
                    case "a":
                        CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "href") ? tagProperty = specialTagProperties["with-href"] : tagProperty = specialTagProperties["without-href"];
                        break;
                    case "area":
                        CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "href") ? tagProperty = specialTagProperties["with-href"] : tagProperty = specialTagProperties["without-href"];
                        break;
                    case "figure": {
                        var fcs = CommonUtil_1.CommonUtil.getChildByTag(ruleContext, "figcaption");
                        fcs !== null && fcs.length > 0 ? tagProperty = specialTagProperties["child-figcaption"] : tagProperty = specialTagProperties["no-child-figcaption"];
                        break;
                    }
                    case "footer":
                    case "header":
                        if (AriaUtil.getAncestorWithRole(ruleContext, "article", true) !== null || AriaUtil.getAncestorWithRole(ruleContext, "complementary", true) !== null
                            || AriaUtil.getAncestorWithRole(ruleContext, "navigation", true) !== null || AriaUtil.getAncestorWithRole(ruleContext, "region", true) !== null
                            || CommonUtil_1.CommonUtil.getAncestor(ruleContext, ["article", "aside", "main", "nav", "section"]) !== null)
                            tagProperty = specialTagProperties["des-section-article-aside-main-nav"];
                        else
                            tagProperty = specialTagProperties["other"];
                        break;
                    case "img":
                        var alt = ruleContext.hasAttribute("alt") ? ruleContext.getAttribute("alt") : null;
                        var title = ruleContext.hasAttribute("title") ? ruleContext.getAttribute("title") : null;
                        if (AriaUtil.getAriaLabel(ruleContext).trim().length !== 0 || (alt !== null && alt.length > 0) || (title !== null && title.length > 0)) {
                            // If the img has non-empty alt (alt="some text" or alt="  ") or an accessible name is provided
                            tagProperty = specialTagProperties["img-with-accname"];
                        }
                        else {
                            if (alt !== null) {
                                // If the img has an empty alt (alt="") 
                                tagProperty = specialTagProperties["img-without-accname-empty-alt"];
                            }
                            else {
                                // If the img lacks an alt attribute 
                                tagProperty = specialTagProperties["img-without-accname-no-alt"];
                            }
                        }
                        break;
                    case "input":
                        if (CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "type")) {
                            var type = ruleContext.getAttribute("type").trim().toLowerCase();
                            tagProperty = specialTagProperties[type];
                            if (tagProperty === null || tagProperty === undefined) {
                                switch (type) {
                                    case "checkbox":
                                        CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "aria-pressed") ? tagProperty = specialTagProperties["checkbox-with-aria-pressed"] : tagProperty = specialTagProperties["checkbox-without-aria-pressed"];
                                        break;
                                    case "email":
                                        CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["email-with-list"] : tagProperty = specialTagProperties["email-no-list"];
                                        break;
                                    case "search":
                                        CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["search-with-list"] : tagProperty = specialTagProperties["search-no-list"];
                                        break;
                                    case "tel":
                                        CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["tel-with-list"] : tagProperty = specialTagProperties["tel-no-list"];
                                        break;
                                    case "text":
                                        CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["text-with-list"] : tagProperty = specialTagProperties["text-no-list"];
                                        break;
                                    case "url":
                                        CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["url-with-list"] : tagProperty = specialTagProperties["url-no-list"];
                                        break;
                                    default:
                                        // default
                                        CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["default-with-list"] : tagProperty = specialTagProperties["default-no-list"];
                                        break;
                                }
                            }
                        }
                        else {
                            // default type is the same as type=text
                            CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "list") ? tagProperty = specialTagProperties["text-with-list"] : tagProperty = specialTagProperties["text-no-list"];
                        }
                        break;
                    case "li":
                        specialTagProperties = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags["li"];
                        if (ruleContext.parentElement && AriaUtil.hasRoleInSemantics(ruleContext.parentElement, "list"))
                            tagProperty = specialTagProperties["child-of-list-role"];
                        else
                            tagProperty = specialTagProperties["no-child-of-list-role"];
                        break;
                    case "section":
                        //name = ARIAMapper.computeName(ruleContext);
                        //if (name && name.trim().length > 0) {
                        var label = AriaUtil.getAriaLabel(ruleContext);
                        if ((label && label.trim().length > 0) || CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "title")) {
                            tagProperty = specialTagProperties["with-name"];
                        }
                        else {
                            tagProperty = specialTagProperties["without-name"];
                        }
                        break;
                    case "select":
                        specialTagProperties = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags["select"];
                        if (ruleContext.hasAttribute("multiple") ||
                            CommonUtil_1.CommonUtil.attributeNonEmpty(ruleContext, "size") && ruleContext.getAttribute("size") > 1)
                            tagProperty = specialTagProperties["multiple-attr-size-gt1"];
                        else
                            tagProperty = specialTagProperties["no-multiple-attr-size-gt1"];
                        break;
                    case "summary":
                        specialTagProperties = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags["summary"];
                        if (ruleContext.parentElement && ruleContext.parentElement.nodeName.toLowerCase() === 'details'
                            && DOMUtil_1.DOMUtil.sameNode(__spreadArray([], ruleContext.parentElement.children, true).filter(function (elem) { return elem.nodeName.toLowerCase() === 'summary'; })[0], ruleContext))
                            tagProperty = specialTagProperties["first-summary-of-detail"];
                        else
                            tagProperty = specialTagProperties["no-first-summary-of-detail"];
                        break;
                    case "tbody":
                    case "td":
                    case "tr":
                        if (AriaUtil.getAncestorWithRole(ruleContext, "table", true) !== null) {
                            tagProperty = specialTagProperties["des-table"];
                        }
                        else {
                            AriaUtil.getAncestorWithRole(ruleContext, "grid", true) || AriaUtil.getAncestorWithRole(ruleContext, "treegrid", true) ? tagProperty = specialTagProperties["des-grid"] : tagProperty = specialTagProperties["des-other"];
                        }
                        break;
                    case "th":
                        if (AriaUtil.getAncestorWithRole(ruleContext, "table", true) !== null || AriaUtil.getAncestorWithRole(ruleContext, "grid", true) !== null || AriaUtil.getAncestorWithRole(ruleContext, "treegrid", true) !== null) {
                            var scope = CommonUtil_1.CommonUtil.getScopeForTh(ruleContext);
                            if (scope === 'column')
                                tagProperty = specialTagProperties["des-table-grid-treegrid-column-scope"];
                            else
                                tagProperty = specialTagProperties["des-table-grid-treegrid-row-scope"];
                        }
                        else {
                            tagProperty = specialTagProperties["des-other"];
                        }
                        break;
                    case "div":
                        var prt = ruleContext.parentElement;
                        prt !== null && prt.nodeName.toLowerCase() === 'dl' ? tagProperty = specialTagProperties["child-dl"] : tagProperty = specialTagProperties["no-child-dl"];
                        break;
                    default:
                        tagProperty = ARIADefinitions_1.ARIADefinitions.documentConformanceRequirementSpecialTags["default"];
                } //switch
            }
        }
        CacheUtil_1.CacheUtil.setCache(ruleContext, "AriaUtil_ElementAriaProperty", tagProperty);
        return tagProperty || null;
    };
    AriaUtil.getAllowedAriaRoles = function (ruleContext, properties) {
        var allowedRoles = CacheUtil_1.CacheUtil.getCache(ruleContext, "AriaUtil_AllowedAriaRoles", null);
        if (!allowedRoles) {
            allowedRoles = [];
            var tagProperty = null;
            if (properties !== null && properties !== undefined) {
                tagProperty = properties;
            }
            else {
                tagProperty = AriaUtil.getElementAriaProperty(ruleContext);
            }
            if (tagProperty !== null && tagProperty !== undefined) {
                if (tagProperty.implicitRole !== null) {
                    CommonUtil_1.CommonUtil.concatUniqueArrayItemList(tagProperty.implicitRole, allowedRoles);
                }
                if (tagProperty.validRoles !== null) {
                    CommonUtil_1.CommonUtil.concatUniqueArrayItemList(tagProperty.validRoles, allowedRoles);
                }
                var implicitRoles = AriaUtil.getImplicitRole(ruleContext);
                if (implicitRoles && implicitRoles.length > 0) {
                    CommonUtil_1.CommonUtil.concatUniqueArrayItemList(tagProperty.validRoles, allowedRoles);
                }
            }
            CacheUtil_1.CacheUtil.setCache(ruleContext, "AriaUtil_AllowedAriaRoles", allowedRoles);
        }
        return allowedRoles;
    };
    AriaUtil.getAllowedAriaAttributes = function (ruleContext, roles, properties) {
        var allowedAttributes = CacheUtil_1.CacheUtil.getCache(ruleContext, "AriaUtil_AllowedAriaAttributes", null);
        if (!allowedAttributes) {
            allowedAttributes = [];
            var permittedRoles = __spreadArray([], roles, true);
            var tagName = ruleContext.tagName.toLowerCase();
            var prohibitedAttributes = [];
            // Element with a disabled attribute  https://www.w3.org/TR/html5/disabled-elements.html
            if (ARIADefinitions_1.ARIADefinitions.elementsAllowedDisabled.indexOf(tagName) > -1) {
                // Use the aria-disabled attribute on any element that is allowed the disabled attribute in HTML5.
                allowedAttributes = CommonUtil_1.CommonUtil.concatUniqueArrayItem("aria-disabled", allowedAttributes);
            }
            // Element with a required attribute http://www.the-art-of-web.com/html/html5-form-validation/
            if (ARIADefinitions_1.ARIADefinitions.elementsAllowedRequired.indexOf(tagName) > -1) {
                // Use the aria-required attribute on any element that is allowed the required attribute in HTML5.
                allowedAttributes = CommonUtil_1.CommonUtil.concatUniqueArrayItem("aria-required", allowedAttributes);
            }
            if (ARIADefinitions_1.ARIADefinitions.elementsAllowedReadOnly.indexOf(tagName) > -1) {
                // Use the aria-readonly attribute on any element that is allowed the readonly attribute in HTML5.
                allowedAttributes = CommonUtil_1.CommonUtil.concatUniqueArrayItem("aria-readonly", allowedAttributes);
            }
            var tagProperty = null;
            if (properties != null && properties !== undefined)
                tagProperty = properties;
            else
                tagProperty = AriaUtil.getElementAriaProperty(ruleContext);
            if (tagProperty !== null && tagProperty !== undefined) {
                // add the implicit role allowed attributes to the allowed role list if there is no specified role
                // ignore if the element doesn't allow the attributes from the implicit roles
                if (tagProperty.implicitRole !== null &&
                    (permittedRoles === null || permittedRoles === undefined || permittedRoles.length === 0)
                    && tagProperty.allowAttributesFromImplicitRole === undefined) {
                    for (var i = 0; i < tagProperty.implicitRole.length; i++) {
                        var roleProperty = ARIADefinitions_1.ARIADefinitions.designPatterns[tagProperty.implicitRole[i]];
                        if (roleProperty !== null && roleProperty !== undefined) {
                            var properties_1 = roleProperty.props;
                            CommonUtil_1.CommonUtil.concatUniqueArrayItemList(properties_1, allowedAttributes);
                            properties_1 = AriaUtil.getRoleRequiredProperties(tagProperty.implicitRole[i], ruleContext);
                            CommonUtil_1.CommonUtil.concatUniqueArrayItemList(properties_1, allowedAttributes);
                            var prohibitedProps = roleProperty.prohibitedProps;
                            if (prohibitedProps && prohibitedProps.length > 0)
                                CommonUtil_1.CommonUtil.concatUniqueArrayItemList(prohibitedProps, prohibitedAttributes);
                            // special case of separator
                            if (tagProperty.implicitRole[i] === "separator" && CommonUtil_1.CommonUtil.isFocusable(ruleContext)) {
                                CommonUtil_1.CommonUtil.concatUniqueArrayItemList(["aria-disabled", "aria-valuenow", "aria-valuemax", "aria-valuemin", "aria-valuetext"], allowedAttributes);
                            }
                        }
                    }
                }
                // Adding the global properties to the valid attribute list
                if (tagProperty.globalAriaAttributesValid) {
                    var properties_2 = ARIADefinitions_1.ARIADefinitions.globalProperties; // global properties
                    CommonUtil_1.CommonUtil.concatUniqueArrayItemList(properties_2, allowedAttributes);
                }
            }
            // adding the other role to the allowed roles for the attributes
            if (tagProperty && tagProperty.otherRolesForAttributes && tagProperty.otherRolesForAttributes.length > 0)
                CommonUtil_1.CommonUtil.concatUniqueArrayItemList(tagProperty.otherRolesForAttributes, permittedRoles);
            // adding the specified role properties to the allowed attribute list
            for (var i = 0; permittedRoles !== null && i < permittedRoles.length; i++) {
                var roleProperties = ARIADefinitions_1.ARIADefinitions.designPatterns[permittedRoles[i]];
                if (roleProperties !== null && roleProperties !== undefined) {
                    // ignore the properties if the element doesn't allow attributes from the implicit role
                    if (!tagProperty || tagProperty.implicitRole === null || !tagProperty.implicitRole.includes(permittedRoles[i]) || (tagProperty.implicitRole.includes(permittedRoles[i]) && tagProperty.allowAttributesFromImplicitRole === undefined)) {
                        var properties_3 = roleProperties.props; // allowed properties
                        CommonUtil_1.CommonUtil.concatUniqueArrayItemList(properties_3, allowedAttributes);
                        properties_3 = AriaUtil.getRoleRequiredProperties(permittedRoles[i], ruleContext); // required properties
                        CommonUtil_1.CommonUtil.concatUniqueArrayItemList(properties_3, allowedAttributes);
                    }
                    var prohibitedProps = roleProperties.prohibitedProps;
                    if (prohibitedProps && prohibitedProps.length > 0)
                        CommonUtil_1.CommonUtil.concatUniqueArrayItemList(prohibitedProps, prohibitedAttributes);
                    // special case for separator
                    if (permittedRoles[i] === "separator" && CommonUtil_1.CommonUtil.isFocusable(ruleContext)) {
                        CommonUtil_1.CommonUtil.concatUniqueArrayItemList(["aria-disabled", "aria-valuemax", "aria-valuemin", "aria-valuetext"], allowedAttributes);
                    }
                }
            }
            // ignore aria-level, aria-setsize or aria-posinset if "row" is not in treegrid
            if (permittedRoles.includes("row") && AriaUtil.getAncestorWithRole(ruleContext, "treegrid", true) == null) {
                var index = -1;
                if ((index = allowedAttributes.indexOf("aria-level")) > -1)
                    allowedAttributes.splice(index, 1);
                if ((index = allowedAttributes.indexOf("aria-setsize")) > -1)
                    allowedAttributes.splice(index, 1);
                if ((index = allowedAttributes.indexOf("aria-posinset")) > -1)
                    allowedAttributes.splice(index, 1);
            }
            // add the other allowed attributes for the element
            if (tagProperty && tagProperty.otherAllowedAriaAttributes && tagProperty.otherAllowedAriaAttributes.length > 0) {
                // check attribute-value pair if exists
                var allowed = [];
                for (var p = 0; p < tagProperty.otherAllowedAriaAttributes.length; p++) {
                    var attr = tagProperty.otherAllowedAriaAttributes[p];
                    if (attr.includes("=")) {
                        var pair = attr.split("=");
                        if (ruleContext.getAttribute(pair[0]) === pair[1])
                            allowed.push(pair[0]);
                    }
                    else
                        allowed.push(attr);
                }
                if (allowed.length > 0)
                    CommonUtil_1.CommonUtil.concatUniqueArrayItemList(allowed, allowedAttributes);
            }
            // add the other prohibitted attributes for the element
            if (tagProperty && tagProperty.otherDisallowedAriaAttributes && tagProperty.otherDisallowedAriaAttributes.length > 0) {
                // check attribute-value pair if exists
                var disallowed = [];
                for (var p = 0; p < tagProperty.otherDisallowedAriaAttributes.length; p++) {
                    var attr = tagProperty.otherDisallowedAriaAttributes[p];
                    if (attr.includes("=")) {
                        var pair = attr.split("=");
                        if (ruleContext.getAttribute(pair[0]) === pair[1])
                            disallowed.push(pair[0]);
                    }
                    else
                        disallowed.push(attr);
                }
                if (disallowed.length > 0)
                    CommonUtil_1.CommonUtil.concatUniqueArrayItemList(disallowed, prohibitedAttributes);
            }
            //exclude the prohibitedAttributes from the allowedAttributes
            allowedAttributes = CommonUtil_1.CommonUtil.reduceArrayItemList(prohibitedAttributes, allowedAttributes);
            //exclude aria attribute for elements without implicit role and with 'Naming Prohibited'
            if ((!roles || roles.length === 0) && tagProperty.implicitRole === null && tagProperty.prohibitedAriaAttributesWhenNoImplicitRole)
                allowedAttributes = CommonUtil_1.CommonUtil.reduceArrayItemList(tagProperty.prohibitedAriaAttributesWhenNoImplicitRole, allowedAttributes);
            CacheUtil_1.CacheUtil.setCache(ruleContext, "AriaUtil_AllowedAriaAttributes", allowedAttributes);
        }
        return allowedAttributes;
    };
    /**
     *
     * @param ariaAttr
     * @param htmlAttrs
     * @type: conflict or overlapping
     * @returns htmlAttrName, 'Pass' or null
     *         htmlAttrName that conflicts with the ariaAttr,
     *         'Pass' with no conflict with the ariaAttr,
     *         or null where ariaAttr won't cause conflict
     */
    AriaUtil.getConflictOrOverlappingHtmlAttribute = function (ariaAttr, htmlAttrs, type) {
        var exist = ARIADefinitions_1.ARIADefinitions.relatedAriaHtmlAttributes[ariaAttr['name']];
        if (exist) {
            if (!ariaAttr || ariaAttr.length == 0 || !htmlAttrs || htmlAttrs.length == 0)
                return [];
            var examinedHtmlAtrNames = [];
            var concernTypes = null;
            if (type === 'conflict') {
                if (!exist.conflict || Object.keys(exist.conflict).length === 0)
                    return null;
                concernTypes = exist.conflict;
            }
            else if (type === 'overlapping') {
                if (!exist.overlapping || Object.keys(exist.overlapping).length === 0)
                    return null;
                concernTypes = exist.overlapping;
            }
            else
                return null;
            var applicable = false;
            var fail = false;
            for (var k = 0; k < concernTypes.length; k++) {
                var concernAriaValue = concernTypes[k].ariaAttributeValue;
                var concernHtmlNames = concernTypes[k].htmlAttributeNames;
                var concernHtmlValues = concernTypes[k].htmlAttributeValues;
                for (var i = 0; i < htmlAttrs.length; i++) {
                    var index = concernHtmlNames.indexOf(htmlAttrs[i]['name']);
                    if (index !== -1) {
                        applicable = true;
                        var htmlValuesInConcern = (concernHtmlValues === null || concernHtmlValues[index] === null) ? null : concernHtmlValues[index].split(",");
                        if (concernAriaValue === null) {
                            if (htmlValuesInConcern === null) {
                                examinedHtmlAtrNames.push({ result: 'Failed', 'attr': htmlAttrs[i]['name'] });
                                fail = true;
                            }
                            else if (htmlValuesInConcern.includes(htmlAttrs[i]['value'])) {
                                examinedHtmlAtrNames.push({ result: 'Failed', 'attr': htmlAttrs[i]['name'] });
                                fail = true;
                            }
                        }
                        else if (htmlValuesInConcern === null) {
                            if (concernAriaValue === ariaAttr['value']) {
                                examinedHtmlAtrNames.push({ result: 'Failed', 'attr': htmlAttrs[i]['name'] });
                                fail = true;
                            }
                        }
                        else if (concernAriaValue === 'VALUE' && htmlValuesInConcern.includes('VALUE') && htmlValuesInConcern[0] !== ariaAttr['value']) {
                            examinedHtmlAtrNames.push({ result: 'Failed', 'attr': htmlAttrs[i]['name'] });
                            fail = true;
                        }
                        else if (concernAriaValue === ariaAttr['value'] && htmlValuesInConcern.includes(htmlAttrs[i]['value'])) {
                            examinedHtmlAtrNames.push({ result: 'Failed', 'attr': htmlAttrs[i]['name'] });
                            fail = true;
                        }
                    }
                }
            }
            if (applicable && !fail)
                examinedHtmlAtrNames.push({ result: 'Pass', 'attr': '' });
            return examinedHtmlAtrNames;
        }
        else
            return null;
    };
    AriaUtil.containsPresentationalChildrenOnly = function (elem) {
        var roles = AriaUtil.getRoles(elem, false);
        // if explicit role doesn't exist, get the implicit one
        if (!roles || roles.length === 0)
            roles = AriaUtil.getImplicitRole(elem);
        //ignore if the element doesn't have any explicit or implicit role, shouldn't happen
        if (!roles || roles.length === 0)
            return false;
        for (var i = 0; roles !== null && i < roles.length; i++) {
            var roleProperties = ARIADefinitions_1.ARIADefinitions.designPatterns[roles[i]];
            if (roleProperties !== null && roleProperties !== undefined) {
                var presentional = roleProperties.presentationalChildren;
                if (presentional === true)
                    return true;
            }
        }
        return false;
    };
    AriaUtil.shouldBePresentationalChild = function (element) {
        var walkNode = DOMWalker_1.DOMWalker.parentElement(element);
        while (walkNode) {
            if (AriaUtil.containsPresentationalChildrenOnly(walkNode))
                return true;
            //aria-own case: if the element is referred by an aria-won
            walkNode = ARIAMapper_1.ARIAMapper.getAriaOwnedBy(walkNode) || DOMWalker_1.DOMWalker.parentElement(walkNode);
        }
        return false;
    };
    /*
 * check if any explicit role specified for the element is a valid ARIA role
 * return: null if no explicit role is defined,
 *         true if the role(s) are defined in ARIA
 *         false if any role is not defined in ARIA
*/
    AriaUtil.areRolesDefined = function (roles) {
        if (!roles || roles.length === 0)
            return null;
        var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
        for (var _i = 0, roles_1 = roles; _i < roles_1.length; _i++) {
            var role = roles_1[_i];
            if (!(role.toLowerCase() in designPatterns))
                return false;
        }
        return true;
    };
    /*
     * check if any explicit role specified for the element is a valid ARIA role
     * return: null if no explicit role is defined,
     *         true if the role(s) are defined in ARIA
     *         false if any role is not defined in ARIA
    */
    AriaUtil.getInvalidRoles = function (ruleContext) {
        var domRoles = AriaUtil.getUserDefinedRoles(ruleContext);
        if (!domRoles || domRoles.length === 0)
            return null;
        // check the 'generic' role first
        if (domRoles && domRoles.includes('generic'))
            return ["generic"];
        // Failing roles
        var failRoleTokens = [];
        // Passing roles
        var passRoleTokens = [];
        var tagProperty = AriaUtil.getElementAriaProperty(ruleContext);
        var allowedRoles = AriaUtil.getAllowedAriaRoles(ruleContext, tagProperty);
        if (!allowedRoles || allowedRoles.length === 0)
            return domRoles;
        var invalidRoles = [];
        if (allowedRoles.includes('any'))
            return [];
        for (var i = 0; i < domRoles.length; i++)
            if (!allowedRoles.includes(domRoles[i]) && !invalidRoles.includes(domRoles[i]))
                invalidRoles.push(domRoles[i]);
        return invalidRoles;
    };
    /*
     * check if any explicit role specified for the element is not defined in ARIA
     * return: list of specified roles not defined in ARIA
    */
    AriaUtil.getRolesUndefinedByAria = function (element) {
        if (!element)
            return null;
        var roles = AriaUtil.getRoles(element, false);
        var undefinedRoles = [];
        if (roles && roles.length > 0) {
            var designPatterns = ARIADefinitions_1.ARIADefinitions.designPatterns;
            for (var i = 0; i < roles.length; i++) {
                if (!(roles[i] in designPatterns)) {
                    undefinedRoles.push(roles[i]);
                }
            }
        }
        return undefinedRoles;
    };
    /*
     * this method first checks explicit roles, if no explicit role, it will check the implicit role
     * return: null if any explicit role is invalid,
     *         a list of invalid attributes
     *         empty list if all attributes are valid, or no aria attributes are specified
     */
    AriaUtil.getInvalidAriaAttributes = function (ruleContext) {
        var roles = AriaUtil.getUserDefinedRoles(ruleContext);
        // the invalid role case: handled by Rpt_Aria_ValidRole. Ignore to avoid duplicated report
        // for mutiple roles, skip if any role is invalid
        var defined = AriaUtil.areRolesDefined(roles);
        if (defined !== null && !defined)
            return null;
        var attrs = [];
        if (!roles || roles.length == 0)
            roles = AriaUtil.getImplicitRole(ruleContext);
        var aria_attrs = AriaUtil.getUserDefinedAriaAttributes(ruleContext);
        var tagProperty = AriaUtil.getElementAriaProperty(ruleContext);
        // Attributes allowed on this node
        var allowedAttributes = AriaUtil.getAllowedAriaAttributes(ruleContext, roles, tagProperty);
        if (aria_attrs) {
            for (var i = 0; i < aria_attrs.length; i++) {
                var attrName = aria_attrs[i].trim().toLowerCase();
                if (!allowedAttributes.includes(attrName) && !attrs.includes(attrName))
                    attrs.push(attrName);
            }
        }
        return attrs;
    };
    /*
     * get conflict Aria and Html attributes
     * return: a list of Aria and Html attribute pairs that are conflict
    */
    AriaUtil.getConflictAriaAndHtmlAttributes = function (elem) {
        var ariaAttrs = AriaUtil.getUserDefinedAriaAttributeNameValuePairs(elem);
        var htmlAttrs = AriaUtil.getUserDefinedHtmlAttributeNameValuePairs(elem);
        var ret = [];
        if (ariaAttrs && ariaAttrs.length > 0 && htmlAttrs && htmlAttrs.length > 0) {
            var _loop_1 = function (i) {
                var examinedHtmlAtrNames = AriaUtil.getConflictOrOverlappingHtmlAttribute(ariaAttrs[i], htmlAttrs, 'conflict');
                if (examinedHtmlAtrNames === null)
                    return "continue";
                examinedHtmlAtrNames.forEach(function (item) {
                    if (item['result'] === 'Failed') //failed
                        ret.push({ 'ariaAttr': ariaAttrs[i]['name'], 'htmlAttr': item['attr'] });
                });
            };
            for (var i = 0; i < ariaAttrs.length; i++) {
                _loop_1(i);
            }
        }
        return ret;
    };
    /*
     * get deprecated Aria roles
     * return: a list of deprecated Aria roles
    */
    AriaUtil.getDeprecatedAriaRoles = function (element) {
        if (!element)
            return null;
        var roles = AriaUtil.getRoles(element, false);
        var ret = [];
        if (roles && roles.length > 0) {
            var globalDeprecatedRoles = ARIADefinitions_1.ARIADefinitions.globalDeprecatedRoles;
            for (var i = 0; i < roles.length; i++) {
                if (globalDeprecatedRoles.includes(roles[i]))
                    ret.push(roles[i]);
            }
        }
        return ret;
    };
    /*
     * get deprecated Aria role-attributes
     * return: a list of deprecated Aria role-attributes paris
     *         for global the role is marked as 'any'
    */
    AriaUtil.getDeprecatedAriaAttributes = function (element) {
        if (!element)
            return null;
        var domAttributes = element.attributes;
        var ariaAttrs = [];
        if (domAttributes) {
            for (var i = 0; i < domAttributes.length; i++) {
                var attrName = domAttributes[i].name;
                if (attrName.substring(0, 5) === 'aria-')
                    ariaAttrs.push(attrName);
            }
        }
        if (ariaAttrs.length === 0)
            return [];
        var ret = [];
        var globalDeprecatedAttributes = ARIADefinitions_1.ARIADefinitions.globalDeprecatedProperties;
        for (var i = 0; i < ariaAttrs.length; i++) {
            if (globalDeprecatedAttributes.includes(ariaAttrs[i]))
                ret.push({ "role": "any", "attribute": ariaAttrs[i] });
        }
        var roles = AriaUtil.getRoles(element, false);
        if (roles && roles.length > 0) {
            for (var i = 0; i < roles.length; i++) {
                var roleWithDeprecatedAttributes = ARIADefinitions_1.ARIADefinitions.designPatterns[roles[i]];
                if (roleWithDeprecatedAttributes) {
                    var deprecatedAttriNames = roleWithDeprecatedAttributes['deprecatedProps'];
                    if (deprecatedAttriNames && deprecatedAttriNames.length > 0) {
                        for (var j = 0; j < ariaAttrs.length; j++) {
                            if (deprecatedAttriNames.includes(ariaAttrs[j]))
                                ret.push({ "role": roles[i], "attribute": ariaAttrs[j] });
                        }
                    }
                }
            }
        }
        return ret;
    };
    AriaUtil.isNodeInGrid = function (node) {
        return AriaUtil.getAncestorWithRole(node, "grid") != null;
    };
    // This list contains a list of elements tags which have display: none by default, since we have rules triggering
    AriaUtil.navLinkKeywords = ['start', 'next', 'prev', 'previous', 'contents', 'index'];
    // This list contains a list of rule ids for the rules that have to check for hidden content regardless of the Check Hidden
    // Content Setting. This means that when the engine is actually determine which elements to mass to the rules, it will always
    // pass theses rules no matter what the Check Hidden Content Setting is.
    AriaUtil.rulesThatHaveToCheckHidden = ['RPT_Elem_UniqueId'];
    // https://www.w3.org/TR/wai-aria-1.1/#introstates
    AriaUtil.ariaAttributeRoleDefaults = {
        "alert": {
            "aria-live": "assertive",
            "aria-atomic": "true"
        },
        "combobox": {
            "aria-haspopup": "listbox"
        },
        "listbox": {
            "aria-orientation": "vertical"
        },
        "log": {
            "aria-live": "polite"
        },
        "menu": {
            "aria-orientation": "vertical"
        },
        "menubar": {
            "aria-orientation": "horizontal"
        },
        "meter": {
            "aria-valuemin": "0",
            "aria-valuemax": "100"
        },
        "option": {
            "aria-selected": "false"
        },
        "progressbar": {
            "aria-valuemin": "0",
            "aria-valuemax": "100"
        },
        "scrollbar": {
            "aria-orientation": "vertical",
            "aria-valuemin": "0",
            "aria-valuemax": "100"
        },
        "separator": {
            "aria-orientation": "horizontal",
            "aria-valuemin": "0",
            "aria-valuemax": "100"
        },
        "slider": {
            "aria-orientation": "horizontal",
            "aria-valuemin": "0",
            "aria-valuemax": "100"
        },
        "spinbutton": {
        // Not sure how to encode min/max (or now in 1.2 - "has no value")
        //"aria-valuenow": "0" TODO: at risk: maybe delete after ARIA 1.2 reaches proposed rec
        // Probably just delete spinbutton from this list completely and let user agents handle "defaults"
        },
        "status": {
            "aria-live": "polite",
            "aria-atomic": "true"
        },
        "tab": {
            "aria-selected": "false"
        },
        "tablist": {
            "aria-orientation": "horizontal"
        },
        "toolbar": {
            "aria-orientation": "horizontal"
        },
        "tree": {
            "aria-orientation": "vertical"
        }
    };
    // https://www.w3.org/TR/wai-aria-1.1/#aria-atomic
    AriaUtil.ariaAttributeGlobalDefaults = {
        "aria-atomic": "false",
        "aria-autocomplete": "none",
        "aria-busy": "false",
        "aria-checked": undefined,
        "aria-current": "false",
        "aria-disabled": "false",
        "aria-dropeffect": "none",
        "aria-expanded": undefined,
        "aria-grabbed": undefined,
        "aria-haspopup": "false",
        "aria-hidden": undefined,
        "aria-invalid": "false",
        "aria-live": "off",
        "aria-modal": "false",
        "aria-multiline": "false",
        "aria-multiselectable": "false",
        "aria-orientation": undefined,
        "aria-pressed": undefined,
        "aria-readonly": "false",
        //"aria-relevant": "additions text", TODO: are multiple values supported?
        "aria-required": "false",
        "aria-selected": undefined,
        "aria-sort": "none"
    };
    // https://www.w3.org/TR/html-aam-1.0/#html-attribute-state-and-property-mappings
    AriaUtil.ariaAttributeImplicitMappings = {
        "aria-autocomplete": {
            "form": function (e) {
                return "off" === e.getAttribute("autocomplete") ? "none" : "both";
            },
            "input": function (e) {
                return "off" === e.getAttribute("autocomplete") ? "none" : "both";
            },
            "select": function (e) {
                return "off" === e.getAttribute("autocomplete") ? "none" : "both";
            },
            "textarea": function (e) {
                return "off" === e.getAttribute("autocomplete") ? "none" : "both";
            }
        },
        "aria-checked": {
            "input": function (e) {
                if (e.hasAttribute("indeterminate"))
                    return "mixed";
                return "" + e.hasAttribute("checked");
            },
            "menuitem": function (e) {
                if (e.hasAttribute("indeterminate"))
                    return "mixed";
                return "" + e.hasAttribute("checked");
            },
            "*": function (e) {
                if (e.hasAttribute("indeterminate"))
                    return "mixed";
            },
        },
        "aria-disabled": {
            "button": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "fieldset": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "input": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "optgroup": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "option": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "select": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            },
            "textarea": function (e) {
                return e.hasAttribute("disabled") ? "true" : "false";
            }
        },
        "aria-expanded": {
            "details": function (e) {
                return e.getAttribute("open");
            },
            "dialog": function (e) {
                return e.getAttribute("open");
            }
        },
        "aria-multiselectable": {
            "select": function (e) {
                if (e.hasAttribute("multiple"))
                    return "true";
                return;
            }
        },
        "aria-placeholder": {
            "input": function (e) {
                return e.getAttribute("placeholder");
            },
            "textarea": function (e) {
                return e.getAttribute("placeholder");
            }
        },
        "aria-required": {
            "input": function (e) {
                return e.getAttribute("required");
            },
            "select": function (e) {
                return e.getAttribute("required");
            },
            "textarea": function (e) {
                return e.getAttribute("required");
            }
        }
    };
    return AriaUtil;
}());
exports.AriaUtil = AriaUtil;


/***/ }),

/***/ 1775:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2022- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CSSUtil = void 0;
var CacheUtil_1 = __webpack_require__(7788);
var CommonUtil_1 = __webpack_require__(8137);
var AriaUtil_1 = __webpack_require__(490);
var DOMMapper_1 = __webpack_require__(5697);
var DOMWalker_1 = __webpack_require__(7440);
var CSSUtil = /** @class */ (function () {
    function CSSUtil() {
    }
    CSSUtil.selectorMatchesElem = function (element, selector) {
        try {
            if (selector.trim() === "")
                return false;
            if (typeof element.matches === "function") {
                return element.matches(selector);
            }
            if (typeof element.matchesSelector === "function") {
                return element.matchesSelector(selector);
            }
            // Native functions not there, fallback
            var matches = (element.document || element.ownerDocument).querySelectorAll(selector);
            var i = 0;
            while (i < matches.length && matches[i] !== element) {
                ++i;
            }
            return i < matches.length;
        }
        catch (err) {
            // Bad selector? Doesn't match then...
            return false;
        }
    };
    /**
     * Returns the style computed for this element
     * @param elem
     */
    CSSUtil.getComputedStyle = function (elem, pseudoElt) {
        if (!elem)
            return null;
        var doc = elem.ownerDocument;
        var win = doc.defaultView;
        return win.getComputedStyle(elem, pseudoElt);
    };
    /**
     * Returns the style defined for this element
     *
     * This differs from the computed style in that the computed style will return
     * styles defined by the user agent. This will only return styles defined by the
     * application
     * if rotation transform is used, the computed style returns the resolved matrix
     *  while the defined style return the transform function(s)
     * for example, for 'transform: rotate(2.5deg);', the computed style returns 'matrix(-0.0436194, 0.999048, -0.999048, -0.0436194, 0, 0)'
     *  and the defined style returns 'rotate(2.5deg)'
     *
     * change the type of the parameter pseudoClass from PseudoClass to string to include both pseudo classes (e.g., :focus, :checked)
     * and pseudo elements (e.g., ::before, ::after).
     *
     * @param {HTMLElement} elem
     * @param {string} [pseudoClass] If specified, will return values that are different
     * than when the pseudoClass does not match.
     */
    CSSUtil.getDefinedStyles = function (elem, pseudoClass) {
        // console.log("Function: getDefinedStyles");
        if (!elem)
            return null;
        var definedStyles = {};
        var definedStylePseudo = {};
        function fillStyle(maps, style) {
            for (var sIndex = 0; sIndex < style.length; ++sIndex) {
                if (style[sIndex] === "all" && style[style[sIndex]]) {
                    for (var _i = 0, maps_1 = maps; _i < maps_1.length; _i++) {
                        var map = maps_1[_i];
                        for (var key in map) {
                            delete map[key];
                        }
                    }
                    break;
                }
                else {
                    var key = style[sIndex];
                    for (var _a = 0, maps_2 = maps; _a < maps_2.length; _a++) {
                        var map = maps_2[_a];
                        var priority = style.getPropertyPriority(key);
                        if (key in map && map[key].endsWith("!important")) {
                            if (priority === "important" &&
                                !map[key].startsWith("inherit") &&
                                !map[key].startsWith("unset"))
                                //override !important only if it is also !important
                                map[key] = style[key] + " !important";
                            //don't override !important if it is not !important
                            else
                                continue;
                        }
                        //create/overide anyway
                        else
                            map[key] =
                                style[key] +
                                    (priority === "important" ? " !important" : "");
                    }
                }
            }
        }
        var storedStyles = CacheUtil_1.CacheUtil.getCache(elem, "RPTUtil_DefinedStyles", null);
        if (!pseudoClass && storedStyles) {
            definedStyles = storedStyles["definedStyles"];
            definedStylePseudo = storedStyles["definedStylePseudo"];
        }
        else {
            // Iterate through all of the stylesheets and rules
            for (var ssIndex = 0; ssIndex < elem.ownerDocument.styleSheets.length; ++ssIndex) {
                var sheet = elem.ownerDocument.styleSheets[ssIndex];
                try {
                    if (sheet && sheet.cssRules) {
                        // console.log("Got sheet");
                        for (var rIndex = 0; rIndex < sheet.cssRules.length; ++rIndex) {
                            // console.log("Got rule: ", sheet.cssRules[rIndex]);
                            var rule = sheet.cssRules[rIndex];
                            var fullRuleSelector = rule.selectorText;
                            if (fullRuleSelector) {
                                var pseudoMatch = fullRuleSelector.match(/^(.*)(:[a-zA-Z-]*)$/);
                                var hasPseudoClass = !!pseudoMatch;
                                var selMain = hasPseudoClass
                                    ? pseudoMatch[1]
                                    : fullRuleSelector;
                                var selPseudo = hasPseudoClass
                                    ? pseudoMatch[2]
                                    : "";
                                var samePseudoClass = selPseudo === pseudoClass;
                                if (pseudoClass && pseudoClass === ":focus") {
                                    // If this element has focus, remove focus-within from parents
                                    selMain = selMain.replace(/([ >][^+~ >]+):focus-within/g, "$1");
                                }
                                // Get styles of non-pseudo selectors
                                if (!hasPseudoClass &&
                                    CSSUtil.selectorMatchesElem(elem, selMain)) {
                                    fillStyle([definedStyles, definedStylePseudo], rule.style);
                                }
                                if (samePseudoClass &&
                                    CSSUtil.selectorMatchesElem(elem, selMain)) {
                                    fillStyle([definedStylePseudo], rule.style);
                                }
                            }
                        }
                    }
                }
                catch (err) {
                    if (!err.toString().includes("Cannot access rules") &&
                        !err.toString().includes("SecurityError:")) {
                        throw err;
                    }
                }
            }
            //
            // Handled the stylesheets, now handle the element defined styles
            fillStyle([definedStyles, definedStylePseudo], elem.style);
            CacheUtil_1.CacheUtil.setCache(elem, "RPTUtil_DefinedStyles", {
                definedStyles: definedStyles,
                definedStylePseudo: definedStylePseudo,
            });
        }
        /**
     * 'initial' sets the style back to default
    for (const key in definedStyles) {
        if (definedStyles[key] === "initial") {
            delete definedStyles[key];
        }
    }
    for (const key in definedStylePseudo) {
        if (definedStylePseudo[key] === "initial") {
            delete definedStylePseudo[key];
        }
    }
    */
        if (!pseudoClass) {
            // console.log("[DEBUG: CSSUtil::getDefinedStyles]", elem.nodeName, pseudoClass, JSON.stringify(definedStyles, null, 2));
            return definedStyles;
        }
        else {
            for (var key in definedStylePseudo) {
                if (definedStylePseudo[key] === definedStyles[key]) {
                    delete definedStylePseudo[key];
                }
            }
            // console.log("[DEBUG: CSSUtil::getDefinedStyles]", elem.nodeName, pseudoClass, JSON.stringify(definedStylePseudo, null, 2));
            return definedStylePseudo;
        }
    };
    /**
     * Returns the media query defined for the document
     *
     *
     * @param {Document} doc
     */
    CSSUtil.getMediaOrientationTransform = function (doc) {
        var orientationTransforms = {};
        // Iterate through all of the stylesheets and rules
        for (var ssIndex = 0; ssIndex < doc.styleSheets.length; ++ssIndex) {
            var sheet = doc.styleSheets[ssIndex];
            try {
                if (sheet && sheet.cssRules) {
                    for (var rIndex = 0; rIndex < sheet.cssRules.length; ++rIndex) {
                        var sheetRule = sheet.cssRules[rIndex];
                        if (4 /* CSSRule.MEDIA_RULE */ === sheetRule.MEDIA_RULE) {
                            var rule = sheetRule;
                            if (rule && rule.media) {
                                var mediaList = rule.media;
                                for (var i = 0; i < mediaList.length; i++) {
                                    if (!mediaList.item(i))
                                        continue;
                                    var elem_transforms = orientationTransforms[mediaList.item(i).toLocaleLowerCase()];
                                    if (!elem_transforms)
                                        elem_transforms = {};
                                    var styleRules = rule.cssRules;
                                    for (var i_1 = 0; i_1 < styleRules.length; ++i_1) {
                                        if (1 /* CSSRule.STYLE_RULE */ === styleRules[i_1].STYLE_RULE) {
                                            var styleRule = styleRules[i_1];
                                            var selector = styleRule.selectorText;
                                            if (selector) {
                                                var transforms = {};
                                                var styles = styleRule.style;
                                                for (var s = 0; s < styles.length; ++s) {
                                                    var key = styles[s];
                                                    if (key.toLocaleLowerCase() === "transform") {
                                                        if (key === "all" && styles[key]) {
                                                            delete transforms[key];
                                                            break;
                                                        }
                                                        else {
                                                            transforms[key] = styles[key];
                                                        }
                                                    }
                                                    else if (key.toLocaleLowerCase() === "rotate") {
                                                        transforms[key] = styles[key];
                                                    }
                                                    elem_transforms[selector] =
                                                        transforms;
                                                }
                                            }
                                        }
                                        if (mediaList.item(i_1))
                                            orientationTransforms[mediaList.item(i_1).toLocaleLowerCase()] = elem_transforms;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (err) {
                if (!err.toString().includes("Cannot access rules") &&
                    !err.toString().includes("SecurityError:")) {
                    throw err;
                }
            }
        }
        return orientationTransforms;
    };
    /**
     * convert given rotation transform functions to the degree transformed.
     * If multiple functions are given, then the functions are applied linearly in the order.
     *   rotation_transform function example:  rotate(45deg), rotate(2turn), rotate(2rad), rotate3d(1, 1, 1, 45deg),
     *        rotate(2rad) rotate3d(1, 1, 1, 45deg)
     * @param rotation_transform
     */
    CSSUtil.getRotationDegree = function (rotation_transform) {
        var degree = 0;
        try {
            if (!rotation_transform)
                return degree;
            // normalize the rotation_transform
            rotation_transform = rotation_transform.replaceAll(", ", ",");
            var transform_functions = rotation_transform.split(" ");
            for (var i = 0; i < transform_functions.length; i++) {
                var transform_function = transform_functions[i].trim();
                if (transform_function === "")
                    continue;
                if (transform_function.startsWith("rotate3d")) {
                    // example: rotate3d(1, 1, 1, 45deg);
                    var left = transform_function.indexOf("(");
                    var right = transform_function.indexOf(")");
                    if (left !== -1 && right !== -1) {
                        var matrix = transform_function.substring(left + 1, right);
                        var values = void 0;
                        if (matrix)
                            values = matrix.split(",");
                        if (values && values.length === 4) {
                            var rotation = values[3];
                            if (!rotation)
                                continue;
                            rotation = rotation.trim();
                            if (rotation.endsWith("turn")) {
                                var num = rotation.substring(0, rotation.length - 4);
                                num = parseFloat(num);
                                if (!isNaN(num))
                                    degree = num * 360;
                            }
                            else if (rotation.endsWith("rad")) {
                                var num = rotation.substring(0, rotation.length - 3);
                                num = parseFloat(num);
                                if (!isNaN(num))
                                    degree = (num * 180) / Math.PI;
                            }
                            else if (rotation.endsWith("deg")) {
                                var num = rotation.substring(0, rotation.length - 3);
                                num = parseFloat(num);
                                if (!isNaN(num))
                                    degree += num;
                            }
                        }
                    }
                }
                else if (transform_function.startsWith("rotate") ||
                    transform_function.startsWith("rotateZ")) {
                    // example: rotate(45deg);
                    var left = transform_function.indexOf("(");
                    var right = transform_function.indexOf(")");
                    if (left !== -1 && right !== -1) {
                        var rotation = transform_function.substring(left + 1, right);
                        if (!rotation)
                            continue;
                        rotation = rotation.trim();
                        if (rotation.endsWith("turn")) {
                            var num = rotation.substring(0, rotation.length - 4);
                            num = parseFloat(num);
                            if (!isNaN(num))
                                degree = num * 360;
                        }
                        else if (rotation.endsWith("rad")) {
                            var num = rotation.substring(0, rotation.length - 3);
                            num = parseFloat(num);
                            if (!isNaN(num))
                                degree = (num * 180) / Math.PI;
                        }
                        else if (rotation.endsWith("deg")) {
                            var num = rotation.substring(0, rotation.length - 3);
                            num = parseFloat(num);
                            if (!isNaN(num))
                                degree += num;
                        }
                    }
                }
                else if (transform_function.startsWith("matrix3d")) {
                    // calculate the three Euler angles
                    var left = transform_function.indexOf("(");
                    var right = transform_function.indexOf(")");
                    if (left !== -1 && right !== -1) {
                        var matrix = transform_function.substring(left + 1, right);
                        var values = null;
                        if (matrix)
                            values = matrix.split(",");
                        if (values !== null) {
                            var z_angle = Math.atan2(values[4], values[5]);
                            degree += Math.round(Math.round((z_angle * 180) / Math.PI));
                        }
                    }
                }
                else if (transform_function.startsWith("matrix")) {
                    // calculate the three Euler angles
                    var left = transform_function.indexOf("(");
                    var right = transform_function.indexOf(")");
                    if (left !== -1 && right !== -1) {
                        var matrix = transform_function.substring(left + 1, right);
                        var values = null;
                        if (matrix)
                            values = matrix.split(",");
                        if (values !== null) {
                            var z_angle = Math.atan2(values[1], values[0]);
                            degree += Math.round(Math.round((z_angle * 180) / Math.PI));
                        }
                    }
                }
            }
            while (degree >= 360)
                degree -= 360;
        }
        catch (err) {
            console.log("Cannot retrieve rotation degree: " + err);
            throw err;
        }
        return degree;
    };
    /**
     * Convert CSS style string values to pixels.
     *
     * @param value style value in string, such as 3rem, 230px etc.
     * @param target element.
     * @return value in pixels
     */
    CSSUtil.getPixelsFromStyle = function (value, elem) {
        if (!value)
            return 0;
        var regex = /(-?[\d.]+)([a-z%]*)/;
        var parsed = value.trim().match(regex);
        if (parsed === null)
            return 0;
        if (parsed[2] === "" || parsed[1] === 0)
            //no zero value without unit which is considered as error, so implicable
            return 0;
        var pixels = CSSUtil.convertValue2Pixels(parsed[2], parsed[1], elem);
        return pixels === null ? pixels : parseFloat(pixels);
    };
    /**
     * Convert absolute CSS numerical values to pixels.
     *
     * @param unitValue in string
     * @param target element.
     * @return value in pixels
     */
    CSSUtil.convertValue2Pixels = function (unit, unitValue, elem) {
        if (unitValue === 0)
            return 0;
        if (!unit)
            unit = "px";
        var supportedUnits = {
            // absolute unit
            px: function (value) { return value; },
            cm: function (value) { return value * 37.8; },
            mm: function (value) { return value * 3.78; },
            q: function (value) { return value * 0.95; },
            in: function (value) { return value * 96; },
            pc: function (value) { return value * 16; },
            pt: function (value) { return value * 1.33; },
            // relative unit
            rem: function (value) {
                return value *
                    parseFloat(getComputedStyle(elem.ownerDocument.documentElement).getPropertyValue("font-size"));
            },
            em: function (value) {
                return value *
                    parseFloat(getComputedStyle(elem).getPropertyValue("font-size"));
            },
            vw: function (value) {
                return (value / 100) * elem.ownerDocument.defaultView.innerWidth;
            },
            vh: function (value) {
                return (value / 100) * elem.ownerDocument.defaultView.innerHeight;
            },
            "%": function (value) {
                return (value / 100) *
                    parseFloat(getComputedStyle(elem).getPropertyValue("font-size"));
            },
        };
        if (unit in supportedUnits)
            return supportedUnits[unit](unitValue);
        return null;
    };
    /*
     * Returns if the font for visible text of the element is defined by material icons
     *
     * @param {HTMLElement} elem
     */
    CSSUtil.isMaterialIconFont = function (elem) {
        // TODO: check the existence material icons using fetch in node 18+
        // for now (node 16) just dertermine if the stylesheet for the 'Material Icons' exists statically. note that the loading of the font stylesheet occurs at run time.
        //list of known material icons and stylesheet link
        var known_icons = {
            "Material Icons": "https://fonts.googleapis.com/icon?family=Material+Icons",
        };
        var known_css_classes = {
            "material-icons": "https://fonts.googleapis.com/icon?family=Material+Icons",
        };
        // material icon font can be defined either by font-family: 'Material Icons' or by class="material-icons"
        var styles = CSSUtil.getDefinedStyles(elem);
        var fontFamily = styles["font-family"];
        var found = false;
        // font-family specifies a prioritized list of one or more font family names
        if (fontFamily &&
            fontFamily.split(",")[0].replace(/['"]+/g, "").trim() in known_icons)
            found = true;
        if (!found) {
            var list = elem.classList;
            for (var css_class in known_css_classes) {
                if (list.contains(css_class)) {
                    found = true;
                    break;
                }
            }
        }
        if (!found)
            return false;
        var passed = false;
        // check if the stylesheet for the 'Material Icons' exists statically
        var sheets = elem.ownerDocument.styleSheets;
        for (var s = 0; s < sheets.length; s++) {
            if (sheets &&
                sheets.length > 0 &&
                Object.values(known_icons).indexOf(sheets[s].href) > -1) {
                passed = true;
                break;
            }
        }
        return passed;
    };
    CSSUtil.getWeightNumber = function (styleVal) {
        var map = {
            light: 100,
            bold: 700,
        };
        var retVal = parseInt(styleVal);
        if (retVal)
            return retVal;
        if (styleVal in map)
            return map[styleVal];
        return 400;
    };
    CSSUtil.getFontInPixels = function (styleVal, elem) {
        var map = {
            "xx-small": 16,
            "x-small": 10,
            small: 13,
            medium: 16,
            large: 18,
            "x-large": 24,
            "xx-large": 32,
        };
        var value = parseFloat(styleVal);
        if (!value) {
            return map[styleVal];
        }
        var units = styleVal.substring(("" + value).length);
        /**
        if (units === "" || units === "px") return value;
        if (units === "em") return value * 16;
        if (units === "%") return value / 100 * 16;
        if (units === "pt") return value * 4 / 3;
        return Math.round(value);
    */
        return CSSUtil.convertValue2Pixels(units, value, elem);
    };
    CSSUtil.getCSSStyle = function (element) {
        var styleText = "";
        if (element === null)
            return [];
        if (element.IBM_CSS_THB)
            return element.IBM_CSS_THB;
        var nodeName = element.nodeName.toLowerCase();
        if (nodeName === "style") {
            styleText = element.innerText;
            if (styleText === undefined || styleText.trim() === "")
                styleText = element.textContent;
        }
        else if (element.hasAttribute("style")) {
            styleText = element.getAttribute("style");
        }
        else
            return [];
        if (styleText === null || styleText.trim().length === 0)
            return [];
        //remove comment blocks
        var re = /(\/\*+(?:(?:(?:[^\*])+)|(?:[\*]+(?!\/)))[*]+\/)|\/\/.*/g;
        var subst = " ";
        styleText = styleText.replace(re, subst);
        // Find all "key : val;" pairs with various whitespace inbetween
        var rKeyVals = /\s*([^:\s]+)\s*:\s*([^;$}]+)\s*(;|$)/g;
        // Find all "selector { csskeyvals } with various whitespace inbetween
        var rSelectors = /\s*([^{]*){([^}]*)}/g;
        if (styleText.indexOf("{") === -1) {
            var keyVals = {};
            var m = void 0;
            while ((m = rKeyVals.exec(styleText)) != null) {
                keyVals[m[1]] = m[2].trim().toLowerCase();
            }
            var retVal = [
                {
                    selector: null,
                    values: keyVals,
                },
            ];
            element.IBM_CSS_THB = retVal;
            return retVal;
        }
        else {
            var retVal = [];
            var m = void 0;
            var m2 = void 0;
            while ((m = rSelectors.exec(styleText)) != null) {
                var keyVals = {};
                var selKey = m[1];
                var selVal = m[2];
                while ((m2 = rKeyVals.exec(selVal)) != null) {
                    keyVals[m2[1]] = m2[2].trim().toLowerCase();
                }
                retVal.push({
                    selector: selKey,
                    values: keyVals,
                });
            }
            element.IBM_CSS_THB = retVal;
            return retVal;
        }
    };
    /**
     * an "inline" CSS display property tells the element to fit itself on the same line. An 'inline' element's width and height are ignored.
     * some element has default inline property, such as <span>, <a>
     * most formatting elements inherent inline property, such as <em>, <strong>, <i>, <small>
     * other inline elements: <abbr> <acronym> <b> <bdo> <big> <br> <cite> <code> <dfn> <em> <i> <input> <kbd> <label>
     * <map> <object> <output> <q> <samp> <script> <select> <small> <span> <strong> <sub> <sup> <textarea> <time> <tt> <var>
     * an "inline-block" element still place element in the same line without breaking the line, but the element's width and height are applied.
     * inline-block elements: img, button, select, meter, progress, marguee, also in Chrome: textarea, input
     * A block-level element always starts on a new line, and the browsers automatically add some space (a margin) before and after the element.
     * block-level elements: <address> <article> <aside> <blockquote> <canvas> <dd> <div> <dl> <dt> <fieldset> <figcaption> <figure> <footer> <form>
     * <h1>-<h6> <header> <hr> <li> <main> <nav> <noscript> <ol> <p> <pre> <section> <table> <tfoot> <ul> <video>
     *
     * return: if it's inline element and { inline: true | false, text: true | false, violation: null | {node} }
     */
    CSSUtil.getInlineStatus = function (element) {
        if (!element)
            return null;
        var elem_styl = getComputedStyle(element);
        if (!elem_styl)
            return null;
        var status = { inline: false, text: false, violation: null };
        var udisplay = elem_styl.getPropertyValue("display");
        // inline element only
        if (udisplay !== "inline")
            return status;
        status.inline = true;
        var parent = element.parentElement;
        if (!parent)
            return status;
        var mapper = new DOMMapper_1.DOMMapper();
        var bounds = mapper.getUnadjustedBounds(element);
        var style = getComputedStyle(parent);
        var display = style.getPropertyValue("display");
        // an inline element is inside a block. note <body> is a block element too
        if (display !== "block" && display !== "inline-block") {
            //parent is inline element
            if (!CommonUtil_1.CommonUtil.isInnerTextOnlyEmpty(parent))
                status.text = true;
            return status;
        }
        /**
         * @returns "yes"": inline with text, "no": inline without text,
         *          "violation": not spacing enough to neiboring inline target
         *          "block": block element,
         */
        function isInlineWithText(node, before) {
            // note browsers insert Text nodes to represent whitespaces.
            if (node.nodeType === Node.TEXT_NODE) {
                if (node.nodeValue && node.nodeValue.trim().length > 0)
                    return "yes";
                else
                    return "no";
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                // special case: <br> is styled 'inline' by default, but change the line
                if (node.nodeName.toLowerCase() === "br")
                    return "block";
                var cStyle = getComputedStyle(node);
                var cDisplay = cStyle.getPropertyValue("display");
                if (cDisplay === "inline") {
                    if (CommonUtil_1.CommonUtil.isTarget(node)) {
                        if (bounds.width < 24) {
                            // check if the horizontal spacing is sufficient
                            var bnds = mapper.getUnadjustedBounds(node);
                            if ((before && (Math.round(bounds.width / 2) + bounds.left - bnds.left < 24))
                                || (!before && (Math.round(bounds.width / 2) + bounds.left - (bnds.left + bnds.width) < 24))) {
                                status.violation = node.nodeName.toLowerCase();
                                return "violation";
                            }
                            else
                                return "no";
                        }
                    }
                    if (!CommonUtil_1.CommonUtil.isInnerTextOnlyEmpty(node))
                        return "yes";
                    return "no";
                }
                else
                    return "block";
            }
            else
                return "block";
        }
        // an inline element is inside a block. note <body> is a block element too
        // one or more inline elements with text in the same line: <target>, text<target>, <target>text, <inline>+text<target>, <target><inline>+text, text<target><inline>+
        var walkNode = element.nextSibling;
        while (walkNode) {
            var inlineText = isInlineWithText(walkNode, true);
            if (inlineText === "yes") {
                status.text = true;
                break;
            }
            if (inlineText === "block") {
                break;
            }
            walkNode = walkNode.nextSibling;
        }
        walkNode = element.previousSibling;
        while (walkNode) {
            var inlineText = isInlineWithText(walkNode, false);
            if (inlineText === "yes") {
                status.text = true;
                break;
            }
            if (inlineText === "block") {
                break;
            }
            walkNode = walkNode.previousSibling;
        }
        return status;
    };
    /**
     * a target is en element that accept a pointer action (click or touch)
     * a target is a browser default if it's a native widget (no user defined role) without user style
     */
    CSSUtil.isTargetBrowserDefault = function (element) {
        if (!element)
            return false;
        // user defined widget
        var roles = AriaUtil_1.AriaUtil.getRoles(element, false);
        if (roles && roles.length > 0)
            return false;
        // no user style to space control size, including use of font
        var styles = CSSUtil.getDefinedStyles(element);
        if (styles["line-height"] ||
            styles["height"] ||
            styles["width"] ||
            styles["min-height"] ||
            styles["min-width"] ||
            styles["font-size"] ||
            styles["margin-top"] ||
            styles["margin-bottom"] ||
            styles["margin-left"] ||
            styles["margin-right"])
            return false;
        return true;
    };
    /*
     * string contains CJK (chinese, japaneses, or korea)
     * return: boolean
     */
    CSSUtil.containsCKJ = function (text) {
        if (!text)
            return false;
        // https://en.wikipedia.org/wiki/CJK_Unified_Ideographs  https://ayaka.shn.hk/hanregex/
        var regex = /(?:[\u4e00-\u9fff\u3400-\u4dbf])+/g;
        var replaced = text.trim().replace(regex, "");
        if (replaced.length === text.trim().length)
            return false;
        return true;
    };
    /**
     * return the ancestor with the given style properties.
     *
     * @parm {element} element - The element to start the node walk on to find parent node
     * @parm {[string]} styleProps - The style properties and values of the parent to search for.
     *         such as {"overflow":['auto', 'scroll'], "overflow-x":['auto', 'scroll']}
     *          or {"overflow":['*'], "overflow-x":['*']}, The '*' for any value to check the existence of the style prop.
     * @parm {bool} excludedValues - style values that should be ignored.
     * @return {node} walkNode - A parent node of the element, which has the style properties
     * @memberOf AriaUtil
     */
    CSSUtil.getAncestorWithStyles = function (elem, styleProps, excludedValues) {
        if (excludedValues === void 0) { excludedValues = []; }
        var walkNode = elem;
        while (walkNode !== null) {
            var node = CacheUtil_1.CacheUtil.getCache(walkNode, "AriaUtil_AncestorWithStyles", null);
            if (node)
                return node;
            var styles = CSSUtil.getDefinedStyles(walkNode);
            for (var style in styleProps) {
                var value = styles[style];
                if (value) {
                    value = value.split(" ")[0]; //get rid of !important
                    if (!excludedValues.includes(value)) {
                        if (styleProps[style].includes('*')) {
                            CacheUtil_1.CacheUtil.setCache(walkNode, "AriaUtil_AncestorWithStyles", walkNode);
                            return walkNode;
                        }
                        else if (styleProps[style].includes(value)) {
                            CacheUtil_1.CacheUtil.setCache(walkNode, "AriaUtil_AncestorWithStyles", walkNode);
                            return walkNode;
                        }
                    }
                }
            }
            walkNode = DOMWalker_1.DOMWalker.parentElement(walkNode);
        }
        CacheUtil_1.CacheUtil.setCache(elem, "AriaUtil_AncestorWithStyles", undefined);
        return null;
    };
    /**
     * return an array [value, Unit] from a value-unit combo string
     * @param valueUnitCombo, such as 20px, 2rem
     * @returns
     */
    CSSUtil.getValueUnitPair = function (valueUnitCombo) {
        if (!valueUnitCombo)
            return null;
        if (Number.isInteger(valueUnitCombo))
            return ["px", valueUnitCombo];
        var value = parseInt(valueUnitCombo);
        if (isNaN(value))
            return null;
        valueUnitCombo = valueUnitCombo.trim().toLowerCase();
        var match = valueUnitCombo.trim().match(/([a-z]+)$/);
        var unit = 'px';
        if (match)
            unit = match[1];
        return [unit, value];
    };
    return CSSUtil;
}());
exports.CSSUtil = CSSUtil;


/***/ }),

/***/ 7788:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CacheUtil = void 0;
var DOMWalker_1 = __webpack_require__(7440);
var CacheUtil = /** @class */ (function () {
    function CacheUtil() {
    }
    /* Return a pointer to the given global variable
         * with its initial value as given */
    CacheUtil.getCache = function (cacheSpot, keyName, initValue) {
        if (!cacheSpot)
            return undefined;
        var cacheObj = (cacheSpot.nodeType === 9 /* Node.DOCUMENT_NODE */ || cacheSpot.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? cacheSpot : cacheSpot;
        if (cacheObj.aceCache === undefined) {
            cacheObj.aceCache = {};
        }
        if (cacheObj.aceCache[keyName] === undefined) {
            cacheObj.aceCache[keyName] = initValue;
        }
        return cacheObj.aceCache[keyName];
    };
    CacheUtil.setCache = function (cacheSpot, globalName, value) {
        if (!cacheSpot)
            return undefined;
        var cacheObj = (cacheSpot.nodeType === 9 /* Node.DOCUMENT_NODE */ || cacheSpot.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? cacheSpot : cacheSpot;
        if (cacheObj.aceCache === undefined) {
            cacheObj.aceCache = {};
        }
        cacheObj.aceCache[globalName] = value;
        return value;
    };
    CacheUtil.clearCaches = function (cacheRoot) {
        delete cacheRoot.ownerDocument.aceCache;
        var nw = new DOMWalker_1.DOMWalker(cacheRoot, false, cacheRoot, true);
        do {
            delete nw.node.aceCache;
            nw.node.ownerDocument && delete nw.node.ownerDocument.aceCache;
        } while (nw.nextNode());
    };
    return CacheUtil;
}());
exports.CacheUtil = CacheUtil;


/***/ }),

/***/ 5965:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClipPathUtil = void 0;
var CacheUtil_1 = __webpack_require__(7788);
var CSSUtil_1 = __webpack_require__(1775);
var ClipPathUtil = /** @class */ (function () {
    function ClipPathUtil() {
    }
    /**
     * This function is responsible for checking if the node that is visually hidden by css clip-path:
     *
     * Note 1: If either current node or any of the parent nodes are visually hidden then this
     *          function will return true (node is not visually hidden).
     *
     * Note 2: nodes with CSS properties clip-path, the content is not considered hidden to an AT. Text hidden with these methods
     *      can still be reedable by screen readers.
     * Note 3: if a link, form control, or other focusable element is given this style, the element would be focusable but not visible,
     *      keyboard users might be confused.
     *
     * @parm {Node} node The node which should be checked if it is visually hidden or not.
     * @return {bool} true if the node is visually hidden, false otherwise
     *
     * @memberOf VisUtil
     */
    ClipPathUtil.isNodeVisuallyHiddenByClipPath = function (node) {
        if (!node || node.nodeType !== 1)
            return false;
        var elem = node;
        var hidden = CacheUtil_1.CacheUtil.getCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", undefined);
        if (hidden !== undefined)
            return hidden;
        var style = CSSUtil_1.CSSUtil.getComputedStyle(elem);
        var width = parseInt(style.width); //always in px
        var height = parseInt(style.height); //always in px
        var path = style['clip-path'];
        if (!path || path.trim() === 'none' || path.trim() === '') {
            CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
            return false;
        }
        path = path.trim().replace(/\s+/g, ' ').toLowerCase();
        var index = path.indexOf("inset(");
        if (index !== -1) {
            var round_index = path.indexOf("round");
            var str = path.substring(path.indexOf("(") + 1, path.indexOf(")"));
            if (round_index !== -1)
                str = path.substring(path.indexOf("(") + 1, round_index);
            var numbers = str.trim().split(" ");
            // When one value is specified, it applies the same inset to all four sides
            if (numbers.length === 1) {
                var ret = ClipPathUtil.isClippedByInset(elem, numbers[0], numbers[0], numbers[0], numbers[0]);
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", ret);
                return ret;
            }
            // When two values are specified, the first value applies to the top and bottom, the second to the left and right.
            if (numbers.length === 2) {
                var ret = ClipPathUtil.isClippedByInset(elem, numbers[0], numbers[1], numbers[0], numbers[1]);
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", ret);
                return ret;
            }
            // When three values are specified, the first applies to the top, the second to the right and left, the third to the bottom.
            if (numbers.length === 3) {
                var ret = ClipPathUtil.isClippedByInset(elem, numbers[0], numbers[1], numbers[1], numbers[2]);
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", ret);
                return ret;
            }
            // When four values are specified, the values apply to the top, right, bottom, and left in that order (clockwise).
            if (numbers.length === 4) {
                var ret = ClipPathUtil.isClippedByInset(elem, numbers[0], numbers[1], numbers[2], numbers[3]);
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", ret);
                return ret;
            }
        }
        index = path.indexOf("rect(");
        if (index !== -1) {
            var round_index = path.indexOf("round");
            var str = path.substring(path.indexOf("(") + 1, path.indexOf(")"));
            if (round_index !== -1)
                str = path.substring(path.indexOf("(") + 1, round_index);
            var numbers = str.trim().split(" ");
            /**
             * The first (top) and third (bottom) values are distances from the top edge of the containing block,
             * and the second (right) and fourth (left) values are distances from the left edge of the containing block.
             * The second (right) and third (bottom) values are clamped by the fourth (left) and first (top) values, respectively,
             *
             * If auto is used for the first (top) or fourth (left) value, the value of auto is 0,
             * and if used for the second (right) or third (bottom) value, the value of auto is 100%.
            */
            if (numbers[0] === 'auto')
                numbers[0] = '0px';
            if (numbers[3] === 'auto')
                numbers[3] = '0px';
            if (numbers[1] === 'auto')
                numbers[1] = '100%';
            if (numbers[2] === 'auto')
                numbers[2] = '100%';
            // to prevent the bottom edge from crossing over the top edge and right edge from crossing over the left edge. 
            // for example, rect(10px 0 0 20px) is clamped to rect(10px 20px 10px 20px)
            numbers[2] = Math.max(numbers[0], numbers[2]);
            numbers[1] = Math.max(numbers[1], numbers[3]);
            var top_1 = parseInt(numbers[0]);
            if (isNaN(top_1)) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            if (numbers[0].endsWith("%"))
                top_1 = top_1 * height / 100;
            else {
                var pair = CSSUtil_1.CSSUtil.getValueUnitPair(top_1);
                if (!pair) {
                    CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                    return false;
                }
                top_1 = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
            }
            if (top_1 >= height) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            var left = parseInt(numbers[3]);
            if (isNaN(left)) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            if (numbers[3].endsWith("%"))
                left = left * width / 100;
            else {
                var pair = CSSUtil_1.CSSUtil.getValueUnitPair(left);
                if (!pair) {
                    CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                    return false;
                }
                left = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
            }
            if (left >= width) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            var right = parseInt(numbers[1]);
            if (isNaN(right)) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            if (numbers[1].endsWith("%"))
                right = right * width / 100;
            else {
                var pair = CSSUtil_1.CSSUtil.getValueUnitPair(right);
                if (!pair) {
                    CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                    return false;
                }
                right = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
            }
            var bottom = parseInt(numbers[2]);
            if (isNaN(bottom)) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            if (numbers[2].endsWith("%"))
                bottom = bottom * height / 100;
            else {
                var pair = CSSUtil_1.CSSUtil.getValueUnitPair(bottom);
                if (!pair) {
                    CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                    return false;
                }
                bottom = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
            }
            if ((bottom - top_1) <= ClipPathUtil.THRESHOLD || (right - left) <= ClipPathUtil.THRESHOLD) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", true);
                return true;
            }
            CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
            return false;
        }
        index = path.indexOf("xywh(");
        if (index !== -1) {
            var round_index = path.indexOf("round");
            var str = path.substring(path.indexOf("(") + 1, path.indexOf(")"));
            if (round_index !== -1)
                str = path.substring(path.indexOf("(") + 1, round_index);
            var numbers = str.trim().split(" ");
            var x = parseInt(numbers[0]);
            if (isNaN(x)) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            if (numbers[0].endsWith("%"))
                x = x * width / 100;
            else {
                var pair = CSSUtil_1.CSSUtil.getValueUnitPair(top);
                if (!pair) {
                    CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                    return false;
                }
                x = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
            }
            if (x >= width) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            var y = parseInt(numbers[1]);
            if (isNaN(y)) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            if (numbers[1].endsWith("%"))
                y = y * height / 100;
            else {
                var pair = CSSUtil_1.CSSUtil.getValueUnitPair(y);
                if (!pair) {
                    CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                    return false;
                }
                scrollY = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
            }
            if (y >= height) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            var w = parseInt(numbers[2]);
            if (isNaN(w)) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            if (numbers[2].endsWith("%"))
                w = w * width / 100;
            else {
                var pair = CSSUtil_1.CSSUtil.getValueUnitPair(w);
                if (!pair) {
                    CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                    return false;
                }
                w = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
            }
            if (w <= ClipPathUtil.THRESHOLD) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", true);
                return true;
            }
            var h = parseInt(numbers[3]);
            if (isNaN(h)) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            if (numbers[3].endsWith("%"))
                h = h * height / 100;
            else {
                var pair = CSSUtil_1.CSSUtil.getValueUnitPair(h);
                if (!pair) {
                    CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                    return false;
                }
                h = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
            }
            if (h <= ClipPathUtil.THRESHOLD) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", true);
                return true;
            }
            CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
            return false;
        }
        index = path.indexOf("circle(");
        if (index !== -1) {
            var str = path.substring(path.indexOf("(") + 1, path.indexOf(")"));
            var numbers = str.trim().split(" ");
            var radius = parseInt(numbers[0]);
            if (isNaN(radius)) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            if (numbers[0].endsWith("%")) {
                var short = width > height ? height : width;
                radius = radius * short / 100;
            }
            else {
                var pair = CSSUtil_1.CSSUtil.getValueUnitPair(radius);
                if (!pair) {
                    CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                    return false;
                }
                radius = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
            }
            if (radius <= ClipPathUtil.THRESHOLD) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", true);
                return true;
            }
            CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
            return false;
        }
        index = path.indexOf("ellipse(");
        if (index !== -1) {
            var str = path.substring(path.indexOf("(") + 1, path.indexOf(")"));
            var numbers = str.trim().split(" ");
            // ellipse(closest-side farthest-side at 30% 40%);
            if (numbers.length > 3 && numbers[0] === 'closest-side' && numbers[1] === 'farthest-side' && numbers[2] === 'at') {
                var radius = parseInt(numbers[3]);
                if (numbers.length === 4) {
                    if (numbers[3].endsWith("%")) {
                        var value = width > height ? height : width;
                        radius = radius * value / 100;
                    }
                    else {
                        var pair = CSSUtil_1.CSSUtil.getValueUnitPair(radius);
                        if (!pair) {
                            CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                            return false;
                        }
                        radius = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
                    }
                    if (radius <= ClipPathUtil.THRESHOLD) {
                        CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", true);
                        return true;
                    }
                    CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                    return false;
                }
                else if (numbers.length === 5) {
                    for (var i = 3; i < numbers.length; i++) {
                        var radius_1 = parseInt(numbers[i]);
                        if (numbers[i].endsWith("%")) {
                            var value = (i === 3) ? width : height;
                            radius_1 = radius_1 * value / 100;
                        }
                        else {
                            var pair = CSSUtil_1.CSSUtil.getValueUnitPair(radius_1);
                            if (!pair) {
                                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                                return false;
                            }
                            radius_1 = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
                        }
                        if (radius_1 <= ClipPathUtil.THRESHOLD) {
                            CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", true);
                            return true;
                        }
                        CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                        return false;
                    }
                }
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            // ellipse(40% 50% at left);
            var at_index = path.indexOf("at");
            str = path.substring(path.indexOf("(") + 1, path.indexOf(")"));
            if (at_index !== -1)
                str = path.substring(path.indexOf("(") + 1, at_index);
            numbers = str.trim().split(" ");
            if (numbers.length !== 2) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            for (var i = 0; i < numbers.length; i++) {
                var radius = parseInt(numbers[i]);
                if (numbers[i].endsWith("%")) {
                    var value = (i === 0) ? width : height;
                    radius = radius * value / 100;
                }
                else {
                    var pair = CSSUtil_1.CSSUtil.getValueUnitPair(radius);
                    if (!pair) {
                        CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                        return false;
                    }
                    radius = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
                }
                if (radius <= ClipPathUtil.THRESHOLD) {
                    CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", true);
                    return true;
                }
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
            return false;
        }
        index = path.indexOf("polygon(");
        if (index !== -1) {
            var str = path.substring(path.indexOf("(") + 1, path.indexOf(")"));
            var numbers = str.trim().split(",");
            // polygon(nonzero|evenodd, 0% 0%, 50% 50%, 0% 100%)
            if (numbers[0] === 'nonzero' || numbers[0] === 'evenodd')
                numbers.shift();
            var y = 0;
            var x = 0;
            var changed_x = false;
            var changed_y = false;
            for (var i = 0; i < numbers.length; i++) {
                var coordinates = numbers[i].trim().split(" ");
                if (coordinates.length != 2) {
                    CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                    return false;
                }
                var coordinate_xy = [0, 0];
                for (var i_1 = 0; i_1 < 2; i_1++) {
                    var value = parseInt(coordinates[i_1]);
                    if (isNaN(value))
                        return false;
                    if (coordinates[i_1].endsWith("%"))
                        coordinate_xy[i_1] = (i_1 === 0) ? value * width / 100 : value * height / 100;
                    else {
                        var pair = CSSUtil_1.CSSUtil.getValueUnitPair(coordinates[i_1]);
                        if (!pair)
                            return false;
                        coordinate_xy[i_1] = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
                    }
                }
                if (i === 0) {
                    x = coordinate_xy[0];
                    y = coordinate_xy[1];
                }
                if (Math.abs(coordinate_xy[0] - x) >= ClipPathUtil.THRESHOLD)
                    changed_x = true;
                if (Math.abs(coordinate_xy[1] - y) >= ClipPathUtil.THRESHOLD)
                    changed_y = true;
            }
            if (changed_x && changed_y) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
                return false;
            }
            CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", true);
            return true;
        }
        CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN_CLIPPATH", false);
        return false;
    };
    ClipPathUtil.isClippedByInset = function (elem, top, right, bottom, left) {
        if (right === void 0) { right = '0px'; }
        if (bottom === void 0) { bottom = '0px'; }
        if (left === void 0) { left = '0px'; }
        var style = CSSUtil_1.CSSUtil.getComputedStyle(elem);
        var width = parseInt(style.width); //always in px
        var height = parseInt(style.height); //always in px
        // top
        var top_value = parseInt(top);
        if (isNaN(top_value))
            return false;
        if (top.endsWith("%"))
            top_value = top_value * height / 100;
        else {
            var pair = CSSUtil_1.CSSUtil.getValueUnitPair(top);
            if (!pair)
                return false;
            top_value = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
        }
        //inset outside of the container
        if (top_value > height)
            return false;
        // right
        var right_value = parseInt(right);
        if (isNaN(right_value))
            return false;
        if (right.endsWith("%"))
            right_value = right_value * width / 100;
        else {
            var pair = CSSUtil_1.CSSUtil.getValueUnitPair(right);
            if (!pair)
                return false;
            right_value = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
        }
        //inset outside of the container
        if (right_value > width)
            return false;
        // bottom
        var bottom_value = parseInt(bottom);
        if (isNaN(bottom_value))
            return false;
        if (bottom.endsWith("%"))
            bottom_value = bottom_value * height / 100;
        else {
            var pair = CSSUtil_1.CSSUtil.getValueUnitPair(bottom);
            if (!pair)
                return false;
            bottom_value = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
        }
        //inset outside of the container
        if (bottom_value > height)
            return false;
        // left
        var left_value = parseInt(left);
        if (isNaN(left_value))
            return false;
        if (left.endsWith("%"))
            left_value = left_value * width / 100;
        else {
            var pair = CSSUtil_1.CSSUtil.getValueUnitPair(left);
            if (!pair)
                return false;
            left_value = CSSUtil_1.CSSUtil.convertValue2Pixels(pair[0], pair[1], elem);
        }
        //inset outside of the container
        if (left_value > width)
            return false;
        if (height - (top_value + bottom_value) <= ClipPathUtil.THRESHOLD || width - (right_value + left_value) <= ClipPathUtil.THRESHOLD)
            return true;
        return false;
    };
    ClipPathUtil.THRESHOLD = 5; // 5px
    return ClipPathUtil;
}());
exports.ClipPathUtil = ClipPathUtil;


/***/ }),

/***/ 8680:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorObj = exports.ColorUtil = void 0;
var DOMWalker_1 = __webpack_require__(7440);
var ColorUtil = /** @class */ (function () {
    function ColorUtil() {
    }
    // Rewrite the color object to account for alpha
    ColorUtil.Color = function (cssStyleColor) {
        if (!cssStyleColor)
            return null;
        cssStyleColor = cssStyleColor.toLowerCase();
        if (cssStyleColor === "transparent")
            return new ColorObj(255, 255, 255, 0);
        if (cssStyleColor in ColorUtil.CSSColorLookup)
            cssStyleColor = ColorUtil.CSSColorLookup[cssStyleColor];
        if (cssStyleColor.startsWith("rgb(")) {
            var rgbRegex = /\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/;
            var m = cssStyleColor.match(rgbRegex);
            if (m === null)
                return null;
            else {
                return new ColorObj(m[1], m[2], m[3]);
            }
        }
        else if (cssStyleColor.startsWith("rgba(")) {
            var rgbRegex = /\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(.+)\s*\)/;
            var m = cssStyleColor.match(rgbRegex);
            if (m === null)
                return null;
            else {
                return new ColorObj(m[1], m[2], m[3], m[4]);
            }
        }
        else if (cssStyleColor.charAt(0) != "#") {
            return null;
        }
        else {
            if (cssStyleColor.length === 4) {
                // The three-digit RGB (#rgb) is converted to six-digit form (#rrggbb) by replicating digits
                // (https://www.w3.org/TR/css-color-3/#rgb-color)
                cssStyleColor = "#" + cssStyleColor.charAt(1).repeat(2) +
                    cssStyleColor.charAt(2).repeat(2) +
                    cssStyleColor.charAt(3).repeat(2);
            }
            var thisRed = parseInt(cssStyleColor.substring(1, 3), 16);
            var thisGreen = parseInt(cssStyleColor.substring(3, 5), 16);
            var thisBlue = parseInt(cssStyleColor.substring(5, 7), 16);
            return new ColorObj(thisRed, thisGreen, thisBlue);
        }
        //    return null; // Unreachable
    };
    ;
    ColorUtil.ColorCombo = function (ruleContext) {
        try {
            var doc = ruleContext.ownerDocument;
            if (!doc) {
                return null;
            }
            var win = doc.defaultView;
            if (!win) {
                return null;
            }
            var ancestors = [];
            var walkNode = ruleContext;
            while (walkNode) {
                if (walkNode.nodeType === 1)
                    ancestors.push(walkNode);
                walkNode = DOMWalker_1.DOMWalker.parentElement(walkNode);
            }
            var retVal = {
                "hasGradient": false,
                "hasBGImage": false,
                "textShadow": false,
                "fg": null,
                "bg": null
            };
            // start
            var cStyle = win.getComputedStyle(ruleContext);
            var compStyleColor = cStyle.color;
            if (!compStyleColor)
                compStyleColor = "black";
            var fg = ColorUtil.Color(compStyleColor);
            var reColor = /transparent|rgba?\([^)]+\)/gi;
            var guessGradColor = function (gradList, bgColor, fgColor) {
                try {
                    // If there's only one color, return that
                    if (typeof gradList.length === "undefined")
                        return gradList;
                    var overallWorst = null;
                    var overallWorstRatio = null;
                    for (var iGrad = 1; iGrad < gradList.length; ++iGrad) {
                        var worstColor = gradList[iGrad - 1];
                        var worstRatio = fgColor.contrastRatio(gradList[iGrad - 1]);
                        var step = .1;
                        var idx = 0;
                        while (step > .0001) {
                            while (idx + step <= 1 && worstRatio > fgColor.contrastRatio(gradList[iGrad].mix(gradList[iGrad - 1], idx + step).getOverlayColor(bgColor))) {
                                worstColor = gradList[iGrad].mix(gradList[iGrad - 1], idx + step).getOverlayColor(bgColor);
                                worstRatio = fgColor.contrastRatio(worstColor);
                                idx = idx + step;
                            }
                            while (idx - step >= 0 && worstRatio > fgColor.contrastRatio(gradList[iGrad].mix(gradList[iGrad - 1], idx - step).getOverlayColor(bgColor))) {
                                worstColor = gradList[iGrad].mix(gradList[iGrad - 1], idx - step).getOverlayColor(bgColor);
                                worstRatio = fgColor.contrastRatio(worstColor);
                                idx = idx - step;
                            }
                            step = step / 10;
                        }
                        if (overallWorstRatio === null || overallWorstRatio > worstRatio) {
                            overallWorstRatio = worstRatio;
                            overallWorst = worstColor;
                        }
                    }
                    return overallWorst; // return the darkest color
                }
                catch (e) {
                    console.log(e);
                }
                return bgColor;
            };
            var priorStackBG = ColorUtil.Color("white");
            var thisStackOpacity = null;
            var thisStackAlpha = null;
            var thisStackBG = null;
            // Ancestors processed from the topmost parent toward the child
            while (ancestors.length > 0) {
                var procNext = ancestors.pop();
                //var procNext = ancestors.splice(0, 1)[0];
                // cStyle is the computed style of this layer
                var cStyle = win.getComputedStyle(procNext);
                if (cStyle === null)
                    continue;
                // thisBgColor is the color of this layer or null if the layer is transparent
                var thisBgColor = null;
                if (cStyle.backgroundColor && cStyle.backgroundColor != "transparent" && cStyle.backgroundColor != "rgba(0, 0, 0, 0)") {
                    thisBgColor = ColorUtil.Color(cStyle.backgroundColor);
                }
                // If there is a gradient involved, set thisBgColor to the worst color combination available against the foreground
                if (cStyle.backgroundImage && cStyle.backgroundImage.indexOf && cStyle.backgroundImage.indexOf("gradient") != -1) {
                    var gradColors = cStyle.backgroundImage.match(reColor);
                    if (gradColors) {
                        var gradColorComp = [];
                        for (var i = 0; i < gradColors.length; ++i) {
                            if (!gradColors[i].length) {
                                gradColors.splice(i--, 1);
                            }
                            else {
                                var colorComp = ColorUtil.Color(gradColors[i]);
                                if (colorComp.alpha !== undefined && colorComp.alpha < 1) {
                                    // mix the grdient bg color wit parent bg if alpha < 1
                                    var compStackBg = thisStackBG || priorStackBG;
                                    colorComp = colorComp.getOverlayColor(compStackBg);
                                }
                                gradColorComp.push(colorComp);
                            }
                        }
                        thisBgColor = guessGradColor(gradColorComp, thisStackBG || priorStackBG, fg);
                    }
                }
                // Handle non-solid opacity
                if (thisStackOpacity === null || (cStyle.opacity && cStyle.opacity.length > 0 && parseFloat(cStyle.opacity) < 1)) {
                    // New stack, reset
                    if (thisStackBG != null) {
                        // Overlay
                        thisStackBG.alpha = thisStackOpacity * thisStackAlpha;
                        priorStackBG = thisStackBG.getOverlayColor(priorStackBG);
                    }
                    thisStackOpacity = 1.0;
                    thisStackAlpha = null;
                    thisStackBG = null;
                    if (cStyle.opacity && cStyle.opacity.length > 0) {
                        thisStackOpacity = parseFloat(cStyle.opacity);
                    }
                    if (thisBgColor != null) {
                        thisStackBG = thisBgColor;
                        thisStackAlpha = thisStackBG.alpha || 1.0;
                        delete thisStackBG.alpha;
                        if (thisStackOpacity === 1.0 && thisStackAlpha === 1.0) {
                            retVal.hasBGImage = false;
                            retVal.hasGradient = false;
                        }
                    }
                }
                // Handle solid color backgrounds and gradient color backgrounds
                else if (thisBgColor != null) {
                    // If this stack already has a background color, blend it
                    if (thisStackBG === null) {
                        thisStackBG = thisBgColor;
                        thisStackAlpha = thisStackBG.alpha || 1.0;
                        delete thisStackBG.alpha;
                    }
                    else {
                        thisStackBG = thisBgColor.getOverlayColor(thisStackBG);
                        //thisStackAlpha = thisBgColor.alpha || 1.0;
                        thisStackAlpha = thisStackBG.alpha || 1.0;
                    }
                    // #526: If thisBgColor had an alpha value, it may not expose through thisStackBG in the above code
                    // We can't wipe out the gradient info if this layer was transparent
                    if (thisStackOpacity === 1.0 && thisStackAlpha === 1.0 && (thisStackBG.alpha || 1.0) === 1.0 && (thisBgColor.alpha || 1.0) === 0) {}
                }
                if (cStyle.backgroundImage && cStyle.backgroundImage != "none") {
                    if (cStyle.backgroundImage.indexOf && cStyle.backgroundImage.indexOf("gradient") != -1) {
                        retVal.hasGradient = true;
                    }
                    else {
                        retVal.hasBGImage = true;
                    }
                }
            }
            if (thisStackBG != null) {
                fg = fg.getOverlayColor(thisStackBG);
                delete fg.alpha;
            }
            fg.alpha = (fg.alpha || 1) * thisStackOpacity;
            fg = fg.getOverlayColor(priorStackBG);
            if (thisStackBG != null) {
                thisStackBG.alpha = thisStackOpacity * thisStackAlpha;
                priorStackBG = thisStackBG.getOverlayColor(priorStackBG);
            }
            retVal.fg = fg;
            retVal.bg = priorStackBG;
            if (cStyle.textShadow && cStyle.textShadow !== 'none')
                retVal.textShadow = true;
            return retVal;
        }
        catch (err) {
            // something happened, then...
            return null;
        }
    };
    ;
    ColorUtil.CSSColorLookup = {
        "aliceblue": "#f0f8ff",
        "antiquewhite": "#faebd7",
        "aqua": "#00ffff",
        "aquamarine": "#7fffd4",
        "azure": "#f0ffff",
        "beige": "#f5f5dc",
        "bisque": "#ffe4c4",
        "black": "#000000",
        "blanchedalmond": "#ffebcd",
        "blue": "#0000ff",
        "blueviolet": "#8a2be2",
        "brown": "#a52a2a",
        "burlywood": "#deb887",
        "cadetblue": "#5f9ea0",
        "chartreuse": "#7fff00",
        "chocolate": "#d2691e",
        "coral": "#ff7f50",
        "cornflowerblue": "#6495ed",
        "cornsilk": "#fff8dc",
        "crimson": "#dc143c",
        "cyan": "#00ffff",
        "darkblue": "#00008b",
        "darkcyan": "#008b8b",
        "darkgoldenrod": "#b8860b",
        "darkgray": "#a9a9a9",
        "darkgreen": "#006400",
        "darkkhaki": "#bdb76b",
        "darkmagenta": "#8b008b",
        "darkolivegreen": "#556b2f",
        "darkorange": "#ff8c00",
        "darkorchid": "#9932cc",
        "darkred": "#8b0000",
        "darksalmon": "#e9967a",
        "darkseagreen": "#8fbc8f",
        "darkslateblue": "#483d8b",
        "darkslategray": "#2f4f4f",
        "darkturquoise": "#00ced1",
        "darkviolet": "#9400d3",
        "deeppink": "#ff1493",
        "deepskyblue": "#00bfff",
        "dimgray": "#696969",
        "dodgerblue": "#1e90ff",
        "firebrick": "#b22222",
        "floralwhite": "#fffaf0",
        "forestgreen": "#228b22",
        "fuchsia": "#ff00ff",
        "gainsboro": "#dcdcdc",
        "ghostwhite": "#f8f8ff",
        "gold": "#ffd700",
        "goldenrod": "#daa520",
        "gray": "#808080",
        "green": "#008000",
        "greenyellow": "#adff2f",
        "honeydew": "#f0fff0",
        "hotpink": "#ff69b4",
        "indianred": "#cd5c5c",
        "indigo": "#4b0082",
        "ivory": "#fffff0",
        "khaki": "#f0e68c",
        "lavender": "#e6e6fa",
        "lavenderblush": "#fff0f5",
        "lawngreen": "#7cfc00",
        "lemonchiffon": "#fffacd",
        "lightblue": "#add8e6",
        "lightcoral": "#f08080",
        "lightcyan": "#e0ffff",
        "lightgoldenrodyellow": "#fafad2",
        "lightgrey": "#d3d3d3",
        "lightgreen": "#90ee90",
        "lightpink": "#ffb6c1",
        "lightsalmon": "#ffa07a",
        "lightseagreen": "#20b2aa",
        "lightskyblue": "#87cefa",
        "lightslategray": "#778899",
        "lightsteelblue": "#b0c4de",
        "lightyellow": "#ffffe0",
        "lime": "#00ff00",
        "limegreen": "#32cd32",
        "linen": "#faf0e6",
        "magenta": "#ff00ff",
        "maroon": "#800000",
        "mediumaquamarine": "#66cdaa",
        "mediumblue": "#0000cd",
        "mediumorchid": "#ba55d3",
        "mediumpurple": "#9370d8",
        "mediumseagreen": "#3cb371",
        "mediumslateblue": "#7b68ee",
        "mediumspringgreen": "#00fa9a",
        "mediumturquoise": "#48d1cc",
        "mediumvioletred": "#c71585",
        "midnightblue": "#191970",
        "mintcream": "#f5fffa",
        "mistyrose": "#ffe4e1",
        "moccasin": "#ffe4b5",
        "navajowhite": "#ffdead",
        "navy": "#000080",
        "oldlace": "#fdf5e6",
        "olive": "#808000",
        "olivedrab": "#6b8e23",
        "orange": "#ffa500",
        "orangered": "#ff4500",
        "orchid": "#da70d6",
        "palegoldenrod": "#eee8aa",
        "palegreen": "#98fb98",
        "paleturquoise": "#afeeee",
        "palevioletred": "#d87093",
        "papayawhip": "#ffefd5",
        "peachpuff": "#ffdab9",
        "peru": "#cd853f",
        "pink": "#ffc0cb",
        "plum": "#dda0dd",
        "powderblue": "#b0e0e6",
        "purple": "#800080",
        "red": "#ff0000",
        "rosybrown": "#bc8f8f",
        "royalblue": "#4169e1",
        "saddlebrown": "#8b4513",
        "salmon": "#fa8072",
        "sandybrown": "#f4a460",
        "seagreen": "#2e8b57",
        "seashell": "#fff5ee",
        "sienna": "#a0522d",
        "silver": "#c0c0c0",
        "skyblue": "#87ceeb",
        "slateblue": "#6a5acd",
        "slategray": "#708090",
        "snow": "#fffafa",
        "springgreen": "#00ff7f",
        "steelblue": "#4682b4",
        "tan": "#d2b48c",
        "teal": "#008080",
        "thistle": "#d8bfd8",
        "tomato": "#ff6347",
        "turquoise": "#40e0d0",
        "violet": "#ee82ee",
        "wheat": "#f5deb3",
        "white": "#ffffff",
        "whitesmoke": "#f5f5f5",
        "yellow": "#ffff00",
        "yellowgreen": "#9acd32",
        "buttontext": "rgba(0, 0, 0, 0.847)",
        "buttonface": "#ffffff",
        "graytext": "rgba(0, 0, 0, 0.247)"
    };
    return ColorUtil;
}());
exports.ColorUtil = ColorUtil;
var ColorObj = /** @class */ (function () {
    function ColorObj(red, green, blue, alpha) {
        function fixComponent(comp) {
            if (typeof (comp) != typeof (""))
                return comp;
            var compStr = comp;
            compStr = compStr.trim();
            if (compStr[compStr.length - 1] != "%")
                return parseInt(compStr);
            return Math.round(parseFloat(compStr.substring(0, compStr.length - 1)) * 2.55);
        }
        this.red = fixComponent(red);
        this.green = fixComponent(green);
        this.blue = fixComponent(blue);
        if (typeof (alpha) != "undefined") {
            this.alpha = (typeof (alpha) === typeof ("")) ? parseFloat(alpha) : alpha;
        }
    }
    ColorObj.prototype.toHexHelp = function (value) {
        var retVal = Math.round(value).toString(16);
        if (retVal.length === 1)
            return "0" + retVal;
        return retVal;
    };
    ;
    ColorObj.prototype.toHex = function () {
        return "#" + this.toHexHelp(this.red) + this.toHexHelp(this.green) + this.toHexHelp(this.blue);
    };
    ;
    ColorObj.prototype.contrastRatio = function (bgColor) {
        var fgColor = this;
        if (typeof (this.alpha) != "undefined")
            fgColor = this.getOverlayColor(bgColor);
        var lum1 = fgColor.relativeLuminance();
        if (!bgColor.relativeLuminance) {
            var s = "";
            for (var key in bgColor) {
                s += key + "\n";
            }
            alert(bgColor);
            alert(s);
        }
        var lum2 = bgColor.relativeLuminance();
        var ratio = (lum1 > lum2) ? (lum1 + .05) / (lum2 + .05) : (lum2 + .05) / (lum1 + .05);
        return ratio;
    };
    ;
    ColorObj.prototype.relativeLuminance = function () {
        var R = this.red / 255.0;
        var G = this.green / 255.0;
        var B = this.blue / 255.0;
        R = R <= .04045 ? R / 12.92 : Math.pow((R + .055) / 1.055, 2.4);
        G = G <= .04045 ? G / 12.92 : Math.pow((G + .055) / 1.055, 2.4);
        B = B <= .04045 ? B / 12.92 : Math.pow((B + .055) / 1.055, 2.4);
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    };
    ;
    ColorObj.prototype.mix = function (color2, percThis) {
        if (typeof (this.alpha) === "undefined" && typeof (color2.alpha) === "undefined") {
            return new ColorObj(percThis * this.red + (1 - percThis) * color2.red, percThis * this.green + (1 - percThis) * color2.green, percThis * this.blue + (1 - percThis) * color2.blue);
        }
        else {
            var alphaThis = this.alpha ? this.alpha : 1;
            var alphaOther = color2.alpha ? color2.alpha : 1;
            return new ColorObj(percThis * this.red + (1 - percThis) * color2.red, percThis * this.green + (1 - percThis) * color2.green, percThis * this.blue + (1 - percThis) * color2.blue, percThis * alphaThis + (1 - percThis) * alphaOther);
        }
    };
    ;
    ColorObj.prototype.getOverlayColor = function (bgColor) {
        if (typeof (this.alpha) === "undefined" || this.alpha >= 1) {
            // No mixing required - it's opaque
            return this;
        }
        if (this.alpha < 0) {
            //		Haac.Error.logError("Invalid alpha value");
            return null;
        }
        if (typeof (bgColor.alpha) != "undefined" && bgColor.alpha < 1) {
            //		Haac.Error.logError("Cannot mix with a background alpha");
            return null;
        }
        var retVal = this.mix(bgColor, this.alpha);
        delete retVal.alpha;
        return retVal;
    };
    ColorObj.fromCSSColor = function (cssStyleColor) {
        var thisRed = -1;
        var thisGreen = -1;
        var thisBlue = -1;
        cssStyleColor = cssStyleColor.toLowerCase();
        if (cssStyleColor.startsWith("rgb(")) {
            var rgbRegex = /\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/;
            var m = cssStyleColor.match(rgbRegex);
            if (m === null)
                return null;
            else {
                thisRed = m[1];
                thisGreen = m[2];
                thisBlue = m[3];
            }
        }
        else if (cssStyleColor.startsWith("rgba(")) {
            var rgbRegex = /\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(.+)\s*\)/;
            var m = cssStyleColor.match(rgbRegex);
            if (m === null)
                return null;
            else {
                thisRed = m[1];
                thisGreen = m[2];
                thisBlue = m[3];
            }
        }
        else {
            if (cssStyleColor.charAt(0) != "#") {
                if (cssStyleColor in ColorUtil.CSSColorLookup)
                    cssStyleColor = ColorUtil.CSSColorLookup[cssStyleColor];
                else
                    return null;
            }
            var fromHex = function (val) {
                var lookup = {
                    "a": 10,
                    "b": 11,
                    "c": 12,
                    "d": 13,
                    "e": 14,
                    "f": 15
                };
                var retVal = 0;
                for (var i = 0; i < val.length; ++i) {
                    retVal = retVal * 16 +
                        parseInt(val.charAt(i) in lookup ? lookup[val.charAt(i)] : val.charAt(i));
                }
                return retVal;
            };
            if (cssStyleColor.length === 4) {
                // The three-digit RGB (#rgb) is converted to six-digit form (#rrggbb) by replicating digits
                // (https://www.w3.org/TR/css-color-3/#rgb-color)
                cssStyleColor = "#" + cssStyleColor.charAt(1).repeat(2) +
                    cssStyleColor.charAt(2).repeat(2) +
                    cssStyleColor.charAt(3).repeat(2);
            }
            thisRed = fromHex(cssStyleColor.substring(1, 3));
            thisGreen = fromHex(cssStyleColor.substring(3, 5));
            thisBlue = fromHex(cssStyleColor.substring(5, 7));
        }
        return new ColorObj(thisRed, thisGreen, thisBlue);
    };
    return ColorObj;
}());
exports.ColorObj = ColorObj;


/***/ }),

/***/ 8137:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonUtil = void 0;
var ARIADefinitions_1 = __webpack_require__(8235);
var CacheUtil_1 = __webpack_require__(7788);
var AriaUtil_1 = __webpack_require__(490);
var AccNameUtil_1 = __webpack_require__(1421);
var VisUtil_1 = __webpack_require__(8656);
var DOMUtil_1 = __webpack_require__(295);
var DOMWalker_1 = __webpack_require__(7440);
var fragment_1 = __webpack_require__(482);
var CommonUtil = /** @class */ (function () {
    function CommonUtil() {
    }
    CommonUtil.wordCount = function (str) {
        str = str.trim();
        if (str.length === 0)
            return 0;
        return str.split(/\s+/g).length;
    };
    /**
     * Note that this only detects if the element itself is in the tab order.
     * However, this element may delegate focus to another element via aria-activedescendant.
     * Also, focus varies by browser... sticking to things that are focusable on Chrome and Firefox.
     */
    CommonUtil.isTabbable = function (element) {
        // Using https://allyjs.io/data-tables/focusable.html
        // Handle the explicit cases first
        if (!VisUtil_1.VisUtil.isNodeVisible(element))
            return false;
        if (element.hasAttribute("tabindex")) {
            return parseInt(element.getAttribute("tabindex")) >= 0;
        }
        // Explicit cases handled - now the implicit
        var nodeName = element.nodeName.toLowerCase();
        if (nodeName in CommonUtil.tabTagMap) {
            var retVal = CommonUtil.tabTagMap[nodeName];
            if (typeof (retVal) === "function") {
                retVal = retVal(element);
            }
            return retVal;
        }
        else {
            if (element.hasAttribute("contenteditable"))
                return true;
            return false;
        }
    };
    /**
     * Test if the ele node is focusable
     */
    CommonUtil.isFocusable = function (ele) {
        if (ele === "undefined" || ele === null) {
            return false;
        }
        return CommonUtil.isTabbable(ele);
    };
    /**
     * Note that this only detects if the element itself is interactive, but not onclick event.
     */
    CommonUtil.isClickable = function (element) {
        if (!VisUtil_1.VisUtil.isNodeVisible(element))
            return false;
        // native focusable element
        var nodeName = element.nodeName.toLowerCase();
        if (nodeName in CommonUtil.tabTagMap) {
            var retVal = CommonUtil.tabTagMap[nodeName];
            if (typeof (retVal) === "function") {
                retVal = retVal(element);
            }
            return retVal;
        }
        else {
            //custom widget
            if (AriaUtil_1.AriaUtil.isWidget(element) && element.hasAttribute("tabindex")) {
                return true;
            }
        }
        return false;
    };
    /*
     * get conflict Aria and Html attributes
     * return: a list of Aria and Html attribute pairs that are conflict
    */
    CommonUtil.isTableDescendant = function (contextHierarchies) {
        if (!contextHierarchies)
            return null;
        return contextHierarchies["aria"].filter(function (hier) { return ["table", "grid", "treegrid"].includes(hier.role); });
    };
    CommonUtil.tabIndexLEZero = function (elem) {
        if (CommonUtil.hasAttribute(elem, "tabindex")) {
            if (elem.getAttribute("tabindex").match(/^-?\d+$/)) {
                var tabindexValue = parseInt(elem.getAttribute("tabindex"));
                return tabindexValue === 0 || tabindexValue === -1;
            }
        }
        return false;
    };
    /**
     * get number of tabbable children
     * @param element
     */
    CommonUtil.getTabbableChildren = function (element) {
        var count = 0;
        // If node has children, look for tab stops in the children
        if (element.firstChild || element.nodeName.toUpperCase() === "IFRAME") {
            var nw = new DOMWalker_1.DOMWalker(element);
            while (nw.nextNode() && nw.node != element) {
                if (nw.node.nodeType == 1 && !nw.bEndTag && CommonUtil.isTabbable(nw.node)) {
                    ++count;
                }
            }
        }
        return count;
    };
    CommonUtil.normalizeSpacing = function (s) {
        if (!s)
            return '';
        return s.trim().replace(/\s+/g, ' ');
    };
    ;
    //TODO: function does not handle equivalents for roles: row, link, header, button
    // But it may not have to. Bug reports have been about radio buttons and checkboxes.
    CommonUtil.isHtmlEquiv = function (node, htmlEquiv) {
        var retVal = false;
        if (node) {
            var nodeName = node.nodeName.toLowerCase();
            if (nodeName === "input") {
                var type = node.getAttribute("type").toLowerCase();
                if (type) {
                    if (htmlEquiv.indexOf("checkbox") != -1) {
                        retVal = type === "checkbox";
                    }
                    else if (htmlEquiv.indexOf("radio") != -1) {
                        retVal = type === "radio";
                    }
                }
            }
        }
        return retVal;
    };
    CommonUtil.nonExistantIDs = function (node, targetids) {
        var returnnotfoundids = '';
        if (CommonUtil.normalizeSpacing(targetids).length < 1)
            return returnnotfoundids;
        var targetArray = targetids.split(" ");
        var doc = node.ownerDocument;
        for (var i = 0; i < targetArray.length; i++) {
            var xp = "//*[@id='" + targetArray[i] + "']";
            var xpathResult = doc.evaluate(xp, node, doc.defaultNSResolver, 0 /* XPathResult.ANY_TYPE */, null);
            var r = xpathResult.iterateNext();
            if (!r)
                returnnotfoundids += targetArray[i] + ', ';
        }
        if (CommonUtil.normalizeSpacing(returnnotfoundids).length >= 2)
            returnnotfoundids = returnnotfoundids.substring(0, returnnotfoundids.length - 2);
        else
            returnnotfoundids = '';
        return returnnotfoundids;
    };
    CommonUtil.getDocElementsByTag = function (elem, tagName) {
        var doc = fragment_1.FragmentUtil.getOwnerFragment(elem);
        tagName = tagName.toLowerCase();
        var cache = CacheUtil_1.CacheUtil.getCache(doc, "RPT_DOCELEMSBYTAG", {});
        if (!(tagName in cache)) {
            cache[tagName] = doc.querySelectorAll(tagName);
            CacheUtil_1.CacheUtil.setCache(doc, "RPT_DOCELEMSBYTAG", cache);
        }
        return cache[tagName];
    };
    /**
     * This function is responsible for get a list of all the child elemnts which match the tag
     * name provided.
     *
     * Note: This is a wrapper function to: AriaUtil.getChildByTagHidden
     *
     * @parm {element} parentElem - The parent element
     * @parm {string} tagName - The tag to search for under the parent element
     * @parm {boolean} ignoreHidden - true if hidden elements with the tag should ignored from the list
     *                                false if the hidden elements should be added
     *
     * @return {List} retVal - list of all the elements which matched the tag under the parent that were provided.
     *
     * @memberOf AriaUtil
     */
    CommonUtil.getChildByTag = function (parentElem, tagName) {
        return CommonUtil.getChildByTagHidden(parentElem, tagName, false, false);
    };
    /**
     * This function is responsible for get a list of all the child elemnts which match the tag
     * name provided.
     *
     * @parm {element} parentElem - The parent element
     * @parm {string} tagName - The tag to search for under the parent element
     * @parm {boolean} ignoreHidden - true if hidden elements with the tag should ignored from the list
     *                                false if the hidden elements should be added
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     *
     * @return {List} retVal - list of all the elements which matched the tag under the parent that were provided.
     *
     * @memberOf AriaUtil
     */
    CommonUtil.getChildByTagHidden = function (parentElem, tagName, ignoreHidden, considerHiddenSetting) {
        // Variable Decleration
        var retVal = [];
        var child = parentElem.firstChild;
        // Loop over all the child elements of the parent to build a list of all the elements that
        // match the tagName provided
        while (child != null) {
            // Only include the children into the return array if they match with tagname.
            if (child.nodeName.toLowerCase() === tagName) {
                // In the case that ignorehidden was set to true, then perform a isNodeVisible check
                // and in the case the node is not visilble we more to theses then move to the next node.
                // Perform a couple of checks to determine if hidden elements should be ignored or not.
                //  1. When ignoreHidden is set to true upfront, then perform a isNodeVisible
                //  2. If considerHiddenSetting option is set to true then we perform the check to consider the
                //     Check Hidden Content that is provided.
                //  2.1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                //       be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                //       add it to the roleToElems hash at all or even do any checking for it at all.
                if ((ignoreHidden || (considerHiddenSetting && !CommonUtil.shouldCheckHiddenContent(child))) && !VisUtil_1.VisUtil.isNodeVisible(child)) {
                    // Move on to the next element
                    child = child.nextSibling;
                    continue;
                }
                // Push the element
                retVal.push(child);
            }
            // Move to the next sibling element
            child = child.nextSibling;
        }
        return retVal;
    };
    /**
         * This function is responsible for finding a list of elements that match given roles(s).
         * This function by defauly will not consider Check Hidden Setting at all.
         * This function by defauly will not consider implicit roles.
         * Note: This is a wrapper function to: AriaUtil.getElementsByRoleHidden
         *
         * @parm {document} doc - The document node
         * @parm {list or string} roles - List or single role for which to return elements based on.
         *
         * @return {List} retVal - list of all the elements which matched the role(s) that were provided.
         *
         * @memberOf AriaUtil
         */
    CommonUtil.getElementsByRole = function (doc, roles) {
        return CommonUtil.getElementsByRoleHidden(doc, roles, false, false);
    };
    /**
     * This function is responsible for finding a list of elements that match given roles(s).
     * This function aslo finds elements with implicit roles.
     * This function will also consider elements that are hidden based on the if the Check
     * Hidden Content settings should be considered or not.
     *
     * @parm {document} doc - The document node
     * @parm {list or string} roles - List or single role for which to return elements based on.
     * @parm {bool} considerHiddenSetting - true or false based on if hidden setting should be considered.
     * @parm {bool} considerImplicitRoles - true or false based on if implicit roles setting should be considered.
     *
     * @return {List} retVal - list of all the elements which matched the role(s) that were provided.
     *
     * @memberOf AriaUtil
     */
    CommonUtil.getElementsByRoleHidden = function (doc, roles, considerHiddenSetting, considerImplicitRoles) {
        // In the case that the role to element assoication is already made, and available in the global hasAttribute
        // we can just use that one instead of building a new one.
        var roleToElems = null;
        if (considerImplicitRoles) {
            roleToElems = CacheUtil_1.CacheUtil.getCache(doc, "AriaUtil_GETELEMENTSBY_ROLE_IMPLICIT", null);
        }
        else {
            roleToElems = CacheUtil_1.CacheUtil.getCache(doc, "AriaUtil_GETELEMENTSBY_ROLE", null);
        }
        // Build the new role to element, this is where we loop through all the elements and extract all the
        // elements bsaed on roles.
        if (roleToElems === null) {
            // Re-initialize the roleToElems hash
            roleToElems = {};
            // Get the body of the doc
            var root = doc.body;
            // Keep looping until we are at the very parent node of the entire page, so that we can loop through
            // all the nodes.
            while (DOMWalker_1.DOMWalker.parentNode(root) !== null) {
                // Get the parentNode
                root = DOMWalker_1.DOMWalker.parentNode(root);
            }
            // Build a nodewalter based of the root node, this node walter will be use loop over all the nodes
            // and build the roles to Element coralation
            //let nw = new NodeWalker(root);
            var nw = new DOMWalker_1.DOMWalker(root);
            // Loop over the entire doc/list of nodes to build the role to element map
            // Note: This will build an roleToElems hash which is in the following format.
            // roleToElems = {
            //    document: [{div},{abbr},{var}],
            //    main: [{div}],
            //    navigation: [{div}]
            // }
            while (nw.nextNode()) {
                if (!nw.elem())
                    continue;
                // Only check the elements which have the role attribute assiciated to them
                if (!nw.bEndTag) {
                    var wRoles = [];
                    //check if the node has role attributes
                    if (nw.elem() && nw.elem().hasAttribute("role")) {
                        // Extract all the roles that are assigned to this element, can have multiple roles on one
                        // element split by space, so we need to extract all of them into an array.
                        wRoles = nw.elem().getAttribute("role").split(" ");
                    }
                    if (nw.elem() && wRoles.length === 0 && considerImplicitRoles) {
                        //check if there are any implicit roles for this element.
                        var implicitRole = AriaUtil_1.AriaUtil.getImplicitRole(nw.node);
                        if (implicitRole !== null && implicitRole.length > 0)
                            wRoles = implicitRole;
                    }
                    if (wRoles.length === 0) {
                        continue;
                    }
                    // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
                    // or not.
                    //  1. If considerHiddenSetting option is set to true then we perform the check to consider the
                    //     Check Hidden Content that is provided.
                    //  2. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
                    //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we do not
                    //     add it to the roleToElems hash at all or even do any checking for it at all.
                    //
                    // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
                    //       so on and so forth.
                    if (considerHiddenSetting && CommonUtil.shouldNodeBeSkippedHidden(nw.node)) {
                        continue;
                    }
                    // Loop through all the roles and assigned this node to all thes roles
                    for (var i = 0; i < wRoles.length; ++i) {
                        // In the case that the role key is not already in the roleToElems hash, construct the
                        // add the key and assign empty array.
                        if (!(wRoles[i] in roleToElems)) {
                            roleToElems[wRoles[i]] = [];
                        }
                        // Add the node to the array for the role
                        roleToElems[wRoles[i]].push(nw.node);
                    }
                }
            }
            // Set the roleToElems hash map as a global variable
            if (considerImplicitRoles) {
                CacheUtil_1.CacheUtil.setCache(doc, "AriaUtil_GETELEMENTSBY_ROLE_IMPLICIT", roleToElems);
            }
            else {
                CacheUtil_1.CacheUtil.setCache(doc, "AriaUtil_GETELEMENTSBY_ROLE", roleToElems);
            }
        }
        // Initilize the return value
        var retVal = [];
        // Handle the cases where the provided role is a string and not an array,
        // for this case we take the string and put it into an array
        if (typeof (roles) === "string") {
            var role = roles;
            roles = [];
            roles.push(role);
        }
        // Loop through the roles that were provided and find the list of elements for this roles
        // and add them to the return value.
        if (roles.length) {
            // loop over all the roles
            for (var i = 0; i < roles.length; ++i) {
                // Extract the role from the array
                var nextRole = roles[i];
                // Fetch the list of all the elements for this role
                var copyRoles = roleToElems[nextRole];
                // If there are elements to copy to another array, then perform the copy
                if (copyRoles) {
                    // Loop over all the elements which are to be copied
                    for (var j = 0; j < copyRoles.length; ++j) {
                        // Add this element to the return val
                        retVal.push(copyRoles[j]);
                    }
                }
            }
        }
        return retVal;
    };
    /**
         * a target is en element that accept a pointer action (click or touch)
         *
         */
    CommonUtil.isTarget = function (element) {
        if (!element || element.nodeType !== 1
            || ["html", "body"].includes(element.nodeName.toLowerCase())
            || CommonUtil.getAncestor(element, ["svg", "pre", "code", "script", "meta", 'head']) !== null
            || !VisUtil_1.VisUtil.isNodeVisible(element) || VisUtil_1.VisUtil.isNodeVisuallyHidden(element)
            || CommonUtil.isNodeDisabled(element) || VisUtil_1.VisUtil.isElementOffscreen(element))
            return false;
        if (CommonUtil.isClickable(element))
            return true;
        var role = AriaUtil_1.AriaUtil.getResolvedRole(element);
        if (!role)
            return false;
        var target_roles = ["listitem", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "switch", "treeitem"];
        if (target_roles.includes(role)) {
            // find the proper parent elements
            var parent_1 = element.parentElement;
            if (parent_1) {
                var parent_role = AriaUtil_1.AriaUtil.getResolvedRole(parent_1);
                // datalist, fieldset, optgroup, etc. may be just used for grouping purpose, so go up to the parent
                if (parent_role === 'group')
                    parent_1 = parent_1.parentElement;
            }
            if (parent_1 && CommonUtil.isTarget(parent_1))
                return true;
        }
        return false;
    };
    CommonUtil.getFileExt = function (url) {
        var m = url.match(/\.(([^;?#\.]|^$)+)([;?#]|$)/);
        if (m != null && m.length >= 2) {
            return "." + m[1];
        }
        return "";
    };
    CommonUtil.getFileAnchor = function (url) {
        var m = url.match(/#(([^;?\.]|^$)+)([;?]|$)/);
        if (m != null && m.length >= 2) {
            return m[1];
        }
        return "";
    };
    CommonUtil.checkObjEmbed = function (node, extTest, mimeTest) {
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName != "object" && nodeName != "embed" &&
            nodeName != "a" && nodeName != "area")
            return false;
        var retVal = false;
        // Check mime type
        if (!retVal && node.hasAttribute("type")) {
            var mime = node.getAttribute("type").toLowerCase();
            retVal = mimeTest(mime);
        }
        if (!retVal && node.hasAttribute("codetype")) {
            var mime = node.getAttribute("codetype");
            retVal = mimeTest(mime);
        }
        // Check the filename
        if (!retVal) {
            var filename = "";
            if (nodeName === "embed") {
                filename = node.getAttribute("src");
            }
            else if (nodeName === "a" || nodeName === "area") {
                filename = node.getAttribute("href");
            }
            else if (node.hasAttribute("data")) {
                filename = node.getAttribute("data");
            }
            if (filename === null)
                filename = "";
            var ext = CommonUtil.getFileExt(filename);
            retVal = extTest(ext);
        }
        // Check for filenames in the params
        if (!retVal && nodeName === "object") {
            // In the case that Check Hidden Option is set then comply with that setting
            var params = CommonUtil.getChildByTagHidden(node, "param", false, true);
            for (var i = 0; !retVal && params != null && i < params.length; ++i) {
                retVal = params[i].hasAttribute("value") &&
                    extTest(CommonUtil.getFileExt(params[i].getAttribute("value")));
            }
        }
        return retVal;
    };
    CommonUtil.isAudioObjEmbedLink = function (node) {
        return CommonUtil.checkObjEmbed(node, CommonUtil.isAudioExt, function (mime) {
            return mime.startsWith("audio");
        });
    };
    CommonUtil.isAudioExt = function (ext) {
        var audio_extensions = [".aif", ".aifc", ".aiff", ".air", ".asf", ".au", ".cda",
            ".dsm", ".dss", ".dwd", ".iff", ".kar", ".m1a", ".med",
            ".mp2", ".mp3", ".mpa", ".pcm", ".ra", ".ram", ".rm",
            ".sam", ".sf", ".sf2", ".smp", ".snd", ".svx", ".ul",
            ".voc", ".wav", ".wma", ".wve"
        ];
        return CommonUtil.valInArray(ext.toLowerCase(), audio_extensions);
    };
    CommonUtil.isVideoObjEmbedLink = function (node) {
        return CommonUtil.checkObjEmbed(node, CommonUtil.isVideoExt, function (mime) {
            return mime.startsWith("video") ||
                mime.startsWith("application/x-shockwave-flash");
        });
    };
    CommonUtil.isVideoExt = function (ext) {
        var video_extensions = [".asf", ".avi", ".divx", ".dv", ".m1v", ".m2p", ".m2v", ".moov",
            ".mov", ".mp4", ".mpeg", ".mpg", ".mpv", ".ogm", ".omf", ".qt",
            ".rm", ".rv", ".smi", ".smil", ".swf", ".vob", ".wmv", ".rmvb",
            ".mvb"
        ];
        return CommonUtil.valInArray(ext.toLowerCase(), video_extensions);
    };
    CommonUtil.isImageObjEmbedLink = function (node) {
        return CommonUtil.checkObjEmbed(node, CommonUtil.isImgExt, function (mime) {
            return mime.startsWith("image");
        });
    };
    CommonUtil.isImgExt = function (ext) {
        return CommonUtil.valInArray(ext.toLowerCase(), CommonUtil.image_extensions);
    };
    CommonUtil.isHtmlExt = function (ext) {
        var html_extensions = [".asp", ".aspx", ".cfm", ".cfml", ".cgi", ".htm", ".html", ".shtm",
            ".shtml", ".php", ".pl", ".py", ".shtm", ".shtml", ".xhtml"
        ];
        return CommonUtil.valInArray(ext.toLowerCase(), html_extensions);
    };
    CommonUtil.hasTriggered = function (doc, id) {
        return CacheUtil_1.CacheUtil.getCache(doc, id, false);
    };
    CommonUtil.triggerOnce = function (doc, id, passed) {
        if (passed)
            return true;
        var triggered = CacheUtil_1.CacheUtil.getCache(doc, id, false);
        CacheUtil_1.CacheUtil.setCache(doc, id, true);
        return triggered;
    };
    /* determine if the given value exists in the given array */
    CommonUtil.valInArray = function (value, arr) {
        for (var idx in arr) {
            if (arr[idx] === value)
                return true;
        }
        return false;
    };
    /**
     * return the ancestor of the given element
     * @param tagNames string, array, or dictionary containing the tags to search for
     */
    CommonUtil.getAncestor = function (element, tagNames) {
        var walkNode = element;
        while (walkNode !== null) {
            var thisTag = walkNode.nodeName.toLowerCase();
            if (typeof (tagNames) === "string") {
                if (thisTag === tagNames.toLowerCase()) {
                    break;
                }
            }
            else if (tagNames.length) {
                for (var idx in tagNames) {
                    if (tagNames[idx] === thisTag)
                        return walkNode;
                }
            }
            else if (thisTag in tagNames) {
                break;
            }
            walkNode = DOMWalker_1.DOMWalker.parentNode(walkNode);
        }
        return walkNode;
    };
    // return true if element1 and element2 are siblings
    CommonUtil.isSibling = function (element1, element2) {
        if (element1 && element2) {
            var node = null;
            if (DOMWalker_1.DOMWalker.parentNode(element1) && DOMWalker_1.DOMWalker.parentNode(element1).firstChild) {
                node = DOMWalker_1.DOMWalker.parentNode(element1).firstChild;
            }
            while (node) {
                if (node === element2)
                    return true;
                node = node.nextSibling;
            }
        }
        return false;
    };
    CommonUtil.isDescendant = function (parent, child) {
        var node = DOMWalker_1.DOMWalker.parentNode(child);
        while (node != null) {
            if (node === parent) {
                return true;
            }
            node = DOMWalker_1.DOMWalker.parentNode(node);
        }
        return false;
    };
    //check if the first form control child is disabled
    CommonUtil.isDisabledByFirstChildFormElement = function (element) {
        var formElements = ["input", "textarea", "select", "keygen", "progress", "meter", "output"];
        if (element.firstChild != null) {
            //let nw = new NodeWalker(element);
            var nw = new DOMWalker_1.DOMWalker(element);
            while (nw.nextNode()) {
                if (formElements.includes(nw.node.nodeName.toLowerCase())) {
                    if (CommonUtil.isNodeDisabled(nw.node))
                        return true;
                    return false;
                }
            }
        }
        return false;
    };
    CommonUtil.isDisabledByReferringElement = function (element) {
        var id = element.getAttribute("id");
        var doc = element.ownerDocument;
        var root = doc.body;
        while (DOMWalker_1.DOMWalker.parentNode(root) !== null) {
            // Get the parentNode
            root = DOMWalker_1.DOMWalker.parentNode(root);
        }
        //let nw = new NodeWalker(root);
        var nw = new DOMWalker_1.DOMWalker(root);
        while (nw.nextNode()) {
            // check the element whose 'aria-describedby' equals to the id
            if (nw.node && nw.node.nodeType === 1 && nw.elem()) {
                var AriaDescribedbyIDArray = (nw.elem().getAttribute("aria-describedby") || "").split(" ");
                if (AriaDescribedbyIDArray.includes(id) && CommonUtil.isNodeDisabled(nw.node)) {
                    return true;
                }
            }
        }
    };
    /** get element containing label for the given element
         * @deprecated Deprecated because the function name is misleading. Use getLabelForElement(element) instead
         */
    CommonUtil.getInputLabel = function (element) {
        return CommonUtil.getLabelForElement(element);
    };
    /**
     * This function is responsible for getting the element containing the label for the given element.
     *
     * Note: This is a wrapper function to: AriaUtil.getLabelForElementHidden
     *
     * @parm {element} element - The element for which to get the label element for.
     *
     * @return {element} element - return the element for the label, otherwise null
     *
     * @memberOf AriaUtil
     */
    CommonUtil.getLabelForElement = function (element) {
        return CommonUtil.getLabelForElementHidden(element, false);
    };
    /**
     * This function is responsible for getting the element containing the label for the given element.
     *
     * This function will return null if the containing lable element is hidden, when the ignoreHidden option
     * is set to true.
     *
     * @parm {element} element - The element for which to get the label element for.
     * @parm {boolean} ignoreHidden - true if hidden elements with label should be ignored from the list
     *                                false if the hidden elements should be added
     *
     * @return {element} element - return the element for the label, otherwise null
     *
     * @memberOf AriaUtil
     */
    CommonUtil.getLabelForElementHidden = function (element, ignoreHidden) {
        // Check if the global AriaUtil_LABELS hash is available, as this will contain the label nodes based on
        // for attribute.
        //if (!getCache(element.ownerDocument,"AriaUtil_LABELS", null)) {
        var root = element.getRootNode();
        if (!CacheUtil_1.CacheUtil.getCache((root.nodeType === 11) ? root : root, "AriaUtil_LABELS", null)) {
            // Variable Decleration
            var idToLabel = {};
            // Get all the label elements in the entire doc
            var labelNodes = CommonUtil.getDocElementsByTag(element, "label");
            // Loop over all the label nodes, in the case the label node has a for attribute,
            // extract that attribute and add this node to the hash if it is visible.
            for (var i = 0; i < labelNodes.length; ++i) {
                if (labelNodes[i].hasAttribute("for")) {
                    // If ignore hidden is specified and the node is not visible we do not add it to the
                    // labelNodes hash.
                    if (ignoreHidden && !VisUtil_1.VisUtil.isNodeVisible(labelNodes[i])) {
                        continue;
                    }
                    idToLabel[labelNodes[i].getAttribute("for")] = labelNodes[i];
                }
            }
            // Add the built hash to the ownerDocument (document), to be used later to fast retrival
            //setCache(element.ownerDocument, "AriaUtil_LABELS", idToLabel);
            CacheUtil_1.CacheUtil.setCache((root.nodeType === 11) ? root : root, "AriaUtil_LABELS", idToLabel);
        }
        // If this element has an id attribute, get the corosponding label element
        if (element.hasAttribute("id")) {
            // Fetch the id attribute
            var ctrlId = element.getAttribute("id");
            // Return the corosponding label element.
            // Note: in the case that the the id is not found in the hash that means, it does not exists or is hidden
            if (ctrlId.trim().length > 0) {
                //return getCache(element.getRootNode().ownerDocument,"AriaUtil_LABELS",{})[ctrlId];
                return CacheUtil_1.CacheUtil.getCache((root.nodeType === 11) ? root : root, "AriaUtil_LABELS", {})[ctrlId];
            }
        }
        return null;
    };
    /* Return specified element attribute if present else return null */
    CommonUtil.getElementAttribute = function (element, attr) {
        //return (element && element.hasAttribute && element.hasAttribute(attr)) ? element.getAttribute(attr) : null;
        if (!attr || !element || !element.hasAttribute || !element.hasAttribute(attr))
            return null;
        var atrValue = element.getAttribute(attr);
        if (!ARIADefinitions_1.ARIADefinitions.referenceProperties.includes(attr))
            return atrValue;
        //attr is a reference to other elements(s)
        var values = atrValue.split(/ +/g);
        //ignore if none of the referred element(s) exist or all point to the element itself
        var exist = false;
        for (var id = 0; values < values.length; ++id) {
            var referred = document.getElementById(values[id]);
            if (referred && !DOMUtil_1.DOMUtil.sameNode(referred, element)) {
                exist = true;
                break;
            }
        }
        return exist ? atrValue : null;
    };
    // Return true if element has valid implicit label
    CommonUtil.hasImplicitLabel = function (element) {
        var parentNode = CommonUtil.getAncestor(element, "label");
        // Test  a) if the parent is a label which is the implicit label
        //       b) if the form element is the first child of the label
        //       c) if the form element requires an implicit or explicit label : "input",  "textarea", "select", "keygen", "progress", "meter", "output"
        //       d) form elements which may have a label: button
        // form elements that do not require implicit or explicit label element are:
        // "optgroup", "option", "datalist"(added later). These were handled differently in the main rule, might need to refactor the code later
        if (parentNode && parentNode.tagName.toLowerCase() === "label" && CommonUtil.isFirstFormElement(parentNode, element)) {
            var parentClone = parentNode.cloneNode(true);
            // exclude all form elements from the label since they might also have inner content
            parentClone = CommonUtil.removeAllFormElementsFromLabel(parentClone);
            return CommonUtil.hasInnerContentHidden(parentClone);
        }
        else {
            return false;
        }
    };
    // Return the implicit label of the given form field
    CommonUtil.getImplicitLabel = function (element) {
        var parentNode = CommonUtil.getAncestor(element, "label");
        // Test  a) if the parent is a label which is the implicit label
        //       b) if the form element is the first child of the label
        //       c) if the form element requires an implicit or explicit label : "input",  "textarea", "select", "keygen", "progress", "meter", "output"
        //       d) form elements which may have a label: button
        // form elements that do not require implicit or explicit label element are:
        // "optgroup", "option", "datalist"(added later). These were handled differently in the main rule, might need to refactor the code later
        if (parentNode && parentNode.tagName.toLowerCase() === "label" && CommonUtil.isFirstFormElement(parentNode, element)) {
            var parentClone = parentNode.cloneNode(true);
            // exclude all form elements from the label since they might also have inner content
            parentClone = CommonUtil.removeAllFormElementsFromLabel(parentClone);
            var label = CommonUtil.getInnerText(parentClone);
            return label && label.trim() !== '' ? label.trim() : null;
        }
        else
            return null;
    };
    /**
     * This function is responsible for getting the label for a form field element.
     *
     *
     * @parm {element} element - The element from which to get the label.
     *
     * @return {string} text - return the label text or null
     *
     * @memberOf AriaUtil
     */
    CommonUtil.getFormFieldLabel = function (elem) {
        // get the label from the attribute "for" of the label element
        // Get only the non-hidden labels for element
        var value = "";
        var label = null;
        var labelElem = CommonUtil.getLabelForElementHidden(elem, true);
        if (labelElem) {
            // value directly from element text
            label = labelElem.innerText; // ignore hidden text
        }
        else {
            /** if it's not label with for attribute, then find implicit label
             * cases for explict label:
             *   <label for='my'></label><input id='my'/>
             *   <label for='my'><input id='my'/></label>
             * cases for implicit label:
             *    <label><input /></label>
             */
            labelElem = CommonUtil.getAncestor(elem, "label");
            if (labelElem && labelElem.tagName.toLowerCase() === "label" && CommonUtil.isFirstFormElement(labelElem, elem)) {
                var parentClone = labelElem.cloneNode(true);
                // exclude all the text from the first form element since they might also 
                // have inner content that is part of innerText
                parentClone = CommonUtil.removeAllFormElementsFromLabel(parentClone);
                label = CommonUtil.getInnerText(parentClone);
            }
            else
                return null;
        }
        if (label && label.trim() !== "")
            value += label.trim();
        // value from child element attribute
        label = CommonUtil.getLabelTextFromAttribute(labelElem, true);
        if (label && label.trim() !== "")
            value += label.trim();
        // wired case: get aria label from label element itself just in case (though name prohibited from aria in html)
        label = AriaUtil_1.AriaUtil.getAriaLabel(labelElem);
        if (label && label.trim() !== "")
            value += label.trim();
        return value.trim();
    };
    /**
     * calculate label from embedded control: https://w3c.github.io/accname/
     * @param {element} labelElem label element
     * @param {boolean} ignoreHidden - true if hidden elements with label should be ignored from the list
     *                                false if the hidden elements should be added
     * @returns label text or ''
     *
     * note the assumption is the labelElem refers either to a labelled element by 'for' attribute
     *  or its first form field is labbelled element
     */
    CommonUtil.getLabelTextFromAttribute = function (labelElem, ignoreHidden) {
        // label either points to a labelable element by its for attribute or the first element child
        // get the labelled elment if it's an implicit label
        var labeledElem = null;
        for (var i = 0; i < labelElem.children.length; i++) {
            var child = labelElem.children.item(i);
            if (CommonUtil.form_labelable_elements.includes(child.nodeName.toLowerCase())) {
                labeledElem = child;
                break;
            }
        }
        var nw = new DOMWalker_1.DOMWalker(labelElem);
        var text = '';
        while (nw.nextNode() && nw.node !== labelElem) {
            // only check element children
            if (nw.node && nw.node.nodeType === 1 && nw.elem()) {
                var elem = nw.elem();
                // ignore if it's hidden, or labelled element, or first form element if not labeled by for attribute
                if ((ignoreHidden && (VisUtil_1.VisUtil.isNodeHiddenFromAT(elem) || VisUtil_1.VisUtil.isNodePresentational(elem)))
                    || (labeledElem && labeledElem.contains(elem)))
                    continue;
                var role = AriaUtil_1.AriaUtil.getResolvedRole(elem);
                // textbox etc. return its text value
                if (role === "textbox") {
                    var name_1 = elem.getAttribute("value");
                    if (name_1 && name_1.trim().length > 0)
                        text += ' ' + name_1.trim();
                }
                else if (role === "combobox" || role === "listbox") {
                    // for combobox or listbox roles, return the text alternative of the chosen option.
                    var selectedId = elem.getAttribute("aria-activedescendant") || elem.getAttribute("aria-selected") || elem.getAttribute("aria-checked");
                    if (selectedId) {
                        var selectedOption = elem.ownerDocument.getElementById(selectedId);
                        if (selectedOption && !DOMUtil_1.DOMUtil.sameNode(elem, selectedOption)) {
                            var pair = AccNameUtil_1.AccNameUtil.computeAccessibleName(selectedOption);
                            if (pair && pair.name)
                                text += ' ' + pair.name.trim();
                        }
                    }
                }
                else if (["progressbar", "scrollbar", "slider", "spinbutton", "meter"].includes(role)) {
                    // for range role type, including "progressbar", "scrollbar", "slider", "spinbutton" roles
                    // If the aria-valuetext property is present, return its value
                    var value_1 = elem.getAttribute("aria-valuetext");
                    if (value_1 && value_1.trim().length > 0)
                        text += ' ' + value_1.trim();
                    // Otherwise, if the aria-valuenow property is present, return its value,
                    value_1 = elem.getAttribute("aria-valuenow");
                    if (value_1 && value_1.trim().length > 0)
                        text += ' ' + value_1.trim();
                    // finally use native value attribute
                    value_1 = elem.getAttribute("value");
                    if (value_1 && value_1.trim().length > 0)
                        text += ' ' + value_1.trim();
                }
                // get aria label from the element
                var value = AriaUtil_1.AriaUtil.getAriaLabel(elem);
                if (value && value.trim() !== "")
                    text += ' ' + value.trim();
            }
        }
        return text.trim();
    };
    CommonUtil.isFirstFormElement = function (parentNode, element) {
        //let formElementsRequiringLabel = ["input", "textarea", "select", "keygen", "progress", "meter", "output"];
        if (parentNode.firstChild != null) {
            //let nw = new NodeWalker(parentNode);
            var nw = new DOMWalker_1.DOMWalker(parentNode);
            while (nw.nextNode()) {
                if (CommonUtil.form_labelable_elements.indexOf(nw.node.nodeName.toLowerCase()) !== -1) {
                    return nw.node === element;
                }
            }
        }
        return false;
    };
    // check if the element is a shadow host or descendant of a shadow host, but not a descedant of the shadow root of the host (to be assigned to shadow slot or ignored)  
    CommonUtil.isShadowHostElement = function (element) {
        if (CommonUtil.isShadowElement(element))
            return false;
        var walkNode = element;
        while (walkNode) {
            if (walkNode.shadowRoot)
                return true;
            walkNode = DOMWalker_1.DOMWalker.parentElement(walkNode);
        }
        return false;
    };
    //check if an element is in a shadow tree
    CommonUtil.isShadowElement = function (element) {
        var root = element.getRootNode();
        if (root.toString() === "[object ShadowRoot]")
            return true;
        return false;
    };
    CommonUtil.removeAllFormElementsFromLabel = function (element) {
        var formElements = ["input", "textarea", "select", "button", "datalist", "optgroup", "option", "keygen", "output", "progress", "meter"];
        var childNodes = element.childNodes;
        for (var i = 0; i < childNodes.length; i++) {
            if (formElements.indexOf(childNodes[i].nodeName.toLowerCase()) > -1) {
                element.removeChild(childNodes[i]);
            }
        }
        return element;
    };
    /**
         * @param element
         * @param idStr
         * @returns true if any one (if multiple Ids) id points to itself
         */
    CommonUtil.isIdReferToSelf = function (element, idStr) {
        if (!idStr || idStr.trim() === '')
            return false;
        var ids = idStr.trim().split(" ");
        for (var j = 0, length_1 = ids.length; j < length_1; ++j) {
            var referredNode = fragment_1.FragmentUtil.getById(element, ids[j]);
            if (referredNode && DOMUtil_1.DOMUtil.sameNode(referredNode, element))
                return true;
        }
        return false;
    };
    /* Determine the node depth of the given element */
    CommonUtil.nodeDepth = function (element) {
        var depth = 0;
        var walkNode = element;
        while (walkNode !== null) {
            walkNode = DOMWalker_1.DOMWalker.parentNode(walkNode);
            depth = depth + 1;
        }
        return depth;
    };
    /* compare node order of the 2 given nodes */
    /* returns
     *   0 if the nodes are equal
     *   1 if node b is before node a
     *  -1 if node a is before node b
     *   2 if node a is nested in node b
     *  -2 if node b is nested in node a
     *   null if either node is null or their parent nodes are not equal
     */
    CommonUtil.compareNodeOrder = function (nodeA, nodeB) {
        if (nodeA === nodeB)
            return 0;
        var aDepth = CommonUtil.nodeDepth(nodeA);
        var bDepth = CommonUtil.nodeDepth(nodeB);
        if (bDepth > aDepth) {
            for (var i = 0; i < bDepth - aDepth; ++i)
                nodeB = DOMWalker_1.DOMWalker.parentNode(nodeB);
            if (nodeA === nodeB) // Node B nested in Node A
                return -2;
        }
        else if (aDepth > bDepth) {
            for (var i = 0; i < aDepth - bDepth; ++i)
                nodeA = DOMWalker_1.DOMWalker.parentNode(nodeA);
            if (nodeA === nodeB) // Node A nested in Node B
                return 2;
        }
        while (nodeA != null && nodeB != null && DOMWalker_1.DOMWalker.parentNode(nodeA) != DOMWalker_1.DOMWalker.parentNode(nodeB)) {
            nodeA = DOMWalker_1.DOMWalker.parentNode(nodeA);
            nodeB = DOMWalker_1.DOMWalker.parentNode(nodeB);
        }
        if (nodeA === null || nodeB === null || DOMWalker_1.DOMWalker.parentNode(nodeA) != DOMWalker_1.DOMWalker.parentNode(nodeB))
            return null;
        while (nodeB != null && nodeB != nodeA)
            nodeB = nodeB.previousSibling;
        if (nodeB === null) // nodeB before nodeA
            return 1;
        else
            return -1;
    };
    /**
     *  Determine if the given attribute of the given element is not empty
     *  @memberOf AriaUtil
     */
    CommonUtil.attributeNonEmpty = function (element, attrStr) {
        return element.hasAttribute(attrStr) && element.getAttribute(attrStr).trim().length > 0;
    };
    /* Return a pointer to the given frame, null if not found */
    CommonUtil.getFrameByName = function (ruleContext, frameName) {
        var window = ruleContext.ownerDocument.defaultView;
        var frameList = [window];
        var idx = 0;
        while (idx < frameList.length) {
            try {
                if (frameList[idx].name === frameName)
                    return frameList[idx];
                for (var i = 0; i < frameList[idx].frames.length; ++i) {
                    try {
                        // Ensure it's a real frame and avoid recursion
                        if (frameList[idx].frames[i] && !frameList.includes(frameList[idx].frames[i])) {
                            frameList.push(frameList[idx].frames[i]);
                        }
                    }
                    catch (e) { }
                }
            }
            catch (e) { }
            ++idx;
        }
        return null;
    };
    CommonUtil.defaultNSResolver = function (prefix) {
        var uri;
        switch (prefix) {
            case 'html':
                uri = 'http://www.w3.org/1999/xhtml';
            case 'x2':
                uri = 'http://www.w3.org/TR/xhtml2';
            case 'x':
                uri = 'http://www.w3.org/1999/xhtml';
            case 'xhtml':
                uri = 'http://www.w3.org/1999/xhtml';
            default:
                uri = null;
        }
        return uri;
    };
    //checking if only the inner text is empty or not
    CommonUtil.isInnerTextOnlyEmpty = function (element) {
        // Get the innerText of the element
        var text = element.innerText;
        if ((text === undefined || text === null || text.trim().length === 0) && element.nodeName.toLowerCase() !== 'slot' && element.textContent !== undefined) {
            //ignore slot because its text will be filled by the corresponding content in the light DOM 
            // innerText is sometimes 'undefined' in headless mode, or null if the element is invisible or not erxpanded 
            // so we try textContent as a workaround
            text = element.textContent;
        }
        var retVal = !(text !== null && text.trim().length > 0);
        if (element.nodeType === 1 && element.nodeName.toLowerCase() === "slot") {
            //TODO: need to conside its own content, a slot may have its own content or assigned content
            for (var _i = 0, _a = element.assignedNodes(); _i < _a.length; _i++) {
                var slotElem = _a[_i];
                retVal = retVal && CommonUtil.isInnerTextEmpty(slotElem);
            }
        }
        // Trim the inner text and verify that it is not empty.
        return retVal;
    };
    /* Return the inner text of the given element */
    CommonUtil.getInnerText = function (element) {
        var retVal = element.innerText;
        if (retVal === undefined || retVal === null || retVal.trim() === "")
            retVal = element.textContent;
        return retVal;
    };
    /**
     * return onscreen innerText only.
     * This function should return the same result as innerText if no offscreen content exists
     *
     * @parm {element} node The node which should be checked it has inner text or not.
     * @return {null | string} null if element has empty inner text, text otherwise
     *
     * @memberOf AriaUtil
     */
    CommonUtil.getOnScreenInnerText = function (element) {
        if (!element)
            return null;
        if (element.nodeType === 3)
            return element.nodeValue();
        var text = "";
        //let nw = new NodeWalker(element);
        var nw = new DOMWalker_1.DOMWalker(element);
        // Loop over all the childrens of the element to get the text
        while (nw.nextNode() && nw.node !== element && nw.node !== element.parentNode) {
            if (nw.bEndTag)
                continue;
            if (nw.node.nodeType === 1 && (VisUtil_1.VisUtil.hiddenByDefaultElements.includes(nw.node.nodeName.toLowerCase()) || !VisUtil_1.VisUtil.isNodeVisible(nw.node) || VisUtil_1.VisUtil.isElementOffscreen(nw.node))) {
                /** special case for svg <title> element:
                 *     text in a <title> element is not rendered as part of the graphic, but browsers usually display it as a tooltip
                 *     note some svg elements, such as title, desc, have a bounds {"left":0,"top":0,"height":0,"width":0}
                */
                if (nw.node.nodeName.toLowerCase() === 'title' && CommonUtil.getAncestor(nw.node, "svg"))
                    continue;
                if (nw.node.nextSibling) {
                    if (nw.node.nextSibling.nodeType === 3 && nw.node.nextSibling.nodeValue && nw.node.nextSibling.nodeValue.trim() !== '')
                        text += ' ' + nw.node.nextSibling.nodeValue.trim();
                    nw.node = nw.node.nextSibling;
                    continue;
                }
                else
                    break;
            }
            if (nw.node.nodeType === 3 && nw.node.nodeValue && nw.node.nodeValue.trim() !== '') {
                text += ' ' + nw.node.nodeValue.trim();
            }
        }
        return text.trim();
    };
    /** Return the text content of the given node
     *  this is different than innerText or textContent that return text content of a node and its descendants
    */
    CommonUtil.getNodeText = function (element) {
        if (!element)
            return "";
        var text = "";
        var childNodes = element.childNodes;
        for (var i = 0; i < childNodes.length; ++i) {
            if (childNodes[i].nodeType == 3) {
                text += childNodes[i].nodeValue;
            }
        }
        return text;
    };
    /**
     * This function is responsible for checking if elements inner text is empty or not.
     *
     * @parm {element} node The node which should be checked it has inner text or not.
     * @return {bool} true if element has empty inner text, false otherwise
     *
     * @memberOf AriaUtil
     */
    CommonUtil.isInnerTextEmpty = function (element) {
        // Get the innerText of the element
        var text = CommonUtil.getInnerText(element);
        // Trim the inner text and verify that it is not empty.
        return !(text != null && text.trim().length > 0);
    };
    CommonUtil.hasInnerContent = function (element) {
        var text = CommonUtil.getInnerText(element);
        var hasContent = (text !== null && text.trim().length > 0);
        if (element.firstChild !== null) {
            //let nw = new NodeWalker(element);
            var nw = new DOMWalker_1.DOMWalker(element);
            while (!hasContent && nw.nextNode()) {
                hasContent = (nw.node.nodeName.toLowerCase() === "img" &&
                    CommonUtil.attributeNonEmpty(nw.node, "alt"));
            }
        }
        return hasContent;
    };
    /**
     * This function is responsible for determine if an element has inner content.
     * This function also considers cases where inner text is hidden, which now will
     * be classified as does not have hidden content.
     *
     * @parm {element} node The node which should be checked it has inner text or not.
     * @return {bool} true if element has empty inner text, false otherwise
     *
     * @memberOf AriaUtil
     */
    CommonUtil.hasInnerContentHidden = function (element) {
        return CommonUtil.hasInnerContentHiddenHyperLink(element, false);
    };
    CommonUtil.svgHasName = function (element) {
        return CommonUtil.attributeNonEmpty(element, "aria-label")
            || CommonUtil.attributeNonEmpty(element, "aria-labelledby")
            || !!element.querySelector(":scope > title");
    };
    CommonUtil.hasInnerContentHiddenHyperLink = function (element, hyperlink_flag) {
        if (!element)
            return false;
        // Variable Decleration
        var childElement = element.firstElementChild;
        var hasContent = false;
        // In the case that the childElement is not null then we need to check each of the elements
        // to make sure that the elements are not all hidden.
        if (childElement != null) {
            // Get the nodewalter of the element node, so that we can loop over it and verify
            // that the elements under the element are not completly hidden.
            //let nw = new NodeWalker(element);
            var nw = new DOMWalker_1.DOMWalker(element);
            // Loop over all the nodes until there are no more nodes or we have determine that there is content under
            // this parent element.
            while (!hasContent && nw.nextNode() && nw.node != element) {
                // Get the next node
                var node = nw.node;
                // In the case an img element is present with alt then we can mark this as pass
                // otherwise keep checking all the other elements. Make sure that this image element is not hidden.
                hasContent = (node.nodeName.toLowerCase() === "img"
                    && (CommonUtil.attributeNonEmpty(node, "alt") || CommonUtil.attributeNonEmpty(node, "title"))
                    && !VisUtil_1.VisUtil.isNodeHiddenFromAT(node) && !VisUtil_1.VisUtil.isNodePresentational(node)) || (node.nodeName.toLowerCase() === "svg"
                    && CommonUtil.svgHasName(node));
                // Now we check if this node is of type element, visible
                if (!hasContent && node.nodeType === 1 && !VisUtil_1.VisUtil.isNodeHiddenFromAT(node) && !VisUtil_1.VisUtil.isNodePresentational(node)) {
                    // Check if the innerText of the element is empty or not
                    hasContent = !CommonUtil.isInnerTextOnlyEmpty(node);
                    if (!hasContent && hyperlink_flag === true) {
                        hasContent = CommonUtil.attributeNonEmpty(node, "aria-label") || CommonUtil.attributeNonEmpty(node, "aria-labelledby");
                        var doc = node.ownerDocument;
                        if (doc) {
                            var win = doc.defaultView;
                            if (win) {
                                var cStyle = win.getComputedStyle(node);
                                if (!hasContent && cStyle != null) {
                                    //                                       console.log(cStyle.backgroundImage);
                                    //                                       console.log(cStyle.content)
                                    hasContent = ((cStyle.backgroundImage && cStyle.backgroundImage.indexOf) || cStyle.content) && CommonUtil.attributeNonEmpty(node, "alt");
                                }
                            }
                        }
                    }
                }
                // Check for cases where there is text node after an element under the parent
                // In the case we detect nodetype as text node and the patent of the text node is
                // the same element we are checking has Inner content for then get the inner content of this
                // text node.
                if (node.nodeType === 3 && DOMWalker_1.DOMWalker.parentElement(node) === element) {
                    // Check if the innerText of the element is empty or not
                    hasContent = !CommonUtil.isInnerTextEmpty(node);
                }
            }
        }
        // In the case there are no child elements then we can simply perform the check for only innertext
        // the img with alt case will be covered in the above if, as img is considers as an element.
        else {
            // Check if the innerText of the element is empty or not
            hasContent = !CommonUtil.isInnerTextEmpty(element);
        }
        return hasContent;
    };
    CommonUtil.hasInnerContentOrAlt = function (element) {
        var text = CommonUtil.getInnerText(element);
        var hasContent = (text != null && text.trim().length > 0) || CommonUtil.attributeNonEmpty(element, "alt");
        if (element.firstChild != null) {
            //let nw = new NodeWalker(element);
            var nw = new DOMWalker_1.DOMWalker(element);
            while (!hasContent && nw.nextNode() && nw.node != element) {
                hasContent = (nw.node.nodeName.toLowerCase() === "img" &&
                    CommonUtil.attributeNonEmpty(nw.node, "alt"));
                if (!hasContent
                    && (AriaUtil_1.AriaUtil.hasRole(nw.node, "button", true) || AriaUtil_1.AriaUtil.hasRole(nw.node, "textbox"))
                    && (AriaUtil_1.AriaUtil.hasAriaLabel(nw.node) || CommonUtil.attributeNonEmpty(nw.node, "title") || CommonUtil.getLabelForElementHidden(nw.elem(), true))) {
                    hasContent = true;
                }
            }
        }
        return hasContent;
    };
    CommonUtil.concatUniqueArrayItem = function (item, arr) {
        arr.indexOf(item) === -1 && item !== null ? arr.push(item) : false;
        return arr;
    };
    CommonUtil.concatUniqueArrayItemList = function (itemList, arr) {
        for (var i = 0; itemList !== null && i < itemList.length; i++) {
            arr = CommonUtil.concatUniqueArrayItem(itemList[i], arr);
        }
        return arr;
    };
    /**
     * remove array items from a given array
     * @param itemList items to be removed from arr
     * @param arr the array
     * @returns
     */
    CommonUtil.reduceArrayItemList = function (itemList, arr) {
        if (arr && arr.length > 0 && itemList && itemList.length > 0) {
            var result = arr.filter(function (value) {
                return !itemList.includes(value);
            });
            return result;
        }
        return arr;
    };
    CommonUtil.getScopeForTh = function (element) {
        /** https://www.w3.org/TR/html5/tabular-data.html#header-and-data-cell-semantics
         * A header cell anchored at the slot with coordinate (x, y) with width width and height height is
         * said to be a column header if any of the following conditions are true:
         * * The cell's scope attribute is in the column state, or
         * * The cell's scope attribute is in the auto state, and there are no data cells in any of
         *   the cells covering slots with y-coordinates y .. y+height-1.
         * A header cell anchored at the slot with coordinate (x, y) with width width and height height is
         * said to be a row header if any of the following conditions are true:
         * * The cell's scope attribute is in the row state, or
         * * The cell's scope attribute is in the auto state, the cell is not a column header, and there are
         *   no data cells in any of the cells covering slots with x-coordinates x .. x+width-1.
         */
        // Note: auto is default scope
        // Easiest answer is if scope is specified
        if (element.hasAttribute("scope")) {
            var scope = element.getAttribute("scope").toLowerCase();
            if (scope === "row" || scope === 'rowgroup')
                return "row";
            if (scope === "col" || scope === 'colgroup')
                return "column";
        }
        // scope is auto, default (without a scope) or invalid value.
        // if all the sibling elements are th, then return "columnheader" 
        var siblings = function (element) { return __spreadArray([], element.parentElement.children, true).filter(function (node) { return node.nodeType === 1 && node.tagName != "TH"; }); };
        if (siblings === null || siblings.length === 0)
            return "column";
        else
            return "row";
    };
    CommonUtil.getControlOfLabel = function (node) {
        // Handle the easy case of label -> for
        var labelAncestor = CommonUtil.getAncestor(node, "label");
        if (labelAncestor) {
            if (labelAncestor.hasAttribute("for")) {
                return fragment_1.FragmentUtil.getById(node, labelAncestor.getAttribute("for"));
            }
        }
        // Create a dictionary containing ids of parent nodes
        var idDict = {};
        var parentWalk = node;
        while (parentWalk) {
            if (parentWalk.nodeType === 1 /* Node.ELEMENT_NODE */) {
                var ancestor = parentWalk;
                if (ancestor.hasAttribute("id")) {
                    idDict[ancestor.getAttribute("id")] = true;
                }
            }
            parentWalk = DOMWalker_1.DOMWalker.parentNode(parentWalk);
        }
        // Iterate through controls that use aria-labelledby and see if any of them reference one of my ancestor ids
        var inputsUsingLabelledBy = node.ownerDocument.querySelectorAll("*[aria-labelledby]");
        for (var idx = 0; idx < inputsUsingLabelledBy.length; ++idx) {
            var inputUsingLabelledBy = inputsUsingLabelledBy[idx];
            var ariaLabelledBy = inputUsingLabelledBy.getAttribute("aria-labelledby");
            var sp = ariaLabelledBy.split(" ");
            for (var _i = 0, sp_1 = sp; _i < sp_1.length; _i++) {
                var id = sp_1[_i];
                if (id in idDict && !CommonUtil.isIdReferToSelf(node, node.getAttribute("aria-labelledby"))) {
                    return inputUsingLabelledBy;
                }
            }
        }
        // Find the cases where we're within an aria labelledby
        return null;
    };
    /**
     * This function is responsible for checking if the node that is provied is
     * disabled or not. Following is how the check is performed:
     *    1. Check if the current node is disabled with the following options:
     *       attribute --> disabled
     *         Also needs to be "button", "input", "select", "textarea", "optgroup", "option",
     *         "menuitem", "fieldset" nodes (in array elementsAllowedDisabled)
     *       attribute --> aria-disabled="true"
     *    2. Check if any of the current nodes parents are disabled with the same
     *       options listed in 1.
     *
     *    Note: If either current node or any of the parent nodes are disabled then this
     *          function will return true (node is disabled).
     *
     * @parm {HTMLElement} node - The node which should be checked if it is disabled or not.
     * @return {bool} true if the node is disabled, false otherwise
     *
     * @memberOf AriaUtil
     */
    CommonUtil.isNodeDisabled = function (node) {
        // Set PT_NODE_DISABLED to false for all the nodes, before the check and this will be changed to
        // true when we detect that the node is disabled. We have to set it to false so that we know
        // the node has already been checked. Only set it to false if the setting is undefined or null
        // as if it is defined we do not wnat to reset it. As if it is true then we should make use of it
        // to speed up the check.
        var PT_NODE_DISABLED = CacheUtil_1.CacheUtil.getCache(node, "PT_NODE_DISABLED", false);
        // Check the nodeType of this node, if this node is a text node then
        // we get the parentnode and set that as the node as a text nodes,
        // disabled is directly related to the parent node.
        if (node.nodeType === 3) {
            node = DOMWalker_1.DOMWalker.parentNode(node);
        }
        // Variable Declaration
        var nodeName = node.nodeName.toLowerCase();
        // Get the disabled element property, disabled and aria-disabled attribute and check that it is true
        var disabledAttribute = node.hasAttribute("disabled");
        var disabledPropertyCustom = PT_NODE_DISABLED;
        var ariaDisabledAttribute = node.hasAttribute('aria-disabled') && node.getAttribute("aria-disabled") === 'true';
        // If this node has disabled attribute and the node allows disabled attribute, then return true.
        // Disabled attribute is only allowed on "button", "input", "select", "textarea", "optgroup", "option", "menuitem", "fieldset"
        // In the case aria-disabled is set to true, then also return true
        if (disabledPropertyCustom || (disabledAttribute && ARIADefinitions_1.ARIADefinitions.elementsAllowedDisabled.indexOf(nodeName) > -1) || ariaDisabledAttribute) {
            PT_NODE_DISABLED = true;
            CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_DISABLED", PT_NODE_DISABLED);
            return true;
        }
        // Get the parentNode for this node, becuase we have to check all parents to make sure they do not have
        // disabled attribute. Only keep checking until we are all the way back to the parentNode
        // element.
        var parentElement = DOMWalker_1.DOMWalker.parentNode(node);
        // If the parent node exists and the nodetype is element (1), then run recursive call to perform the check
        // all the way up to the very parent node. Use recursive call here instead of a while loop so that we do not
        // have to duplicate the logic for checking if the node is disabled or not for all the parents starting with
        // child node.
        if (parentElement != null && parentElement.nodeType === 1) {
            // Check upwards recursively, and save the results in an variable
            var nodeDisabled = CommonUtil.isNodeDisabled(parentElement);
            // If the node is found to be disabled then add the custom PT_NODE_DISABLED to true.
            // so that we can use this next time, to quickly determine if node is disabled or not.
            // This is extra percaution, the isNodeDisabled function already sets this.
            if (nodeDisabled) {
                PT_NODE_DISABLED = true;
            }
            // Check upwards recursively
            CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_DISABLED", PT_NODE_DISABLED);
            return nodeDisabled;
        }
        // Return false (node is not disabled)
        return false;
    };
    /**
     * This function is responsible for determine if hidden content should be checked
     * in rules.
     *
     * @parm {element} node - A node so that the document can be accessed to check for the
     *                        option. Can be document element or a simple node element.
     * @return {bool} true if hidden content should be checked, false otherwise
     *
     * @memberOf AriaUtil
     */
    CommonUtil.shouldCheckHiddenContent = function (node) {
        return false;
    };
    /**
     * This function is responsible for determining if node should be skipped from checking or not, based
     * on the Check Hidden Content settings and if the node is visible or not.
     *
     * @parm {element} node - Node to check if it is visible or not based on the Check Hidden Content
     *                        setting.
     *
     * @return {bool} true if node should be skipped, false otherwise
     *
     * @memberOf AriaUtil
     */
    CommonUtil.shouldNodeBeSkippedHidden = function (node) {
        // Following are the steps that are executed at this stage to determine if the node should be classified as hidden
        // or not.
        //  1. Only run isNodeVisible check if hidden content should NOT be checked. In the case that hidden content is to,
        //     be scanned then we can just scan everything as normal. In the case that the current node is hidden we
        //     return true to identify that the node should not be scanned/added to any hash/array.
        //
        // Note: The if conditions uses short-circuiting so if the first condition is not true it will not check the next one,
        //       so on and so forth.
        if (!CommonUtil.shouldCheckHiddenContent(node) && !VisUtil_1.VisUtil.isNodeVisible(node)) {
            return true;
        }
        return false;
    };
    CommonUtil.isfocusableByDefault = function (node) {
        var focusableElements = ['input', 'select', 'button', 'textarea', 'option', 'area'];
        if (node.nodeName.toLowerCase() === "a" && CommonUtil.hasAttribute(node, 'href'))
            return true;
        if (node.nodeName.toLowerCase() === "area" && CommonUtil.hasAttribute(node, 'href'))
            return true;
        if (focusableElements.indexOf(node.nodeName.toLowerCase()) !== -1)
            return true;
        return false;
    };
    /**
     * This function check if a non-tabable node has valid tabable content.
     * If it is tabable (the tabindex is not speicified or is not -1), returns false;
     * If it is non-tabable, but a child is tabable and does not have element content, returns false;
     * Otherwise, returns true.
     */
    CommonUtil.nonTabableChildCheck = function (element) {
        if (!element.hasAttribute("tabindex") ||
            (parseInt(element.getAttribute("tabindex")) != -1)) {
            return false;
        }
        //let nw = new NodeWalker(element);
        var nw = new DOMWalker_1.DOMWalker(element);
        while (nw.nextNode()) {
            var child = nw.elem();
            if (child === null) { // Text node. usually is a cartridge return.
                continue;
            }
            if (child.hasAttribute("tabindex") &&
                (parseInt(child.getAttribute("tabindex")) != -1) &&
                !CommonUtil.hasInnerContent(child)) {
                return false;
            }
        }
        return true;
    };
    CommonUtil.hasAttribute = function (element, attributeName) {
        var hasAttribute = false;
        if (element.hasAttribute) {
            hasAttribute = element.hasAttribute(attributeName);
        }
        else if (element.attributes && element.attributes.getNamedItem) {
            var attr = element.attributes.getNamedItem(attributeName);
            hasAttribute = attr && attr.specified;
        }
        return hasAttribute;
    };
    // truncate the given text to a given number of characters
    // return truncated text to 150 chars, same with the media_alt_brief rule
    CommonUtil.truncateText = function (text, len) {
        if (len === void 0) { len = 150; }
        if (!text)
            return text;
        text = text.trim();
        if (text.length > len)
            return text.substring(0, len - 1) + "...";
        return text;
    };
    CommonUtil.input_type_with_placeholder = ["text", "search", "tel", "url", "email", "password", "number"];
    CommonUtil.input_text_types = [
        "text", "file", "password",
        "checkbox", "radio",
        "search", "tel", "url", "email",
        "date", "number", "range",
        "time", "color"
    ];
    CommonUtil.input_time_types = [
        "date", "month", "week", "time", "datetime-local"
    ];
    CommonUtil.input_other_types = [
        "range", "color", "checkbox", "radio", "file", "image"
    ];
    CommonUtil.form_button_types = [
        "button", "reset", "submit"
    ];
    CommonUtil.form_labelable_elements = ["input", "textarea", "select", "keygen", "progress", "meter", "output", "button"];
    CommonUtil.tabTagMap = {
        "button": function (element) {
            return !element.hasAttribute("disabled");
        },
        "iframe": true,
        "input": function (element) {
            if (element.hasAttribute("disabled") || element.getAttribute("type") === "hidden")
                return false;
            if (element.getAttribute("type") === "radio") {
                var name_2 = element.getAttribute("name");
                if (!name_2 || name_2.trim().length === 0)
                    return true; //single radio, no group
                var doc = element.ownerDocument;
                var group = doc.querySelectorAll("input[type='radio'][name='" + name_2.trim() + "']");
                if (group.length === 0 || group.length === 1)
                    return true; //single radio with the name, no others in group
                var checked = null;
                for (var i = 0; i < group.length; i++) {
                    if (group[i].checked)
                        checked = group[i];
                }
                //only last one applies if multiple radios with 'checked' attributes
                if (checked !== null) {
                    if (DOMUtil_1.DOMUtil.sameNode(checked, element))
                        return true;
                    return false;
                }
                else {
                    // if nothing checked yet, return true if it's the first element
                    if (DOMUtil_1.DOMUtil.sameNode(group[0], element))
                        return true;
                    return false;
                }
            }
            else
                return true;
        },
        "select": function (element) {
            return !element.hasAttribute("disabled");
        },
        "textarea": true,
        /**"div": function (element) {
            return element.hasAttribute("contenteditable");
        },*/
        "a": function (element) {
            // xlink:href?? see svg
            return element.hasAttribute("href");
        },
        "area": function (element) {
            return element.hasAttribute("href");
        },
        "audio": function (element) {
            return element.hasAttribute("controls");
        },
        "video": function (element) {
            return element.hasAttribute("controls");
        },
        "summary": function (element) {
            // first summary child of a details element is automatically focusable 
            return element.parentElement && element.parentElement.nodeName.toLowerCase() === 'details'
                && DOMUtil_1.DOMUtil.sameNode(__spreadArray([], element.parentElement.children, true).filter(function (elem) { return elem.nodeName.toLowerCase() === 'summary'; })[0], element);
        },
        "details": function (element) {
            //details element without a direct summary child is automatically focusable
            return element.children && __spreadArray([], element.children, true).filter(function (elem) { return elem.nodeName.toLowerCase() === 'summary'; }).length === 0;
        }
    };
    CommonUtil.image_extensions = [".bmp", ".gif", ".jpg", ".jpeg", ".pcx", ".png"];
    return CommonUtil;
}());
exports.CommonUtil = CommonUtil;


/***/ }),

/***/ 5755:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TableUtil = void 0;
var VisUtil_1 = __webpack_require__(8656);
var AriaUtil_1 = __webpack_require__(490);
var CommonUtil_1 = __webpack_require__(8137);
var TableUtil = /** @class */ (function () {
    function TableUtil() {
    }
    TableUtil.isDataTable = function (tableNode) {
        return !(AriaUtil_1.AriaUtil.hasRole(tableNode, "none") || AriaUtil_1.AriaUtil.hasRole(tableNode, "presentation"));
    };
    /*
     * A complex data table is a data table with any of the following characteristics:
     *
     * a thead element that contains two or more tr elements
     * a table with more than one thead element
     * a table with two or more tr elements that contain only th elements
     * a th or td element with a rowspan or colspan attribute
     * a tr element that contains at least one td element and two or more th elements
     * a table with headers not located in the first row or first column
     * a td element with a headers attribute value that contains more than two IDREFs
     */
    TableUtil.isComplexDataTable = function (table) {
        if ("AriaUtil_isComplexDataTable" in table) {
            return !!table.AriaUtil_isComplexDataTable;
        }
        var isComplexTable = false;
        if (table && TableUtil.isDataTable(table)) {
            var thNodes = null, tdNodes = null;
            var trNodes = table.getElementsByTagName("tr");
            var trNodeCount = trNodes.length;
            var tdNodeCount = 0, thNodeCount = 0, trNodesHavingOnlyThNodes = 0;
            for (var i = 0; !isComplexTable && i < trNodeCount; ++i) {
                thNodes = trNodes[i].getElementsByTagName("th");
                tdNodes = trNodes[i].getElementsByTagName("td");
                thNodeCount = thNodes.length;
                tdNodeCount = tdNodes.length;
                if (tdNodeCount !== 0) {
                    // a tr element that contains at least one td element and two or more th elements;
                    isComplexTable = thNodeCount > 1;
                    // a th element with a rowspan or colspan attribute
                    for (var j = 0; !isComplexTable && j < thNodeCount; ++j) {
                        isComplexTable = ((thNodes[j].hasAttribute("rowspan") ||
                            thNodes[j].hasAttribute("colspan")) &&
                            CommonUtil_1.CommonUtil.getAncestor(thNodes[j], "table") === table);
                    }
                    // a td element with a rowspan or colspan attribute
                    // a td element with a headers attribute value that contains more than two IDREFs
                    for (var k = 0; !isComplexTable && k < tdNodeCount; ++k) {
                        isComplexTable = ((tdNodes[k].hasAttribute("rowspan") ||
                            tdNodes[k].hasAttribute("colspan") ||
                            (tdNodes[k].hasAttribute("headers") && CommonUtil_1.CommonUtil.normalizeSpacing(tdNodes[k].getAttribute("headers")).split(" ").length > 2)) &&
                            CommonUtil_1.CommonUtil.getAncestor(tdNodes[k], "table") === table);
                    }
                }
                else {
                    // two or more tr elements that contain only th elements
                    if (thNodeCount > 0) {
                        ++trNodesHavingOnlyThNodes;
                    }
                    isComplexTable = trNodesHavingOnlyThNodes === 2;
                }
            }
            if (!isComplexTable) {
                var theadNodes = table.getElementsByTagName("thead");
                var theadNodesLength = theadNodes.length;
                if (theadNodesLength > 0) {
                    // table has more than one thead element
                    isComplexTable = theadNodesLength > 1;
                    // a thead element that contains two or more tr elements
                    if (!isComplexTable) {
                        isComplexTable = theadNodes[0].getElementsByTagName("tr").length > 1;
                    }
                }
            }
            if (!isComplexTable && trNodeCount !== 0) {
                // a table with headers not located in the first row or first column
                isComplexTable = thNodeCount > 0 && !TableUtil.tableHeaderExists(table);
            }
        }
        table.AriaUtil_isComplexDataTable = isComplexTable;
        return isComplexTable;
    };
    // Return true if a table cell is hidden or contain no data: <td></td>
    TableUtil.isTableCellEmpty = function (cell) {
        if (!cell || !VisUtil_1.VisUtil.isNodeVisible(cell) || cell.innerHTML.replace(/&nbsp;/g, ' ').trim().length === 0)
            return true;
        return false;
    };
    // Return true if a table row is hidden or contain no data: <tr /> or <tr><td></td><td></td></tr> 
    TableUtil.isTableRowEmpty = function (row) {
        if (!row || !row.cells || row.cells.length === 0 || !VisUtil_1.VisUtil.isNodeVisible(row))
            return true;
        var passed = true; //empty
        for (var c = 0; passed && c < row.cells.length; c++) {
            var cell = row.cells[c];
            passed = TableUtil.isTableCellEmpty(cell);
        }
        return passed;
    };
    // Return true if a table's header is in the first row or column
    TableUtil.tableHeaderExists = function (ruleContext) {
        var rows = ruleContext.rows;
        if (!rows || rows.length === 0)
            return null;
        // note that table.rows return all all the rows in the table, 
        // including the rows contained within <thead>, <tfoot>, and <tbody> elements. 
        //case 1: headers are in the very first row with data in tbody or thead, but not in tfoot   
        //get the first row with data, ignoring the rows with no data
        var passed = true;
        var firstRow = rows[0];
        for (var r = 0; passed && r < rows.length; r++) {
            firstRow = rows[r];
            // ignore the rows from tfoot
            if (firstRow.parentNode && firstRow.parentNode.nodeName.toLowerCase() === 'tfoot')
                continue;
            passed = TableUtil.isTableRowEmpty(firstRow);
        }
        //table contain no data:  <table><tr><td></td><td></td></tr></table> 
        if (passed)
            return null;
        // Check if the cells with data in the first data row are all TH's
        passed = true;
        for (var r = 0; passed && r < firstRow.cells.length; r++) {
            var cell = firstRow.cells[r];
            passed = TableUtil.isTableCellEmpty(cell) || cell.nodeName.toLowerCase() === 'th';
        }
        if (passed)
            return true;
        // Case 2: headers are in the first column with data
        // Assume that the first column has all TH's or a TD without data in the first column.
        passed = true;
        for (var i = 0; passed && i < rows.length; ++i) {
            // ignore the rows from tfoot
            if (rows[i].parentNode && rows[i].parentNode.nodeName.toLowerCase() === 'tfoot')
                continue;
            // If no cells in this row, or no data at all, that's okay too.
            passed = !rows[i].cells ||
                rows[i].cells.length === 0 ||
                rows[i].cells[0].innerHTML.trim().length === 0 ||
                rows[i].cells[0].nodeName.toLowerCase() != "td";
        }
        if (passed)
            return true;
        //case 3: all td data cells have headers attributes that point to the id of a th element in the same table. 
        // https://html.spec.whatwg.org/multipage/tables.html#attributes-common-to-td-and-th-elements
        passed = true;
        var thIds = [];
        var tdHeaders = [];
        for (var r = 0; passed && r < rows.length; r++) {
            var row = rows[r];
            // Check if the cells with data in the last data row are all TH's
            for (var c = 0; c < row.cells.length; c++) {
                var cell = row.cells[c];
                if (TableUtil.isTableCellEmpty(cell))
                    continue;
                if (cell.nodeName.toLowerCase() === 'td') {
                    if (!cell.getAttribute('headers') || cell.getAttribute('headers').trim().length === 0)
                        passed = false;
                    else
                        CommonUtil_1.CommonUtil.concatUniqueArrayItemList(cell.getAttribute('headers').trim().split(" "), tdHeaders);
                }
                else if (cell.nodeName.toLowerCase() === 'th' && cell.getAttribute('id') && cell.getAttribute('id').trim().length > 0)
                    CommonUtil_1.CommonUtil.concatUniqueArrayItem(cell.getAttribute('id').trim(), thIds);
            }
        }
        if (passed) { // all td elements have headers, to exam if the headers point to a th id
            if (thIds.length > 0 && tdHeaders.every(function (header) { return thIds.includes(header); }))
                return true;
        }
        return false;
    };
    TableUtil.isLayoutTable = function (tableNode) {
        return AriaUtil_1.AriaUtil.hasRole(tableNode, "presentation") || AriaUtil_1.AriaUtil.hasRole(tableNode, "none");
    };
    /*
     * get conflict Aria and Html attributes
     * return: a list of Aria and Html attribute pairs that are conflict
    */
    TableUtil.isTableDescendant = function (contextHierarchies) {
        if (!contextHierarchies)
            return null;
        return contextHierarchies["aria"].filter(function (hier) { return ["table", "grid", "treegrid"].includes(hier.role); });
    };
    return TableUtil;
}());
exports.TableUtil = TableUtil;


/***/ }),

/***/ 8656:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/******************************************************************************
  Copyright:: 2022- IBM, Inc
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VisUtil = void 0;
var CacheUtil_1 = __webpack_require__(7788);
var DOMUtil_1 = __webpack_require__(295);
var DOMWalker_1 = __webpack_require__(7440);
var DOMMapper_1 = __webpack_require__(5697);
var AriaUtil_1 = __webpack_require__(490);
var CSSUtil_1 = __webpack_require__(1775);
var ClipPathUtil_1 = __webpack_require__(5965);
var VisUtil = /** @class */ (function () {
    function VisUtil() {
    }
    /**
     * This function is responsible for checking if the node that is provied is
     * visible or not. Following is how the check is performed:
     *    1. Check if the current node is hidden with the following options:
     *       CSS --> dislay: none
     *       CSS --> visibility: hidden
     *       attribute --> hidden
     *    2. Check if the any of the current nodes parents are hidden with the same
     *       options listed in 1.
     *
     *    Note: If either current node or any of the parent nodes are hidden then this
     *          function will return false (node is not visible).
     *
     *    Note: nodes with CSS properties opacity:0 or filter:opacity(0%), or similar SVG mechanisms:
     *      They are not considered hidden. Text hidden with these methods can still be selected or copied,
     *      and user agents still expose it in their accessibility trees.
     *
     *    Note: nodes hidden off screen or behind another object: they are not considered hidden.
     *      They are exposed in the accessibility tree and they can even name on-screen objects.
     *
     * @parm {element} node The node which should be checked if it is visible or not.
     * @return {bool} false if the node is NOT visible, true otherwise
     *
     * @memberOf VisUtil
     */
    VisUtil.isNodeVisible = function (nodeIn) {
        // Check the nodeType if this node, if this node is a text node then
        // we get the parentnode and set that as the node as a text nodes,
        // visibility is directly related to the parent node.
        if (nodeIn.nodeType === 3) {
            nodeIn = DOMWalker_1.DOMWalker.parentNode(nodeIn);
        }
        var node = nodeIn;
        // We should only allow nodeType element, and TextNode all other nodesTypes
        // we can return the visibility as visible.
        // Following nodes will be returned as visable by default, since we can not
        // actually change their visibility.
        //  Node.PROCESSING_INSTRUCTION_NODE --> 7
        //  Node.COMMENT_NODE                --> 8
        //  9 /* Node.DOCUMENT_NODE */               --> 9
        //  Node.DOCUMENT_TYPE_NODE          --> 10
        //  Node.DOCUMENT_FRAGMENT_NODE      --> 11
        if (node.nodeType !== 1) {
            return true;
        }
        // Make sure that the ownerDocument is present before moving forward
        // in detecting if the node is visible or not. In the case that ownerDocument
        // does not exist then we simply return node is visible by default.
        if (!node.ownerDocument) {
            return true;
        }
        // Variable Declaration
        var compStyle;
        var nodeName = node.nodeName.toLowerCase();
        // In the case this node is a script, link or style node, right away return node is visible
        // because scripts, links and style nodes can not be hidden by HTML attribute or CSS or are hidden by default. But we want to scan
        // the elements everytime as they render content still which is still visible to users.
        //  script --> script elements have display: none by default
        //  link --> link elements have display: none by default, but the actually CSS script is still executed so we have to
        //            mark this element as visible at all times.
        //  style --> style elements have display: none by default, but the actually CSS script is still executed so we have to
        //            mark this element as visible at all times.
        // datalist --> In the rendering, the datalist element represents nothing and it, along with its children, should be hidden.
        if (VisUtil.hiddenByDefaultElements != null && VisUtil.hiddenByDefaultElements != undefined && VisUtil.hiddenByDefaultElements.indexOf(nodeName) > -1) {
            //return true;
            return false;
        }
        if (CacheUtil_1.CacheUtil.getCache(node, "PT_NODE_HIDDEN", undefined) !== undefined) {
            return CacheUtil_1.CacheUtil.getCache(node, "PT_NODE_HIDDEN", undefined);
        }
        // Set PT_NODE_HIDDEN to false for all the nodes, before the check and this will be changed to
        // true when we detect that the node is hidden. We have to set it to false so that we know
        // the rules has already been checked.
        CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_HIDDEN", CacheUtil_1.CacheUtil.getCache(node, "PT_NODE_HIDDEN", false));
        // Check if this node is visible, we check couple of CSS properties and hidden attribute.
        // area, param and audio elements we do not check if they are hidden as it does not apply to them.
        // Check the unhideableElements array which is part of the rules, to check if this element is allowed to be hidden or not
        // in the case that the element is part of the unhideableElements array then we do not run the hidden check on this element,
        // and go stright to the parent node.
        // Array check elements like:
        //  area --> area element is part of a map element and it can not be hidden because it is used to
        //           make an certian parts of an map interactive.
        //  param --> element can only be part of object elment and it cannot be hidden directly, it
        //            can only be hidden if the parent is hidden.
        //  audio --> If this element is hidden it will still play the music, so we should still trigger
        //            violations for this element.
        // In the case that unhideableElements array is not defined then we just scan all elements and do no filtering at all.
        if (VisUtil.unhideableElements === null || VisUtil.unhideableElements === undefined || VisUtil.unhideableElements.indexOf(nodeName) === -1) {
            // Check if defaultView exists for this node, if it does then use this to run the getComputedStyle
            // function to get the CSS style for the node.
            if (node.ownerDocument.defaultView) {
                // Run the getComputedStyle on this node to fetch the CSS compuation of the node
                compStyle = node.ownerDocument.defaultView.getComputedStyle(node, null);
            }
            // In the case that defaultView does not exists return true to identify that this
            // node is visible, because were not able to detect if it was not.
            else {
                CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_HIDDEN", true);
                return true;
            }
            // Get the hidden element property and hidden attribute
            var hiddenAttribute = node.getAttribute("hidden");
            var hiddenPropertyCustom = CacheUtil_1.CacheUtil.getCache(node, "PT_NODE_HIDDEN", undefined);
            // To get the hidden property we need to perform a special check as in some cases the hidden property will not be
            // a boolean, for theses cases we set it to false as we are not able to determine the true hidden condition.
            // The reason for this is because form elements are able to perform an override, so when we have id="hidden" for an element
            // which is under the form element then, node.hidden gives the element/list of elements which have id="hidden". Refer to
            // mozilla bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1267356
            var hiddenProperty = typeof node.hidden === "boolean" ? node.hidden : false;
            // If compStyle object is empty, node does't have hidden property, node does't have hidden attribute and does't have custom PT
            // hidden property then we can just return true (node visible) at this point.
            if (!compStyle &&
                !hiddenProperty && // this covers false, null, or undefined
                (hiddenAttribute === null || hiddenAttribute === undefined) &&
                !hiddenPropertyCustom // This covers false, null or undefined
            ) {
                CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_HIDDEN", true);
                return true;
            }
            // In the case that the compStyle is defined we check the following:
            //  CSS style display set to none
            //  CSS style visibility set to hidden
            //    Note: For this property since it is inherited, need to skip the check on parents as
            //          the parent can have hidden but the child can be visible. So we only check this property
            //          on child elements/elements that are passed to this function the first time.
            //  node hidden property set (node.hidden)
            //  node attribute hidden set (to any value)
            //  node custom hidden property ser (node.PT_NODE_HIDDEN)
            // If any of the above conditions are true then we return false as this element is not visible
            if ((compStyle !== null && ((compStyle.getPropertyValue('display') === 'none' ||
                (!CacheUtil_1.CacheUtil.getCache(node, "Visibility_Check_Parent", null) && compStyle.getPropertyValue('visibility') === 'hidden'))) ||
                (compStyle.getPropertyValue('display') !== 'block' && (hiddenProperty || hiddenAttribute != null || hiddenPropertyCustom)))) {
                // Set a custom expandos property on the the node to identify that it is hidden, so that we can uses
                // use this in the rules to determine if the node is hidden or not, if we need to.
                // Use expandos property instead of a hash map which stores the elements, adding/checking expandos
                // properties is a lot faster performance whise. For Hash map we need to store based on xpath, and to calculate
                // xpath it is more performance impact.
                CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_HIDDEN", false);
                return false;
            }
            // check content-visibility: if the content-visibility is hidden, then, return false as the element is not visible
            if (VisUtil.isContentHidden(node)) {
                CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_HIDDEN", false);
                return false;
            }
            // check hidden by clip-path
            // TODO: need to check if hidden content contains focusable elements, similarly to offscreen content
            if (ClipPathUtil_1.ClipPathUtil.isNodeVisuallyHiddenByClipPath(node)) {
                CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_HIDDEN", false);
                return false;
            }
        }
        // Get the parentNode for this node, becuase we have to check all parents to make sure they do not have
        // the hidden CSS, property or attribute. Only keep checking until we are all the way back to the parentNode
        // element.
        var parentElement = DOMWalker_1.DOMWalker.parentNode(node);
        // If the parent node exists and the nodetype is element (1), then run recursive call to perform the check
        // all the way up to the very parent node. Use recursive call here instead of a while loop so that we do not
        // have to duplicate the logic for checking if the node is visible or not for all the parents starting with
        // child node.
        if (parentElement != null && parentElement.nodeType === 1) {
            // When we have a parent element going through the isNodeVisible function we have to mark it as such
            // so that in the function we can skip checking visibility: hidden for parent elements since visibility: hidden
            // is inherited, which allows a child to have a different setting then the child. This property only needs to be checked
            // once for the first element that is passed down and that is all. Ignore it for all the parents that we iterate over.
            CacheUtil_1.CacheUtil.setCache(parentElement, "Visibility_Check_Parent", true);
            // Check upwards recursively, and save the results in an variable
            var nodeVisible = VisUtil.isNodeVisible(parentElement);
            // If the node is found to not be visible then add the custom PT_NODE_HIDDEN to true.
            // so that we can use this in the rules.
            // if (!nodeVisible) {
            //     CacheUtil.setCache(node, "PT_NODE_HIDDEN", true);
            // }
            // Check upwards recursively
            CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_HIDDEN", nodeVisible);
            return nodeVisible;
        }
        // Return true (node is visible)
        CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_HIDDEN", true);
        return true;
    };
    /**
     * This function is responsible for checking if the node that is visually hidden by clipping or opaq:
     *    1. Check if the current node is visually hidden:
     *       CSS --> clip: rect(0px, 0px, 0px, 0px)
     *       CSS --> opacity: 0
     *
     *    Note: If either current node or any of the parent nodes are visually hidden then this
     *          function will return true (node is not visually hidden).
     *
     *    Note: nodes with CSS properties clip: rect(0px, 0px, 0px, 0px) or opacity:0 or filter:opacity(0%), or similar SVG mechanisms:
     *      They are not considered hidden to an AT. Text hidden with these methods can still be selected or copied,
     *      and user agents still expose it in their accessibility trees.
     *
     * @parm {element} node The node which should be checked if it is visually hidden or not.
     * @return {bool} true if the node is visually hidden, false otherwise
     *
     * @memberOf VisUtil
     */
    VisUtil.isNodeVisuallyHidden = function (node) {
        if (!node || node.nodeType !== 1)
            return false;
        var elem = node;
        // Set PT_NODE_HIDDEN to false for all the nodes, before the check and this will be changed to
        // true when we detect that the node is hidden. We have to set it to false so that we know
        // the rules has already been checked.
        var hidden = CacheUtil_1.CacheUtil.getCache(elem, "PT_NODE_VISUALLY_HIDDEN", undefined);
        if (hidden === undefined) {
            // defined styles only give the styles that changed
            var defined_styles = CSSUtil_1.CSSUtil.getDefinedStyles(elem);
            if ((defined_styles['position'] === 'absolute' && defined_styles['clip'] && defined_styles['clip'].replaceAll(' ', '') === 'rect(0px,0px,0px,0px)')
                || (defined_styles['opacity'] && parseFloat(defined_styles['opacity']) < 0.1)) {
                CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN", true);
                return true;
            }
            // Get the parentNode for this node, becuase we have to check all parents to make sure they do not have
            // the hidden CSS, property or attribute. Only keep checking until we are all the way back to the parentNode
            // element.
            var parentElement = DOMWalker_1.DOMWalker.parentElement(elem);
            if (!parentElement)
                return false;
            // Check upwards recursively
            var hid = VisUtil.isNodeVisuallyHidden(parentElement);
            CacheUtil_1.CacheUtil.setCache(elem, "PT_NODE_VISUALLY_HIDDEN", hid);
            return hid;
        }
        return hidden;
    };
    /**
     * return true if the node or its ancestor is hidden by CSS content-visibility:hidden
     * At this time, CSS content-visibility is partially supported by Chrome & Edge, but not supported by Firefox
     * The implementation TEMPORARILY follows the Chrome test results:
     *   if content-visibility:hidden
     *      if the element is block-level (default or specified by the user), then the element and its children are normally hidden;
     *      if the element is inline (default or specified by the user), then the element and its children are normally NOT hidden;
     *
     * @param node
     */
    VisUtil.isContentHidden = function (node) {
        if (!node)
            return false;
        var vis = CacheUtil_1.CacheUtil.getCache(node, "PT_NODE_ContentHidden", undefined);
        if (vis !== undefined)
            return vis;
        var style = getComputedStyle(node);
        if (!style) {
            CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_ContentHidden", false);
            return false;
        }
        var content_visibility = style.getPropertyValue("content-visibility");
        if (content_visibility !== 'hidden') {
            CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_ContentHidden", false);
            return false;
        }
        var display = style.getPropertyValue("display");
        // inline element only
        if (display === 'inline') {
            CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_ContentHidden", false);
            return false;
        }
        CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_ContentHidden", true);
        return true;
    };
    /**
     * return true if the node is offscreen by CSS position
     * @param node
     */
    VisUtil.isElementOffscreen = function (node) {
        if (!node)
            return true;
        if (node.nodeType !== 1)
            return false;
        var vis = CacheUtil_1.CacheUtil.getCache(node, "PT_NODE_Offscreen", undefined);
        if (vis !== undefined)
            return vis;
        var mapper = new DOMMapper_1.DOMMapper();
        var bounds = mapper.getUnadjustedBounds(node);
        if (!bounds) {
            CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_Offscreen", true);
            return true;
        }
        if (bounds['height'] === 0 || bounds['width'] === 0 || (bounds['top'] + bounds['height']) <= 0 || (bounds['left'] + bounds['width']) <= 0) {
            CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_Offscreen", true);
            return true;
        }
        CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_Offscreen", false);
        return false;
    };
    /**
     * return true if the node or its ancestor is natively hidden or aria-hidden = 'true'
     * @param node
     */
    VisUtil.isNodeHiddenFromAT = function (node) {
        if (!node)
            return false;
        var vis = CacheUtil_1.CacheUtil.getCache(node, "PT_NODE_HiddenFromAT", undefined);
        if (vis !== undefined)
            return vis;
        if (!VisUtil.isNodeVisible(node) || node.getAttribute("aria-hidden") === 'true') {
            CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_HiddenFromAT", true);
            return true;
        }
        var ancestor = DOMUtil_1.DOMUtil.getAncestorWithAttribute(node, "aria-hidden", "true");
        if (ancestor) {
            CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_HiddenFromAT", true);
            return true;
        }
        CacheUtil_1.CacheUtil.setCache(node, "PT_NODE_HiddenFromAT", false);
        return false;
    };
    /**
     * return true if the node or its ancestor is natively hidden or aria-hidden = 'true'
     * @param node
     */
    VisUtil.isNodePresentational = function (node) {
        var role = AriaUtil_1.AriaUtil.getResolvedRole(node);
        if (role && (role === 'none' || role === 'presentation'))
            return true;
        return false;
    };
    /**
     * return true if the element is scrollable
     * @param node
     */
    VisUtil.isElementScrollable = function (elem) {
        if (!elem)
            return false;
        var styles = CSSUtil_1.CSSUtil.getComputedStyle(elem);
        if (!styles)
            return false;
        var x_scroll = styles.getPropertyValue('overflow-x');
        var y_scroll = styles.getPropertyValue('overflow-y');
        //console.log("before node="+ elem.nodeName +", id="+elem.getAttribute("id") +", x_scroll="+x_scroll + ", y_scroll="+y_scroll);
        // If overflow-y is hidden, scroll, or auto, and the overflow-x property is visible (default), the value will be implicitly computed as auto.
        if (x_scroll === 'visible' && (y_scroll === 'hidden' || y_scroll === 'scroll' || y_scroll === 'auto'))
            x_scroll = 'auto';
        // If overflow-x is hidden, scroll, or auto and the overflow-y property is visible (default), the value will be implicitly computed as auto.
        if (y_scroll === 'visible' && (x_scroll === 'hidden' || x_scroll === 'scroll' || x_scroll === 'auto'))
            y_scroll = 'auto';
        // setting overflow to clip in one direction when it isn't set to visible or clip in the other direction results in the clip value behaving as hidden. 
        if (x_scroll === 'clip' && y_scroll !== 'visible' && y_scroll !== 'clip')
            x_scroll = 'hidden';
        if (y_scroll === 'clip' && x_scroll !== 'visible' && x_scroll !== 'clip')
            y_scroll = 'hidden';
        // not scrollable: no scroll bars
        if ((x_scroll === 'visible' || x_scroll === 'hidden' || x_scroll === 'clip')
            && (y_scroll === 'visible' || y_scroll === 'hidden' || y_scroll === 'clip'))
            return false;
        // false if the overall scrollable element (clientWidth + scrollbarWidth and clientHeight + scrollbarHeight) is too small to be visible on screen
        if (Math.max(elem.offsetWidth, elem.offsetHeight) < 30 || Math.min(elem.offsetWidth, elem.offsetHeight) < 15)
            return false;
        // false if content is smaller than the scrollable container: both x and y scroll distances < element's horizontal/vertical padding
        var padding_x = CSSUtil_1.CSSUtil.getPixelsFromStyle(styles.paddingLeft, elem) + CSSUtil_1.CSSUtil.getPixelsFromStyle(styles.paddingRight, elem);
        var padding_y = CSSUtil_1.CSSUtil.getPixelsFromStyle(styles.paddingTop, elem) + CSSUtil_1.CSSUtil.getPixelsFromStyle(styles.paddingBottom, elem);
        if (elem.scrollWidth - elem.clientWidth < 1 + padding_x
            && elem.scrollHeight - elem.clientHeight < 1 + padding_y)
            return false;
        return true;
    };
    // This list contains a list of element tags which can not be hidden, when hidden is
    // added to theses elements it does not do anything at all.
    //  area --> area element is part of a map element and it can not be hidden because it is used to
    //           make an certian parts of an map interactive.
    //  param --> element can only be part of object elment and it cannot be hidden directly, it
    //            can only be hidden if the parent is hidden.
    //  audio --> If this element is hidden it will still play the music, so we should still trigger
    //            violations for this element.
    // Note: All element tags that are added here should be added as lowercase, as we are using indexOf to do the check.
    VisUtil.unhideableElements = ['area', 'param', 'audio'];
    // This list contains a list of elements tags which have display: none by default, since we have rules triggering
    // on theses elements we need to make then visible by default so that the rules can trigger regardless of the
    // Check Hidden Content option in the tools.
    //  script --> script elements have display: none by default
    //  link --> link elements have display: none by default, but the actually CSS script is still executed so we have to
    //            mark this element as visible at all times.
    //  style --> style elements have display: none by default, but the actually CSS script is still executed so we have to
    //            mark this element as visible at all times.
    //  head --> head elements have display: none by default, but it will still behave correct
    //  title --> title elements have display: none by default, but it will still display the title. remove title from the list because a title can be a child of a svg element too
    //  meta --> meta elements have display: none by default, but it will still perform the action that meta is suppose to
    //  base --> base elements have display: none by default, but it will still perform the action that meta is suppose to
    //  noscript --> noscript elements have display: none by default, but it will still perform the action that meta is suppose to
    //  template --> template elements have display: none by default, because they are just a mechanism for holding client-side content
    //               that is not to be rendered when a page is loaded. https://developer.mozilla.org/en/docs/Web/HTML/Element/template
    //  datalist --> datalist elements have display: none by default,
    VisUtil.hiddenByDefaultElements = ['script', 'link', 'style', 'head', 'meta', 'base', 'noscript', 'template', 'datalist'];
    return VisUtil;
}());
exports.VisUtil = VisUtil;


/***/ }),

/***/ 4976:
/***/ ((module) => {

module.exports = JSON.parse('{"1.1.1":{"num":"1.1.1","url":"https://www.w3.org/TR/WCAG22/#non-text-content","scId":"WCAG2:non-text-content","scAltId":["text-equiv-all"],"test":"WCAG2:text-equiv-all","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#non-text-content","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/non-text-content.html","handle":"Non-text Content","level":"A","wcagType":"2.0"},"1.2.1":{"num":"1.2.1","url":"https://www.w3.org/TR/WCAG22/#audio-only-and-video-only-prerecorded","scId":"WCAG2:audio-only-and-video-only-prerecorded","scAltId":["media-equiv-av-only-alt"],"test":"WCAG2:media-equiv-av-only-alt","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#audio-only-and-video-only-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/audio-only-and-video-only-prerecorded.html","handle":"Audio-only and Video-only (Prerecorded)","level":"A","wcagType":"2.0"},"1.2.2":{"num":"1.2.2","url":"https://www.w3.org/TR/WCAG22/#captions-prerecorded","scId":"WCAG2:captions-prerecorded","scAltId":["media-equiv-captions"],"test":"WCAG2:media-equiv-captions","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#captions-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/captions-prerecorded.html","handle":"Captions (Prerecorded)","level":"A","wcagType":"2.0"},"1.2.3":{"num":"1.2.3","url":"https://www.w3.org/TR/WCAG22/#audio-description-or-media-alternative-prerecorded","scId":"WCAG2:audio-description-or-media-alternative-prerecorded","scAltId":["media-equiv-audio-desc"],"test":"WCAG2:media-equiv-audio-desc","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#audio-description-or-media-alternative-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/audio-description-or-media-alternative-prerecorded.html","handle":"Audio Description or Media Alternative (Prerecorded)","level":"A","wcagType":"2.0"},"1.2.4":{"num":"1.2.4","url":"https://www.w3.org/TR/WCAG22/#captions-live","scId":"WCAG2:captions-live","scAltId":["media-equiv-real-time-captions"],"test":"WCAG2:media-equiv-real-time-captions","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#captions-live","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/captions-live.html","handle":"Captions (Live)","level":"AA","wcagType":"2.0"},"1.2.5":{"num":"1.2.5","url":"https://www.w3.org/TR/WCAG22/#audio-description-prerecorded","scId":"WCAG2:audio-description-prerecorded","scAltId":["media-equiv-audio-desc-only"],"test":"WCAG2:media-equiv-audio-desc-only","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#audio-description-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/audio-description-prerecorded.html","handle":"Audio Description (Prerecorded)","level":"AA","wcagType":"2.0"},"1.2.6":{"num":"1.2.6","url":"https://www.w3.org/TR/WCAG22/#sign-language-prerecorded","scId":"WCAG2:sign-language-prerecorded","scAltId":["media-equiv-sign"],"test":"WCAG2:media-equiv-sign","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#sign-language-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/sign-language-prerecorded.html","handle":"Sign Language (Prerecorded)","level":"AAA","wcagType":"2.0"},"1.2.7":{"num":"1.2.7","url":"https://www.w3.org/TR/WCAG22/#extended-audio-description-prerecorded","scId":"WCAG2:extended-audio-description-prerecorded","scAltId":["media-equiv-extended-ad"],"test":"WCAG2:media-equiv-extended-ad","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#extended-audio-description-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/extended-audio-description-prerecorded.html","handle":"Extended Audio Description (Prerecorded)","level":"AAA","wcagType":"2.0"},"1.2.8":{"num":"1.2.8","url":"https://www.w3.org/TR/WCAG22/#media-alternative-prerecorded","scId":"WCAG2:media-alternative-prerecorded","scAltId":["media-equiv-text-doc"],"test":"WCAG2:media-equiv-text-doc","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#media-alternative-prerecorded","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/media-alternative-prerecorded.html","handle":"Media Alternative (Prerecorded)","level":"AAA","wcagType":"2.0"},"1.2.9":{"num":"1.2.9","url":"https://www.w3.org/TR/WCAG22/#audio-only-live","scId":"WCAG2:audio-only-live","scAltId":["media-equiv-live-audio-only"],"test":"WCAG2:media-equiv-live-audio-only","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#audio-only-live","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/audio-only-live.html","handle":"Audio-only (Live)","level":"AAA","wcagType":"2.0"},"1.3.1":{"num":"1.3.1","url":"https://www.w3.org/TR/WCAG22/#info-and-relationships","scId":"WCAG2:info-and-relationships","scAltId":["content-structure-separation-programmatic"],"test":"WCAG2:content-structure-separation-programmatic","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#info-and-relationships","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html","handle":"Info and Relationships","level":"A","wcagType":"2.0"},"1.3.2":{"num":"1.3.2","url":"https://www.w3.org/TR/WCAG22/#meaningful-sequence","scId":"WCAG2:meaningful-sequence","scAltId":["content-structure-separation-sequence"],"test":"WCAG2:content-structure-separation-sequence","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#meaningful-sequence","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/meaningful-sequence.html","handle":"Meaningful Sequence","level":"A","wcagType":"2.0"},"1.3.3":{"num":"1.3.3","url":"https://www.w3.org/TR/WCAG22/#sensory-characteristics","scId":"WCAG2:sensory-characteristics","scAltId":["content-structure-separation-understanding"],"test":"WCAG2:content-structure-separation-understanding","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#sensory-characteristics","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/sensory-characteristics.html","handle":"Sensory Characteristics","level":"A","wcagType":"2.0"},"1.3.4":{"num":"1.3.4","url":"https://www.w3.org/TR/WCAG22/#orientation","scId":"WCAG2:orientation","scAltId":[],"test":"WCAG2:orientation","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#orientation","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/orientation.html","handle":"Orientation","level":"AA","wcagType":"2.1"},"1.3.5":{"num":"1.3.5","url":"https://www.w3.org/TR/WCAG22/#identify-input-purpose","scId":"WCAG2:identify-input-purpose","scAltId":[],"test":"WCAG2:identify-input-purpose","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#identify-input-purpose","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/identify-input-purpose.html","handle":"Identify Input Purpose","level":"AA","wcagType":"2.1"},"1.3.6":{"num":"1.3.6","url":"https://www.w3.org/TR/WCAG22/#identify-purpose","scId":"WCAG2:identify-purpose","scAltId":[],"test":"WCAG2:identify-purpose","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#identify-purpose","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/identify-purpose.html","handle":"Identify Purpose","level":"AAA","wcagType":"2.1"},"1.4.1":{"num":"1.4.1","url":"https://www.w3.org/TR/WCAG22/#use-of-color","scId":"WCAG2:use-of-color","scAltId":["visual-audio-contrast-without-color"],"test":"WCAG2:visual-audio-contrast-without-color","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#use-of-color","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/use-of-color.html","handle":"Use of Color","level":"A","wcagType":"2.0"},"1.4.2":{"num":"1.4.2","url":"https://www.w3.org/TR/WCAG22/#audio-control","scId":"WCAG2:audio-control","scAltId":["visual-audio-contrast-dis-audio"],"test":"WCAG2:visual-audio-contrast-dis-audio","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#audio-control","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/audio-control.html","handle":"Audio Control","level":"A","wcagType":"2.0"},"1.4.3":{"num":"1.4.3","url":"https://www.w3.org/TR/WCAG22/#contrast-minimum","scId":"WCAG2:contrast-minimum","scAltId":["visual-audio-contrast-contrast"],"test":"WCAG2:visual-audio-contrast-contrast","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#contrast-minimum","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/contrast-minimum.html","handle":"Contrast (Minimum)","level":"AA","wcagType":"2.0"},"1.4.4":{"num":"1.4.4","url":"https://www.w3.org/TR/WCAG22/#resize-text","scId":"WCAG2:resize-text","scAltId":["visual-audio-contrast-scale"],"test":"WCAG2:visual-audio-contrast-scale","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#resize-text","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/resize-text.html","handle":"Resize text","level":"AA","wcagType":"2.0"},"1.4.5":{"num":"1.4.5","url":"https://www.w3.org/TR/WCAG22/#images-of-text","scId":"WCAG2:images-of-text","scAltId":["visual-audio-contrast-text-presentation"],"test":"WCAG2:visual-audio-contrast-text-presentation","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#images-of-text","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/images-of-text.html","handle":"Images of Text","level":"AA","wcagType":"2.0"},"1.4.6":{"num":"1.4.6","url":"https://www.w3.org/TR/WCAG22/#contrast-enhanced","scId":"WCAG2:contrast-enhanced","scAltId":["visual-audio-contrast7"],"test":"WCAG2:visual-audio-contrast7","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#contrast-enhanced","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/contrast-enhanced.html","handle":"Contrast (Enhanced)","level":"AAA","wcagType":"2.0"},"1.4.7":{"num":"1.4.7","url":"https://www.w3.org/TR/WCAG22/#low-or-no-background-audio","scId":"WCAG2:low-or-no-background-audio","scAltId":["visual-audio-contrast-noaudio"],"test":"WCAG2:visual-audio-contrast-noaudio","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#low-or-no-background-audio","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/low-or-no-background-audio.html","handle":"Low or No Background Audio","level":"AAA","wcagType":"2.0"},"1.4.8":{"num":"1.4.8","url":"https://www.w3.org/TR/WCAG22/#visual-presentation","scId":"WCAG2:visual-presentation","scAltId":["visual-audio-contrast-visual-presentation"],"test":"WCAG2:visual-audio-contrast-visual-presentation","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#visual-presentation","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/visual-presentation.html","handle":"Visual Presentation","level":"AAA","wcagType":"2.0"},"1.4.9":{"num":"1.4.9","url":"https://www.w3.org/TR/WCAG22/#images-of-text-no-exception","scId":"WCAG2:images-of-text-no-exception","scAltId":["visual-audio-contrast-text-images"],"test":"WCAG2:visual-audio-contrast-text-images","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#images-of-text-no-exception","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/images-of-text-no-exception.html","handle":"Images of Text (No Exception)","level":"AAA","wcagType":"2.0"},"1.4.10":{"num":"1.4.10","url":"https://www.w3.org/TR/WCAG22/#reflow","scId":"WCAG2:reflow","scAltId":[],"test":"WCAG2:reflow","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#reflow","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/reflow.html","handle":"Reflow","level":"AA","wcagType":"2.1"},"1.4.11":{"num":"1.4.11","url":"https://www.w3.org/TR/WCAG22/#non-text-contrast","scId":"WCAG2:non-text-contrast","scAltId":[],"test":"WCAG2:non-text-contrast","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#non-text-contrast","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/non-text-contrast.html","handle":"Non-text Contrast","level":"AA","wcagType":"2.1"},"1.4.12":{"num":"1.4.12","url":"https://www.w3.org/TR/WCAG22/#text-spacing","scId":"WCAG2:text-spacing","scAltId":[],"test":"WCAG2:text-spacing","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#text-spacing","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/text-spacing.html","handle":"Text Spacing","level":"AA","wcagType":"2.1"},"1.4.13":{"num":"1.4.13","url":"https://www.w3.org/TR/WCAG22/#content-on-hover-or-focus","scId":"WCAG2:content-on-hover-or-focus","scAltId":[],"test":"WCAG2:content-on-hover-or-focus","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#content-on-hover-or-focus","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/content-on-hover-or-focus.html","handle":"Content on Hover or Focus","level":"AA","wcagType":"2.1"},"2.1.1":{"num":"2.1.1","url":"https://www.w3.org/TR/WCAG22/#keyboard","scId":"WCAG2:keyboard","scAltId":["keyboard-operation-keyboard-operable"],"test":"WCAG2:keyboard-operation-keyboard-operable","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#keyboard","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/keyboard.html","handle":"Keyboard","level":"A","wcagType":"2.0"},"2.1.2":{"num":"2.1.2","url":"https://www.w3.org/TR/WCAG22/#no-keyboard-trap","scId":"WCAG2:no-keyboard-trap","scAltId":["keyboard-operation-trapping"],"test":"WCAG2:keyboard-operation-trapping","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#no-keyboard-trap","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/no-keyboard-trap.html","handle":"No Keyboard Trap","level":"A","wcagType":"2.0"},"2.1.3":{"num":"2.1.3","url":"https://www.w3.org/TR/WCAG22/#keyboard-no-exception","scId":"WCAG2:keyboard-no-exception","scAltId":["keyboard-operation-all-funcs"],"test":"WCAG2:keyboard-operation-all-funcs","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#keyboard-no-exception","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/keyboard-no-exception.html","handle":"Keyboard (No Exception)","level":"AAA","wcagType":"2.0"},"2.1.4":{"num":"2.1.4","url":"https://www.w3.org/TR/WCAG22/#character-key-shortcuts","scId":"WCAG2:character-key-shortcuts","scAltId":[],"test":"WCAG2:WCAG2:character-key-shortcuts","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#character-key-shortcuts","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/character-key-shortcuts.html","handle":"Character Key Shortcuts","level":"A","wcagType":"2.1"},"2.2.1":{"num":"2.2.1","url":"https://www.w3.org/TR/WCAG22/#timing-adjustable","scId":"WCAG2:timing-adjustable","scAltId":["time-limits-required-behaviors"],"test":"WCAG2:time-limits-required-behaviors","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#timing-adjustable","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/timing-adjustable.html","handle":"Timing Adjustable","level":"A","wcagType":"2.0"},"2.2.2":{"num":"2.2.2","url":"https://www.w3.org/TR/WCAG22/#pause-stop-hide","scId":"WCAG2:pause-stop-hide","scAltId":["time-limits-pause"],"test":"WCAG2:time-limits-pause","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#pause-stop-hide","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/pause-stop-hide.html","handle":"Pause, Stop, Hide","level":"A","wcagType":"2.0"},"2.2.3":{"num":"2.2.3","url":"https://www.w3.org/TR/WCAG22/#no-timing","scId":"WCAG2:no-timing","scAltId":["time-limits-no-exceptions"],"test":"WCAG2:time-limits-no-exceptions","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#no-timing","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/no-timing.html","handle":"No Timing","level":"AAA","wcagType":"2.0"},"2.2.4":{"num":"2.2.4","url":"https://www.w3.org/TR/WCAG22/#interruptions","scId":"WCAG2:interruptions","scAltId":["time-limits-postponed"],"test":"WCAG2:time-limits-postponed","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#interruptions","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/interruptions.html","handle":"Interruptions","level":"AAA","wcagType":"2.0"},"2.2.5":{"num":"2.2.5","url":"https://www.w3.org/TR/WCAG22/#re-authenticating","scId":"WCAG2:re-authenticating","scAltId":["time-limits-server-timeout"],"test":"WCAG2:time-limits-server-timeout","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#re-authenticating","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/re-authenticating.html","handle":"Re-authenticating","level":"AAA","wcagType":"2.0"},"2.2.6":{"num":"2.2.6","url":"https://www.w3.org/TR/WCAG22/#timeouts","scId":"WCAG2:timeouts","scAltId":[],"test":"WCAG2:WCAG2:timeouts","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#timeouts","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/timeouts.html","handle":"Timeouts","level":"AAA","wcagType":"2.1"},"2.3.1":{"num":"2.3.1","url":"https://www.w3.org/TR/WCAG22/#three-flashes-or-below-threshold","scId":"WCAG2:three-flashes-or-below-threshold","scAltId":["seizure-does-not-violate"],"test":"WCAG2:seizure-does-not-violate","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#three-flashes-or-below-threshold","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/three-flashes-or-below-threshold.html","handle":"Three Flashes or Below Threshold","level":"A","wcagType":"2.0"},"2.3.2":{"num":"2.3.2","url":"https://www.w3.org/TR/WCAG22/#three-flashes","scId":"WCAG2:three-flashes","scAltId":["seizure-three-times"],"test":"WCAG2:seizure-three-times","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#three-flashes","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/three-flashes.html","handle":"Three Flashes","level":"AAA","wcagType":"2.0"},"2.3.3":{"num":"2.3.3","url":"https://www.w3.org/TR/WCAG22/#animation-from-interactions","scId":"WCAG2:animation-from-interactions","scAltId":[],"test":"WCAG2:WCAG2:animation-from-interactions","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#animation-from-interactions","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/animation-from-interactions.html","handle":"Animation from Interactions","level":"AAA","wcagType":"2.1"},"2.4.1":{"num":"2.4.1","url":"https://www.w3.org/TR/WCAG22/#bypass-blocks","scId":"WCAG2:bypass-blocks","scAltId":["navigation-mechanisms-skip"],"test":"WCAG2:navigation-mechanisms-skip","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#bypass-blocks","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/bypass-blocks.html","handle":"Bypass Blocks","level":"A","wcagType":"2.0"},"2.4.2":{"num":"2.4.2","url":"https://www.w3.org/TR/WCAG22/#page-titled","scId":"WCAG2:page-titled","scAltId":["navigation-mechanisms-title"],"test":"WCAG2:navigation-mechanisms-title","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#page-titled","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/page-titled.html","handle":"Page Titled","level":"A","wcagType":"2.0"},"2.4.3":{"num":"2.4.3","url":"https://www.w3.org/TR/WCAG22/#focus-order","scId":"WCAG2:focus-order","scAltId":["navigation-mechanisms-focus-order"],"test":"WCAG2:navigation-mechanisms-focus-order","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#focus-order","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/focus-order.html","handle":"Focus Order","level":"A","wcagType":"2.0"},"2.4.4":{"num":"2.4.4","url":"https://www.w3.org/TR/WCAG22/#link-purpose-in-context","scId":"WCAG2:link-purpose-in-context","scAltId":["navigation-mechanisms-refs"],"test":"WCAG2:navigation-mechanisms-refs","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#link-purpose-in-context","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/link-purpose-in-context.html","handle":"Link Purpose (In Context)","level":"A","wcagType":"2.0"},"2.4.5":{"num":"2.4.5","url":"https://www.w3.org/TR/WCAG22/#multiple-ways","scId":"WCAG2:multiple-ways","scAltId":["navigation-mechanisms-mult-loc"],"test":"WCAG2:navigation-mechanisms-mult-loc","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#multiple-ways","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/multiple-ways.html","handle":"Multiple Ways","level":"AA","wcagType":"2.0"},"2.4.6":{"num":"2.4.6","url":"https://www.w3.org/TR/WCAG22/#headings-and-labels","scId":"WCAG2:headings-and-labels","scAltId":["navigation-mechanisms-descriptive"],"test":"WCAG2:navigation-mechanisms-descriptive","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#headings-and-labels","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/headings-and-labels.html","handle":"Headings and Labels","level":"AA","wcagType":"2.0"},"2.4.7":{"num":"2.4.7","url":"https://www.w3.org/TR/WCAG22/#focus-visible","scId":"WCAG2:focus-visible","scAltId":["navigation-mechanisms-focus-visible"],"test":"WCAG2:navigation-mechanisms-focus-visible","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#focus-visible","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/focus-visible.html","handle":"Focus Visible","level":"AA","wcagType":"2.0"},"2.4.8":{"num":"2.4.8","url":"https://www.w3.org/TR/WCAG22/#location","scId":"WCAG2:location","scAltId":["navigation-mechanisms-location"],"test":"WCAG2:navigation-mechanisms-location","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#location","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/location.html","handle":"Location","level":"AAA","wcagType":"2.0"},"2.4.9":{"num":"2.4.9","url":"https://www.w3.org/TR/WCAG22/#link-purpose-link-only","scId":"WCAG2:link-purpose-link-only","scAltId":["navigation-mechanisms-link"],"test":"WCAG2:navigation-mechanisms-link","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#link-purpose-link-only","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/link-purpose-link-only.html","handle":"Link Purpose (Link Only)","level":"AAA","wcagType":"2.0"},"2.4.10":{"num":"2.4.10","url":"https://www.w3.org/TR/WCAG22/#section-headings","scId":"WCAG2:section-headings","scAltId":["navigation-mechanisms-headings"],"test":"WCAG2:navigation-mechanisms-headings","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#section-headings","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/section-headings.html","handle":"Section Headings","level":"AAA","wcagType":"2.0"},"2.4.11":{"num":"2.4.11","url":"https://www.w3.org/TR/WCAG22/#focus-not-obscured-minimum","scId":"WCAG2:focus-not-obscured-minimum","scAltId":["focus-not-obscured-minimum-alt"],"test":"WCAG2:focus-not-obscured-minimum-test","howToMeetUrl":"https://www.w3.org/TR/WCAG22/#focus-not-obscured-minimum","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/focus-not-obscured-minimum.html","handle":"Focus Not Obscured (Minimum)","level":"AA","wcagType":"2.2"},"2.4.12":{"num":"2.4.12","url":"https://www.w3.org/TR/WCAG22/#focus-not-obscured-enhanced","scId":"WCAG2:focus-not-obscured-enhanced","scAltId":[],"test":"WCAG2:focus-not-obscured-enhanced-test","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#focus-not-obscured-enhanced","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/focus-not-obscured-enhanced.html","handle":"Focus Not Obscured (Enhanced)","level":"AAA","wcagType":"2.2"},"2.4.13":{"num":"2.4.13","url":"https://www.w3.org/TR/WCAG22/#focus-appearance","scId":"WCAG2:focus-appearance","scAltId":[],"test":"WCAG2:focus-appearance","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#focus-appearance","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/focus-appearance.html","handle":"Focus Appearance","level":"AAA","wcagType":"2.2"},"2.5.1":{"num":"2.5.1","url":"https://www.w3.org/TR/WCAG22/#pointer-gestures","scId":"WCAG2:pointer-gestures","scAltId":[],"test":"WCAG2:pointer-gestures-test","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#pointer-gestures","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/pointer-gestures.html","handle":"Pointer Gestures","level":"A","wcagType":"2.1"},"2.5.2":{"num":"2.5.2","url":"https://www.w3.org/TR/WCAG22/#pointer-cancellation","scId":"WCAG2:pointer-cancellation","scAltId":[],"test":"WCAG2:WCAG2:pointer-cancellation","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#pointer-cancellation","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/pointer-cancellation.html","handle":"Pointer Cancellation","level":"A","wcagType":"2.1"},"2.5.3":{"num":"2.5.3","url":"https://www.w3.org/TR/WCAG22/#label-in-name","scId":"WCAG2:label-in-name","scAltId":[],"test":"WCAG2:WCAG2:label-in-name","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#label-in-name","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/label-in-name.html","handle":"Label in Name","level":"A","wcagType":"2.1"},"2.5.4":{"num":"2.5.4","url":"https://www.w3.org/TR/WCAG22/#motion-actuation","scId":"WCAG2:motion-actuation","scAltId":[],"test":"WCAG2:WCAG2:motion-actuation","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#motion-actuation","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/motion-actuation.html","handle":"Motion Actuation","level":"A","wcagType":"2.1"},"2.5.5":{"num":"2.5.5","url":"https://www.w3.org/TR/WCAG22/#target-size","scId":"WCAG2:target-size","scAltId":[],"test":"WCAG2:WCAG2:target-size","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#target-size","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/target-size.html","handle":"Target Size","level":"AAA","wcagType":"2.1"},"2.5.6":{"num":"2.5.6","url":"https://www.w3.org/TR/WCAG22/#concurrent-input-mechanisms","scId":"WCAG2:concurrent-input-mechanisms","scAltId":[],"test":"WCAG2:WCAG2:concurrent-input-mechanisms","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#concurrent-input-mechanisms","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/concurrent-input-mechanisms.html","handle":"Concurrent Input Mechanisms","level":"AAA","wcagType":"2.1"},"2.5.7":{"num":"2.5.7","url":"https://www.w3.org/TR/WCAG22/#dragging-movements","scId":"WCAG2:dragging-movement","scAltId":["dragging-movement-alt"],"test":"WCAG2:dragging-movement-test","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/Understanding/dragging-movements.html","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/dragging-movements.html","handle":"Dragging Movement","level":"AA","wcagType":"2.2"},"2.5.8":{"num":"2.5.8","url":"https://www.w3.org/TR/WCAG22/#target-size-minimum","scId":"WCAG2:minimum-target-size","scAltId":["minimum-target-size-alt"],"test":"WCAG2:minimum-target-size-test","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#target-size-minimum","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/target-size-minimum.html","handle":"Minimum Target Size","level":"AA","wcagType":"2.2"},"3.1.1":{"num":"3.1.1","url":"https://www.w3.org/TR/WCAG22/#language-of-page","scId":"WCAG2:language-of-page","scAltId":["meaning-doc-lang-id"],"test":"WCAG2:meaning-doc-lang-id","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#language-of-page","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/language-of-page.html","handle":"Language of Page","level":"A","wcagType":"2.0"},"3.1.2":{"num":"3.1.2","url":"https://www.w3.org/TR/WCAG22/#language-of-parts","scId":"WCAG2:language-of-parts","scAltId":["meaning-other-lang-id"],"test":"WCAG2:meaning-other-lang-id","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#language-of-parts","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/language-of-parts.html","handle":"Language of Parts","level":"AA","wcagType":"2.0"},"3.1.3":{"num":"3.1.3","url":"https://www.w3.org/TR/WCAG22/#unusual-words","scId":"WCAG2:unusual-words","scAltId":["meaning-idioms"],"test":"WCAG2:meaning-idioms","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#unusual-words","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/unusual-words.html","handle":"Unusual Words","level":"AAA","wcagType":"2.0"},"3.1.4":{"num":"3.1.4","url":"https://www.w3.org/TR/WCAG22/#abbreviations","scId":"WCAG2:abbreviations","scAltId":["meaning-located"],"test":"WCAG2:meaning-located","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#abbreviations","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/abbreviations.html","handle":"Abbreviations","level":"AAA","wcagType":"2.0"},"3.1.5":{"num":"3.1.5","url":"https://www.w3.org/TR/WCAG22/#reading-level","scId":"WCAG2:reading-level","scAltId":["meaning-supplements"],"test":"WCAG2:meaning-supplements","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#reading-level","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/reading-level.html","handle":"Reading Level","level":"AAA","wcagType":"2.0"},"3.1.6":{"num":"3.1.6","url":"https://www.w3.org/TR/WCAG22/#pronunciation","scId":"WCAG2:pronunciation","scAltId":["meaning-pronunciation"],"test":"WCAG2:meaning-pronunciation","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#pronunciation","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/pronunciation.html","handle":"Pronunciation","level":"AAA","wcagType":"2.0"},"3.2.1":{"num":"3.2.1","url":"https://www.w3.org/TR/WCAG22/#on-focus","scId":"WCAG2:on-focus","scAltId":["consistent-behavior-receive-focus"],"test":"WCAG2:consistent-behavior-receive-focus","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#on-focus","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/on-focus.html","handle":"On Focus","level":"A","wcagType":"2.0"},"3.2.2":{"num":"3.2.2","url":"https://www.w3.org/TR/WCAG22/#on-input","scId":"WCAG2:on-input","scAltId":["consistent-behavior-unpredictable-change"],"test":"WCAG2:consistent-behavior-unpredictable-change","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#on-input","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/on-input.html","handle":"On Input","level":"A","wcagType":"2.0"},"3.2.3":{"num":"3.2.3","url":"https://www.w3.org/TR/WCAG22/#consistent-navigation","scId":"WCAG2:consistent-navigation","scAltId":["consistent-behavior-consistent-locations"],"test":"WCAG2:consistent-behavior-consistent-locations","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#consistent-navigation","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/consistent-navigation.html","handle":"Consistent Navigation","level":"AA","wcagType":"2.0"},"3.2.4":{"num":"3.2.4","url":"https://www.w3.org/TR/WCAG22/#consistent-identification","scId":"WCAG2:consistent-identification","scAltId":["consistent-behavior-consistent-functionality"],"test":"WCAG2:consistent-behavior-consistent-functionality","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#consistent-identification","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/consistent-identification.html","handle":"Consistent Identification","level":"AA","wcagType":"2.0"},"3.2.5":{"num":"3.2.5","url":"https://www.w3.org/TR/WCAG22/#change-on-request","scId":"WCAG2:change-on-request","scAltId":["consistent-behavior-no-extreme-changes-context"],"test":"WCAG2:consistent-behavior-no-extreme-changes-context","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#change-on-request","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/change-on-request.html","handle":"Change on Request","level":"AAA","wcagType":"2.0"},"3.2.6":{"num":"3.2.6","url":"https://www.w3.org/TR/WCAG22/#consistent-help","scId":"WCAG2:consistent-help","scAltId":["consistent-help-alt"],"test":"WCAG2:consistent-help-test","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#consistent-help","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/consistent-help.html","handle":"Consistent Help","level":"AA","wcagType":"2.2"},"3.3.1":{"num":"3.3.1","url":"https://www.w3.org/TR/WCAG22/#error-identification","scId":"WCAG2:error-identification","scAltId":["minimize-error-identified"],"test":"WCAG2:minimize-error-identified","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#error-identification","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/error-identification.html","handle":"Error Identification","level":"A","wcagType":"2.0"},"3.3.2":{"num":"3.3.2","url":"https://www.w3.org/TR/WCAG22/#labels-or-instructions","scId":"WCAG2:labels-or-instructions","scAltId":["minimize-error-cues"],"test":"WCAG2:minimize-error-cues","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#labels-or-instructions","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/labels-or-instructions.html","handle":"Labels or Instructions","level":"A","wcagType":"2.0"},"3.3.3":{"num":"3.3.3","url":"https://www.w3.org/TR/WCAG22/#error-suggestion","scId":"WCAG2:error-suggestion","scAltId":["minimize-error-suggestions"],"test":"WCAG2:minimize-error-suggestions","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#error-suggestion","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/error-suggestion.html","handle":"Error Suggestion","level":"AA","wcagType":"2.0"},"3.3.4":{"num":"3.3.4","url":"https://www.w3.org/TR/WCAG22/#error-prevention-legal-financial-data","scId":"WCAG2:error-prevention-legal-financial-data","scAltId":["minimize-error-reversible"],"test":"WCAG2:minimize-error-reversible","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#error-prevention-legal-financial-data","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/error-prevention-legal-financial-data.html","handle":"Error Prevention (Legal, Financial, Data)","level":"AA","wcagType":"2.0"},"3.3.5":{"num":"3.3.5","url":"https://www.w3.org/TR/WCAG22/#help","scId":"WCAG2:help","scAltId":["minimize-error-context-help"],"test":"WCAG2:minimize-error-context-help","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#help","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/help.html","handle":"Help","level":"AAA","wcagType":"2.0"},"3.3.6":{"num":"3.3.6","url":"https://www.w3.org/TR/WCAG22/#error-prevention-all","scId":"WCAG2:error-prevention-all","scAltId":["minimize-error-reversible-all"],"test":"WCAG2:minimize-error-reversible-all","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#error-prevention-all","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/error-prevention-all.html","handle":"Error Prevention (All)","level":"AAA","wcagType":"2.0"},"3.3.7":{"num":"3.3.7","url":"https://www.w3.org/TR/WCAG22/#redundant-entry","scId":"WCAG2:redundant-entry","scAltId":["redundant-entry-alt"],"test":"WCAG2:redundant-entry-test","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#redundant-entry","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/redundant-entry.html","handle":"Redundant Entry","level":"AA","wcagType":"2.2"},"3.3.8":{"num":"3.3.8","url":"https://www.w3.org/TR/WCAG22/#accessible-authentication-minimum","scId":"WCAG2:accessible-authentication-minimum","scAltId":["accessible-authentication-minimum-alt"],"test":"WCAG2:accessible-authentication-minimum-test","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#accessible-authentication-minimum","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/accessible-authentication-minimum.html","handle":"Accessible Authentication (Minimum)","level":"AA","wcagType":"2.2"},"3.3.9":{"num":"3.3.9","url":"https://www.w3.org/TR/WCAG22/#accessible-authentication-enhanced","scId":"WCAG2:accessible-authentication-enhanced","scAltId":[],"test":"WCAG2:accessible-authentication-enhanced","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#accessible-authentication-enhanced","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/accessible-authentication-enhanced.html","handle":"Accessible Authentication (Enhanced)","level":"AAA","wcagType":"2.2"},"4.1.1":{"num":"4.1.1","url":"https://www.w3.org/TR/WCAG22/#parsing","scId":"WCAG2:parsing","scAltId":["ensure-compat-parses"],"test":"WCAG2:ensure-compat-parses","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/?versions=2.1#parsing","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/parsing.html","handle":"Parsing","level":"A","wcagType":"2.0"},"4.1.2":{"num":"4.1.2","url":"https://www.w3.org/TR/WCAG22/#name-role-value","scId":"WCAG2:name-role-value","scAltId":["ensure-compat-rsv"],"test":"WCAG2:ensure-compat-rsv","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#name-role-value","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/name-role-value.html","handle":"Name, Role, Value","level":"A","wcagType":"2.0"},"4.1.3":{"num":"4.1.3","url":"https://www.w3.org/TR/WCAG22/#status-messages","scId":"WCAG2:status-messages","scAltId":[],"test":"WCAG2:status-messages","howToMeetUrl":"https://www.w3.org/WAI/WCAG22/quickref/#status-messages","understandingUrl":"https://www.w3.org/WAI/WCAG22/Understanding/status-messages.html","handle":"Status Messages","level":"AA","wcagType":"2.1"},"HTML":{"num":"HTML","url":"https://html.spec.whatwg.org/multipage/","scId":"","scAltId":[],"test":"","howToMeetUrl":"https://html.spec.whatwg.org/multipage/","understandingUrl":"https://html.spec.whatwg.org/multipage/","handle":"specification","level":"NA","wcagType":"NA"},"ARIA":{"num":"ARIA","url":"https://www.w3.org/TR/wai-aria-1.2/","scId":"","scAltId":[],"test":"","howToMeetUrl":"https://www.w3.org/TR/wai-aria-1.2/","understandingUrl":"https://www.w3.org/TR/wai-aria-1.2/","handle":"specification","level":"NA","wcagType":"NA"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;

/******************************************************************************
     Copyright:: 2020- IBM, Inc

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 *****************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkDemo = exports.DOMWalker = exports.Config = exports.ARIAMapper = exports.Checker = exports.Context = void 0;
var Context_1 = __webpack_require__(2306);
Object.defineProperty(exports, "Context", ({ enumerable: true, get: function () { return Context_1.Context; } }));
// import { Simulator } from "./v2/simulator"
var Checker_1 = __webpack_require__(7884);
Object.defineProperty(exports, "Checker", ({ enumerable: true, get: function () { return Checker_1.Checker; } }));
var ARIAMapper_1 = __webpack_require__(4944);
Object.defineProperty(exports, "ARIAMapper", ({ enumerable: true, get: function () { return ARIAMapper_1.ARIAMapper; } }));
var Config_1 = __webpack_require__(3962);
Object.defineProperty(exports, "Config", ({ enumerable: true, get: function () { return Config_1.Config; } }));
var DOMWalker_1 = __webpack_require__(7440);
Object.defineProperty(exports, "DOMWalker", ({ enumerable: true, get: function () { return DOMWalker_1.DOMWalker; } }));
String.prototype.startsWith = String.prototype.startsWith || function (str) {
    return this.indexOf(str) === 0;
};
String.prototype.includes = String.prototype.includes || function (str) {
    return this.indexOf(str) !== -1;
};
Array.prototype.includes = Array.prototype.includes || function (str) {
    return this.indexOf(str) !== -1;
};
function checkDemo(timeout) {
    if (!timeout)
        timeout = 0;
    var checker = new Checker_1.Checker();
    setTimeout(function () {
        checker.check(document.documentElement, ["IBM_Accessibility", "IBM_Design"])
            .then(function (report) {
            console.log(report);
            var vals = {
                "FAIL": 0,
                "POTENTIAL": 1,
                "MANUAL": 2,
                "PASS": 3
            };
            for (var idx = 0; idx < report.results.length; ++idx) {
                if (report.results[idx].value[1] === "PASS") {
                    report.results.splice(idx--, 1);
                }
            }
            report.results.sort(function (a, b) {
                if (a.category != b.category) {
                    return a.category.localeCompare(b.category);
                }
                if (a.path["aria"] === b.path["aria"]) {
                    return vals[a.value[1]] - vals[b.value[1]];
                }
                return a.path["aria"].localeCompare(b.path["aria"]);
            });
            var lastPath = null;
            var category = null;
            for (var _i = 0, _a = report.results; _i < _a.length; _i++) {
                var result = _a[_i];
                if (category !== result.category) {
                    if (category !== null) {
                        console.groupEnd();
                        console.groupEnd();
                        lastPath = null;
                    }
                    category = result.category;
                    console.group(result.category);
                }
                if (result.path["aria"] != lastPath) {
                    if (lastPath !== null) {
                        console.groupEnd();
                    }
                    lastPath = result.path["aria"];
                    if (lastPath === "") {
                        console.group("page");
                    }
                    else {
                        console.group(lastPath);
                    }
                }
                console.log(result.value, result.message);
            }
            console.groupEnd();
            console.groupEnd();
        });
    }, timeout);
}
exports.checkDemo = checkDemo;

})();

module.exports = __webpack_exports__;
/******/ })()
;